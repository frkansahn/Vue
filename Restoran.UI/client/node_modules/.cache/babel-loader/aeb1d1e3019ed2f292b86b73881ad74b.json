{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\upcasthelpers.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\upcasthelpers.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5IjsKaW1wb3J0IF90eXBlb2YgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwppbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIjsKaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mIjsKaW1wb3J0IF9pbmhlcml0cyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCmltcG9ydCBNYXRjaGVyIGZyb20gJy4uL3ZpZXcvbWF0Y2hlcic7CmltcG9ydCBNb2RlbFJhbmdlIGZyb20gJy4uL21vZGVsL3JhbmdlJzsKaW1wb3J0IENvbnZlcnNpb25IZWxwZXJzIGZyb20gJy4vY29udmVyc2lvbmhlbHBlcnMnOwppbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gtZXMnOwppbXBvcnQgTW9kZWxTZWxlY3Rpb24gZnJvbSAnLi4vbW9kZWwvc2VsZWN0aW9uJzsKLyoqCiAqIENvbnRhaW5zIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlldyB2aWV3fSB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbCBtb2RlbH0gY29udmVydGVycyBmb3IKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ9LgogKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnMKICovCgovKioKICogVXBjYXN0IGNvbnZlcnNpb24gaGVscGVyIGZ1bmN0aW9ucy4KICoKICogQGV4dGVuZHMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25oZWxwZXJzfkNvbnZlcnNpb25IZWxwZXJzCiAqLwoKdmFyIFVwY2FzdEhlbHBlcnMgPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uIChfQ29udmVyc2lvbkhlbHBlcnMpIHsKICBfaW5oZXJpdHMoVXBjYXN0SGVscGVycywgX0NvbnZlcnNpb25IZWxwZXJzKTsKCiAgZnVuY3Rpb24gVXBjYXN0SGVscGVycygpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGNhc3RIZWxwZXJzKTsKCiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFVwY2FzdEhlbHBlcnMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogIH0KCiAgX2NyZWF0ZUNsYXNzKFVwY2FzdEhlbHBlcnMsIFt7CiAgICBrZXk6ICJlbGVtZW50VG9FbGVtZW50IiwKCiAgICAvKioKICAgICAqIFZpZXcgZWxlbWVudCB0byBtb2RlbCBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGNyZWF0aW5nIGEgbW9kZWwgZWxlbWVudC4gRm9yIGV4YW1wbGUsCiAgICAgKiB2aWV3IGA8cD5Gb288L3A+YCBiZWNvbWVzIGA8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPmAgaW4gdGhlIG1vZGVsLgogICAgICoKICAgICAqIEtlZXAgaW4gbWluZCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgaW5zZXJ0ZWQgb25seSBpZiBpdCBpcyBhbGxvd2VkCiAgICAgKiBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gY29uZmlndXJhdGlvbi4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJdmlldzogJ3AnLAogICAgICoJCQltb2RlbDogJ3BhcmFncmFwaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCXZpZXc6ICdwJywKICAgICAqCQkJbW9kZWw6ICdwYXJhZ3JhcGgnLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAncCcsCiAgICAgKgkJCQljbGFzc2VzOiAnZmFuY3knCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiAnZmFuY3lQYXJhZ3JhcGgnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICogCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3AnLAogICAgICoJCQkJY2xhc3NlczogJ2hlYWRpbmcnCiAgICAgKiAJCQl9LAogICAgICogCQkJbW9kZWw6ICggdmlld0VsZW1lbnQsIG1vZGVsV3JpdGVyICkgPT4gewogICAgICogCQkJCXJldHVybiBtb2RlbFdyaXRlci5jcmVhdGVFbGVtZW50KCAnaGVhZGluZycsIHsgbGV2ZWw6IHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSggJ2RhdGEtbGV2ZWwnICkgfSApOwogICAgICogCQkJfQogICAgICogCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjZWxlbWVudFRvRWxlbWVudAogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBbY29uZmlnLnZpZXddIFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4gSWYgbm90CiAgICAgKiBzZXQsIHRoZSBjb252ZXJ0ZXIgd2lsbCBmaXJlIGZvciBldmVyeSB2aWV3IGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxGdW5jdGlvbn0gY29uZmlnLm1vZGVsIE5hbWUgb2YgdGhlIG1vZGVsIGVsZW1lbnQsIGEgbW9kZWwgZWxlbWVudAogICAgICogaW5zdGFuY2Ugb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIGEgbW9kZWwgZWxlbWVudC4gVGhlIG1vZGVsIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgbW9kZWwuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwogICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRUb0VsZW1lbnQoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZCh1cGNhc3RFbGVtZW50VG9FbGVtZW50KGNvbmZpZykpOwogICAgfQogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIHNldHRpbmcgYW4gYXR0cmlidXRlIG9uIGEgbW9kZWwgbm9kZS4gRm9yIGV4YW1wbGUsIHZpZXcgYDxzdHJvbmc+Rm9vPC9zdHJvbmc+YCBiZWNvbWVzCiAgICAgKiBgRm9vYCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHQgbW9kZWwgdGV4dCBub2RlfSB3aXRoIGBib2xkYCBhdHRyaWJ1dGUgc2V0IHRvIGB0cnVlYC4KICAgICAqCiAgICAgKiBUaGlzIGhlbHBlciBpcyBtZWFudCB0byBzZXQgYSBtb2RlbCBhdHRyaWJ1dGUgb24gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBpbnNpZGUgdGhlIGNvbnZlcnRlZCBlbGVtZW50OgogICAgICoKICAgICAqCQk8c3Ryb25nPkZvbzwvc3Ryb25nPiAgIC0tPiAgIDxzdHJvbmc+PHA+Rm9vPC9wPjwvc3Ryb25nPiAgIC0tPiAgIDxwYXJhZ3JhcGg+PCR0ZXh0IGJvbGQ9InRydWUiPkZvbzwvJHRleHQ+PC9wYXJhZ3JhcGg+CiAgICAgKgogICAgICogQWJvdmUgaXMgYSBzYW1wbGUgb2YgSFRNTCBjb2RlLCB0aGF0IGdvZXMgdGhyb3VnaCBhdXRvcGFyYWdyYXBoaW5nIChmaXJzdCBzdGVwKSBhbmQgdGhlbiBpcyBjb252ZXJ0ZWQgKHNlY29uZCBzdGVwKS4KICAgICAqIEV2ZW4gdGhvdWdoIGA8c3Ryb25nPmAgaXMgb3ZlciBgPHA+YCBlbGVtZW50LCBgYm9sZD0idHJ1ZSJgIHdhcyBhZGRlZCB0byB0aGUgdGV4dC4gU2VlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVycyNhdHRyaWJ1dGVUb0F0dHJpYnV0ZX0gZm9yIGNvbXBhcmlzb24uCiAgICAgKgogICAgICogS2VlcCBpbiBtaW5kIHRoYXQgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCBvbmx5IGlmIGl0IGlzIGFsbG93ZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IGNvbmZpZ3VyYXRpb24uCiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogJ3N0cm9uZycsCiAgICAgKgkJCW1vZGVsOiAnYm9sZCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogJ3N0cm9uZycsCiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJY2xhc3NlczogJ2JvbGQnCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiAnYm9sZCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJY2xhc3NlczogWyAnc3R5bGVkJywgJ3N0eWxlZC1kYXJrJyBdCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdzdHlsZWQnLAogICAgICoJCQkJdmFsdWU6ICdkYXJrJwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIAkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQknZm9udC1zaXplJzogL1tcc1xTXSsvCiAgICAgKgkJCQl9CiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdmb250U2l6ZScsCiAgICAgKgkJCQl2YWx1ZTogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICAgKgkJCQkJY29uc3QgdmFsdWUgPSBmb250U2l6ZS5zdWJzdHIoIDAsIGZvbnRTaXplLmxlbmd0aCAtIDIgKTsKICAgICAqCiAgICAgKgkJCQkJaWYgKCB2YWx1ZSA8PSAxMCApIHsKICAgICAqCQkJCQkJcmV0dXJuICdzbWFsbCc7CiAgICAgKgkJCQkJfSBlbHNlIGlmICggdmFsdWUgPiAxMiApIHsKICAgICAqCQkJCQkJcmV0dXJuICdiaWcnOwogICAgICoJCQkJCX0KICAgICAqCiAgICAgKgkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjZWxlbWVudFRvQXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IGNvbmZpZy52aWV3IFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIE1vZGVsIGF0dHJpYnV0ZSBrZXkgb3IgYW4gb2JqZWN0IHdpdGggYGtleWAgYW5kIGB2YWx1ZWAgcHJvcGVydGllcywgZGVzY3JpYmluZwogICAgICogdGhlIG1vZGVsIGF0dHJpYnV0ZS4gYHZhbHVlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgdmFsdWUuCiAgICAgKiBJZiBgU3RyaW5nYCBpcyBnaXZlbiwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdsb3cnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJlbGVtZW50VG9BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRUb0F0dHJpYnV0ZShjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEVsZW1lbnRUb0F0dHJpYnV0ZShjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogVmlldyBhdHRyaWJ1dGUgdG8gbW9kZWwgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIHNldHRpbmcgYW4gYXR0cmlidXRlIG9uIGEgbW9kZWwgbm9kZS4gRm9yIGV4YW1wbGUsIHZpZXcgYDxpbWcgc3JjPSJmb28uanBnIj48L2ltZz5gIGJlY29tZXMKICAgICAqIGA8aW1hZ2Ugc291cmNlPSJmb28uanBnIj48L2ltYWdlPmAgaW4gdGhlIG1vZGVsLgogICAgICoKICAgICAqIFRoaXMgaGVscGVyIGlzIG1lYW50IHRvIGNvbnZlcnQgdmlldyBhdHRyaWJ1dGVzIGZyb20gdmlldyBlbGVtZW50cyB3aGljaCBnb3QgY29udmVydGVkIHRvIHRoZSBtb2RlbCwgc28gdGhlIHZpZXcgYXR0cmlidXRlCiAgICAgKiBpcyBzZXQgb25seSBvbiB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCBub2RlOgogICAgICoKICAgICAqCQk8ZGl2IGNsYXNzPSJkYXJrIj48ZGl2PmZvbzwvZGl2PjwvZGl2PiAgICAtLT4gICAgPGRpdiBkYXJrPSJ0cnVlIj48ZGl2PmZvbzwvZGl2PjwvZGl2PgogICAgICoKICAgICAqIEFib3ZlLCBgY2xhc3M9ImRhcmsiYCBhdHRyaWJ1dGUgaXMgYWRkZWQgb25seSB0byB0aGUgYDxkaXY+YCBlbGVtZW50cyB0aGF0IGhhcyBpdC4gVGhpcyBpcyBpbiBjb250cmFyeSB0bwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvQXR0cmlidXRlfSB3aGljaCBzZXRzIGF0dHJpYnV0ZXMgZm9yCiAgICAgKiBhbGwgdGhlIGNoaWxkcmVuIGluIHRoZSBtb2RlbDoKICAgICAqCiAgICAgKgkJPHN0cm9uZz5Gb288L3N0cm9uZz4gICAtLT4gICA8c3Ryb25nPjxwPkZvbzwvcD48L3N0cm9uZz4gICAtLT4gICA8cGFyYWdyYXBoPjwkdGV4dCBib2xkPSJ0cnVlIj5Gb288LyR0ZXh0PjwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIEFib3ZlIGlzIGEgc2FtcGxlIG9mIEhUTUwgY29kZSwgdGhhdCBnb2VzIHRocm91Z2ggYXV0b3BhcmFncmFwaGluZyAoZmlyc3Qgc3RlcCkgYW5kIHRoZW4gaXMgY29udmVydGVkIChzZWNvbmQgc3RlcCkuCiAgICAgKiBFdmVuIHRob3VnaCBgPHN0cm9uZz5gIGlzIG92ZXIgYDxwPmAgZWxlbWVudCwgYGJvbGQ9InRydWUiYCB3YXMgYWRkZWQgdG8gdGhlIHRleHQuCiAgICAgKgogICAgICogS2VlcCBpbiBtaW5kIHRoYXQgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCBvbmx5IGlmIGl0IGlzIGFsbG93ZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IGNvbmZpZ3VyYXRpb24uCiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiAnc3JjJywKICAgICAqCQkJbW9kZWw6ICdzb3VyY2UnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogeyBrZXk6ICdzcmMnIH0sCiAgICAgKgkJCW1vZGVsOiAnc291cmNlJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsga2V5OiAnc3JjJyB9LAogICAgICoJCQltb2RlbDogJ3NvdXJjZScsCiAgICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnbm9ybWFsJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCWtleTogJ2RhdGEtc3R5bGUnLAogICAgICoJCQkJdmFsdWU6IC9bXHNcU10rLwogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogJ3N0eWxlZCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnaW1nJywKICAgICAqCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCXZhbHVlOiAnc3R5bGVkLWRhcmsnCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdzdHlsZWQnLAogICAgICoJCQkJdmFsdWU6ICdkYXJrJwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJdmlldzogewogICAgICoJCQkJa2V5OiAnY2xhc3MnLAogICAgICoJCQkJdmFsdWU6IC9zdHlsZWQtW1xTXSsvCiAgICAgKgkJCX0sCiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdzdHlsZWQnCiAgICAgKgkJCQl2YWx1ZTogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IHJlZ2V4cCA9IC9zdHlsZWQtKFtcU10rKS87CiAgICAgKgkJCQkJY29uc3QgbWF0Y2ggPSB2aWV3RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjbGFzcycgKS5tYXRjaCggcmVnZXhwICk7CiAgICAgKgogICAgICoJCQkJCXJldHVybiBtYXRjaFsgMSBdOwogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIENvbnZlcnRpbmcgc3R5bGVzIHdvcmtzIGEgYml0IGRpZmZlcmVudGx5IGFzIGl0IHJlcXVpcmVzIGB2aWV3LnN0eWxlc2AgdG8gYmUgYW4gb2JqZWN0IGFuZCBieSBkZWZhdWx0CiAgICAgKiBhIG1vZGVsIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCB0byBgdHJ1ZWAgYnkgc3VjaCBhIGNvbnZlcnRlci4gWW91IGNhbiBzZXQgdGhlIG1vZGVsIGF0dHJpYnV0ZSB0byBhbnkgdmFsdWUgYnkgcHJvdmlkaW5nIHRoZSBgdmFsdWVgCiAgICAgKiBjYWxsYmFjayB0aGF0IHJldHVybnMgdGhlIGRlc2lyZWQgdmFsdWUuCiAgICAgKgogICAgICoJCS8vIERlZmF1bHQgY29udmVyc2lvbiBvZiBmb250LXdlaWdodCBzdHlsZSB3aWxsIHJlc3VsdCBpbiBzZXR0aW5nIGJvbGQgYXR0cmlidXRlIHRvIHRydWUuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCXN0eWxlczogewogICAgICoJCQkJCSdmb250LXdlaWdodCc6ICdib2xkJwogICAgICoJCQkJfQogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogJ2JvbGQnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBUaGlzIGNvbnZlcnRlciB3aWxsIHBhc3MgYW55IHN0eWxlIHZhbHVlIHRvIHRoZSBgbGluZUhlaWdodGAgbW9kZWwgYXR0cmlidXRlLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQknbGluZS1oZWlnaHQnOiAvW1xzXFNdKy8KICAgICAqCQkJCX0KICAgICAqCQkJfSwKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCWtleTogJ2xpbmVIZWlnaHQnLAogICAgICoJCQkJdmFsdWU6IHZpZXdFbGVtZW50ID0+IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnbGluZS1oZWlnaHQnICkKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNhdHRyaWJ1dGVUb0F0dHJpYnV0ZQogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy52aWV3IFNwZWNpZmllcyB3aGljaCB2aWV3IGF0dHJpYnV0ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYSBgU3RyaW5nYCBpcyBwYXNzZWQsCiAgICAgKiBhdHRyaWJ1dGVzIHdpdGggZ2l2ZW4ga2V5IHdpbGwgYmUgY29udmVydGVkLiBJZiBhbiBgT2JqZWN0YCBpcyBwYXNzZWQsIGl0IG11c3QgaGF2ZSBhIHJlcXVpcmVkIGBrZXlgIHByb3BlcnR5LAogICAgICogc3BlY2lmeWluZyB2aWV3IGF0dHJpYnV0ZSBrZXksIGFuZCBtYXkgaGF2ZSBhbiBvcHRpb25hbCBgdmFsdWVgIHByb3BlcnR5LCBzcGVjaWZ5aW5nIHZpZXcgYXR0cmlidXRlIHZhbHVlIGFuZCBvcHRpb25hbCBgbmFtZWAKICAgICAqIHByb3BlcnR5IHNwZWNpZnlpbmcgYSB2aWV3IGVsZW1lbnQgbmFtZSBmcm9tL29uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZC4gYHZhbHVlYCBjYW4gYmUgZ2l2ZW4gYXMgYSBgU3RyaW5nYCwKICAgICAqIGEgYFJlZ0V4cGAgb3IgYSBmdW5jdGlvbiBjYWxsYmFjaywgdGhhdCB0YWtlcyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSBhcyB0aGUgb25seSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYEJvb2xlYW5gLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgTW9kZWwgYXR0cmlidXRlIGtleSBvciBhbiBvYmplY3Qgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLCBkZXNjcmliaW5nCiAgICAgKiB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4KICAgICAqIElmIGBTdHJpbmdgIGlzIGdpdmVuLCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmUgc2FtZSBhcyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J2xvdyddIENvbnZlcnRlciBwcmlvcml0eS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzfQogICAgICovCgogIH0sIHsKICAgIGtleTogImF0dHJpYnV0ZVRvQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEF0dHJpYnV0ZVRvQXR0cmlidXRlKGNvbmZpZykpOwogICAgfQogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgbWFya2VyIGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGNyZWF0aW5nIGEgbW9kZWwgbWFya2VyLiBGb3IgZXhhbXBsZSwgaWYgdGhlIG1hcmtlciB3YXMgc3RvcmVkIGluIGEgdmlldyBhcyBhbiBlbGVtZW50OgogICAgICogYDxwPkZvPHNwYW4gZGF0YS1tYXJrZXI9ImNvbW1lbnQiIGRhdGEtY29tbWVudC1pZD0iNyI+PC9zcGFuPm88L3A+PHA+QjxzcGFuIGRhdGEtbWFya2VyPSJjb21tZW50IiBkYXRhLWNvbW1lbnQtaWQ9IjciPjwvc3Bhbj5hcjwvcD5gLAogICAgICogYWZ0ZXIgdGhlIGNvbnZlcnNpb24gaXMgZG9uZSwgdGhlIG1hcmtlciB3aWxsIGJlIGF2YWlsYWJsZSBpbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjbWFya2VycyBtb2RlbCBkb2N1bWVudCBtYXJrZXJzfS4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcsCiAgICAgKgkJCW1vZGVsOiAnc2VhcmNoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcsCiAgICAgKgkJCW1vZGVsOiAnc2VhcmNoJywKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb01hcmtlciggewogICAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcsCiAgICAgKgkJCW1vZGVsOiB2aWV3RWxlbWVudCA9PiAnY29tbWVudDonICsgdmlld0VsZW1lbnQuZ2V0QXR0cmlidXRlKCAnZGF0YS1jb21tZW50LWlkJyApCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCWF0dHJpYnV0ZXM6IHsKICAgICAqCQkJCQknZGF0YS1tYXJrZXInOiAnc2VhcmNoJwogICAgICoJCQkJfQogICAgICoJCQl9LAogICAgICoJCQltb2RlbDogJ3NlYXJjaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjZWxlbWVudFRvTWFya2VyCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IGNvbmZpZy52aWV3IFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBjb25maWcubW9kZWwgTmFtZSBvZiB0aGUgbW9kZWwgbWFya2VyLCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHJldHVybnMKICAgICAqIGEgbW9kZWwgbWFya2VyIG5hbWUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJlbGVtZW50VG9NYXJrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRUb01hcmtlcihjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEVsZW1lbnRUb01hcmtlcihjb25maWcpKTsKICAgIH0KICB9XSk7CgogIHJldHVybiBVcGNhc3RIZWxwZXJzOwp9KENvbnZlcnNpb25IZWxwZXJzKTsKLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnksIGNyZWF0ZXMgYSBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fQogKiBvciBhbGwgY2hpbGRyZW4gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGludG8KICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fS4KICogVGhpcyBpcyB0aGUgImVudHJ5LXBvaW50IiBjb252ZXJ0ZXIgZm9yIHVwY2FzdCAodmlldyB0byBtb2RlbCBjb252ZXJzaW9uKS4gVGhpcyBjb252ZXJ0ZXIgc3RhcnRzIHRoZSBjb252ZXJzaW9uIG9mIGFsbCBjaGlsZHJlbgogKiBvZiBwYXNzZWQgdmlldyBkb2N1bWVudCBmcmFnbWVudC4gVGhvc2UgY2hpbGRyZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2Rlc30gYXJlIHRoZW4gaGFuZGxlZCBieSBvdGhlciBjb252ZXJ0ZXJzLgogKgogKiBUaGlzIGFsc28gYSAiZGVmYXVsdCIsIGxhc3QgcmVzb3J0IGNvbnZlcnRlciBmb3IgYWxsIHZpZXcgZWxlbWVudHMgdGhhdCBoYXMgbm90IGJlZW4gY29udmVydGVkIGJ5IG90aGVyIGNvbnZlcnRlcnMuCiAqIFdoZW4gYSB2aWV3IGVsZW1lbnQgaXMgYmVpbmcgY29udmVydGVkIHRvIHRoZSBtb2RlbCBidXQgaXQgZG9lcyBub3QgaGF2ZSBjb252ZXJ0ZXIgc3BlY2lmaWVkLCB0aGF0IHZpZXcgZWxlbWVudAogKiB3aWxsIGJlIGNvbnZlcnRlZCB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgbW9kZWwgZG9jdW1lbnQgZnJhZ21lbnR9IGFuZCByZXR1cm5lZC4KICoKICogQHJldHVybnMge0Z1bmN0aW9ufSBVbml2ZXJzYWwgY29udmVydGVyIGZvciB2aWV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IGZyYWdtZW50c30gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnRzfSB0aGF0IHJldHVybnMKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGZyYWdtZW50fSB3aXRoIGNoaWxkcmVuIG9mIGNvbnZlcnRlZCB2aWV3IGl0ZW0uCiAqLwoKCmV4cG9ydCB7IFVwY2FzdEhlbHBlcnMgYXMgZGVmYXVsdCB9OwpleHBvcnQgZnVuY3Rpb24gY29udmVydFRvTW9kZWxGcmFnbWVudCgpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgLy8gU2Vjb25kIGFyZ3VtZW50IGluIGBjb25zdW1hYmxlLmNvbnN1bWVgIGlzIGRpc2NhcmRlZCBmb3IgVmlld0RvY3VtZW50RnJhZ21lbnQgYnV0IGlzIG5lZWRlZCBmb3IgVmlld0VsZW1lbnQuCiAgICBpZiAoIWRhdGEubW9kZWxSYW5nZSAmJiBjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLnZpZXdJdGVtLCB7CiAgICAgIG5hbWU6IHRydWUKICAgIH0pKSB7CiAgICAgIHZhciBfY29udmVyc2lvbkFwaSRjb252ZXIgPSBjb252ZXJzaW9uQXBpLmNvbnZlcnRDaGlsZHJlbihkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yKSwKICAgICAgICAgIG1vZGVsUmFuZ2UgPSBfY29udmVyc2lvbkFwaSRjb252ZXIubW9kZWxSYW5nZSwKICAgICAgICAgIG1vZGVsQ3Vyc29yID0gX2NvbnZlcnNpb25BcGkkY29udmVyLm1vZGVsQ3Vyc29yOwoKICAgICAgZGF0YS5tb2RlbFJhbmdlID0gbW9kZWxSYW5nZTsKICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IG1vZGVsQ3Vyc29yOwogICAgfQogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnksIGNyZWF0ZXMgYSBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fS4KICoKICogQHJldHVybnMge0Z1bmN0aW9ufSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCBWaWV3IHRleHR9IGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gY29udmVydFRleHQoKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIGlmIChjb252ZXJzaW9uQXBpLnNjaGVtYS5jaGVja0NoaWxkKGRhdGEubW9kZWxDdXJzb3IsICckdGV4dCcpKSB7CiAgICAgIGlmIChjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLnZpZXdJdGVtKSkgewogICAgICAgIHZhciB0ZXh0ID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlVGV4dChkYXRhLnZpZXdJdGVtLmRhdGEpOwogICAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLmluc2VydCh0ZXh0LCBkYXRhLm1vZGVsQ3Vyc29yKTsKICAgICAgICBkYXRhLm1vZGVsUmFuZ2UgPSBNb2RlbFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChkYXRhLm1vZGVsQ3Vyc29yLCB0ZXh0Lm9mZnNldFNpemUpOwogICAgICAgIGRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogICAgICB9CiAgICB9CiAgfTsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSwgY3JlYXRlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNvbnZlcnRzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9uCiAqIHZpZXcgc2VsZWN0aW9ufSB0YWtlbiBmcm9tIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50I2V2ZW50OnNlbGVjdGlvbkNoYW5nZX0gZXZlbnQKICogYW5kIHNldHMgaW4gb24gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3NlbGVjdGlvbiBtb2RlbH0uCiAqCiAqICoqTm90ZSoqOiBiZWNhdXNlIHRoZXJlIGlzIG5vIHZpZXcgc2VsZWN0aW9uIGNoYW5nZSBkaXNwYXRjaGVyIG5vciBhbnkgb3RoZXIgYWR2YW5jZWQgdmlldyBzZWxlY3Rpb24gdG8gbW9kZWwKICogY29udmVyc2lvbiBtZWNoYW5pc20sIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgc2V0IGRpcmVjdGx5IG9uIHZpZXcgZG9jdW1lbnQuCiAqCiAqCQl2aWV3LmRvY3VtZW50Lm9uKCAnc2VsZWN0aW9uQ2hhbmdlJywgY29udmVydFNlbGVjdGlvbkNoYW5nZSggbW9kZWxEb2N1bWVudCwgbWFwcGVyICkgKTsKICoKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbCBEYXRhIG1vZGVsLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyfSBtYXBwZXIgQ29udmVyc2lvbiBtYXBwZXIuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpzZWxlY3Rpb25DaGFuZ2V9IGNhbGxiYWNrIGZ1bmN0aW9uLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0U2VsZWN0aW9uQ2hhbmdlKG1vZGVsLCBtYXBwZXIpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSkgewogICAgdmFyIHZpZXdTZWxlY3Rpb24gPSBkYXRhLm5ld1NlbGVjdGlvbjsKICAgIHZhciBtb2RlbFNlbGVjdGlvbiA9IG5ldyBNb2RlbFNlbGVjdGlvbigpOwogICAgdmFyIHJhbmdlcyA9IFtdOwogICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgdHJ5IHsKICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmlld1NlbGVjdGlvbi5nZXRSYW5nZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICB2YXIgdmlld1JhbmdlID0gX3N0ZXAudmFsdWU7CiAgICAgICAgcmFuZ2VzLnB1c2gobWFwcGVyLnRvTW9kZWxSYW5nZSh2aWV3UmFuZ2UpKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICB9IGZpbmFsbHkgewogICAgICB0cnkgewogICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICB9CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBtb2RlbFNlbGVjdGlvbi5zZXRUbyhyYW5nZXMsIHsKICAgICAgYmFja3dhcmQ6IHZpZXdTZWxlY3Rpb24uaXNCYWNrd2FyZAogICAgfSk7CgogICAgaWYgKCFtb2RlbFNlbGVjdGlvbi5pc0VxdWFsKG1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbikpIHsKICAgICAgbW9kZWwuY2hhbmdlKGZ1bmN0aW9uICh3cml0ZXIpIHsKICAgICAgICB3cml0ZXIuc2V0U2VsZWN0aW9uKG1vZGVsU2VsZWN0aW9uKTsKICAgICAgfSk7CiAgICB9CiAgfTsKfSAvLyBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNlbGVtZW50VG9FbGVtZW50IGAuZWxlbWVudFRvRWxlbWVudCgpYCB1cGNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBbY29uZmlnLnZpZXddIFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4gSWYgbm90Ci8vIHNldCwgdGhlIGNvbnZlcnRlciB3aWxsIGZpcmUgZm9yIGV2ZXJ5IHZpZXcgZWxlbWVudC4KLy8gQHBhcmFtIHtTdHJpbmd8bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8RnVuY3Rpb259IGNvbmZpZy5tb2RlbCBOYW1lIG9mIHRoZSBtb2RlbCBlbGVtZW50LCBhIG1vZGVsIGVsZW1lbnQKLy8gaW5zdGFuY2Ugb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIGEgbW9kZWwgZWxlbWVudC4gVGhlIG1vZGVsIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgbW9kZWwuCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddIENvbnZlcnRlciBwcmlvcml0eS4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBDb252ZXJzaW9uIGhlbHBlci4KCmZ1bmN0aW9uIHVwY2FzdEVsZW1lbnRUb0VsZW1lbnQoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgdmFyIGNvbnZlcnRlciA9IHByZXBhcmVUb0VsZW1lbnRDb252ZXJ0ZXIoY29uZmlnKTsKICB2YXIgZWxlbWVudE5hbWUgPSBnZXRWaWV3RWxlbWVudE5hbWVGcm9tQ29uZmlnKGNvbmZpZy52aWV3KTsKICB2YXIgZXZlbnROYW1lID0gZWxlbWVudE5hbWUgPyAnZWxlbWVudDonICsgZWxlbWVudE5hbWUgOiAnZWxlbWVudCc7CiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgY29udmVydGVyLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gVmlldyBlbGVtZW50IHRvIG1vZGVsIGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNlbGVtZW50VG9BdHRyaWJ1dGUgYC5lbGVtZW50VG9BdHRyaWJ1dGUoKWAgdXBjYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn0gY29uZmlnLnZpZXcgUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBNb2RlbCBhdHRyaWJ1dGUga2V5IG9yIGFuIG9iamVjdCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMsIGRlc2NyaWJpbmcKLy8gdGhlIG1vZGVsIGF0dHJpYnV0ZS4gYHZhbHVlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgdmFsdWUuCi8vIElmIGBTdHJpbmdgIGlzIGdpdmVuLCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGB0cnVlYC4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIHVwY2FzdEVsZW1lbnRUb0F0dHJpYnV0ZShjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcpOwogIHZhciBjb252ZXJ0ZXIgPSBwcmVwYXJlVG9BdHRyaWJ1dGVDb252ZXJ0ZXIoY29uZmlnLCBmYWxzZSk7CiAgdmFyIGVsZW1lbnROYW1lID0gZ2V0Vmlld0VsZW1lbnROYW1lRnJvbUNvbmZpZyhjb25maWcudmlldyk7CiAgdmFyIGV2ZW50TmFtZSA9IGVsZW1lbnROYW1lID8gJ2VsZW1lbnQ6JyArIGVsZW1lbnROYW1lIDogJ2VsZW1lbnQnOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGNvbnZlcnRlciwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdsb3cnCiAgICB9KTsKICB9Owp9IC8vIFZpZXcgYXR0cmlidXRlIHRvIG1vZGVsIGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNhdHRyaWJ1dGVUb0F0dHJpYnV0ZSBgLmF0dHJpYnV0ZVRvQXR0cmlidXRlKClgIHVwY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLnZpZXcgU3BlY2lmaWVzIHdoaWNoIHZpZXcgYXR0cmlidXRlIHdpbGwgYmUgY29udmVydGVkLiBJZiBhIGBTdHJpbmdgIGlzIHBhc3NlZCwKLy8gYXR0cmlidXRlcyB3aXRoIGdpdmVuIGtleSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYW4gYE9iamVjdGAgaXMgcGFzc2VkLCBpdCBtdXN0IGhhdmUgYSByZXF1aXJlZCBga2V5YCBwcm9wZXJ0eSwKLy8gc3BlY2lmeWluZyB2aWV3IGF0dHJpYnV0ZSBrZXksIGFuZCBtYXkgaGF2ZSBhbiBvcHRpb25hbCBgdmFsdWVgIHByb3BlcnR5LCBzcGVjaWZ5aW5nIHZpZXcgYXR0cmlidXRlIHZhbHVlIGFuZCBvcHRpb25hbCBgbmFtZWAKLy8gcHJvcGVydHkgc3BlY2lmeWluZyBhIHZpZXcgZWxlbWVudCBuYW1lIGZyb20vb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgY29udmVydGVkLiBgdmFsdWVgIGNhbiBiZSBnaXZlbiBhcyBhIGBTdHJpbmdgLAovLyBhIGBSZWdFeHBgIG9yIGEgZnVuY3Rpb24gY2FsbGJhY2ssIHRoYXQgdGFrZXMgdmlldyBhdHRyaWJ1dGUgdmFsdWUgYXMgdGhlIG9ubHkgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGBCb29sZWFuYC4KLy8gQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgTW9kZWwgYXR0cmlidXRlIGtleSBvciBhbiBvYmplY3Qgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLCBkZXNjcmliaW5nCi8vIHRoZSBtb2RlbCBhdHRyaWJ1dGUuIGB2YWx1ZWAgcHJvcGVydHkgbWF5IGJlIHNldCBhcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHJldHVybnMgdGhlIHZhbHVlLgovLyBJZiBgU3RyaW5nYCBpcyBnaXZlbiwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNhbWUgYXMgdmlldyBhdHRyaWJ1dGUgdmFsdWUuCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J2xvdyddIENvbnZlcnRlciBwcmlvcml0eS4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBDb252ZXJzaW9uIGhlbHBlci4KCgpmdW5jdGlvbiB1cGNhc3RBdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICB2YXIgdmlld0tleSA9IG51bGw7CgogIGlmICh0eXBlb2YgY29uZmlnLnZpZXcgPT0gJ3N0cmluZycgfHwgY29uZmlnLnZpZXcua2V5KSB7CiAgICB2aWV3S2V5ID0gbm9ybWFsaXplVmlld0F0dHJpYnV0ZUtleVZhbHVlQ29uZmlnKGNvbmZpZyk7CiAgfQoKICBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcsIHZpZXdLZXkpOwogIHZhciBjb252ZXJ0ZXIgPSBwcmVwYXJlVG9BdHRyaWJ1dGVDb252ZXJ0ZXIoY29uZmlnLCB0cnVlKTsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oJ2VsZW1lbnQnLCBjb252ZXJ0ZXIsIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbG93JwogICAgfSk7CiAgfTsKfSAvLyBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgbWFya2VyIGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb01hcmtlciBgLmVsZW1lbnRUb01hcmtlcigpYCB1cGNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBjb25maWcudmlldyBQYXR0ZXJuIG1hdGNoaW5nIGFsbCB2aWV3IGVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBjb252ZXJ0ZWQuCi8vIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBjb25maWcubW9kZWwgTmFtZSBvZiB0aGUgbW9kZWwgbWFya2VyLCBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHJldHVybnMKLy8gYSBtb2RlbCBtYXJrZXIgbmFtZS4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIHVwY2FzdEVsZW1lbnRUb01hcmtlcihjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBub3JtYWxpemVUb01hcmtlckNvbmZpZyhjb25maWcpOwogIHJldHVybiB1cGNhc3RFbGVtZW50VG9FbGVtZW50KGNvbmZpZyk7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBmcm9tLXZpZXctZWxlbWVudCBjb252ZXJzaW9uLiBDaGVja3MgaWYgYGNvbmZpZy52aWV3YCBkaXJlY3RseSBzcGVjaWZpZXMgY29udmVydGVkIHZpZXcgZWxlbWVudCdzIG5hbWUKLy8gYW5kIGlmIHNvLCByZXR1cm5zIGl0LgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gdmlldyBjb25maWcuCi8vIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gVmlldyBlbGVtZW50IG5hbWUgb3IgYG51bGxgIGlmIG5hbWUgaXMgbm90IGRpcmVjdGx5IHNldC4KCgpmdW5jdGlvbiBnZXRWaWV3RWxlbWVudE5hbWVGcm9tQ29uZmlnKHZpZXdDb25maWcpIHsKICBpZiAodHlwZW9mIHZpZXdDb25maWcgPT0gJ3N0cmluZycpIHsKICAgIHJldHVybiB2aWV3Q29uZmlnOwogIH0KCiAgaWYgKF90eXBlb2Yodmlld0NvbmZpZykgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZpZXdDb25maWcubmFtZSA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIHZpZXdDb25maWcubmFtZTsKICB9CgogIHJldHVybiBudWxsOwp9IC8vIEhlbHBlciBmb3IgdG8tbW9kZWwtZWxlbWVudCBjb252ZXJzaW9uLiBUYWtlcyBhIGNvbmZpZyBvYmplY3QgYW5kIHJldHVybnMgYSBwcm9wZXIgY29udmVydGVyIGZ1bmN0aW9uLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBWaWV3IHRvIG1vZGVsIGNvbnZlcnRlci4KCgpmdW5jdGlvbiBwcmVwYXJlVG9FbGVtZW50Q29udmVydGVyKGNvbmZpZykgewogIHZhciBtYXRjaGVyID0gY29uZmlnLnZpZXcgPyBuZXcgTWF0Y2hlcihjb25maWcudmlldykgOiBudWxsOwogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgbWF0Y2ggPSB7fTsgLy8gSWYgYGNvbmZpZy52aWV3YCBoYXMgbm90IGJlZW4gcGFzc2VkIGRvIG5vdCB0cnkgbWF0Y2hpbmcuIEluIHRoaXMgY2FzZSwgdGhlIGNvbnZlcnRlciBzaG91bGQgZmlyZSBmb3IgYWxsIGVsZW1lbnRzLgoKICAgIGlmIChtYXRjaGVyKSB7CiAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c3VhbGx5IGp1c3Qgb25lIHBhdHRlcm4gYnV0IHdlIHN1cHBvcnQgbWF0Y2hlcnMgd2l0aCBtYW55IHBhdHRlcm5zIHRvby4KICAgICAgdmFyIG1hdGNoZXJSZXN1bHQgPSBtYXRjaGVyLm1hdGNoKGRhdGEudmlld0l0ZW0pOyAvLyBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhpcyBjYWxsYmFjayBzaG91bGQgbm90IGRvIGFueXRoaW5nLgoKICAgICAgaWYgKCFtYXRjaGVyUmVzdWx0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBtYXRjaCA9IG1hdGNoZXJSZXN1bHQubWF0Y2g7CiAgICB9IC8vIEZvcmNlIGNvbnN1bWluZyBlbGVtZW50J3MgbmFtZS4KCgogICAgbWF0Y2gubmFtZSA9IHRydWU7IC8vIENyZWF0ZSBtb2RlbCBlbGVtZW50IGJhc2luZyBvbiBjb25maWcuCgogICAgdmFyIG1vZGVsRWxlbWVudCA9IGdldE1vZGVsRWxlbWVudChjb25maWcubW9kZWwsIGRhdGEudmlld0l0ZW0sIGNvbnZlcnNpb25BcGkud3JpdGVyKTsgLy8gRG8gbm90IGNvbnZlcnQgaWYgZWxlbWVudCBidWlsZGluZyBmdW5jdGlvbiByZXR1cm5lZCBmYWxzeSB2YWx1ZS4KCiAgICBpZiAoIW1vZGVsRWxlbWVudCkgewogICAgICByZXR1cm47CiAgICB9IC8vIFdoZW4gZWxlbWVudCB3YXMgYWxyZWFkeSBjb25zdW1lZCB0aGVuIHNraXAgaXQuCgoKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLnRlc3QoZGF0YS52aWV3SXRlbSwgbWF0Y2gpKSB7CiAgICAgIHJldHVybjsKICAgIH0gLy8gRmluZCBhbGxvd2VkIHBhcmVudCBmb3IgZWxlbWVudCB0aGF0IHdlIGFyZSBnb2luZyB0byBpbnNlcnQuCiAgICAvLyBJZiBjdXJyZW50IHBhcmVudCBkb2VzIG5vdCBhbGxvdyB0byBpbnNlcnQgZWxlbWVudCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgZG9lcwogICAgLy8gdGhlbiBzcGxpdCBub2RlcyB0byBhbGxvd2VkIHBhcmVudC4KCgogICAgdmFyIHNwbGl0UmVzdWx0ID0gY29udmVyc2lvbkFwaS5zcGxpdFRvQWxsb3dlZFBhcmVudChtb2RlbEVsZW1lbnQsIGRhdGEubW9kZWxDdXJzb3IpOyAvLyBXaGVuIHRoZXJlIGlzIG5vIHNwbGl0IHJlc3VsdCBpdCBtZWFucyB0aGF0IHdlIGNhbid0IGluc2VydCBlbGVtZW50IHRvIG1vZGVsIHRyZWUsIHNvIGxldCdzIHNraXAgaXQuCgogICAgaWYgKCFzcGxpdFJlc3VsdCkgewogICAgICByZXR1cm47CiAgICB9IC8vIEluc2VydCBlbGVtZW50IG9uIGFsbG93ZWQgcG9zaXRpb24uCgoKICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLmluc2VydChtb2RlbEVsZW1lbnQsIHNwbGl0UmVzdWx0LnBvc2l0aW9uKTsgLy8gQ29udmVydCBjaGlsZHJlbiBhbmQgaW5zZXJ0IHRvIGVsZW1lbnQuCgogICAgY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oZGF0YS52aWV3SXRlbSwgY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25BdChtb2RlbEVsZW1lbnQsIDApKTsgLy8gQ29uc3VtZSBhcHByb3ByaWF0ZSB2YWx1ZSBmcm9tIGNvbnN1bWFibGUgdmFsdWVzIGxpc3QuCgogICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgbWF0Y2gpOwogICAgdmFyIHBhcnRzID0gY29udmVyc2lvbkFwaS5nZXRTcGxpdFBhcnRzKG1vZGVsRWxlbWVudCk7IC8vIFNldCBjb252ZXJzaW9uIHJlc3VsdCByYW5nZS4KCiAgICBkYXRhLm1vZGVsUmFuZ2UgPSBuZXcgTW9kZWxSYW5nZShjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZShtb2RlbEVsZW1lbnQpLCBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSk7IC8vIE5vdyB3ZSBuZWVkIHRvIGNoZWNrIHdoZXJlIHRoZSBgbW9kZWxDdXJzb3JgIHNob3VsZCBiZS4KCiAgICBpZiAoc3BsaXRSZXN1bHQuY3Vyc29yUGFyZW50KSB7CiAgICAgIC8vIElmIHdlIHNwbGl0IHBhcmVudCB0byBpbnNlcnQgb3VyIGVsZW1lbnQgdGhlbiB3ZSB3YW50IHRvIGNvbnRpbnVlIGNvbnZlcnNpb24gaW4gdGhlIG5ldyBwYXJ0IG9mIHRoZSBzcGxpdCBwYXJlbnQuCiAgICAgIC8vCiAgICAgIC8vIGJlZm9yZTogPGFsbG93ZWQ+PG5vdEFsbG93ZWQ+Zm9vW108L25vdEFsbG93ZWQ+PC9hbGxvd2VkPgogICAgICAvLyBhZnRlcjogIDxhbGxvd2VkPjxub3RBbGxvd2VkPmZvbzwvbm90QWxsb3dlZD48Y29udmVydGVkPjwvY29udmVydGVkPjxub3RBbGxvd2VkPltdPC9ub3RBbGxvd2VkPjwvYWxsb3dlZD4KICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoc3BsaXRSZXN1bHQuY3Vyc29yUGFyZW50LCAwKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGNvbnRpbnVlIGFmdGVyIGluc2VydGVkIGVsZW1lbnQuCiAgICAgIGRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogICAgfQogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB1cGNhc3RpbmctdG8tZWxlbWVudCBjb252ZXJ0ZXIuIFRha2VzIHRoZSBtb2RlbCBjb25maWd1cmF0aW9uLCB0aGUgY29udmVydGVkIHZpZXcgZWxlbWVudAovLyBhbmQgYSB3cml0ZXIgaW5zdGFuY2UgYW5kIHJldHVybnMgYSBtb2RlbCBlbGVtZW50IGluc3RhbmNlIHRvIGJlIGluc2VydGVkIGluIHRoZSBtb2RlbC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG1vZGVsIE1vZGVsIGNvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfSBpbnB1dCBUaGUgY29udmVydGVkIHZpZXcgbm9kZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlciBBIHdyaXRlciBpbnN0YW5jZSB0byB1c2UgdG8gY3JlYXRlIHRoZSBtb2RlbCBlbGVtZW50LgoKCmZ1bmN0aW9uIGdldE1vZGVsRWxlbWVudChtb2RlbCwgaW5wdXQsIHdyaXRlcikgewogIGlmIChtb2RlbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7CiAgICByZXR1cm4gbW9kZWwoaW5wdXQsIHdyaXRlcik7CiAgfSBlbHNlIHsKICAgIHJldHVybiB3cml0ZXIuY3JlYXRlRWxlbWVudChtb2RlbCk7CiAgfQp9IC8vIEhlbHBlciBmdW5jdGlvbiB2aWV3LWF0dHJpYnV0ZS10by1tb2RlbC1hdHRyaWJ1dGUgaGVscGVyLiBOb3JtYWxpemVzIGBjb25maWcudmlld2Agd2hpY2ggd2FzIHNldCBhcyBgU3RyaW5nYCBvcgovLyBhcyBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgLCBgdmFsdWVgIGFuZCBgbmFtZWAgcHJvcGVydGllcy4gTm9ybWFsaXplZCBgY29uZmlnLnZpZXdgIGhhcyBpcyBjb21wYXRpYmxlIHdpdGgKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufS4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZy4KLy8gQHJldHVybnMge1N0cmluZ30gS2V5IG9mIHRoZSBjb252ZXJ0ZWQgdmlldyBhdHRyaWJ1dGUuCgoKZnVuY3Rpb24gbm9ybWFsaXplVmlld0F0dHJpYnV0ZUtleVZhbHVlQ29uZmlnKGNvbmZpZykgewogIGlmICh0eXBlb2YgY29uZmlnLnZpZXcgPT0gJ3N0cmluZycpIHsKICAgIGNvbmZpZy52aWV3ID0gewogICAgICBrZXk6IGNvbmZpZy52aWV3CiAgICB9OwogIH0KCiAgdmFyIGtleSA9IGNvbmZpZy52aWV3LmtleTsKICB2YXIgbm9ybWFsaXplZDsKCiAgaWYgKGtleSA9PSAnY2xhc3MnIHx8IGtleSA9PSAnc3R5bGUnKSB7CiAgICB2YXIga2V5TmFtZSA9IGtleSA9PSAnY2xhc3MnID8gJ2NsYXNzZXMnIDogJ3N0eWxlcyc7CiAgICBub3JtYWxpemVkID0gX2RlZmluZVByb3BlcnR5KHt9LCBrZXlOYW1lLCBjb25maWcudmlldy52YWx1ZSk7CiAgfSBlbHNlIHsKICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBjb25maWcudmlldy52YWx1ZSA9PSAndW5kZWZpbmVkJyA/IC9bXHNcU10qLyA6IGNvbmZpZy52aWV3LnZhbHVlOwogICAgbm9ybWFsaXplZCA9IHsKICAgICAgYXR0cmlidXRlczogX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKQogICAgfTsKICB9CgogIGlmIChjb25maWcudmlldy5uYW1lKSB7CiAgICBub3JtYWxpemVkLm5hbWUgPSBjb25maWcudmlldy5uYW1lOwogIH0KCiAgY29uZmlnLnZpZXcgPSBub3JtYWxpemVkOwogIHJldHVybiBrZXk7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBgY29uZmlnLm1vZGVsYCBpbiBmcm9tLW1vZGVsLWF0dHJpYnV0ZSBjb252ZXJzaW9uLiBgY29uZmlnLm1vZGVsYCBjYW4gYmUgc2V0Ci8vIGFzIGEgYFN0cmluZ2AsIGFuIGBPYmplY3RgIHdpdGggb25seSBga2V5YCBwcm9wZXJ0eSBvciBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMuIE5vcm1hbGl6ZWQKLy8gYGNvbmZpZy5tb2RlbGAgaXMgYW4gYE9iamVjdGAgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlnLgovLyBAcGFyYW0ge1N0cmluZ30gdmlld0F0dHJpYnV0ZUtleVRvQ29weSBLZXkgb2YgdGhlIGNvbnZlcnRlZCB2aWV3IGF0dHJpYnV0ZS4gSWYgaXQgaXMgc2V0LCBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUKLy8gd2lsbCBiZSBlcXVhbCB0byB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KCgpmdW5jdGlvbiBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcpIHsKICB2YXIgdmlld0F0dHJpYnV0ZUtleVRvQ29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKICB2YXIgZGVmYXVsdE1vZGVsVmFsdWUgPSB2aWV3QXR0cmlidXRlS2V5VG9Db3B5ID09PSBudWxsID8gdHJ1ZSA6IGZ1bmN0aW9uICh2aWV3RWxlbWVudCkgewogICAgcmV0dXJuIHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSh2aWV3QXR0cmlidXRlS2V5VG9Db3B5KTsKICB9OwogIHZhciBrZXkgPSBfdHlwZW9mKGNvbmZpZy5tb2RlbCkgIT0gJ29iamVjdCcgPyBjb25maWcubW9kZWwgOiBjb25maWcubW9kZWwua2V5OwogIHZhciB2YWx1ZSA9IF90eXBlb2YoY29uZmlnLm1vZGVsKSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgY29uZmlnLm1vZGVsLnZhbHVlID09ICd1bmRlZmluZWQnID8gZGVmYXVsdE1vZGVsVmFsdWUgOiBjb25maWcubW9kZWwudmFsdWU7CiAgY29uZmlnLm1vZGVsID0gewogICAga2V5OiBrZXksCiAgICB2YWx1ZTogdmFsdWUKICB9Owp9IC8vIEhlbHBlciBmb3IgdG8tbW9kZWwtYXR0cmlidXRlIGNvbnZlcnNpb24uIFRha2VzIHRoZSBtb2RlbCBhdHRyaWJ1dGUgbmFtZSBhbmQgY29udmVyc2lvbiBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zCi8vIGEgcHJvcGVyIGNvbnZlcnRlciBmdW5jdGlvbi4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IG1vZGVsQXR0cmlidXRlS2V5IFRoZSBrZXkgb2YgdGhlIG1vZGVsIGF0dHJpYnV0ZSB0byBzZXQgb24gYSBtb2RlbCBub2RlLgovLyBAcGFyYW0ge09iamVjdHxBcnJheS48T2JqZWN0Pn0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4gSXQgaXMgcG9zc2libGUgdG8gcHJvdmlkZSBtdWx0aXBsZSBjb25maWd1cmF0aW9ucyBpbiBhbiBhcnJheS4KLy8gQHBhcmFtIHtCb29sZWFufSBzaGFsbG93IElmIHNldCB0byBgdHJ1ZWAgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCBvbmx5IG9uIHRvcC1sZXZlbCBub2Rlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIHNldAovLyBvbiBhbGwgZWxlbWVudHMgaW4gdGhlIHJhbmdlLgoKCmZ1bmN0aW9uIHByZXBhcmVUb0F0dHJpYnV0ZUNvbnZlcnRlcihjb25maWcsIHNoYWxsb3cpIHsKICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKGNvbmZpZy52aWV3KTsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIG1hdGNoID0gbWF0Y2hlci5tYXRjaChkYXRhLnZpZXdJdGVtKTsgLy8gSWYgdGhlcmUgaXMgbm8gbWF0Y2gsIHRoaXMgY2FsbGJhY2sgc2hvdWxkIG5vdCBkbyBhbnl0aGluZy4KCiAgICBpZiAoIW1hdGNoKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgbW9kZWxLZXkgPSBjb25maWcubW9kZWwua2V5OwogICAgdmFyIG1vZGVsVmFsdWUgPSB0eXBlb2YgY29uZmlnLm1vZGVsLnZhbHVlID09ICdmdW5jdGlvbicgPyBjb25maWcubW9kZWwudmFsdWUoZGF0YS52aWV3SXRlbSkgOiBjb25maWcubW9kZWwudmFsdWU7IC8vIERvIG5vdCBjb252ZXJ0IGlmIGF0dHJpYnV0ZSBidWlsZGluZyBmdW5jdGlvbiByZXR1cm5lZCBmYWxzeSB2YWx1ZS4KCiAgICBpZiAobW9kZWxWYWx1ZSA9PT0gbnVsbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKG9ubHlWaWV3TmFtZUlzRGVmaW5lZChjb25maWcudmlldywgZGF0YS52aWV3SXRlbSkpIHsKICAgICAgbWF0Y2gubWF0Y2gubmFtZSA9IHRydWU7CiAgICB9IGVsc2UgewogICAgICAvLyBEbyBub3QgdGVzdCBvciBjb25zdW1lIGBuYW1lYCBjb25zdW1hYmxlLgogICAgICBkZWxldGUgbWF0Y2gubWF0Y2gubmFtZTsKICAgIH0gLy8gVHJ5IHRvIGNvbnN1bWUgYXBwcm9wcmlhdGUgdmFsdWVzIGZyb20gY29uc3VtYWJsZSB2YWx1ZXMgbGlzdC4KCgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCBtYXRjaC5tYXRjaCkpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBTaW5jZSB3ZSBhcmUgY29udmVydGluZyB0byBhdHRyaWJ1dGUgd2UgbmVlZCBhbiByYW5nZSBvbiB3aGljaCB3ZSB3aWxsIHNldCB0aGUgYXR0cmlidXRlLgogICAgLy8gSWYgdGhlIHJhbmdlIGlzIG5vdCBjcmVhdGVkIHlldCwgd2Ugd2lsbCBjcmVhdGUgaXQuCgoKICAgIGlmICghZGF0YS5tb2RlbFJhbmdlKSB7CiAgICAgIC8vIENvbnZlcnQgY2hpbGRyZW4gYW5kIHNldCBjb252ZXJzaW9uIHJlc3VsdCBhcyBhIGN1cnJlbnQgZGF0YS4KICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwgY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oZGF0YS52aWV3SXRlbSwgZGF0YS5tb2RlbEN1cnNvcikpOwogICAgfSAvLyBTZXQgYXR0cmlidXRlIG9uIGN1cnJlbnQgYG91dHB1dGAuIGBTY2hlbWFgIGlzIGNoZWNrZWQgaW5zaWRlIHRoaXMgaGVscGVyIGZ1bmN0aW9uLgoKCiAgICB2YXIgYXR0cmlidXRlV2FzU2V0ID0gc2V0QXR0cmlidXRlT24oZGF0YS5tb2RlbFJhbmdlLCB7CiAgICAgIGtleTogbW9kZWxLZXksCiAgICAgIHZhbHVlOiBtb2RlbFZhbHVlCiAgICB9LCBzaGFsbG93LCBjb252ZXJzaW9uQXBpKTsKCiAgICBpZiAoYXR0cmlidXRlV2FzU2V0KSB7CiAgICAgIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0sIG1hdGNoLm1hdGNoKTsKICAgIH0KICB9Owp9IC8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiBlbGVtZW50IG5hbWUgc2hvdWxkIGJlIGNvbnN1bWVkIGluIGF0dHJpYnV0ZSBjb252ZXJ0ZXJzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gdmlldyBjb25maWcuCi8vIEByZXR1cm5zIHtCb29sZWFufQoKCmZ1bmN0aW9uIG9ubHlWaWV3TmFtZUlzRGVmaW5lZCh2aWV3Q29uZmlnLCB2aWV3SXRlbSkgewogIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNzg2CiAgdmFyIGNvbmZpZ1RvVGVzdCA9IHR5cGVvZiB2aWV3Q29uZmlnID09ICdmdW5jdGlvbicgPyB2aWV3Q29uZmlnKHZpZXdJdGVtKSA6IHZpZXdDb25maWc7CgogIGlmIChfdHlwZW9mKGNvbmZpZ1RvVGVzdCkgPT0gJ29iamVjdCcgJiYgIWdldFZpZXdFbGVtZW50TmFtZUZyb21Db25maWcoY29uZmlnVG9UZXN0KSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KCiAgcmV0dXJuICFjb25maWdUb1Rlc3QuY2xhc3NlcyAmJiAhY29uZmlnVG9UZXN0LmF0dHJpYnV0ZXMgJiYgIWNvbmZpZ1RvVGVzdC5zdHlsZXM7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB0by1tb2RlbC1hdHRyaWJ1dGUgY29udmVydGVyLiBTZXRzIG1vZGVsIGF0dHJpYnV0ZSBvbiBnaXZlbiByYW5nZS4gQ2hlY2tzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9Ci8vIHRvIGVuc3VyZSBwcm9wZXIgbW9kZWwgc3RydWN0dXJlLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG1vZGVsUmFuZ2UgTW9kZWwgcmFuZ2Ugb24gd2hpY2ggYXR0cmlidXRlIHNob3VsZCBiZSBzZXQuCi8vIEBwYXJhbSB7T2JqZWN0fSBtb2RlbEF0dHJpYnV0ZSBNb2RlbCBhdHRyaWJ1dGUgdG8gc2V0LgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGl9IGNvbnZlcnNpb25BcGkgQ29udmVyc2lvbiBBUEkuCi8vIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvdyBJZiBzZXQgdG8gYHRydWVgIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgb25seSBvbiB0b3AtbGV2ZWwgbm9kZXMuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBzZXQKLy8gb24gYWxsIGVsZW1lbnRzIGluIHRoZSByYW5nZS4KLy8gQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhdHRyaWJ1dGUgd2FzIHNldCBvbiBhdCBsZWFzdCBvbmUgbm9kZSBmcm9tIGdpdmVuIGBtb2RlbFJhbmdlYC4KCgpmdW5jdGlvbiBzZXRBdHRyaWJ1dGVPbihtb2RlbFJhbmdlLCBtb2RlbEF0dHJpYnV0ZSwgc2hhbGxvdywgY29udmVyc2lvbkFwaSkgewogIHZhciByZXN1bHQgPSBmYWxzZTsgLy8gU2V0IGF0dHJpYnV0ZSBvbiBlYWNoIGl0ZW0gaW4gcmFuZ2UgYWNjb3JkaW5nIHRvIFNjaGVtYS4KCiAgZm9yICh2YXIgX2kgPSAwLCBfQXJyYXkkZnJvbSA9IEFycmF5LmZyb20obW9kZWxSYW5nZS5nZXRJdGVtcyh7CiAgICBzaGFsbG93OiBzaGFsbG93CiAgfSkpOyBfaSA8IF9BcnJheSRmcm9tLmxlbmd0aDsgX2krKykgewogICAgdmFyIG5vZGUgPSBfQXJyYXkkZnJvbVtfaV07CgogICAgaWYgKGNvbnZlcnNpb25BcGkuc2NoZW1hLmNoZWNrQXR0cmlidXRlKG5vZGUsIG1vZGVsQXR0cmlidXRlLmtleSkpIHsKICAgICAgY29udmVyc2lvbkFwaS53cml0ZXIuc2V0QXR0cmlidXRlKG1vZGVsQXR0cmlidXRlLmtleSwgbW9kZWxBdHRyaWJ1dGUudmFsdWUsIG5vZGUpOwogICAgICByZXN1bHQgPSB0cnVlOwogICAgfQogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHVwY2FzdGluZy10by1tYXJrZXIgY29udmVyc2lvbi4gVGFrZXMgdGhlIGNvbmZpZyBpbiBhIGZvcm1hdCByZXF1ZXN0ZWQgYnkgYHVwY2FzdEVsZW1lbnRUb01hcmtlcigpYAovLyBmdW5jdGlvbiBhbmQgY29udmVydHMgaXQgdG8gYSBmb3JtYXQgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgYF91cGNhc3RFbGVtZW50VG9FbGVtZW50KClgIGZ1bmN0aW9uLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KCgpmdW5jdGlvbiBub3JtYWxpemVUb01hcmtlckNvbmZpZyhjb25maWcpIHsKICB2YXIgb2xkTW9kZWwgPSBjb25maWcubW9kZWw7CgogIGNvbmZpZy5tb2RlbCA9IGZ1bmN0aW9uICh2aWV3RWxlbWVudCwgbW9kZWxXcml0ZXIpIHsKICAgIHZhciBtYXJrZXJOYW1lID0gdHlwZW9mIG9sZE1vZGVsID09ICdzdHJpbmcnID8gb2xkTW9kZWwgOiBvbGRNb2RlbCh2aWV3RWxlbWVudCk7CiAgICByZXR1cm4gbW9kZWxXcml0ZXIuY3JlYXRlRWxlbWVudCgnJG1hcmtlcicsIHsKICAgICAgJ2RhdGEtbmFtZSc6IG1hcmtlck5hbWUKICAgIH0pOwogIH07Cn0="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js"],"names":["Matcher","ModelRange","ConversionHelpers","cloneDeep","ModelSelection","UpcastHelpers","config","add","upcastElementToElement","upcastElementToAttribute","upcastAttributeToAttribute","upcastElementToMarker","convertToModelFragment","evt","data","conversionApi","modelRange","consumable","consume","viewItem","name","convertChildren","modelCursor","convertText","schema","checkChild","text","writer","createText","insert","_createFromPositionAndShift","offsetSize","end","convertSelectionChange","model","mapper","viewSelection","newSelection","modelSelection","ranges","getRanges","viewRange","push","toModelRange","setTo","backward","isBackward","isEqual","document","selection","change","setSelection","converter","prepareToElementConverter","elementName","getViewElementNameFromConfig","view","eventName","dispatcher","on","priority","converterPriority","normalizeModelAttributeConfig","prepareToAttributeConverter","viewKey","key","normalizeViewAttributeKeyValueConfig","normalizeToMarkerConfig","viewConfig","matcher","match","matcherResult","modelElement","getModelElement","test","splitResult","splitToAllowedParent","position","createPositionAt","parts","getSplitParts","createPositionBefore","createPositionAfter","length","cursorParent","input","Function","createElement","normalized","keyName","value","attributes","viewAttributeKeyToCopy","defaultModelValue","viewElement","getAttribute","shallow","modelKey","modelValue","onlyViewNameIsDefined","Object","assign","attributeWasSet","setAttributeOn","configToTest","classes","styles","modelAttribute","result","Array","from","getItems","node","checkAttribute","setAttribute","oldModel","modelWriter","markerName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport Matcher from '../view/matcher';\nimport ModelRange from '../model/range';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport ModelSelection from '../model/selection';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class UpcastHelpers extends ConversionHelpers {\n\t/**\n\t * View element to model element conversion helper.\n\t *\n\t * This conversion results in creating a model element. For example,\n\t * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n\t *\n\t * Keep in mind that the element will be inserted only if it is allowed\n\t * by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'fancyParagraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t * \t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'heading'\n\t * \t\t\t},\n\t * \t\t\tmodel: ( viewElement, modelWriter ) => {\n\t * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n\t * \t\t\t}\n\t * \t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n\t * set, the converter will fire for every view element.\n\t * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n\t * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( upcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * View element to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n\t * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n\t *\n\t * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-size': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n\t *\n\t *\t\t\t\t\tif ( value <= 10 ) {\n\t *\t\t\t\t\t\treturn 'small';\n\t *\t\t\t\t\t} else if ( value > 12 ) {\n\t *\t\t\t\t\t\treturn 'big';\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be set to `true`.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToAttribute( config ) {\n\t\treturn this.add( upcastElementToAttribute( config ) );\n\t}\n\n\t/**\n\t * View attribute to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n\t * `<image source=\"foo.jpg\"></image>` in the model.\n\t *\n\t * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n\t * is set only on the corresponding model node:\n\t *\n\t *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n\t *\n\t * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n\t * all the children in the model:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: 'src',\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tconverterPriority: 'normal'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'data-style',\n\t *\t\t\t\tvalue: /[\\s\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: 'styled'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'img',\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-dark'\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: /styled-[\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled'\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n\t *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n\t *\n\t *\t\t\t\t\treturn match[ 1 ];\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n\t * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n\t * callback that returns the desired value.\n\t *\n\t *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'line-height': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'lineHeight',\n\t *\t\t\t\tvalue: viewElement => viewElement.getStyle( 'line-height' )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n\t * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n\t * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n\t * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n\t * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be same as view attribute value.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( upcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * View element to model marker conversion helper.\n\t *\n\t * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n\t * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n\t * after the conversion is done, the marker will be available in\n\t * {@link module:engine/model/model~Model#markers model document markers}.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n\t * a model marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToMarker( config ) {\n\t\treturn this.add( upcastElementToMarker( config ) );\n\t}\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( conversionApi.schema.checkChild( data.modelCursor, '$text' ) ) {\n\t\t\tif ( conversionApi.consumable.consume( data.viewItem ) ) {\n\t\t\t\tconst text = conversionApi.writer.createText( data.viewItem.data );\n\n\t\t\t\tconversionApi.writer.insert( text, data.modelCursor );\n\n\t\t\t\tdata.modelRange = ModelRange._createFromPositionAndShift( data.modelCursor, text.offsetSize );\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\t\tconst modelSelection = new ModelSelection();\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tmodelSelection.setTo( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n\n// View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = prepareToElementConverter( config );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeModelAttributeConfig( config );\n\n\tconst converter = prepareToAttributeConverter( config, false );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\tnormalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction getViewElementNameFromConfig( viewConfig ) {\n\tif ( typeof viewConfig == 'string' ) {\n\t\treturn viewConfig;\n\t}\n\n\tif ( typeof viewConfig == 'object' && typeof viewConfig.name == 'string' ) {\n\t\treturn viewConfig.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction prepareToElementConverter( config ) {\n\tconst matcher = config.view ? new Matcher( config.view ) : null;\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tlet match = {};\n\n\t\t// If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.\n\t\tif ( matcher ) {\n\t\t\t// This will be usually just one pattern but we support matchers with many patterns too.\n\t\t\tconst matcherResult = matcher.match( data.viewItem );\n\n\t\t\t// If there is no match, this callback should not do anything.\n\t\t\tif ( !matcherResult ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmatch = matcherResult.match;\n\t\t}\n\n\t\t// Force consuming element's name.\n\t\tmatch.name = true;\n\n\t\t// Create model element basing on config.\n\t\tconst modelElement = getModelElement( config.model, data.viewItem, conversionApi.writer );\n\n\t\t// Do not convert if element building function returned falsy value.\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When element was already consumed then skip it.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( modelElement, data.modelCursor );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tconversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\t// Convert children and insert to element.\n\t\tconversionApi.convertChildren( data.viewItem, conversionApi.writer.createPositionAt( modelElement, 0 ) );\n\n\t\t// Consume appropriate value from consumable values list.\n\t\tconversionApi.consumable.consume( data.viewItem, match );\n\n\t\tconst parts = conversionApi.getSplitParts( modelElement );\n\n\t\t// Set conversion result range.\n\t\tdata.modelRange = new ModelRange(\n\t\t\tconversionApi.writer.createPositionBefore( modelElement ),\n\t\t\tconversionApi.writer.createPositionAfter( parts[ parts.length - 1 ] )\n\t\t);\n\n\t\t// Now we need to check where the `modelCursor` should be.\n\t\tif ( splitResult.cursorParent ) {\n\t\t\t// If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\n\t\t\tdata.modelCursor = conversionApi.writer.createPositionAt( splitResult.cursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise just continue after inserted element.\n\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\nfunction getModelElement( model, input, writer ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, writer );\n\t} else {\n\t\treturn writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ? config.model.value( data.viewItem ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onlyViewNameIsDefined( config.view, data.viewItem ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need an range on which we will set the attribute.\n\t\t// If the range is not created yet, we will create it.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\nfunction onlyViewNameIsDefined( viewConfig, viewItem ) {\n\t// https://github.com/ckeditor/ckeditor5-engine/issues/1786\n\tconst configToTest = typeof viewConfig == 'function' ? viewConfig( viewItem ) : viewConfig;\n\n\tif ( typeof configToTest == 'object' && !getViewElementNameFromConfig( configToTest ) ) {\n\t\treturn false;\n\t}\n\n\treturn !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\tif ( conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `_upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, modelWriter ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement );\n\n\t\treturn modelWriter.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n"]}]}