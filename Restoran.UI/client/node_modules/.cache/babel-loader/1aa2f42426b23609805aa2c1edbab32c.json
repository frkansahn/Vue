{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\downcastwriter.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\downcastwriter.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnNldCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcgogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgQ29udGFpbmVyRWxlbWVudCBmcm9tICcuL2NvbnRhaW5lcmVsZW1lbnQnOwppbXBvcnQgQXR0cmlidXRlRWxlbWVudCBmcm9tICcuL2F0dHJpYnV0ZWVsZW1lbnQnOwppbXBvcnQgRW1wdHlFbGVtZW50IGZyb20gJy4vZW1wdHllbGVtZW50JzsKaW1wb3J0IFVJRWxlbWVudCBmcm9tICcuL3VpZWxlbWVudCc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgaXNJdGVyYWJsZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9pc2l0ZXJhYmxlJzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IEVkaXRhYmxlRWxlbWVudCBmcm9tICcuL2VkaXRhYmxlZWxlbWVudCc7CmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnOwovKioKICogVmlldyBkb3duY2FzdCB3cml0ZXIuCiAqCiAqIEl0IHByb3ZpZGVzIGEgc2V0IG9mIG1ldGhvZHMgdXNlZCB0byBtYW5pcHVsYXRlIHZpZXcgbm9kZXMuCiAqCiAqIERvIG5vdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3cml0ZXIgbWFudWFsbHkuIFRvIG1vZGlmeSBhIHZpZXcgc3RydWN0dXJlLCB1c2UKICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2NoYW5nZSBgVmlldyNjaGFuZ2UoKWB9IGJsb2NrLgogKgogKiBUaGUgYERvd25jYXN0V3JpdGVyYCBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggc2VtYW50aWMgdmlld3Mgd2hpY2ggYXJlIHRoZSB2aWV3cyB0aGF0IHdlcmUvYXJlIGJlaW5nIGRvd25jYXN0ZWQgZnJvbSB0aGUgbW9kZWwuCiAqIFRvIHdvcmsgd2l0aCBvcmRpbmFyeSB2aWV3cyAoZS5nLiBwYXJzZWQgZnJvbSBhIHBhc3RlZCBjb250ZW50KSB1c2UgdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdXBjYXN0d3JpdGVyflVwY2FzdFdyaXRlciB1cGNhc3Qgd3JpdGVyfS4KICoKICogUmVhZCBtb3JlIGFib3V0IGNoYW5naW5nIHRoZSB2aWV3IGluIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NoYW5naW5nLXRoZS12aWV3IENoYW5naW5nIHRoZSB2aWV3fQogKiBzZWN0aW9uIG9mIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZX0gZ3VpZGUuCiAqLwoKdmFyIERvd25jYXN0V3JpdGVyID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnR9IGRvY3VtZW50IFRoZSB2aWV3IGRvY3VtZW50IGluc3RhbmNlLgogICAqLwogIGZ1bmN0aW9uIERvd25jYXN0V3JpdGVyKGRvY3VtZW50KSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG93bmNhc3RXcml0ZXIpOwoKICAgIC8qKgogICAgICogVGhlIHZpZXcgZG9jdW1lbnQgaW5zdGFuY2UgaW4gd2hpY2ggdGhpcyB3cml0ZXIgb3BlcmF0ZXMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50fQogICAgICovCiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7CiAgICAvKioKICAgICAqIEhvbGRzIHJlZmVyZW5jZXMgdG8gdGhlIGF0dHJpYnV0ZSBncm91cHMgdGhhdCBzaGFyZSB0aGUgc2FtZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNpZCBpZH0uCiAgICAgKiBUaGUga2V5cyBhcmUgYGlkYHMsIHRoZSB2YWx1ZXMgYXJlIGBTZXRgcyBob2xkaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXAuPFN0cmluZyxTZXQ+fQogICAgICovCgogICAgdGhpcy5fY2xvbmVHcm91cHMgPSBuZXcgTWFwKCk7CiAgfQogIC8qKgogICAqIFNldHMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiBzZWxlY3Rpb24nc30gcmFuZ2VzIGFuZCBkaXJlY3Rpb24gdG8gdGhlCiAgICogc3BlY2lmaWVkIGxvY2F0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3RhYmxlIHNlbGVjdGFibGV9LgogICAqCiAgICogVXNhZ2U6CiAgICoKICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIHJhbmdlLgogICAqCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSApOwogICAqCiAgICoJCS8vIFNldHMgYmFja3dhcmQgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiByYW5nZS4KICAgKgkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0LCBlbmQgKTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UgKTsKICAgKgogICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byBnaXZlbiByYW5nZXMuCiAgICogCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQyLCBlbmQyICkgXTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UgKTsKICAgKgogICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byB0aGUgb3RoZXIgc2VsZWN0aW9uLgogICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggb3RoZXJTZWxlY3Rpb24gKTsKICAgKgogICAqIAkJLy8gU2V0cyBjb2xsYXBzZWQgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4KICAgKgkJY29uc3QgcG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgcGF0aCApOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwb3NpdGlvbiApOwogICAqCiAgICogCQkvLyBTZXRzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIGdpdmVuIGl0ZW0gYW5kIG9mZnNldC4KICAgKgkJY29uc3QgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJyApOwogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwYXJhZ3JhcGgsIG9mZnNldCApOwogICAqCiAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogIAkgKiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAqCiAgICogCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdpbicgKTsKICAgKgogICAqIENyZWF0ZXMgYSByYW5nZSBvbiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gaXRlbX0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgaXRlbSBhbmQgZW5kcyBqdXN0IGFmdGVyIHRoZSBpdGVtLgogICAqCiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ29uJyApOwogICAqCiAgICogCQkvLyBSZW1vdmVzIGFsbCByYW5nZXMuCiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIG51bGwgKTsKICAgKgogICAqIGBEb3duY2FzdFdyaXRlciNzZXRTZWxlY3Rpb24oKWAgYWxsb3cgcGFzc2luZyBhZGRpdGlvbmFsIG9wdGlvbnMgKGBiYWNrd2FyZGAsIGBmYWtlYCBhbmQgYGxhYmVsYCkgYXMgdGhlIGxhc3QgYXJndW1lbnQuCiAgICoKICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gYXMgYmFja3dhcmQuCiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlLCB7IGJhY2t3YXJkOiB0cnVlIH0gKTsKICAgKgogICAqCQkvLyBTZXRzIHNlbGVjdGlvbiBhcyBmYWtlLgogICAqCQkvLyBGYWtlIHNlbGVjdGlvbiBkb2VzIG5vdCByZW5kZXIgYXMgYnJvd3NlciBuYXRpdmUgc2VsZWN0aW9uIG92ZXIgc2VsZWN0ZWQgZWxlbWVudHMgYW5kIGlzIGhpZGRlbiB0byB0aGUgdXNlci4KICAgKiAJCS8vIFRoaXMgd2F5LCBubyBuYXRpdmUgc2VsZWN0aW9uIFVJIGFydGlmYWN0cyBhcmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFuZCBzZWxlY3Rpb24gb3ZlciBlbGVtZW50cyBjYW4gYmUKICAgKiAJCS8vIHJlcHJlc2VudGVkIGluIG90aGVyIHdheSwgZm9yIGV4YW1wbGUgYnkgYXBwbHlpbmcgcHJvcGVyIENTUyBjbGFzcy4KICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UsIHsgZmFrZTogdHJ1ZSB9ICk7CiAgICoKICAgKiAJCS8vIEFkZGl0aW9uYWxseSBmYWtlJ3Mgc2VsZWN0aW9uIGxhYmVsIGNhbiBiZSBwcm92aWRlZC4gSXQgd2lsbCBiZSB1c2VkIHRvIGRlc2NyaWJlIGZha2Ugc2VsZWN0aW9uIGluIERPTQogICAqIAkJLy8gKGFuZCBiZSAgcHJvcGVybHkgaGFuZGxlZCBieSBzY3JlZW4gcmVhZGVycykuCiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlLCB7IGZha2U6IHRydWUsIGxhYmVsOiAnZm9vJyB9ICk7CiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAqIEBwYXJhbSB7TnVtYmVyfCdiZWZvcmUnfCdlbmQnfCdhZnRlcid8J29uJ3wnaW4nfSBbcGxhY2VPck9mZnNldF0gU2V0cyBwbGFjZSBvciBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvbi4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZha2VdIFNldHMgdGhpcyBzZWxlY3Rpb24gaW5zdGFuY2UgdG8gYmUgbWFya2VkIGFzIGBmYWtlYC4KICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFiZWxdIExhYmVsIGZvciB0aGUgZmFrZSBzZWxlY3Rpb24uCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoRG93bmNhc3RXcml0ZXIsIFt7CiAgICBrZXk6ICJzZXRTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIHRoaXMuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogTW92ZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiNmb2N1cyBzZWxlY3Rpb24ncyBmb2N1c30gdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi4KICAgICAqCiAgICAgKiBUaGUgbG9jYXRpb24gY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgc2FtZSBmb3JtIGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2NyZWF0ZVBvc2l0aW9uQXQgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCl9CiAgICAgKiBwYXJhbWV0ZXJzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0U2VsZWN0aW9uRm9jdXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbkZvY3VzKGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpIHsKICAgICAgdGhpcy5kb2N1bWVudC5zZWxlY3Rpb24uX3NldEZvY3VzKGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZX0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSB0ZXh0J3MgZGF0YS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBUaGUgY3JlYXRlZCB0ZXh0IG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGV4dChkYXRhKSB7CiAgICAgIHJldHVybiBuZXcgVGV4dCh0aGlzLmRvY3VtZW50LCBkYXRhKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ3N0cm9uZycgKTsKICAgICAqCQl3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ2EnLCB7IGhyZWY6ICdmb28uYmFyJyB9ICk7CiAgICAgKgogICAgICoJCS8vIE1ha2UgYDxhPmAgZWxlbWVudCBjb250YWluIG90aGVyIGF0dHJpYnV0ZXMgZWxlbWVudCBzbyB0aGUgYDxhPmAgZWxlbWVudCBpcyBub3QgYnJva2VuLgogICAgICoJCXdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnYScsIHsgaHJlZjogJ2Zvby5iYXInIH0sIHsgcHJpb3JpdHk6IDUgfSApOwogICAgICoKICAgICAqCQkvLyBTZXQgYGlkYCBvZiBhIG1hcmtlciBlbGVtZW50IHNvIGl0IGlzIG5vdCBqb2luZWQgb3IgbWVyZ2VkIHdpdGggIm5vcm1hbCIgZWxlbWVudHMuCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzcGFuJywgeyBjbGFzczogJ215LW1hcmtlcicgfSwgeyBpZDogJ21hcmtlcjpteScgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnQncyBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFbGVtZW50J3Mgb3B0aW9ucy4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmlvcml0eV0gRWxlbWVudCdzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I3ByaW9yaXR5IHByaW9yaXR5fS4KICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuaWRdIEVsZW1lbnQncyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNpZCBpZH0uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307CiAgICAgIHZhciBhdHRyaWJ1dGVFbGVtZW50ID0gbmV3IEF0dHJpYnV0ZUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CgogICAgICBpZiAob3B0aW9ucy5wcmlvcml0eSkgewogICAgICAgIGF0dHJpYnV0ZUVsZW1lbnQuX3ByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eTsKICAgICAgfQoKICAgICAgaWYgKG9wdGlvbnMuaWQpIHsKICAgICAgICBhdHRyaWJ1dGVFbGVtZW50Ll9pZCA9IG9wdGlvbnMuaWQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBhdHRyaWJ1dGVFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIG5ldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlIGVsZW1lbnQgd2l0aCBjdXN0b20gYXR0cmlidXRlcy4KICAgICAqCQl3cml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ2RpdicsIHsgaWQ6ICdmb28tYmFyJywgJ2RhdGEtYmF6JzogJzEyMycgfSApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGUgZWxlbWVudCB3aXRoIGN1c3RvbSBzdHlsZXMuCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJywgeyBzdHlsZTogJ2ZvbnQtd2VpZ2h0OiBib2xkOyBwYWRkaW5nLWJvdHRvbTogMTBweCcgfSApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGUgZWxlbWVudCB3aXRoIGN1c3RvbSBjbGFzc2VzLgogICAgICoJCXdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcsIHsgY2xhc3M6ICdmb28gYmFyIGJheicgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUNvbnRhaW5lckVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgICByZXR1cm4gbmV3IENvbnRhaW5lckVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVFZGl0YWJsZUVsZW1lbnQoICdkaXYnICk7CiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVkaXRhYmxlRWxlbWVudCggJ2RpdicsIHsgaWQ6ICdmb28tMTIzNCcgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VkaXRhYmxlZWxlbWVudH5FZGl0YWJsZUVsZW1lbnR9IENyZWF0ZWQgZWxlbWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVFZGl0YWJsZUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVkaXRhYmxlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7CiAgICAgIHZhciBlZGl0YWJsZUVsZW1lbnQgPSBuZXcgRWRpdGFibGVFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG5hbWUsIGF0dHJpYnV0ZXMpOwogICAgICBlZGl0YWJsZUVsZW1lbnQuX2RvY3VtZW50ID0gdGhpcy5kb2N1bWVudDsKICAgICAgcmV0dXJuIGVkaXRhYmxlRWxlbWVudDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50fS4KICAgICAqCiAgICAgKgkJd3JpdGVyLmNyZWF0ZUVtcHR5RWxlbWVudCggJ2ltZycgKTsKICAgICAqCQl3cml0ZXIuY3JlYXRlRW1wdHlFbGVtZW50KCAnaW1nJywgeyBpZDogJ2Zvby0xMjM0JyB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUVtcHR5RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRW1wdHlFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpIHsKICAgICAgcmV0dXJuIG5ldyBFbXB0eUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0uCiAgICAgKgogICAgICoJCXdyaXRlci5jcmVhdGVVSUVsZW1lbnQoICdzcGFuJyApOwogICAgICoJCXdyaXRlci5jcmVhdGVVSUVsZW1lbnQoICdzcGFuJywgeyBpZDogJ2Zvby0xMjM0JyB9ICk7CiAgICAgKgogICAgICogQ3VzdG9tIHJlbmRlciBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQgYXMgdGhpcmQgcGFyYW1ldGVyOgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlVUlFbGVtZW50KCAnc3BhbicsIG51bGwsIGZ1bmN0aW9uKCBkb21Eb2N1bWVudCApIHsKICAgICAqCQkJY29uc3QgZG9tRWxlbWVudCA9IHRoaXMudG9Eb21FbGVtZW50KCBkb21Eb2N1bWVudCApOwogICAgICoJCQlkb21FbGVtZW50LmlubmVySFRNTCA9ICc8Yj50aGlzIGlzIHVpIGVsZW1lbnQ8L2I+JzsKICAgICAqCiAgICAgKgkJCXJldHVybiBkb21FbGVtZW50OwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBFbGVtZW50cyBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbmRlckZ1bmN0aW9uXSBDdXN0b20gcmVuZGVyIGZ1bmN0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSBDcmVhdGVkIGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlVUlFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVVSUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgcmVuZGVyRnVuY3Rpb24pIHsKICAgICAgdmFyIHVpRWxlbWVudCA9IG5ldyBVSUVsZW1lbnQodGhpcy5kb2N1bWVudCwgbmFtZSwgYXR0cmlidXRlcyk7CgogICAgICBpZiAocmVuZGVyRnVuY3Rpb24pIHsKICAgICAgICB1aUVsZW1lbnQucmVuZGVyID0gcmVuZGVyRnVuY3Rpb247CiAgICAgIH0KCiAgICAgIHJldHVybiB1aUVsZW1lbnQ7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgb3Igb3ZlcndyaXRlIGVsZW1lbnQncyBhdHRyaWJ1dGUgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0QXR0cmlidXRlKCAnaHJlZicsICdodHRwOi8vY2tlZGl0b3IuY29tJywgbGlua0VsZW1lbnQgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSwgZWxlbWVudCkgewogICAgICBlbGVtZW50Ll9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYXR0cmlidXRlIGZyb20gdGhlIGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5yZW1vdmVBdHRyaWJ1dGUoICdocmVmJywgbGlua0VsZW1lbnQgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW1vdmVBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShrZXksIGVsZW1lbnQpIHsKICAgICAgZWxlbWVudC5fcmVtb3ZlQXR0cmlidXRlKGtleSk7CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgc3BlY2lmaWVkIGNsYXNzIHRvIHRoZSBlbGVtZW50LgogICAgICoKICAgICAqCQl3cml0ZXIuYWRkQ2xhc3MoICdmb28nLCBsaW5rRWxlbWVudCApOwogICAgICoJCXdyaXRlci5hZGRDbGFzcyggWyAnZm9vJywgJ2JhcicgXSwgbGlua0VsZW1lbnQgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fFN0cmluZ30gY2xhc3NOYW1lCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhZGRDbGFzcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NOYW1lLCBlbGVtZW50KSB7CiAgICAgIGVsZW1lbnQuX2FkZENsYXNzKGNsYXNzTmFtZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgc3BlY2lmaWVkIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5yZW1vdmVDbGFzcyggJ2ZvbycsIGxpbmtFbGVtZW50ICk7CiAgICAgKgkJd3JpdGVyLnJlbW92ZUNsYXNzKCBbICdmb28nLCAnYmFyJyBdLCBsaW5rRWxlbWVudCApOwogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz58U3RyaW5nfSBjbGFzc05hbWUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZUNsYXNzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc05hbWUsIGVsZW1lbnQpIHsKICAgICAgZWxlbWVudC5fcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBzdHlsZSB0byB0aGUgZWxlbWVudC4KICAgICAqCiAgICAgKgkJd3JpdGVyLnNldFN0eWxlKCAnY29sb3InLCAncmVkJywgZWxlbWVudCApOwogICAgICoJCXdyaXRlci5zZXRTdHlsZSggewogICAgICoJCQljb2xvcjogJ3JlZCcsCiAgICAgKgkJCXBvc2l0aW9uOiAnZml4ZWQnCiAgICAgKgkJfSwgZWxlbWVudCApOwogICAgICoKICAgICAqICoqTm90ZSoqOiBUaGUgcGFzc2VkIHN0eWxlIGNhbiBiZSBub3JtYWxpemVkIGlmCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyfkRhdGFDb250cm9sbGVyI2FkZFN0eWxlUHJvY2Vzc29yUnVsZXMgYSBwYXJ0aWN1bGFyIHN0eWxlIHByb2Nlc3NvciBydWxlIGlzIGVuYWJsZWR9LgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc01hcCNzZXQgYFN0eWxlc01hcCNzZXQoKWB9IGZvciBkZXRhaWxzLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgbmFtZSBvciBvYmplY3Qgd2l0aCBrZXkgLSB2YWx1ZSBwYWlycy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdIFZhbHVlIHRvIHNldC4gVGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZCBpZiBvYmplY3QgaXMgcHJvdmlkZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHNldCBzdHlsZXMgb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0U3R5bGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0eWxlKHByb3BlcnR5LCB2YWx1ZSwgZWxlbWVudCkgewogICAgICBpZiAoaXNQbGFpbk9iamVjdChwcm9wZXJ0eSkgJiYgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgZWxlbWVudCA9IHZhbHVlOwogICAgICB9CgogICAgICBlbGVtZW50Ll9zZXRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIHNwZWNpZmllZCBzdHlsZSBmcm9tIHRoZSBlbGVtZW50LgogICAgICoKICAgICAqCQl3cml0ZXIucmVtb3ZlU3R5bGUoICdjb2xvcicsIGVsZW1lbnQgKTsgLy8gUmVtb3ZlcyAnY29sb3InIHN0eWxlLgogICAgICoJCXdyaXRlci5yZW1vdmVTdHlsZSggWyAnY29sb3InLCAnYm9yZGVyLXRvcCcgXSwgZWxlbWVudCApOyAvLyBSZW1vdmVzIGJvdGggJ2NvbG9yJyBhbmQgJ2JvcmRlci10b3AnIHN0eWxlcy4KICAgICAqCiAgICAgKiAqKk5vdGUqKjogVGhpcyBtZXRob2QgY2FuIHdvcmsgd2l0aCBub3JtYWxpemVkIHN0eWxlIG5hbWVzIGlmCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyfkRhdGFDb250cm9sbGVyI2FkZFN0eWxlUHJvY2Vzc29yUnVsZXMgYSBwYXJ0aWN1bGFyIHN0eWxlIHByb2Nlc3NvciBydWxlIGlzIGVuYWJsZWR9LgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc01hcCNyZW1vdmUgYFN0eWxlc01hcCNyZW1vdmUoKWB9IGZvciBkZXRhaWxzLgogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz58U3RyaW5nfSBwcm9wZXJ0eQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlU3R5bGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVN0eWxlKHByb3BlcnR5LCBlbGVtZW50KSB7CiAgICAgIGVsZW1lbnQuX3JlbW92ZVN0eWxlKHByb3BlcnR5KTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBhIGN1c3RvbSBwcm9wZXJ0eSBvbiBlbGVtZW50LiBVbmxpa2UgYXR0cmlidXRlcywgY3VzdG9tIHByb3BlcnRpZXMgYXJlIG5vdCByZW5kZXJlZCB0byB0aGUgRE9NLAogICAgICogc28gdGhleSBjYW4gYmUgdXNlZCB0byBhZGQgc3BlY2lhbCBkYXRhIHRvIGVsZW1lbnRzLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0ga2V5CiAgICAgKiBAcGFyYW0geyp9IHZhbHVlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRDdXN0b21Qcm9wZXJ0eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VzdG9tUHJvcGVydHkoa2V5LCB2YWx1ZSwgZWxlbWVudCkgewogICAgICBlbGVtZW50Ll9zZXRDdXN0b21Qcm9wZXJ0eShrZXksIHZhbHVlKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhIGN1c3RvbSBwcm9wZXJ0eSBzdG9yZWQgdW5kZXIgdGhlIGdpdmVuIGtleS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IGtleQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHByb3BlcnR5IHdhcyByZW1vdmVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZUN1c3RvbVByb3BlcnR5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wZXJ0eShrZXksIGVsZW1lbnQpIHsKICAgICAgcmV0dXJuIGVsZW1lbnQuX3JlbW92ZUN1c3RvbVByb3BlcnR5KGtleSk7CiAgICB9CiAgICAvKioKICAgICAqIEJyZWFrcyBhdHRyaWJ1dGUgbm9kZXMgYXQgcHJvdmlkZWQgcG9zaXRpb24gb3IgYXQgYm91bmRhcmllcyBvZiBwcm92aWRlZCByYW5nZS4gSXQgYnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBpbnNpZGUKICAgICAqIHVwIHRvIGEgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgKgogICAgICogSW4gZm9sbG93aW5nIGV4YW1wbGVzIGA8cD5gIGlzIGEgY29udGFpbmVyLCBgPGI+YCBhbmQgYDx1PmAgYXJlIGF0dHJpYnV0ZSBub2RlczoKICAgICAqCiAgICAgKgkJPHA+Zm9vPGI+PHU+YmFye308L3U+PC9iPjwvcD4gLT4gPHA+Zm9vPGI+PHU+YmFyPC91PjwvYj5bXTwvcD4KICAgICAqCQk8cD5mb288Yj48dT57fWJhcjwvdT48L2I+PC9wPiAtPiA8cD5mb297fTxiPjx1PmJhcjwvdT48L2I+PC9wPgogICAgICoJCTxwPmZvbzxiPjx1PmJ7fWFyPC91PjwvYj48L3A+IC0+IDxwPmZvbzxiPjx1PmI8L3U+PC9iPltdPGI+PHU+YXI8L3U+PC9iPjwvcD4KICAgICAqCQk8cD48Yj5mb3tvPC9iPjx1PmJhfXI8L3U+PC9wPiAtPiA8cD48Yj5mbzwvYj48Yj5vPC9iPjx1PmJhPC91Pjx1PnI8L3U+PC9iPjwvcD4KICAgICAqCiAgICAgKiAqKk5vdGU6Kioge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgRG9jdW1lbnRGcmFnbWVudH0gaXMgdHJlYXRlZCBsaWtlIGEgY29udGFpbmVyLgogICAgICoKICAgICAqICoqTm90ZToqKiBEaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMgYnJlYWtBdHRyaWJ1dGVzfSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtDb250YWluZXIgYnJlYWtDb250YWluZXJ9IGlzIHRoYXQgYGJyZWFrQXR0cmlidXRlc2AgYnJlYWtzIGFsbAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnRzfSB0aGF0IGFyZSBhbmNlc3RvcnMgb2YgZ2l2ZW4gYHBvc2l0aW9uYCwKICAgICAqIHVwIHRvIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0uCiAgICAgKiBgYnJlYWtDb250YWluZXJgIGFzc3VtZXMgdGhhdCBnaXZlbiBgcG9zaXRpb25gIGlzIGRpcmVjdGx5IGluIGNvbnRhaW5lciBlbGVtZW50IGFuZCBicmVha3MgdGhhdCBjb250YWluZXIgZWxlbWVudC4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYAogICAgICogd2hlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fQogICAgICogYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zIG9mIGEgcGFzc2VkIHJhbmdlIGFyZSBub3QgcGxhY2VkIGluc2lkZSBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstZW1wdHktZWxlbWVudGAKICAgICAqIHdoZW4gdHJ5aW5nIHRvIGJyZWFrIGF0dHJpYnV0ZXMKICAgICAqIGluc2lkZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50YAogICAgICogd2hlbiB0cnlpbmcgdG8gYnJlYWsgYXR0cmlidXRlcwogICAgICogaW5zaWRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnR9LgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudAogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0NvbnRhaW5lcgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb258bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBwb3NpdGlvbk9yUmFuZ2UgUG9zaXRpb24gd2hlcmUKICAgICAqIHRvIGJyZWFrIGF0dHJpYnV0ZSBlbGVtZW50cy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb258bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBOZXcgcG9zaXRpb24gb3IgcmFuZ2UsIGFmdGVyIGJyZWFraW5nIHRoZSBhdHRyaWJ1dGUKICAgICAqIGVsZW1lbnRzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImJyZWFrQXR0cmlidXRlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uT3JSYW5nZSkgewogICAgICBpZiAocG9zaXRpb25PclJhbmdlIGluc3RhbmNlb2YgUG9zaXRpb24pIHsKICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uT3JSYW5nZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlc1JhbmdlKHBvc2l0aW9uT3JSYW5nZSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQnJlYWtzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciB2aWV3IGVsZW1lbnR9IGludG8gdHdvLCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFBvc2l0aW9uCiAgICAgKiBoYXMgdG8gYmUgZGlyZWN0bHkgaW5zaWRlIGNvbnRhaW5lciBlbGVtZW50IGFuZCBjYW5ub3QgYmUgaW4gcm9vdC4gRG9lcyBub3QgYnJlYWsgaWYgcG9zaXRpb24gaXMgYXQgdGhlIGJlZ2lubmluZwogICAgICogb3IgYXQgdGhlIGVuZCBvZiBpdCdzIHBhcmVudCBlbGVtZW50LgogICAgICoKICAgICAqCQk8cD5mb29eYmFyPC9wPiAtPiA8cD5mb288L3A+PHA+YmFyPC9wPgogICAgICoJCTxkaXY+PHA+Zm9vPC9wPl48cD5iYXI8L3A+PC9kaXY+IC0+IDxkaXY+PHA+Zm9vPC9wPjwvZGl2PjxkaXY+PHA+YmFyPC9wPjwvZGl2PgogICAgICoJCTxwPl5mb29iYXI8L3A+IC0+IF48cD5mb29iYXI8L3A+CiAgICAgKgkJPHA+Zm9vYmFyXjwvcD4gLT4gPHA+Zm9vYmFyPC9wPl4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogRGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjYnJlYWtBdHRyaWJ1dGVzIGJyZWFrQXR0cmlidXRlc30gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQ29udGFpbmVyIGJyZWFrQ29udGFpbmVyfSBpcyB0aGF0IGBicmVha0F0dHJpYnV0ZXNgIGJyZWFrcyBhbGwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30gdGhhdCBhcmUgYW5jZXN0b3JzIG9mIGdpdmVuIGBwb3NpdGlvbmAsCiAgICAgKiB1cCB0byB0aGUgZmlyc3QgZW5jb3VudGVyZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIGVsZW1lbnR9LgogICAgICogYGJyZWFrQ29udGFpbmVyYCBhc3N1bWVzIHRoYXQgZ2l2ZW4gYHBvc2l0aW9uYCBpcyBkaXJlY3RseSBpbiBjb250YWluZXIgZWxlbWVudCBhbmQgYnJlYWtzIHRoYXQgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQXR0cmlidXRlcwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHdoZXJlIHRvIGJyZWFrIGVsZW1lbnQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBQb3NpdGlvbiBiZXR3ZWVuIGJyb2tlbiBlbGVtZW50cy4gSWYgZWxlbWVudCBoYXMgbm90IGJlZW4gYnJva2VuLAogICAgICogdGhlIHJldHVybmVkIHBvc2l0aW9uIGlzIHBsYWNlZCBlaXRoZXIgYmVmb3JlIGl0IG9yIGFmdGVyIGl0LgogICAgICovCgogIH0sIHsKICAgIGtleTogImJyZWFrQ29udGFpbmVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBicmVha0NvbnRhaW5lcihwb3NpdGlvbikgewogICAgICB2YXIgZWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIGlmICghZWxlbWVudC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVHJ5aW5nIHRvIGJyZWFrIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItYnJlYWstbm9uLWNvbnRhaW5lci1lbGVtZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWJyZWFrLW5vbi1jb250YWluZXItZWxlbWVudDogVHJ5aW5nIHRvIGJyZWFrIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgY29udGFpbmVyIGVsZW1lbnQuJywgdGhpcy5kb2N1bWVudCk7CiAgICAgIH0KCiAgICAgIGlmICghZWxlbWVudC5wYXJlbnQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gYnJlYWsgcm9vdCBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWJyZWFrLXJvb3QKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItYnJlYWstcm9vdDogVHJ5aW5nIHRvIGJyZWFrIHJvb3QgZWxlbWVudC4nLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgaWYgKHBvc2l0aW9uLmlzQXRTdGFydCkgewogICAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGVsZW1lbnQpOwogICAgICB9IGVsc2UgaWYgKCFwb3NpdGlvbi5pc0F0RW5kKSB7CiAgICAgICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50Ll9jbG9uZShmYWxzZSk7CgogICAgICAgIHRoaXMuaW5zZXJ0KFBvc2l0aW9uLl9jcmVhdGVBZnRlcihlbGVtZW50KSwgbmV3RWxlbWVudCk7CiAgICAgICAgdmFyIHNvdXJjZVJhbmdlID0gbmV3IFJhbmdlKHBvc2l0aW9uLCBQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgJ2VuZCcpKTsKICAgICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24obmV3RWxlbWVudCwgMCk7CiAgICAgICAgdGhpcy5tb3ZlKHNvdXJjZVJhbmdlLCB0YXJnZXRQb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoZWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIE1lcmdlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9LiBJdCBhbHNvIG1lcmdlcyB0ZXh0IG5vZGVzIGlmIG5lZWRlZC4KICAgICAqIE9ubHkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaXNTaW1pbGFyIHNpbWlsYXJ9IGF0dHJpYnV0ZSBlbGVtZW50cyBjYW4gYmUgbWVyZ2VkLgogICAgICoKICAgICAqIEluIGZvbGxvd2luZyBleGFtcGxlcyBgPHA+YCBpcyBhIGNvbnRhaW5lciBhbmQgYDxiPmAgaXMgYW4gYXR0cmlidXRlIGVsZW1lbnQ6CiAgICAgKgogICAgICoJCTxwPmZvb1tdYmFyPC9wPiAtPiA8cD5mb297fWJhcjwvcD4KICAgICAqCQk8cD48Yj5mb288L2I+W108Yj5iYXI8L2I+PC9wPiAtPiA8cD48Yj5mb297fWJhcjwvYj48L3A+CiAgICAgKgkJPHA+PGIgZm9vPSJiYXIiPmE8L2I+W108YiBmb289ImJheiI+YjwvYj48L3A+IC0+IDxwPjxiIGZvbz0iYmFyIj5hPC9iPltdPGIgZm9vPSJiYXoiPmI8L2I+PC9wPgogICAgICoKICAgICAqIEl0IHdpbGwgYWxzbyB0YWtlIGNhcmUgYWJvdXQgZW1wdHkgYXR0cmlidXRlcyB3aGVuIG1lcmdpbmc6CiAgICAgKgogICAgICoJCTxwPjxiPltdPC9iPjwvcD4gLT4gPHA+W108L3A+CiAgICAgKgkJPHA+PGI+Zm9vPC9iPjxpPltdPC9pPjxiPmJhcjwvYj48L3A+IC0+IDxwPjxiPmZvb3t9YmFyPC9iPjwvcD4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogRGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjbWVyZ2VBdHRyaWJ1dGVzIG1lcmdlQXR0cmlidXRlc30gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQ29udGFpbmVycyBtZXJnZUNvbnRhaW5lcnN9IGlzIHRoYXQgYG1lcmdlQXR0cmlidXRlc2AgbWVyZ2VzIHR3bwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnRzfSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGVzfQogICAgICogd2hpbGUgYG1lcmdlQ29udGFpbmVyYCBtZXJnZXMgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30uCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQ29udGFpbmVycwogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIE1lcmdlIHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gYWZ0ZXIgbWVyZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWVyZ2VBdHRyaWJ1dGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMocG9zaXRpb24pIHsKICAgICAgdmFyIHBvc2l0aW9uT2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0OwogICAgICB2YXIgcG9zaXRpb25QYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIFdoZW4gaW5zaWRlIHRleHQgbm9kZSAtIG5vdGhpbmcgdG8gbWVyZ2UuCgogICAgICBpZiAocG9zaXRpb25QYXJlbnQuaXMoJ3RleHQnKSkgewogICAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgICAgfSAvLyBXaGVuIGluc2lkZSBlbXB0eSBhdHRyaWJ1dGUgLSByZW1vdmUgaXQuCgoKICAgICAgaWYgKHBvc2l0aW9uUGFyZW50LmlzKCdhdHRyaWJ1dGVFbGVtZW50JykgJiYgcG9zaXRpb25QYXJlbnQuY2hpbGRDb3VudCA9PT0gMCkgewogICAgICAgIHZhciBwYXJlbnQgPSBwb3NpdGlvblBhcmVudC5wYXJlbnQ7CiAgICAgICAgdmFyIG9mZnNldCA9IHBvc2l0aW9uUGFyZW50LmluZGV4OwoKICAgICAgICBwb3NpdGlvblBhcmVudC5fcmVtb3ZlKCk7CgogICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKHBvc2l0aW9uUGFyZW50KTsKCiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ldyBQb3NpdGlvbihwYXJlbnQsIG9mZnNldCkpOwogICAgICB9CgogICAgICB2YXIgbm9kZUJlZm9yZSA9IHBvc2l0aW9uUGFyZW50LmdldENoaWxkKHBvc2l0aW9uT2Zmc2V0IC0gMSk7CiAgICAgIHZhciBub2RlQWZ0ZXIgPSBwb3NpdGlvblBhcmVudC5nZXRDaGlsZChwb3NpdGlvbk9mZnNldCk7IC8vIFBvc2l0aW9uIHNob3VsZCBiZSBwbGFjZWQgYmV0d2VlbiB0d28gbm9kZXMuCgogICAgICBpZiAoIW5vZGVCZWZvcmUgfHwgIW5vZGVBZnRlcikgewogICAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgICAgfSAvLyBXaGVuIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRleHQgbm9kZXMuCgoKICAgICAgaWYgKG5vZGVCZWZvcmUuaXMoJ3RleHQnKSAmJiBub2RlQWZ0ZXIuaXMoJ3RleHQnKSkgewogICAgICAgIHJldHVybiBtZXJnZVRleHROb2Rlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpOwogICAgICB9IC8vIFdoZW4gcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gc2FtZSBhdHRyaWJ1dGUgZWxlbWVudHMuCiAgICAgIGVsc2UgaWYgKG5vZGVCZWZvcmUuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQWZ0ZXIuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQmVmb3JlLmlzU2ltaWxhcihub2RlQWZ0ZXIpKSB7CiAgICAgICAgICAvLyBNb3ZlIGFsbCBjaGlsZHJlbiBub2RlcyBmcm9tIG5vZGUgcGxhY2VkIGFmdGVyIHNlbGVjdGlvbiBhbmQgcmVtb3ZlIHRoYXQgbm9kZS4KICAgICAgICAgIHZhciBjb3VudCA9IG5vZGVCZWZvcmUuY2hpbGRDb3VudDsKCiAgICAgICAgICBub2RlQmVmb3JlLl9hcHBlbmRDaGlsZChub2RlQWZ0ZXIuZ2V0Q2hpbGRyZW4oKSk7CgogICAgICAgICAgbm9kZUFmdGVyLl9yZW1vdmUoKTsKCiAgICAgICAgICB0aGlzLl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cChub2RlQWZ0ZXIpOyAvLyBOZXcgcG9zaXRpb24gaXMgbG9jYXRlZCBpbnNpZGUgdGhlIGZpcnN0IG5vZGUsIGJlZm9yZSBuZXcgbm9kZXMuCiAgICAgICAgICAvLyBDYWxsIHRoaXMgbWV0aG9kIHJlY3Vyc2l2ZWx5IHRvIG1lcmdlIGFnYWluIGlmIG5lZWRlZC4KCgogICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ldyBQb3NpdGlvbihub2RlQmVmb3JlLCBjb3VudCkpOwogICAgICAgIH0KCiAgICAgIHJldHVybiBwb3NpdGlvbjsKICAgIH0KICAgIC8qKgogICAgICogTWVyZ2VzIHR3byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudHN9IHRoYXQgYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKiBQcmVjaXNlbHksIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbiBpcyByZW1vdmVkIGFuZCBpdCdzIGNvbnRlbnRzIGFyZSBtb3ZlZCB0byBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uCiAgICAgKgogICAgICoJCTxwPmZvbzwvcD5ePHA+YmFyPC9wPiAtPiA8cD5mb29eYmFyPC9wPgogICAgICoJCTxkaXY+Zm9vPC9kaXY+XjxwPmJhcjwvcD4gLT4gPGRpdj5mb29eYmFyPC9kaXY+CiAgICAgKgogICAgICogKipOb3RlOioqIERpZmZlcmVuY2UgYmV0d2VlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI21lcmdlQXR0cmlidXRlcyBtZXJnZUF0dHJpYnV0ZXN9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUNvbnRhaW5lcnMgbWVyZ2VDb250YWluZXJzfSBpcyB0aGF0IGBtZXJnZUF0dHJpYnV0ZXNgIG1lcmdlcyB0d28KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdGV4dCBub2Rlc30KICAgICAqIHdoaWxlIGBtZXJnZUNvbnRhaW5lcmAgbWVyZ2VzIHR3byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudHN9LgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudAogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50CiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUF0dHJpYnV0ZXMKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBNZXJnZSBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFBvc2l0aW9uIGFmdGVyIG1lcmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1lcmdlQ29udGFpbmVycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2VDb250YWluZXJzKHBvc2l0aW9uKSB7CiAgICAgIHZhciBwcmV2ID0gcG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5leHQgPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAoIXByZXYgfHwgIW5leHQgfHwgIXByZXYuaXMoJ2NvbnRhaW5lckVsZW1lbnQnKSB8fCAhbmV4dC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogRWxlbWVudCBiZWZvcmUgYW5kIGFmdGVyIGdpdmVuIHBvc2l0aW9uIGNhbm5vdCBiZSBtZXJnZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItbWVyZ2UtY29udGFpbmVycy1pbnZhbGlkLXBvc2l0aW9uCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLW1lcmdlLWNvbnRhaW5lcnMtaW52YWxpZC1wb3NpdGlvbjogJyArICdFbGVtZW50IGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24gY2Fubm90IGJlIG1lcmdlZC4nLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgdmFyIGxhc3RDaGlsZCA9IHByZXYuZ2V0Q2hpbGQocHJldi5jaGlsZENvdW50IC0gMSk7CiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IGxhc3RDaGlsZCBpbnN0YW5jZW9mIFRleHQgPyBQb3NpdGlvbi5fY3JlYXRlQXQobGFzdENoaWxkLCAnZW5kJykgOiBQb3NpdGlvbi5fY3JlYXRlQXQocHJldiwgJ2VuZCcpOwogICAgICB0aGlzLm1vdmUoUmFuZ2UuX2NyZWF0ZUluKG5leHQpLCBQb3NpdGlvbi5fY3JlYXRlQXQocHJldiwgJ2VuZCcpKTsKICAgICAgdGhpcy5yZW1vdmUoUmFuZ2UuX2NyZWF0ZU9uKG5leHQpKTsKICAgICAgcmV0dXJuIG5ld1Bvc2l0aW9uOwogICAgfQogICAgLyoqCiAgICAgKiBJbnNlcnQgbm9kZSBvciBub2RlcyBhdCBzcGVjaWZpZWQgcG9zaXRpb24uIFRha2VzIGNhcmUgYWJvdXQgYnJlYWtpbmcgYXR0cmlidXRlcyBiZWZvcmUgaW5zZXJ0aW9uCiAgICAgKiBhbmQgbWVyZ2luZyB0aGVtIGFmdGVyd2FyZHMuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnNlcnQtaW52YWxpZC1ub2RlYCB3aGVuIG5vZGVzIHRvIGluc2VydAogICAgICogY29udGFpbnMgaW5zdGFuY2VzIHRoYXQgYXJlIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCBUZXh0c30sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50c30sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBDb250YWluZXJFbGVtZW50c30sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50c30gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnRzfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gSW5zZXJ0aW9uIHBvc2l0aW9uLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50fAogICAgICogbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR8SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR8CiAgICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudD59IG5vZGVzIE5vZGUgb3Igbm9kZXMgdG8gaW5zZXJ0LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gUmFuZ2UgYXJvdW5kIGluc2VydGVkIG5vZGVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImluc2VydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBub2RlcykgewogICAgICBub2RlcyA9IGlzSXRlcmFibGUobm9kZXMpID8gX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVzKSA6IFtub2Rlc107IC8vIENoZWNrIGlmIG5vZGVzIHRvIGluc2VydCBhcmUgaW5zdGFuY2VzIG9mIEF0dHJpYnV0ZUVsZW1lbnRzLCBDb250YWluZXJFbGVtZW50cywgRW1wdHlFbGVtZW50cywgVUlFbGVtZW50cyBvciBUZXh0LgoKICAgICAgdmFsaWRhdGVOb2Rlc1RvSW5zZXJ0KG5vZGVzLCB0aGlzLmRvY3VtZW50KTsKICAgICAgdmFyIGNvbnRhaW5lciA9IGdldFBhcmVudENvbnRhaW5lcihwb3NpdGlvbik7CgogICAgICBpZiAoIWNvbnRhaW5lcikgewogICAgICAgIC8qKgogICAgICAgICAqIFBvc2l0aW9uJ3MgcGFyZW50IGNvbnRhaW5lciBjYW5ub3QgYmUgZm91bmQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItaW52YWxpZC1wb3NpdGlvbi1jb250YWluZXIKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW52YWxpZC1wb3NpdGlvbi1jb250YWluZXInLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgdmFyIGluc2VydGlvblBvc2l0aW9uID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uLCB0cnVlKTsKCiAgICAgIHZhciBsZW5ndGggPSBjb250YWluZXIuX2luc2VydENoaWxkKGluc2VydGlvblBvc2l0aW9uLm9mZnNldCwgbm9kZXMpOwoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBub2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBub2RlID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgdGhpcy5fYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKG5vZGUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGVuZFBvc2l0aW9uID0gaW5zZXJ0aW9uUG9zaXRpb24uZ2V0U2hpZnRlZEJ5KGxlbmd0aCk7CiAgICAgIHZhciBzdGFydCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGluc2VydGlvblBvc2l0aW9uKTsgLy8gV2hlbiBubyBub2RlcyB3ZXJlIGluc2VydGVkIC0gcmV0dXJuIGNvbGxhcHNlZCByYW5nZS4KCiAgICAgIGlmIChsZW5ndGggPT09IDApIHsKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uLgogICAgICAgIGlmICghc3RhcnQuaXNFcXVhbChpbnNlcnRpb25Qb3NpdGlvbikpIHsKICAgICAgICAgIGVuZFBvc2l0aW9uLm9mZnNldC0tOwogICAgICAgIH0KCiAgICAgICAgdmFyIGVuZCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGVuZFBvc2l0aW9uKTsKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgcHJvdmlkZWQgcmFuZ2UgZnJvbSB0aGUgY29udGFpbmVyLgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgIHdoZW4KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUKICAgICAqIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZXxtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfSByYW5nZU9ySXRlbSBSYW5nZSB0byByZW1vdmUgZnJvbSBjb250YWluZXIKICAgICAqIG9yIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW19IHRvIHJlbW92ZS4gSWYgcmFuZ2UgaXMgcHJvdmlkZWQsIGFmdGVyIHJlbW92aW5nLCBpdCB3aWxsIGJlIHVwZGF0ZWQKICAgICAqIHRvIGEgY29sbGFwc2VkIHJhbmdlIHNob3dpbmcgdGhlIG5ldyBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBEb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHJlbW92ZWQgbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUocmFuZ2VPckl0ZW0pIHsKICAgICAgdmFyIHJhbmdlID0gcmFuZ2VPckl0ZW0gaW5zdGFuY2VvZiBSYW5nZSA/IHJhbmdlT3JJdGVtIDogUmFuZ2UuX2NyZWF0ZU9uKHJhbmdlT3JJdGVtKTsKICAgICAgdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgdGhpcy5kb2N1bWVudCk7IC8vIElmIHJhbmdlIGlzIGNvbGxhcHNlZCAtIG5vdGhpbmcgdG8gcmVtb3ZlLgoKICAgICAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KHRoaXMuZG9jdW1lbnQpOwogICAgICB9IC8vIEJyZWFrIGF0dHJpYnV0ZXMgYXQgcmFuZ2Ugc3RhcnQgYW5kIGVuZC4KCgogICAgICB2YXIgX3RoaXMkX2JyZWFrQXR0cmlidXRlID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpLAogICAgICAgICAgYnJlYWtTdGFydCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZS5zdGFydCwKICAgICAgICAgIGJyZWFrRW5kID0gX3RoaXMkX2JyZWFrQXR0cmlidXRlLmVuZDsKCiAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSBicmVha1N0YXJ0LnBhcmVudDsKICAgICAgdmFyIGNvdW50ID0gYnJlYWtFbmQub2Zmc2V0IC0gYnJlYWtTdGFydC5vZmZzZXQ7IC8vIFJlbW92ZSBub2RlcyBpbiByYW5nZS4KCiAgICAgIHZhciByZW1vdmVkID0gcGFyZW50Q29udGFpbmVyLl9yZW1vdmVDaGlsZHJlbihicmVha1N0YXJ0Lm9mZnNldCwgY291bnQpOwoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcmVtb3ZlZFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDIudmFsdWU7CgogICAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUNsb25lZEVsZW1lbnRzR3JvdXAobm9kZSk7CiAgICAgICAgfSAvLyBNZXJnZSBhZnRlciByZW1vdmluZy4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgbWVyZ2VQb3NpdGlvbiA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGJyZWFrU3RhcnQpOwogICAgICByYW5nZS5zdGFydCA9IG1lcmdlUG9zaXRpb247CiAgICAgIHJhbmdlLmVuZCA9IG1lcmdlUG9zaXRpb24uY2xvbmUoKTsgLy8gUmV0dXJuIHJlbW92ZWQgbm9kZXMuCgogICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQodGhpcy5kb2N1bWVudCwgcmVtb3ZlZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgbWF0Y2hpbmcgZWxlbWVudHMgZnJvbSBnaXZlbiByYW5nZS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlCiAgICAgKiBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIGNsZWFyLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNsZWFyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcihyYW5nZSwgZWxlbWVudCkgewogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gQ3JlYXRlIHdhbGtlciBvbiBnaXZlbiByYW5nZS4KICAgICAgLy8gV2Ugd2FsayBiYWNrd2FyZCBiZWNhdXNlIHdoZW4gd2UgcmVtb3ZlIGVsZW1lbnQgZHVyaW5nIHdhbGsgaXQgbW9kaWZpZXMgcmFuZ2UgZW5kIHBvc2l0aW9uLgoKICAgICAgdmFyIHdhbGtlciA9IHJhbmdlLmdldFdhbGtlcih7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnLAogICAgICAgIGlnbm9yZUVsZW1lbnRFbmQ6IHRydWUKICAgICAgfSk7IC8vIExldCdzIHdhbGsuCgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB3YWxrZXJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHsKICAgICAgICAgIHZhciBjdXJyZW50ID0gX3N0ZXAzLnZhbHVlOwogICAgICAgICAgdmFyIGl0ZW0gPSBjdXJyZW50Lml0ZW07CiAgICAgICAgICB2YXIgcmFuZ2VUb1JlbW92ZSA9IHZvaWQgMDsgLy8gV2hlbiBjdXJyZW50IGl0ZW0gbWF0Y2hlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC4KCiAgICAgICAgICBpZiAoaXRlbS5pcygnZWxlbWVudCcpICYmIGVsZW1lbnQuaXNTaW1pbGFyKGl0ZW0pKSB7CiAgICAgICAgICAgIC8vIENyZWF0ZSByYW5nZSBvbiB0aGlzIGVsZW1lbnQuCiAgICAgICAgICAgIHJhbmdlVG9SZW1vdmUgPSBSYW5nZS5fY3JlYXRlT24oaXRlbSk7IC8vIFdoZW4gcmFuZ2Ugc3RhcnRzIGluc2lkZSBUZXh0IG9yIFRleHRQcm94eSBlbGVtZW50LgogICAgICAgICAgfSBlbHNlIGlmICghY3VycmVudC5uZXh0UG9zaXRpb24uaXNBZnRlcihyYW5nZS5zdGFydCkgJiYgaXRlbS5pcygndGV4dFByb3h5JykpIHsKICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBwYXJlbnQgb2YgdGhpcyB0ZXh0IG1hdGNoZXMgdG8gZ2l2ZW4gZWxlbWVudC4KICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBpdGVtLmdldEFuY2VzdG9ycygpLmZpbmQoZnVuY3Rpb24gKGFuY2VzdG9yKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9yLmlzKCdlbGVtZW50JykgJiYgZWxlbWVudC5pc1NpbWlsYXIoYW5jZXN0b3IpOwogICAgICAgICAgICB9KTsgLy8gSWYgaXQgaXMgdGhlbiBjcmVhdGUgcmFuZ2UgaW5zaWRlIHRoaXMgZWxlbWVudC4KCiAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7CiAgICAgICAgICAgICAgcmFuZ2VUb1JlbW92ZSA9IFJhbmdlLl9jcmVhdGVJbihwYXJlbnRFbGVtZW50KTsKICAgICAgICAgICAgfQogICAgICAgICAgfSAvLyBJZiB3ZSBoYXZlIGZvdW5kIGVsZW1lbnQgdG8gcmVtb3ZlLgoKCiAgICAgICAgICBpZiAocmFuZ2VUb1JlbW92ZSkgewogICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGVsZW1lbnQgcmFuZ2Ugc3RpY2sgb3V0IG9mIHRoZSBnaXZlbiByYW5nZSBhbmQgdHJ1bmNhdGUgaWYgaXQgaXMuCiAgICAgICAgICAgIGlmIChyYW5nZVRvUmVtb3ZlLmVuZC5pc0FmdGVyKHJhbmdlLmVuZCkpIHsKICAgICAgICAgICAgICByYW5nZVRvUmVtb3ZlLmVuZCA9IHJhbmdlLmVuZDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKHJhbmdlVG9SZW1vdmUuc3RhcnQuaXNCZWZvcmUocmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICAgICAgcmFuZ2VUb1JlbW92ZS5zdGFydCA9IHJhbmdlLnN0YXJ0OwogICAgICAgICAgICB9IC8vIEF0IHRoZSBlbmQgd2UgcmVtb3ZlIHJhbmdlIHdpdGggZm91bmQgZWxlbWVudC4KCgogICAgICAgICAgICB0aGlzLnJlbW92ZShyYW5nZVRvUmVtb3ZlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIE1vdmVzIG5vZGVzIGZyb20gcHJvdmlkZWQgcmFuZ2UgdG8gdGFyZ2V0IHBvc2l0aW9uLgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgIHdoZW4KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUKICAgICAqIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gc291cmNlUmFuZ2UgUmFuZ2UgY29udGFpbmluZyBub2RlcyB0byBtb3ZlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHRhcmdldFBvc2l0aW9uIFBvc2l0aW9uIHRvIGluc2VydC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IFJhbmdlIGluIHRhcmdldCBjb250YWluZXIuIEluc2VydGVkIG5vZGVzIGFyZSBwbGFjZWQgYmV0d2VlbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUoc291cmNlUmFuZ2UsIHRhcmdldFBvc2l0aW9uKSB7CiAgICAgIHZhciBub2RlczsKCiAgICAgIGlmICh0YXJnZXRQb3NpdGlvbi5pc0FmdGVyKHNvdXJjZVJhbmdlLmVuZCkpIHsKICAgICAgICB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyh0YXJnZXRQb3NpdGlvbiwgdHJ1ZSk7CiAgICAgICAgdmFyIHBhcmVudCA9IHRhcmdldFBvc2l0aW9uLnBhcmVudDsKICAgICAgICB2YXIgY291bnRCZWZvcmUgPSBwYXJlbnQuY2hpbGRDb3VudDsKICAgICAgICBzb3VyY2VSYW5nZSA9IHRoaXMuX2JyZWFrQXR0cmlidXRlc1JhbmdlKHNvdXJjZVJhbmdlLCB0cnVlKTsKICAgICAgICBub2RlcyA9IHRoaXMucmVtb3ZlKHNvdXJjZVJhbmdlKTsKICAgICAgICB0YXJnZXRQb3NpdGlvbi5vZmZzZXQgKz0gcGFyZW50LmNoaWxkQ291bnQgLSBjb3VudEJlZm9yZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBub2RlcyA9IHRoaXMucmVtb3ZlKHNvdXJjZVJhbmdlKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHRhcmdldFBvc2l0aW9uLCBub2Rlcyk7CiAgICB9CiAgICAvKioKICAgICAqIFdyYXBzIGVsZW1lbnRzIHdpdGhpbiByYW5nZSB3aXRoIHByb3ZpZGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnR9LgogICAgICogSWYgYSBjb2xsYXBzZWQgcmFuZ2UgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgd3JhcHBlZCBvbmx5IGlmIGl0IGlzIGVxdWFsIHRvIHZpZXcgc2VsZWN0aW9uLgogICAgICoKICAgICAqIElmIGEgY29sbGFwc2VkIHJhbmdlIHdhcyBwYXNzZWQgYW5kIGlzIHNhbWUgYXMgc2VsZWN0aW9uLCB0aGUgc2VsZWN0aW9uCiAgICAgKiB3aWxsIGJlIG1vdmVkIHRvIHRoZSBpbnNpZGUgb2YgdGhlIHdyYXBwZWQgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgCiAgICAgKiB3aGVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnR9CiAgICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUgc2FtZSBwYXJlbnQgY29udGFpbmVyLgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLXdyYXAtaW52YWxpZC1hdHRyaWJ1dGVgIHdoZW4gcGFzc2VkIGF0dHJpYnV0ZSBlbGVtZW50IGlzIG5vdAogICAgICogYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1ub25zZWxlY3Rpb24tY29sbGFwc2VkLXJhbmdlYCB3aGVuIHBhc3NlZCByYW5nZQogICAgICogaXMgY29sbGFwc2VkIGFuZCBkaWZmZXJlbnQgdGhhbiB2aWV3IHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgdG8gd3JhcC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYXR0cmlidXRlIEF0dHJpYnV0ZSBlbGVtZW50IHRvIHVzZSBhcyB3cmFwcGVyLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgYWZ0ZXIgd3JhcHBpbmcsIHNwYW5uaW5nIG92ZXIgd3JhcHBpbmcgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ3cmFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB3cmFwKHJhbmdlLCBhdHRyaWJ1dGUpIHsKICAgICAgaWYgKCEoYXR0cmlidXRlIGluc3RhbmNlb2YgQXR0cmlidXRlRWxlbWVudCkpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZScsIHRoaXMuZG9jdW1lbnQpOwogICAgICB9CgogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsKCiAgICAgIGlmICghcmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICAvLyBOb24tY29sbGFwc2VkIHJhbmdlLiBXcmFwIGl0IHdpdGggdGhlIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICAgIHJldHVybiB0aGlzLl93cmFwUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gQ29sbGFwc2VkIHJhbmdlLiBXcmFwIHBvc2l0aW9uLgogICAgICAgIHZhciBwb3NpdGlvbiA9IHJhbmdlLnN0YXJ0OwoKICAgICAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCdlbGVtZW50JykgJiYgIV9oYXNOb25VaUNoaWxkcmVuKHBvc2l0aW9uLnBhcmVudCkpIHsKICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24uZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pdGVtLmlzKCd1aUVsZW1lbnQnKTsKICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl93cmFwUG9zaXRpb24ocG9zaXRpb24sIGF0dHJpYnV0ZSk7CiAgICAgICAgdmFyIHZpZXdTZWxlY3Rpb24gPSB0aGlzLmRvY3VtZW50LnNlbGVjdGlvbjsgLy8gSWYgd3JhcHBpbmcgcG9zaXRpb24gaXMgZXF1YWwgdG8gdmlldyBzZWxlY3Rpb24sIG1vdmUgdmlldyBzZWxlY3Rpb24gaW5zaWRlIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgoKICAgICAgICBpZiAodmlld1NlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiB2aWV3U2VsZWN0aW9uLmdldEZpcnN0UG9zaXRpb24oKS5pc0VxdWFsKHJhbmdlLnN0YXJ0KSkgewogICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocG9zaXRpb24pOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbik7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVW53cmFwcyBub2RlcyB3aXRoaW4gcHJvdmlkZWQgcmFuZ2UgZnJvbSBhdHRyaWJ1dGUgZWxlbWVudC4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlCiAgICAgKiBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGF0dHJpYnV0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogInVud3JhcCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdW53cmFwKHJhbmdlLCBhdHRyaWJ1dGUpIHsKICAgICAgaWYgKCEoYXR0cmlidXRlIGluc3RhbmNlb2YgQXR0cmlidXRlRWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBBdHRyaWJ1dGUgZWxlbWVudCBuZWVkIHRvIGJlIGluc3RhbmNlIG9mIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLXVud3JhcC1pbnZhbGlkLWF0dHJpYnV0ZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci11bndyYXAtaW52YWxpZC1hdHRyaWJ1dGUnLCB0aGlzLmRvY3VtZW50KTsKICAgICAgfQoKICAgICAgdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgdGhpcy5kb2N1bWVudCk7IC8vIElmIHJhbmdlIGlzIGNvbGxhcHNlZCAtIG5vdGhpbmcgdG8gdW53cmFwLgoKICAgICAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgcmV0dXJuIHJhbmdlOwogICAgICB9IC8vIEJyZWFrIGF0dHJpYnV0ZXMgYXQgcmFuZ2Ugc3RhcnQgYW5kIGVuZC4KCgogICAgICB2YXIgX3RoaXMkX2JyZWFrQXR0cmlidXRlMiA9IHRoaXMuX2JyZWFrQXR0cmlidXRlc1JhbmdlKHJhbmdlLCB0cnVlKSwKICAgICAgICAgIGJyZWFrU3RhcnQgPSBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUyLnN0YXJ0LAogICAgICAgICAgYnJlYWtFbmQgPSBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUyLmVuZDsKCiAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSBicmVha1N0YXJ0LnBhcmVudDsgLy8gVW53cmFwIGNoaWxkcmVuIGxvY2F0ZWQgYmV0d2VlbiBicmVhayBwb2ludHMuCgogICAgICB2YXIgbmV3UmFuZ2UgPSB0aGlzLl91bndyYXBDaGlsZHJlbihwYXJlbnRDb250YWluZXIsIGJyZWFrU3RhcnQub2Zmc2V0LCBicmVha0VuZC5vZmZzZXQsIGF0dHJpYnV0ZSk7IC8vIE1lcmdlIGF0dHJpYnV0ZXMgYXQgdGhlIGJvdGggZW5kcyBhbmQgcmV0dXJuIGEgbmV3IHJhbmdlLgoKCiAgICAgIHZhciBzdGFydCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ld1JhbmdlLnN0YXJ0KTsgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uIGJhY2suCgogICAgICBpZiAoIXN0YXJ0LmlzRXF1YWwobmV3UmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgbmV3UmFuZ2UuZW5kLm9mZnNldC0tOwogICAgICB9CgogICAgICB2YXIgZW5kID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmVuYW1lcyBlbGVtZW50IGJ5IGNyZWF0aW5nIGEgY29weSBvZiByZW5hbWVkIGVsZW1lbnQgYnV0IHdpdGggY2hhbmdlZCBuYW1lIGFuZCB0aGVuIG1vdmluZyBjb250ZW50cyBvZiB0aGUKICAgICAqIG9sZCBlbGVtZW50IHRvIHRoZSBuZXcgb25lLiBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIHdpbGwgaW52YWxpZGF0ZSBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9IHdoaWNoCiAgICAgKiBoYXMgcmVuYW1lZCBlbGVtZW50IGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50IGEgcGFyZW50fS4KICAgICAqCiAgICAgKiBOZXcgZWxlbWVudCBoYXMgdG8gYmUgY3JlYXRlZCBiZWNhdXNlIGBFbGVtZW50I3RhZ05hbWVgIHByb3BlcnR5IGluIERPTSBpcyByZWFkb25seS4KICAgICAqCiAgICAgKiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgZWxlbWVudCBhbmQgcmVtb3ZlcyB0aGUgZ2l2ZW4gb25lLCB0aGUgbmV3IGVsZW1lbnQgaXMgcmV0dXJuZWQgdG8ga2VlcCByZWZlcmVuY2UuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld05hbWUgTmV3IG5hbWUgZm9yIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9IHZpZXdFbGVtZW50IEVsZW1lbnQgdG8gYmUgcmVuYW1lZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW5hbWUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmFtZShuZXdOYW1lLCB2aWV3RWxlbWVudCkgewogICAgICB2YXIgbmV3RWxlbWVudCA9IG5ldyBDb250YWluZXJFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG5ld05hbWUsIHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZXMoKSk7CiAgICAgIHRoaXMuaW5zZXJ0KFBvc2l0aW9uLl9jcmVhdGVBZnRlcih2aWV3RWxlbWVudCksIG5ld0VsZW1lbnQpOwogICAgICB0aGlzLm1vdmUoUmFuZ2UuX2NyZWF0ZUluKHZpZXdFbGVtZW50KSwgUG9zaXRpb24uX2NyZWF0ZUF0KG5ld0VsZW1lbnQsIDApKTsKICAgICAgdGhpcy5yZW1vdmUoUmFuZ2UuX2NyZWF0ZU9uKHZpZXdFbGVtZW50KSk7CiAgICAgIHJldHVybiBuZXdFbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDbGVhbnMgdXAgbWVtb3J5IGJ5IHJlbW92aW5nIG9ic29sZXRlIGNsb25lZCBlbGVtZW50cyBncm91cCBmcm9tIHRoZSB3cml0ZXIuCiAgICAgKgogICAgICogU2hvdWxkIGJlIHVzZWQgd2hlbmV2ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30KICAgICAqIHdpdGggdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaWQgaWR9IGFyZSBnb2luZyB0byBiZSByZW1vdmVkIGZyb20gdGhlIHZpZXcgYW5kCiAgICAgKiB0aGUgZ3JvdXAgd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkLgogICAgICoKICAgICAqIENsb25lZCBlbGVtZW50cyBncm91cCBhcmUgbm90IHJlbW92ZWQgYXV0b21hdGljYWxseSBpbiBjYXNlIGlmIHRoZSBncm91cCBpcyBzdGlsbCBuZWVkZWQgYWZ0ZXIgYWxsIGl0cyBlbGVtZW50cwogICAgICogd2VyZSByZW1vdmVkIGZyb20gdGhlIHZpZXcuCiAgICAgKgogICAgICogS2VlcCBpbiBtaW5kIHRoYXQgZ3JvdXAgbmFtZXMgYXJlIGVxdWFsIHRvIHRoZSBgaWRgIHByb3BlcnR5IG9mIHRoZSBhdHRyaWJ1dGUgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIE5hbWUgb2YgdGhlIGdyb3VwIHRvIGNsZWFyLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNsZWFyQ2xvbmVkRWxlbWVudHNHcm91cCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDbG9uZWRFbGVtZW50c0dyb3VwKGdyb3VwTmFtZSkgewogICAgICB0aGlzLl9jbG9uZUdyb3Vwcy5kZWxldGUoZ3JvdXBOYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSwKICAgICAqICogcGFyZW50IGVsZW1lbnQgYW5kIG9mZnNldCAob2Zmc2V0IGRlZmF1bHRzIHRvIGAwYCksCiAgICAgKiAqIHBhcmVudCBlbGVtZW50IGFuZCBgJ2VuZCdgIChzZXRzIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhhdCBlbGVtZW50KSwKICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtfSBhbmQgYCdiZWZvcmUnYCBvciBgJ2FmdGVyJ2AgKHNldHMgcG9zaXRpb24gYmVmb3JlIG9yIGFmdGVyIGdpdmVuIHZpZXcgaXRlbSkuCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgaXMgYSBzaG9ydGN1dCB0byBvdGhlciBjb25zdHJ1Y3RvcnMgc3VjaCBhczoKICAgICAqCiAgICAgKiAqIHtAbGluayAjY3JlYXRlUG9zaXRpb25CZWZvcmV9LAogICAgICogKiB7QGxpbmsgI2NyZWF0ZVBvc2l0aW9uQWZ0ZXJ9LAogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uQXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICByZXR1cm4gUG9zaXRpb24uX2NyZWF0ZUF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uIGFmdGVyIGdpdmVuIHZpZXcgaXRlbS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IGl0ZW0gVmlldyBpdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgbG9jYXRlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BZnRlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BZnRlcihpdGVtKSB7CiAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoaXRlbSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24gYmVmb3JlIGdpdmVuIHZpZXcgaXRlbS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IGl0ZW0gVmlldyBpdGVtIGJlZm9yZSB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGxvY2F0ZWQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uQmVmb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkJlZm9yZShpdGVtKSB7CiAgICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2Ugc3Bhbm5pbmcgZnJvbSBgc3RhcnRgIHBvc2l0aW9uIHRvIGBlbmRgIHBvc2l0aW9uLgogICAgICoKICAgICAqICoqTm90ZToqKiBUaGlzIGZhY3RvcnkgbWV0aG9kIGNyZWF0ZXMgaXRzIG93biB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBpbnN0YW5jZXMgYmFzaW5nIG9uIHBhc3NlZCB2YWx1ZXMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFtlbmRdIEVuZCBwb3NpdGlvbi4gSWYgbm90IHNldCwgcmFuZ2Ugd2lsbCBiZSBjb2xsYXBzZWQgYXQgYHN0YXJ0YCBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKHN0YXJ0LCBlbmQpIHsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIHRoYXQgc3RhcnRzIGJlZm9yZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19IGFuZCBlbmRzIGFmdGVyIGl0LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZU9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZU9uKGl0ZW0pIHsKICAgICAgcmV0dXJuIFJhbmdlLl9jcmVhdGVPbihpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZUluIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZUluKGVsZW1lbnQpIHsKICAgICAgcmV0dXJuIFJhbmdlLl9jcmVhdGVJbihlbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgIENyZWF0ZXMgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbn0gaW5zdGFuY2UuCiAgICAgKgogICAgICogCQkvLyBDcmVhdGVzIGVtcHR5IHNlbGVjdGlvbiB3aXRob3V0IHJhbmdlcy4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiByYW5nZS4KICAgICAqCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiByYW5nZXMKICAgICAqIAkJY29uc3QgcmFuZ2VzID0gWyB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0MSwgZW5kMiApLCB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXIyLCBlbmQyICkgXTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZXMgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0aGUgb3RoZXIgc2VsZWN0aW9uLgogICAgICoJCWNvbnN0IG90aGVyU2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbigpOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIG90aGVyU2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gdGhlIGRvY3VtZW50IHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBlZGl0b3IuZWRpdGluZy52aWV3LmRvY3VtZW50LnNlbGVjdGlvbiApOwogICAgICoKICAgICAqIAkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHBvc2l0aW9uLgogICAgICoJCWNvbnN0IHBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIHBhdGggKTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwb3NpdGlvbiApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIGdpdmVuIGl0ZW0gYW5kIG9mZnNldC4KICAgICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnICk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZQogICAgICoJCS8vIGZpcnN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgYSByYW5nZSBvbiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSBpdGVtfSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBpdGVtIGFuZCBlbmRzCiAgICAgKgkJLy8ganVzdCBhZnRlciB0aGUgaXRlbS4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdvbicgKTsKICAgICAqCiAgICAgKiBgU2VsZWN0aW9uYCdzIGNvbnN0cnVjdG9yIGFsbG93IHBhc3NpbmcgYWRkaXRpb25hbCBvcHRpb25zIChgYmFja3dhcmRgLCBgZmFrZWAgYW5kIGBsYWJlbGApIGFzIHRoZSBsYXN0IGFyZ3VtZW50LgogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGJhY2t3YXJkIHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSwgeyBiYWNrd2FyZDogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogRmFrZSBzZWxlY3Rpb24gZG9lcyBub3QgcmVuZGVyIGFzIGJyb3dzZXIgbmF0aXZlIHNlbGVjdGlvbiBvdmVyIHNlbGVjdGVkIGVsZW1lbnRzIGFuZCBpcyBoaWRkZW4gdG8gdGhlIHVzZXIuCiAgICAgKiBUaGlzIHdheSwgbm8gbmF0aXZlIHNlbGVjdGlvbiBVSSBhcnRpZmFjdHMgYXJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhbmQgc2VsZWN0aW9uIG92ZXIgZWxlbWVudHMgY2FuIGJlCiAgICAgKiByZXByZXNlbnRlZCBpbiBvdGhlciB3YXksIGZvciBleGFtcGxlIGJ5IGFwcGx5aW5nIHByb3BlciBDU1MgY2xhc3MuCiAgICAgKgogICAgICogQWRkaXRpb25hbGx5IGZha2UncyBzZWxlY3Rpb24gbGFiZWwgY2FuIGJlIHByb3ZpZGVkLiBJdCB3aWxsIGJlIHVzZWQgdG8gZGVzY3JpYmUgZmFrZSBzZWxlY3Rpb24gaW4gRE9NCiAgICAgKiAoYW5kIGJlICBwcm9wZXJseSBoYW5kbGVkIGJ5IHNjcmVlbiByZWFkZXJzKS4KICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBmYWtlIHNlbGVjdGlvbiB3aXRoIGxhYmVsLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlLCB7IGZha2U6IHRydWUsIGxhYmVsOiAnZm9vJyB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGFibGV9IFtzZWxlY3RhYmxlPW51bGxdCiAgICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIE9mZnNldCBvciBwbGFjZSB3aGVuIHNlbGVjdGFibGUgaXMgYW4gYEl0ZW1gLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmFrZV0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBtYXJrZWQgYXMgYGZha2VgLgogICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxhYmVsXSBMYWJlbCBmb3IgdGhlIGZha2Ugc2VsZWN0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVNlbGVjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpIHsKICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIFdyYXBzIGNoaWxkcmVuIHdpdGggcHJvdmlkZWQgYHdyYXBFbGVtZW50YC4gT25seSBjaGlsZHJlbiBjb250YWluZWQgaW4gYHBhcmVudGAgZWxlbWVudCBiZXR3ZWVuCiAgICAgKiBgc3RhcnRPZmZzZXRgIGFuZCBgZW5kT2Zmc2V0YCB3aWxsIGJlIHdyYXBwZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gcGFyZW50CiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZmZzZXQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRPZmZzZXQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gd3JhcEVsZW1lbnQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfd3JhcENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd3JhcENoaWxkcmVuKHBhcmVudCwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgd3JhcEVsZW1lbnQpIHsKICAgICAgdmFyIGkgPSBzdGFydE9mZnNldDsKICAgICAgdmFyIHdyYXBQb3NpdGlvbnMgPSBbXTsKCiAgICAgIHdoaWxlIChpIDwgZW5kT2Zmc2V0KSB7CiAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmdldENoaWxkKGkpOwogICAgICAgIHZhciBpc1RleHQgPSBjaGlsZC5pcygndGV4dCcpOwogICAgICAgIHZhciBpc0F0dHJpYnV0ZSA9IGNoaWxkLmlzKCdhdHRyaWJ1dGVFbGVtZW50Jyk7CiAgICAgICAgdmFyIGlzRW1wdHkgPSBjaGlsZC5pcygnZW1wdHlFbGVtZW50Jyk7CiAgICAgICAgdmFyIGlzVUkgPSBjaGlsZC5pcygndWlFbGVtZW50Jyk7IC8vCiAgICAgICAgLy8gKEluIGFsbCBleGFtcGxlcywgYXNzdW1lIHRoYXQgYHdyYXBFbGVtZW50YCBpcyBgPHNwYW4gY2xhc3M9ImZvbyI+YCBlbGVtZW50LikKICAgICAgICAvLwogICAgICAgIC8vIENoZWNrIGlmIGB3cmFwRWxlbWVudGAgY2FuIGJlIGpvaW5lZCB3aXRoIHRoZSB3cmFwcGVkIGVsZW1lbnQuIE9uZSBvZiByZXF1aXJlbWVudHMgaXMgaGF2aW5nIHNhbWUgbmFtZS4KICAgICAgICAvLyBJZiBwb3NzaWJsZSwgam9pbiBlbGVtZW50cy4KICAgICAgICAvLwogICAgICAgIC8vIDxwPjxzcGFuIGNsYXNzPSJiYXIiPmFiYzwvc3Bhbj48L3A+ICAtLT4gIDxwPjxzcGFuIGNsYXNzPSJmb28gYmFyIj5hYmM8L3NwYW4+PC9wPgogICAgICAgIC8vCgogICAgICAgIGlmIChpc0F0dHJpYnV0ZSAmJiB0aGlzLl93cmFwQXR0cmlidXRlRWxlbWVudCh3cmFwRWxlbWVudCwgY2hpbGQpKSB7CiAgICAgICAgICB3cmFwUG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHBhcmVudCwgaSkpOwogICAgICAgIH0gLy8KICAgICAgICAvLyBXcmFwIHRoZSBjaGlsZCBpZiBpdCBpcyBub3QgYW4gYXR0cmlidXRlIGVsZW1lbnQgb3IgaWYgaXQgaXMgYW4gYXR0cmlidXRlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgaW5zaWRlCiAgICAgICAgLy8gYHdyYXBFbGVtZW50YCAoZHVlIHRvIHByaW9yaXR5KS4KICAgICAgICAvLwogICAgICAgIC8vIDxwPmFiYzwvcD4gICAgICAgICAgICAgICAgICAgLS0+ICA8cD48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9wPgogICAgICAgIC8vIDxwPjxzdHJvbmc+YWJjPC9zdHJvbmc+PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iZm9vIj48c3Ryb25nPmFiYzwvc3Ryb25nPjwvc3Bhbj48L3A+CiAgICAgICAgLy8KICAgICAgICBlbHNlIGlmIChpc1RleHQgfHwgaXNFbXB0eSB8fCBpc1VJIHx8IGlzQXR0cmlidXRlICYmIHNob3VsZEFCZU91dHNpZGVCKHdyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICAgICAgLy8gQ2xvbmUgYXR0cmlidXRlLgogICAgICAgICAgICB2YXIgbmV3QXR0cmlidXRlID0gd3JhcEVsZW1lbnQuX2Nsb25lKCk7IC8vIFdyYXAgY3VycmVudCBub2RlIHdpdGggbmV3IGF0dHJpYnV0ZS4KCgogICAgICAgICAgICBjaGlsZC5fcmVtb3ZlKCk7CgogICAgICAgICAgICBuZXdBdHRyaWJ1dGUuX2FwcGVuZENoaWxkKGNoaWxkKTsKCiAgICAgICAgICAgIHBhcmVudC5faW5zZXJ0Q2hpbGQoaSwgbmV3QXR0cmlidXRlKTsKCiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cChuZXdBdHRyaWJ1dGUpOwoKICAgICAgICAgICAgd3JhcFBvc2l0aW9ucy5wdXNoKG5ldyBQb3NpdGlvbihwYXJlbnQsIGkpKTsKICAgICAgICAgIH0gLy8KICAgICAgICAgIC8vIElmIG90aGVyIG5lc3RlZCBhdHRyaWJ1dGUgaXMgZm91bmQgYW5kIGl0IHdhc24ndCB3cmFwcGVkIChzZWUgYWJvdmUpLCBjb250aW51ZSB3cmFwcGluZyBpbnNpZGUgaXQuCiAgICAgICAgICAvLwogICAgICAgICAgLy8gPHA+PGEgaHJlZj0iZm9vLmh0bWwiPmFiYzwvYT48L3A+ICAtLT4gIDxwPjxhIGhyZWY9ImZvby5odG1sIj48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9hPjwvcD4KICAgICAgICAgIC8vCiAgICAgICAgICBlbHNlIGlmIChpc0F0dHJpYnV0ZSkgewogICAgICAgICAgICAgIHRoaXMuX3dyYXBDaGlsZHJlbihjaGlsZCwgMCwgY2hpbGQuY2hpbGRDb3VudCwgd3JhcEVsZW1lbnQpOwogICAgICAgICAgICB9CgogICAgICAgIGkrKzsKICAgICAgfSAvLyBNZXJnZSBhdCBlYWNoIHdyYXAuCgoKICAgICAgdmFyIG9mZnNldENoYW5nZSA9IDA7CgogICAgICBmb3IgKHZhciBfaSA9IDAsIF93cmFwUG9zaXRpb25zID0gd3JhcFBvc2l0aW9uczsgX2kgPCBfd3JhcFBvc2l0aW9ucy5sZW5ndGg7IF9pKyspIHsKICAgICAgICB2YXIgcG9zaXRpb24gPSBfd3JhcFBvc2l0aW9uc1tfaV07CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0IC09IG9mZnNldENoYW5nZTsgLy8gRG8gbm90IG1lcmdlIHdpdGggZWxlbWVudHMgb3V0c2lkZSBzZWxlY3RlZCBjaGlsZHJlbi4KCiAgICAgICAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBzdGFydE9mZnNldCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhwb3NpdGlvbik7IC8vIElmIG5vZGVzIHdlcmUgbWVyZ2VkIC0gb3RoZXIgbWVyZ2Ugb2Zmc2V0cyB3aWxsIGNoYW5nZS4KCiAgICAgICAgaWYgKCFuZXdQb3NpdGlvbi5pc0VxdWFsKHBvc2l0aW9uKSkgewogICAgICAgICAgb2Zmc2V0Q2hhbmdlKys7CiAgICAgICAgICBlbmRPZmZzZXQtLTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBSYW5nZS5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHBhcmVudCwgc3RhcnRPZmZzZXQsIHBhcmVudCwgZW5kT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogVW53cmFwcyBjaGlsZHJlbiBmcm9tIHByb3ZpZGVkIGB1bndyYXBFbGVtZW50YC4gT25seSBjaGlsZHJlbiBjb250YWluZWQgaW4gYHBhcmVudGAgZWxlbWVudCBiZXR3ZWVuCiAgICAgKiBgc3RhcnRPZmZzZXRgIGFuZCBgZW5kT2Zmc2V0YCB3aWxsIGJlIHVud3JhcHBlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZE9mZnNldAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB1bndyYXBFbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3Vud3JhcENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfdW53cmFwQ2hpbGRyZW4ocGFyZW50LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB1bndyYXBFbGVtZW50KSB7CiAgICAgIHZhciBpID0gc3RhcnRPZmZzZXQ7CiAgICAgIHZhciB1bndyYXBQb3NpdGlvbnMgPSBbXTsgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHByb3ZpZGVkIG9mZnNldHMgaW5zaWRlIHBhcmVudC4KICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRyZWUgd2Fsa2VyIG9yIHJhbmdlIGl0ZXJhdG9yIGJlY2F1c2Ugd2Ugd2lsbCBiZSByZW1vdmluZyBhbmQgbWVyZ2luZyBwb3RlbnRpYWxseSBtdWx0aXBsZSBub2RlcywKICAgICAgLy8gc28gaXQgY291bGQgZ2V0IG1lc3N5LiBJdCBpcyBzYWZlciB0byBpdCBtYW51YWxseSBpbiB0aGlzIGNhc2UuCgogICAgICB3aGlsZSAoaSA8IGVuZE9mZnNldCkgewogICAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5nZXRDaGlsZChpKTsgLy8gU2tpcCBhbGwgdGV4dCBub2Rlcy4gVGhlcmUgc2hvdWxkIGJlIG5vIGNvbnRhaW5lciBlbGVtZW50J3MgaGVyZSBlaXRoZXIuCgogICAgICAgIGlmICghY2hpbGQuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSkgewogICAgICAgICAgaSsrOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLwogICAgICAgIC8vIChJbiBhbGwgZXhhbXBsZXMsIGFzc3VtZSB0aGF0IGB1bndyYXBFbGVtZW50YCBpcyBgPHNwYW4gY2xhc3M9ImZvbyI+YCBlbGVtZW50LikKICAgICAgICAvLwogICAgICAgIC8vIElmIHRoZSBjaGlsZCBpcyBzaW1pbGFyIHRvIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZWxlbWVudCwgdW53cmFwIGl0IC0gaXQgd2lsbCBiZSBjb21wbGV0ZWx5IHJlbW92ZWQuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+eHl6PC9wPiAgLS0+ICA8cD5hYmN4eXo8L3A+CiAgICAgICAgLy8KCgogICAgICAgIGlmIChjaGlsZC5pc1NpbWlsYXIodW53cmFwRWxlbWVudCkpIHsKICAgICAgICAgIHZhciB1bndyYXBwZWQgPSBjaGlsZC5nZXRDaGlsZHJlbigpOwogICAgICAgICAgdmFyIGNvdW50ID0gY2hpbGQuY2hpbGRDb3VudDsgLy8gUmVwbGFjZSB3cmFwcGVyIGVsZW1lbnQgd2l0aCBpdHMgY2hpbGRyZW4KCiAgICAgICAgICBjaGlsZC5fcmVtb3ZlKCk7CgogICAgICAgICAgcGFyZW50Ll9pbnNlcnRDaGlsZChpLCB1bndyYXBwZWQpOwoKICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsgLy8gU2F2ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIG9mIG1vdmVkIGl0ZW1zLgoKCiAgICAgICAgICB1bndyYXBQb3NpdGlvbnMucHVzaChuZXcgUG9zaXRpb24ocGFyZW50LCBpKSwgbmV3IFBvc2l0aW9uKHBhcmVudCwgaSArIGNvdW50KSk7IC8vIFNraXAgZWxlbWVudHMgdGhhdCB3ZXJlIHVud3JhcHBlZC4gQXNzdW1pbmcgdGhlcmUgd29uJ3QgYmUgYW5vdGhlciBlbGVtZW50IHRvIHVud3JhcCBpbiBjaGlsZCBlbGVtZW50cy4KCiAgICAgICAgICBpICs9IGNvdW50OwogICAgICAgICAgZW5kT2Zmc2V0ICs9IGNvdW50IC0gMTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0gLy8KICAgICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgbm90IHNpbWlsYXIgYnV0IGlzIGFuIGF0dHJpYnV0ZSBlbGVtZW50LCB0cnkgcGFydGlhbCB1bndyYXBwaW5nIC0gcmVtb3ZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMvc3R5bGVzL2NsYXNzZXMuCiAgICAgICAgLy8gUGFydGlhbCB1bndyYXBwaW5nIHdpbGwgaGFwcGVuIG9ubHkgaWYgdGhlIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgbmFtZS4KICAgICAgICAvLwogICAgICAgIC8vIDxwPjxzcGFuIGNsYXNzPSJmb28gYmFyIj5hYmM8L3NwYW4+eHl6PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iYmFyIj5hYmM8L3NwYW4+eHl6PC9wPgogICAgICAgIC8vIDxwPjxpIGNsYXNzPSJmb28iPmFiYzwvaT54eXo8L3A+ICAgICAgICAgICAgLS0+ICA8cD48aSBjbGFzcz0iZm9vIj5hYmM8L2k+eHl6PC9wPgogICAgICAgIC8vCgoKICAgICAgICBpZiAodGhpcy5fdW53cmFwQXR0cmlidXRlRWxlbWVudCh1bndyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICAgIHVud3JhcFBvc2l0aW9ucy5wdXNoKG5ldyBQb3NpdGlvbihwYXJlbnQsIGkpLCBuZXcgUG9zaXRpb24ocGFyZW50LCBpICsgMSkpOwogICAgICAgICAgaSsrOwogICAgICAgICAgY29udGludWU7CiAgICAgICAgfSAvLwogICAgICAgIC8vIElmIG90aGVyIG5lc3RlZCBhdHRyaWJ1dGUgaXMgZm91bmQsIGxvb2sgdGhyb3VnaCBpdCdzIGNoaWxkcmVuIGZvciBlbGVtZW50cyB0byB1bndyYXAuCiAgICAgICAgLy8KICAgICAgICAvLyA8cD48aT48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9pPjxwPiAgLS0+ICA8cD48aT5hYmM8L2k+PHA+CiAgICAgICAgLy8KCgogICAgICAgIHRoaXMuX3Vud3JhcENoaWxkcmVuKGNoaWxkLCAwLCBjaGlsZC5jaGlsZENvdW50LCB1bndyYXBFbGVtZW50KTsKCiAgICAgICAgaSsrOwogICAgICB9IC8vIE1lcmdlIGF0IGVhY2ggdW53cmFwLgoKCiAgICAgIHZhciBvZmZzZXRDaGFuZ2UgPSAwOwoKICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3Vud3JhcFBvc2l0aW9ucyA9IHVud3JhcFBvc2l0aW9uczsgX2kyIDwgX3Vud3JhcFBvc2l0aW9ucy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgdmFyIHBvc2l0aW9uID0gX3Vud3JhcFBvc2l0aW9uc1tfaTJdOwogICAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSBvZmZzZXRDaGFuZ2U7IC8vIERvIG5vdCBtZXJnZSB3aXRoIGVsZW1lbnRzIG91dHNpZGUgc2VsZWN0ZWQgY2hpbGRyZW4uCgogICAgICAgIGlmIChwb3NpdGlvbi5vZmZzZXQgPT0gc3RhcnRPZmZzZXQgfHwgcG9zaXRpb24ub2Zmc2V0ID09IGVuZE9mZnNldCkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhwb3NpdGlvbik7IC8vIElmIG5vZGVzIHdlcmUgbWVyZ2VkIC0gb3RoZXIgbWVyZ2Ugb2Zmc2V0cyB3aWxsIGNoYW5nZS4KCiAgICAgICAgaWYgKCFuZXdQb3NpdGlvbi5pc0VxdWFsKHBvc2l0aW9uKSkgewogICAgICAgICAgb2Zmc2V0Q2hhbmdlKys7CiAgICAgICAgICBlbmRPZmZzZXQtLTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBSYW5nZS5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHBhcmVudCwgc3RhcnRPZmZzZXQsIHBhcmVudCwgZW5kT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgdmlldy53cml0ZXIud3JhcGAuIFdyYXBzIHJhbmdlIHdpdGggcHJvdmlkZWQgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gbWVyZ2UgbmV3bHkgYWRkZWQgYXR0cmlidXRlIGVsZW1lbnQgd2l0aCBpdHMgc2libGluZ3Mgd2hlbmV2ZXIgcG9zc2libGUuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBwYXNzZWQgYXR0cmlidXRlIGVsZW1lbnQgaXMgbm90CiAgICAgKiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGF0dHJpYnV0ZQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gTmV3IHJhbmdlIGFmdGVyIHdyYXBwaW5nLCBzcGFubmluZyBvdmVyIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogIl93cmFwUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cmFwUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICAvLyBCcmVhayBhdHRyaWJ1dGVzIGF0IHJhbmdlIHN0YXJ0IGFuZCBlbmQuCiAgICAgIHZhciBfdGhpcyRfYnJlYWtBdHRyaWJ1dGUzID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpLAogICAgICAgICAgYnJlYWtTdGFydCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTMuc3RhcnQsCiAgICAgICAgICBicmVha0VuZCA9IF90aGlzJF9icmVha0F0dHJpYnV0ZTMuZW5kOwoKICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OyAvLyBXcmFwIGFsbCBjaGlsZHJlbiB3aXRoIGF0dHJpYnV0ZS4KCiAgICAgIHZhciBuZXdSYW5nZSA9IHRoaXMuX3dyYXBDaGlsZHJlbihwYXJlbnRDb250YWluZXIsIGJyZWFrU3RhcnQub2Zmc2V0LCBicmVha0VuZC5vZmZzZXQsIGF0dHJpYnV0ZSk7IC8vIE1lcmdlIGF0dHJpYnV0ZXMgYXQgdGhlIGJvdGggZW5kcyBhbmQgcmV0dXJuIGEgbmV3IHJhbmdlLgoKCiAgICAgIHZhciBzdGFydCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ld1JhbmdlLnN0YXJ0KTsgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uIGJhY2suCgogICAgICBpZiAoIXN0YXJ0LmlzRXF1YWwobmV3UmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgbmV3UmFuZ2UuZW5kLm9mZnNldC0tOwogICAgICB9CgogICAgICB2YXIgZW5kID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciB7QGxpbmsgI3dyYXB9LiBXcmFwcyBwb3NpdGlvbiB3aXRoIHByb3ZpZGVkIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIG1lcmdlIG5ld2x5IGFkZGVkIGF0dHJpYnV0ZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdzIHdoZW5ldmVyIHBvc3NpYmxlLgogICAgICoKICAgICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLXdyYXAtaW52YWxpZC1hdHRyaWJ1dGVgIHdoZW4gcGFzc2VkIGF0dHJpYnV0ZSBlbGVtZW50IGlzIG5vdAogICAgICogYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBhdHRyaWJ1dGUKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IE5ldyBwb3NpdGlvbiBhZnRlciB3cmFwcGluZy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfd3JhcFBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd3JhcFBvc2l0aW9uKHBvc2l0aW9uLCBhdHRyaWJ1dGUpIHsKICAgICAgLy8gUmV0dXJuIHNhbWUgcG9zaXRpb24gd2hlbiB0cnlpbmcgdG8gd3JhcCB3aXRoIGF0dHJpYnV0ZSBzaW1pbGFyIHRvIHBvc2l0aW9uIHBhcmVudC4KICAgICAgaWYgKGF0dHJpYnV0ZS5pc1NpbWlsYXIocG9zaXRpb24ucGFyZW50KSkgewogICAgICAgIHJldHVybiBtb3ZlUG9zaXRpb25Ub1RleHROb2RlKHBvc2l0aW9uLmNsb25lKCkpOwogICAgICB9IC8vIFdoZW4gcG9zaXRpb24gaXMgaW5zaWRlIHRleHQgbm9kZSAtIGJyZWFrIGl0IGFuZCBwbGFjZSBuZXcgcG9zaXRpb24gYmV0d2VlbiB0d28gdGV4dCBub2Rlcy4KCgogICAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgICBwb3NpdGlvbiA9IGJyZWFrVGV4dE5vZGUocG9zaXRpb24pOwogICAgICB9IC8vIENyZWF0ZSBmYWtlIGVsZW1lbnQgdGhhdCB3aWxsIHJlcHJlc2VudCBwb3NpdGlvbiwgYW5kIHdpbGwgbm90IGJlIG1lcmdlZCB3aXRoIG90aGVyIGF0dHJpYnV0ZXMuCgoKICAgICAgdmFyIGZha2VQb3NpdGlvbiA9IHRoaXMuY3JlYXRlQXR0cmlidXRlRWxlbWVudCgpOwogICAgICBmYWtlUG9zaXRpb24uX3ByaW9yaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwoKICAgICAgZmFrZVBvc2l0aW9uLmlzU2ltaWxhciA9IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH07IC8vIEluc2VydCBmYWtlIGVsZW1lbnQgaW4gcG9zaXRpb24gbG9jYXRpb24uCgoKICAgICAgcG9zaXRpb24ucGFyZW50Ll9pbnNlcnRDaGlsZChwb3NpdGlvbi5vZmZzZXQsIGZha2VQb3NpdGlvbik7IC8vIFJhbmdlIGFyb3VuZCBpbnNlcnRlZCBmYWtlIGF0dHJpYnV0ZSBlbGVtZW50LgoKCiAgICAgIHZhciB3cmFwUmFuZ2UgPSBuZXcgUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uLmdldFNoaWZ0ZWRCeSgxKSk7IC8vIFdyYXAgZmFrZSBlbGVtZW50IHdpdGggYXR0cmlidXRlIChpdCB3aWxsIGFsc28gbWVyZ2UgaWYgcG9zc2libGUpLgoKICAgICAgdGhpcy53cmFwKHdyYXBSYW5nZSwgYXR0cmlidXRlKTsgLy8gUmVtb3ZlIGZha2UgZWxlbWVudCBhbmQgcGxhY2UgbmV3IHBvc2l0aW9uIHRoZXJlLgoKICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGZha2VQb3NpdGlvbi5wYXJlbnQsIGZha2VQb3NpdGlvbi5pbmRleCk7CgogICAgICBmYWtlUG9zaXRpb24uX3JlbW92ZSgpOyAvLyBJZiBwb3NpdGlvbiBpcyBwbGFjZWQgYmV0d2VlbiB0ZXh0IG5vZGVzIC0gbWVyZ2UgdGhlbSBhbmQgcmV0dXJuIHBvc2l0aW9uIGluc2lkZS4KCgogICAgICB2YXIgbm9kZUJlZm9yZSA9IG5ld1Bvc2l0aW9uLm5vZGVCZWZvcmU7CiAgICAgIHZhciBub2RlQWZ0ZXIgPSBuZXdQb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAobm9kZUJlZm9yZSBpbnN0YW5jZW9mIFRleHQgJiYgbm9kZUFmdGVyIGluc3RhbmNlb2YgVGV4dCkgewogICAgICAgIHJldHVybiBtZXJnZVRleHROb2Rlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpOwogICAgICB9IC8vIElmIHBvc2l0aW9uIGlzIG5leHQgdG8gdGV4dCBub2RlIC0gbW92ZSBwb3NpdGlvbiBpbnNpZGUuCgoKICAgICAgcmV0dXJuIG1vdmVQb3NpdGlvblRvVGV4dE5vZGUobmV3UG9zaXRpb24pOwogICAgfQogICAgLyoqCiAgICAgKiAJV3JhcHMgb25lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnR9IGludG8gYW5vdGhlciBieQogICAgICogCW1lcmdpbmcgdGhlbSBpZiBwb3NzaWJsZS4gV2hlbiBtZXJnaW5nIGlzIHBvc3NpYmxlIC0gYWxsIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgY2xhc3NlcyBhcmUgbW92ZWQgZnJvbSB3cmFwcGVyCiAgICAgKiAJZWxlbWVudCB0byBlbGVtZW50IGJlaW5nIHdyYXBwZWQuCiAgICAgKgogICAgICogCUBwcml2YXRlCiAgICAgKiAJQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSB3cmFwcGVyIFdyYXBwZXIgQXR0cmlidXRlRWxlbWVudC4KICAgICAqIAlAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IHRvV3JhcCBBdHRyaWJ1dGVFbGVtZW50IHRvIHdyYXAgdXNpbmcgd3JhcHBlciBlbGVtZW50LgogICAgICogCUByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBlbGVtZW50cyBhcmUgbWVyZ2VkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl93cmFwQXR0cmlidXRlRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3dyYXBBdHRyaWJ1dGVFbGVtZW50KHdyYXBwZXIsIHRvV3JhcCkgewogICAgICBpZiAoIWNhbkJlSm9pbmVkKHdyYXBwZXIsIHRvV3JhcCkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2FuJ3QgbWVyZ2UgaWYgbmFtZSBvciBwcmlvcml0eSBkaWZmZXJzLgoKCiAgICAgIGlmICh3cmFwcGVyLm5hbWUgIT09IHRvV3JhcC5uYW1lIHx8IHdyYXBwZXIucHJpb3JpdHkgIT09IHRvV3JhcC5wcmlvcml0eSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDaGVjayBpZiBhdHRyaWJ1dGVzIGNhbiBiZSBtZXJnZWQuCgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gd3JhcHBlci5nZXRBdHRyaWJ1dGVLZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDQudmFsdWU7CgogICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gLy8gSWYgc29tZSBhdHRyaWJ1dGVzIGFyZSBkaWZmZXJlbnQgd2UgY2Fubm90IHdyYXAuCgoKICAgICAgICAgIGlmICh0b1dyYXAuaGFzQXR0cmlidXRlKGtleSkgJiYgdG9XcmFwLmdldEF0dHJpYnV0ZShrZXkpICE9PSB3cmFwcGVyLmdldEF0dHJpYnV0ZShrZXkpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIENoZWNrIGlmIHN0eWxlcyBjYW4gYmUgbWVyZ2VkLgoKICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX2tleSA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICBpZiAodG9XcmFwLmhhc1N0eWxlKF9rZXkpICYmIHRvV3JhcC5nZXRTdHlsZShfa2V5KSAhPT0gd3JhcHBlci5nZXRTdHlsZShfa2V5KSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBNb3ZlIGFsbCBhdHRyaWJ1dGVzL2NsYXNzZXMvc3R5bGVzIGZyb20gd3JhcHBlciB0byB3cmFwcGVkIEF0dHJpYnV0ZUVsZW1lbnQuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gd3JhcHBlci5nZXRBdHRyaWJ1dGVLZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHsKICAgICAgICAgIHZhciBfa2V5MiA9IF9zdGVwNi52YWx1ZTsKCiAgICAgICAgICAvLyBDbGFzc2VzIGFuZCBzdHlsZXMgc2hvdWxkIGJlIGNoZWNrZWQgc2VwYXJhdGVseS4KICAgICAgICAgIGlmIChfa2V5MiA9PT0gJ2NsYXNzJyB8fCBfa2V5MiA9PT0gJ3N0eWxlJykgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0gLy8gTW92ZSBvbmx5IHRoZXNlIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbm90IHByZXNlbnQgLSBvdGhlciBhcmUgc2ltaWxhci4KCgogICAgICAgICAgaWYgKCF0b1dyYXAuaGFzQXR0cmlidXRlKF9rZXkyKSkgewogICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShfa2V5Miwgd3JhcHBlci5nZXRBdHRyaWJ1dGUoX2tleTIpLCB0b1dyYXApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I2LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I2KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX2tleTMgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgaWYgKCF0b1dyYXAuaGFzU3R5bGUoX2tleTMpKSB7CiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoX2tleTMsIHdyYXBwZXIuZ2V0U3R5bGUoX2tleTMpLCB0b1dyYXApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjggPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IHdyYXBwZXIuZ2V0Q2xhc3NOYW1lcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA4OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX2tleTQgPSBfc3RlcDgudmFsdWU7CgogICAgICAgICAgaWYgKCF0b1dyYXAuaGFzQ2xhc3MoX2tleTQpKSB7CiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoX2tleTQsIHRvV3JhcCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yOCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCAmJiBfaXRlcmF0b3I4LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjgpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFVud3JhcHMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0gZnJvbSBhbm90aGVyIGJ5IHJlbW92aW5nCiAgICAgKiBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcy4gQWxsIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcyBmcm9tIHdyYXBwZXIgc2hvdWxkIGJlIHByZXNlbnQKICAgICAqIGluc2lkZSBlbGVtZW50IGJlaW5nIHVud3JhcHBlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSB3cmFwcGVyIFdyYXBwZXIgQXR0cmlidXRlRWxlbWVudC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gdG9VbndyYXAgQXR0cmlidXRlRWxlbWVudCB0byB1bndyYXAgdXNpbmcgd3JhcHBlciBlbGVtZW50LgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGVsZW1lbnRzIGFyZSB1bndyYXBwZWQuCiAgICAgKiovCgogIH0sIHsKICAgIGtleTogIl91bndyYXBBdHRyaWJ1dGVFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfdW53cmFwQXR0cmlidXRlRWxlbWVudCh3cmFwcGVyLCB0b1Vud3JhcCkgewogICAgICBpZiAoIWNhbkJlSm9pbmVkKHdyYXBwZXIsIHRvVW53cmFwKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDYW4ndCB1bndyYXAgaWYgbmFtZSBvciBwcmlvcml0eSBkaWZmZXJzLgoKCiAgICAgIGlmICh3cmFwcGVyLm5hbWUgIT09IHRvVW53cmFwLm5hbWUgfHwgd3JhcHBlci5wcmlvcml0eSAhPT0gdG9VbndyYXAucHJpb3JpdHkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gQ2hlY2sgaWYgQXR0cmlidXRlRWxlbWVudCBoYXMgYWxsIHdyYXBwZXIgYXR0cmlidXRlcy4KCgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I5ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjkgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjkgPSB3cmFwcGVyLmdldEF0dHJpYnV0ZUtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGtleSA9IF9zdGVwOS52YWx1ZTsKCiAgICAgICAgICAvLyBDbGFzc2VzIGFuZCBzdHlsZXMgc2hvdWxkIGJlIGNoZWNrZWQgc2VwYXJhdGVseS4KICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfSAvLyBJZiBzb21lIGF0dHJpYnV0ZXMgYXJlIG1pc3Npbmcgb3IgZGlmZmVyZW50IHdlIGNhbm5vdCB1bndyYXAuCgoKICAgICAgICAgIGlmICghdG9VbndyYXAuaGFzQXR0cmlidXRlKGtleSkgfHwgdG9VbndyYXAuZ2V0QXR0cmlidXRlKGtleSkgIT09IHdyYXBwZXIuZ2V0QXR0cmlidXRlKGtleSkpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0gLy8gQ2hlY2sgaWYgQXR0cmlidXRlRWxlbWVudCBoYXMgYWxsIHdyYXBwZXIgY2xhc3Nlcy4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yOSA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yOS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yOSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIXRvVW53cmFwLmhhc0NsYXNzLmFwcGx5KHRvVW53cmFwLCBfdG9Db25zdW1hYmxlQXJyYXkod3JhcHBlci5nZXRDbGFzc05hbWVzKCkpKSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDaGVjayBpZiBBdHRyaWJ1dGVFbGVtZW50IGhhcyBhbGwgd3JhcHBlciBzdHlsZXMuCgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSAoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWUpIHsKICAgICAgICAgIHZhciBfa2V5NSA9IF9zdGVwMTAudmFsdWU7CgogICAgICAgICAgLy8gSWYgc29tZSBzdHlsZXMgYXJlIG1pc3Npbmcgb3IgZGlmZmVyZW50IHdlIGNhbm5vdCB1bndyYXAuCiAgICAgICAgICBpZiAoIXRvVW53cmFwLmhhc1N0eWxlKF9rZXk1KSB8fCB0b1Vud3JhcC5nZXRTdHlsZShfa2V5NSkgIT09IHdyYXBwZXIuZ2V0U3R5bGUoX2tleTUpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIFJlbW92ZSBhbGwgd3JhcHBlcidzIGF0dHJpYnV0ZXMgZnJvbSB1bndyYXBwZWQgZWxlbWVudC4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTAgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yMTAgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwICYmIF9pdGVyYXRvcjEwLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjEwLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMCkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjEwOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjExID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjExID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMSA9IHdyYXBwZXIuZ2V0QXR0cmlidXRlS2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSAoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWUpIHsKICAgICAgICAgIHZhciBfa2V5NiA9IF9zdGVwMTEudmFsdWU7CgogICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjbGFzcycgfHwgX2tleTYgPT09ICdzdHlsZScpIHsKICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoX2tleTYsIHRvVW53cmFwKTsKICAgICAgICB9IC8vIFJlbW92ZSBhbGwgd3JhcHBlcidzIGNsYXNzZXMgZnJvbSB1bndyYXBwZWQgZWxlbWVudC4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTEgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yMTEgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExICYmIF9pdGVyYXRvcjExLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjExLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjExOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5yZW1vdmVDbGFzcyhBcnJheS5mcm9tKHdyYXBwZXIuZ2V0Q2xhc3NOYW1lcygpKSwgdG9VbndyYXApOyAvLyBSZW1vdmUgYWxsIHdyYXBwZXIncyBzdHlsZXMgZnJvbSB1bndyYXBwZWQgZWxlbWVudC4KCiAgICAgIHRoaXMucmVtb3ZlU3R5bGUoQXJyYXkuZnJvbSh3cmFwcGVyLmdldFN0eWxlTmFtZXMoKSksIHRvVW53cmFwKTsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IG90aGVyIGBEb3duY2FzdFdyaXRlcmAgbWV0aG9kcy4gQnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBhdCB0aGUgYm91bmRhcmllcyBvZiBnaXZlbiByYW5nZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHdoaWNoIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucyB3aWxsIGJlIHVzZWQgdG8gYnJlYWsgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlU3BsaXRUZXh0PWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIGJyZWFrIHRleHQgbm9kZXMgZXZlbiBpZiB0aGV5IGFyZSBkaXJlY3RseSBpbiBjb250YWluZXIgZWxlbWVudC4KICAgICAqIFRoaXMgYmVoYXZpb3Igd2lsbCByZXN1bHQgaW4gaW5jb3JyZWN0IHZpZXcgc3RhdGUsIGJ1dCBpcyBuZWVkZWQgYnkgb3RoZXIgdmlldyB3cml0aW5nIG1ldGhvZHMgd2hpY2ggdGhlbiBmaXhlcyB2aWV3IHN0YXRlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gTmV3IHJhbmdlIHdpdGggbG9jYXRlZCBhdCBicmVhayBwb3NpdGlvbnMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2JyZWFrQXR0cmlidXRlc1JhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UpIHsKICAgICAgdmFyIGZvcmNlU3BsaXRUZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgdmFyIHJhbmdlU3RhcnQgPSByYW5nZS5zdGFydDsKICAgICAgdmFyIHJhbmdlRW5kID0gcmFuZ2UuZW5kOwogICAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gQnJlYWsgYXQgdGhlIGNvbGxhcHNlZCBwb3NpdGlvbi4gUmV0dXJuIG5ldyBjb2xsYXBzZWQgcmFuZ2UuCgogICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9icmVha0F0dHJpYnV0ZXMocmFuZ2Uuc3RhcnQsIGZvcmNlU3BsaXRUZXh0KTsKCiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24pOwogICAgICB9CgogICAgICB2YXIgYnJlYWtFbmQgPSB0aGlzLl9icmVha0F0dHJpYnV0ZXMocmFuZ2VFbmQsIGZvcmNlU3BsaXRUZXh0KTsKCiAgICAgIHZhciBjb3VudCA9IGJyZWFrRW5kLnBhcmVudC5jaGlsZENvdW50OwoKICAgICAgdmFyIGJyZWFrU3RhcnQgPSB0aGlzLl9icmVha0F0dHJpYnV0ZXMocmFuZ2VTdGFydCwgZm9yY2VTcGxpdFRleHQpOyAvLyBDYWxjdWxhdGUgbmV3IGJyZWFrIGVuZCBvZmZzZXQuCgoKICAgICAgYnJlYWtFbmQub2Zmc2V0ICs9IGJyZWFrRW5kLnBhcmVudC5jaGlsZENvdW50IC0gY291bnQ7CiAgICAgIHJldHVybiBuZXcgUmFuZ2UoYnJlYWtTdGFydCwgYnJlYWtFbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBvdGhlciBgRG93bmNhc3RXcml0ZXJgIG1ldGhvZHMuIEJyZWFrcyBhdHRyaWJ1dGUgZWxlbWVudHMgYXQgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstZW1wdHktZWxlbWVudGAgd2hlbiBicmVhayBwb3NpdGlvbgogICAgICogaXMgcGxhY2VkIGluc2lkZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fS4KICAgICAqCiAgICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50YCB3aGVuIGJyZWFrIHBvc2l0aW9uCiAgICAgKiBpcyBwbGFjZWQgaW5zaWRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnR9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gd2hlcmUgdG8gYnJlYWsgYXR0cmlidXRlcy4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlU3BsaXRUZXh0PWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIGJyZWFrIHRleHQgbm9kZXMgZXZlbiBpZiB0aGV5IGFyZSBkaXJlY3RseSBpbiBjb250YWluZXIgZWxlbWVudC4KICAgICAqIFRoaXMgYmVoYXZpb3Igd2lsbCByZXN1bHQgaW4gaW5jb3JyZWN0IHZpZXcgc3RhdGUsIGJ1dCBpcyBuZWVkZWQgYnkgb3RoZXIgdmlldyB3cml0aW5nIG1ldGhvZHMgd2hpY2ggdGhlbiBmaXhlcyB2aWV3IHN0YXRlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gTmV3IHBvc2l0aW9uIGFmdGVyIGJyZWFraW5nIHRoZSBhdHRyaWJ1dGVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9icmVha0F0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9icmVha0F0dHJpYnV0ZXMocG9zaXRpb24pIHsKICAgICAgdmFyIGZvcmNlU3BsaXRUZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgdmFyIHBvc2l0aW9uT2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0OwogICAgICB2YXIgcG9zaXRpb25QYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIElmIHBvc2l0aW9uIGlzIHBsYWNlZCBpbnNpZGUgRW1wdHlFbGVtZW50IC0gdGhyb3cgYW4gZXhjZXB0aW9uIGFzIHdlIGNhbm5vdCBicmVhayBpbnNpZGUuCgogICAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCdlbXB0eUVsZW1lbnQnKSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBicmVhayBpbnNpZGUgRW1wdHlFbGVtZW50IGluc3RhbmNlLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1lbXB0eS1lbGVtZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1lbXB0eS1lbGVtZW50JywgdGhpcy5kb2N1bWVudCk7CiAgICAgIH0gLy8gSWYgcG9zaXRpb24gaXMgcGxhY2VkIGluc2lkZSBVSUVsZW1lbnQgLSB0aHJvdyBhbiBleGNlcHRpb24gYXMgd2UgY2Fubm90IGJyZWFrIGluc2lkZS4KCgogICAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCd1aUVsZW1lbnQnKSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBicmVhayBpbnNpZGUgVUlFbGVtZW50IGluc3RhbmNlLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50JywgdGhpcy5kb2N1bWVudCk7CiAgICAgIH0gLy8gVGhlcmUgYXJlIG5vIGF0dHJpYnV0ZXMgdG8gYnJlYWsgYW5kIHRleHQgbm9kZXMgYnJlYWtpbmcgaXMgbm90IGZvcmNlZC4KCgogICAgICBpZiAoIWZvcmNlU3BsaXRUZXh0ICYmIHBvc2l0aW9uUGFyZW50LmlzKCd0ZXh0JykgJiYgaXNDb250YWluZXJPckZyYWdtZW50KHBvc2l0aW9uUGFyZW50LnBhcmVudCkpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb24uY2xvbmUoKTsKICAgICAgfSAvLyBQb3NpdGlvbidzIHBhcmVudCBpcyBjb250YWluZXIsIHNvIG5vIGF0dHJpYnV0ZXMgdG8gYnJlYWsuCgoKICAgICAgaWYgKGlzQ29udGFpbmVyT3JGcmFnbWVudChwb3NpdGlvblBhcmVudCkpIHsKICAgICAgICByZXR1cm4gcG9zaXRpb24uY2xvbmUoKTsKICAgICAgfSAvLyBCcmVhayB0ZXh0IGFuZCBzdGFydCBhZ2FpbiBpbiBuZXcgcG9zaXRpb24uCgoKICAgICAgaWYgKHBvc2l0aW9uUGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKGJyZWFrVGV4dE5vZGUocG9zaXRpb24pLCBmb3JjZVNwbGl0VGV4dCk7CiAgICAgIH0KCiAgICAgIHZhciBsZW5ndGggPSBwb3NpdGlvblBhcmVudC5jaGlsZENvdW50OyAvLyA8cD5mb288Yj48dT5iYXJ7fTwvdT48L2I+PC9wPgogICAgICAvLyA8cD5mb288Yj48dT5iYXI8L3U+W108L2I+PC9wPgogICAgICAvLyA8cD5mb288Yj48dT5iYXI8L3U+PC9iPltdPC9wPgoKICAgICAgaWYgKHBvc2l0aW9uT2Zmc2V0ID09IGxlbmd0aCkgewogICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihwb3NpdGlvblBhcmVudC5wYXJlbnQsIHBvc2l0aW9uUGFyZW50LmluZGV4ICsgMSk7CiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlcyhuZXdQb3NpdGlvbiwgZm9yY2VTcGxpdFRleHQpOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIDxwPmZvbzxiPjx1Pnt9YmFyPC91PjwvYj48L3A+CiAgICAgICAgLy8gPHA+Zm9vPGI+W108dT5iYXI8L3U+PC9iPjwvcD4KICAgICAgICAvLyA8cD5mb297fTxiPjx1PmJhcjwvdT48L2I+PC9wPgogICAgICAgIGlmIChwb3NpdGlvbk9mZnNldCA9PT0gMCkgewogICAgICAgICAgdmFyIF9uZXdQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihwb3NpdGlvblBhcmVudC5wYXJlbnQsIHBvc2l0aW9uUGFyZW50LmluZGV4KTsKCiAgICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKF9uZXdQb3NpdGlvbiwgZm9yY2VTcGxpdFRleHQpOwogICAgICAgIH0gLy8gPHA+Zm9vPGI+PHU+Ynt9YXI8L3U+PC9iPjwvcD4KICAgICAgICAvLyA8cD5mb288Yj48dT5iW11hcjwvdT48L2I+PC9wPgogICAgICAgIC8vIDxwPmZvbzxiPjx1PmI8L3U+W108dT5hcjwvdT48L2I+PC9wPgogICAgICAgIC8vIDxwPmZvbzxiPjx1PmI8L3U+PC9iPltdPGI+PHU+YXI8L3U+PC9iPjwvcD4KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgdmFyIG9mZnNldEFmdGVyID0gcG9zaXRpb25QYXJlbnQuaW5kZXggKyAxOyAvLyBCcmVhayBlbGVtZW50LgoKICAgICAgICAgICAgdmFyIGNsb25lZE5vZGUgPSBwb3NpdGlvblBhcmVudC5fY2xvbmUoKTsgLy8gSW5zZXJ0IGNsb25lZCBub2RlIHRvIHBvc2l0aW9uJ3MgcGFyZW50IG5vZGUuCgoKICAgICAgICAgICAgcG9zaXRpb25QYXJlbnQucGFyZW50Ll9pbnNlcnRDaGlsZChvZmZzZXRBZnRlciwgY2xvbmVkTm9kZSk7CgogICAgICAgICAgICB0aGlzLl9hZGRUb0Nsb25lZEVsZW1lbnRzR3JvdXAoY2xvbmVkTm9kZSk7IC8vIEdldCBub2RlcyB0byBtb3ZlLgoKCiAgICAgICAgICAgIHZhciBjb3VudCA9IHBvc2l0aW9uUGFyZW50LmNoaWxkQ291bnQgLSBwb3NpdGlvbk9mZnNldDsKCiAgICAgICAgICAgIHZhciBub2Rlc1RvTW92ZSA9IHBvc2l0aW9uUGFyZW50Ll9yZW1vdmVDaGlsZHJlbihwb3NpdGlvbk9mZnNldCwgY291bnQpOyAvLyBNb3ZlIG5vZGVzIHRvIGNsb25lZCBub2RlLgoKCiAgICAgICAgICAgIGNsb25lZE5vZGUuX2FwcGVuZENoaWxkKG5vZGVzVG9Nb3ZlKTsgLy8gQ3JlYXRlIG5ldyBwb3NpdGlvbiB0byB3b3JrIG9uLgoKCiAgICAgICAgICAgIHZhciBfbmV3UG9zaXRpb24yID0gbmV3IFBvc2l0aW9uKHBvc2l0aW9uUGFyZW50LnBhcmVudCwgb2Zmc2V0QWZ0ZXIpOwoKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrQXR0cmlidXRlcyhfbmV3UG9zaXRpb24yLCBmb3JjZVNwbGl0VGV4dCk7CiAgICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU3RvcmVzIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fSB3YXMKICAgICAqIGFkZGVkIHRvIHRoZSB0cmVlLiBTYXZlcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBncm91cCBpbiB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgZ3JvdXAsIHNvIG90aGVyIGVsZW1lbnRzCiAgICAgKiBmcm9tIHRoZSBncm91cCBub3cga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgKgogICAgICogVGhlIGNsb25lcyBncm91cCBjYW4gYmUgb2J0YWluZWQgdXNpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjZ2V0RWxlbWVudHNXaXRoU2FtZUlkfS4KICAgICAqCiAgICAgKiBEb2VzIG5vdGhpbmcgaWYgYWRkZWQgZWxlbWVudCBoYXMgbm8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaWQgaWR9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGVsZW1lbnQgQXR0cmlidXRlIGVsZW1lbnQgdG8gc2F2ZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKGVsZW1lbnQpIHsKICAgICAgLy8gQWRkIG9ubHkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gZG9jdW1lbnQgdHJlZS4KICAgICAgaWYgKCFlbGVtZW50LnJvb3QuaXMoJ3Jvb3RFbGVtZW50JykpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0gLy8gVHJhdmVyc2UgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiByZWN1cnNpdmVseSB0byBmaW5kIG90aGVyIGF0dHJpYnV0ZSBlbGVtZW50cyB0aGF0IGFsc28gbWlnaHQgZ290IGluc2VydGVkLgogICAgICAvLyBUaGUgbG9vcCBpcyBhdCB0aGUgYmVnaW5uaW5nIHNvIHdlIGNhbiBtYWtlIGZhc3QgcmV0dXJucyBsYXRlciBpbiB0aGUgY29kZS4KCgogICAgICBpZiAoZWxlbWVudC5pcygnZWxlbWVudCcpKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTIgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMiA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEyID0gZWxlbWVudC5nZXRDaGlsZHJlbigpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSAoX3N0ZXAxMiA9IF9pdGVyYXRvcjEyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAxMi52YWx1ZTsKCiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cChjaGlsZCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEyID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yMTIgPSBlcnI7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyICYmIF9pdGVyYXRvcjEyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMTIucmV0dXJuKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEyKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGlkID0gZWxlbWVudC5pZDsKCiAgICAgIGlmICghaWQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBncm91cCA9IHRoaXMuX2Nsb25lR3JvdXBzLmdldChpZCk7CgogICAgICBpZiAoIWdyb3VwKSB7CiAgICAgICAgZ3JvdXAgPSBuZXcgU2V0KCk7CgogICAgICAgIHRoaXMuX2Nsb25lR3JvdXBzLnNldChpZCwgZ3JvdXApOwogICAgICB9CgogICAgICBncm91cC5hZGQoZWxlbWVudCk7CiAgICAgIGVsZW1lbnQuX2Nsb25lc0dyb3VwID0gZ3JvdXA7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnR9CiAgICAgKiBmcm9tIGl0cyBjbG9uZXMgZ3JvdXAuCiAgICAgKgogICAgICogS2VlcCBpbiBtaW5kLCB0aGF0IHRoZSBlbGVtZW50IHdpbGwgc3RpbGwga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZ3JvdXAgKGJ1dCB0aGUgZ3JvdXAgd2lsbCBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCkuCiAgICAgKiBUaGlzIGFsbG93cyB0byByZWZlcmVuY2UgdGhlIHdob2xlIGdyb3VwIGV2ZW4gaWYgdGhlIGVsZW1lbnQgd2FzIGFscmVhZHkgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLgogICAgICoKICAgICAqIERvZXMgbm90aGluZyBpZiB0aGUgZWxlbWVudCBoYXMgbm8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaWQgaWR9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGVsZW1lbnQgQXR0cmlidXRlIGVsZW1lbnQgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGVsZW1lbnQpIHsKICAgICAgLy8gVHJhdmVyc2UgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiByZWN1cnNpdmVseSB0byBmaW5kIG90aGVyIGF0dHJpYnV0ZSBlbGVtZW50cyB0aGF0IGFsc28gZ290IHJlbW92ZWQuCiAgICAgIC8vIFRoZSBsb29wIGlzIGF0IHRoZSBiZWdpbm5pbmcgc28gd2UgY2FuIG1ha2UgZmFzdCByZXR1cm5zIGxhdGVyIGluIHRoZSBjb2RlLgogICAgICBpZiAoZWxlbWVudC5pcygnZWxlbWVudCcpKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTMgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMyA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEzID0gZWxlbWVudC5nZXRDaGlsZHJlbigpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSAoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAxMy52YWx1ZTsKCiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTMgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3IxMyA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgJiYgX2l0ZXJhdG9yMTMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3IxMy5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTMpIHsKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjEzOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgaWQgPSBlbGVtZW50LmlkOwoKICAgICAgaWYgKCFpZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGdyb3VwID0gdGhpcy5fY2xvbmVHcm91cHMuZ2V0KGlkKTsKCiAgICAgIGlmICghZ3JvdXApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGdyb3VwLmRlbGV0ZShlbGVtZW50KTsgLy8gTm90IHJlbW92aW5nIGdyb3VwIGZyb20gZWxlbWVudCBvbiBwdXJwb3NlIQogICAgICAvLyBJZiBvdGhlciBwYXJ0cyBvZiBjb2RlIGhhdmUgcmVmZXJlbmNlIHRvIHRoaXMgZWxlbWVudCwgdGhleSB3aWxsIGJlIGFibGUgdG8gZ2V0IHJlZmVyZW5jZXMgdG8gb3RoZXIgZWxlbWVudHMgZnJvbSB0aGUgZ3JvdXAuCiAgICB9CiAgfV0pOwoKICByZXR1cm4gRG93bmNhc3RXcml0ZXI7Cn0oKTsgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgdmlldy53cml0ZXIud3JhcGAuIENoZWNrcyBpZiBnaXZlbiBlbGVtZW50IGhhcyBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHVpIGVsZW1lbnRzLgoKCmV4cG9ydCB7IERvd25jYXN0V3JpdGVyIGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIF9oYXNOb25VaUNoaWxkcmVuKHBhcmVudCkgewogIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5nZXRDaGlsZHJlbigpKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkgewogICAgcmV0dXJuICFjaGlsZC5pcygndWlFbGVtZW50Jyk7CiAgfSk7Cn0KLyoqCiAqIEF0dHJpYnV0ZSBlbGVtZW50IG5lZWQgdG8gYmUgaW5zdGFuY2Ugb2YgYXR0cmlidXRlIGVsZW1lbnQuCiAqCiAqIEBlcnJvciB2aWV3LXdyaXRlci13cmFwLWludmFsaWQtYXR0cmlidXRlCiAqLwovLyBSZXR1cm5zIGZpcnN0IHBhcmVudCBjb250YWluZXIgb2Ygc3BlY2lmaWVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gUG9zaXRpb259LgovLyBQb3NpdGlvbidzIHBhcmVudCBub2RlIGlzIGNoZWNrZWQgYXMgZmlyc3QsIHRoZW4gbmV4dCBwYXJlbnRzIGFyZSBjaGVja2VkLgovLyBOb3RlIHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgRG9jdW1lbnRGcmFnbWVudH0gaXMgdHJlYXRlZCBsaWtlIGEgY29udGFpbmVyLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gdXNlZCBhcyBhIHN0YXJ0IHBvaW50IHRvIGxvY2F0ZSBwYXJlbnQgY29udGFpbmVyLgovLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH0KLy8gUGFyZW50IGNvbnRhaW5lciBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIGNvbnRhaW5lciBpcyBub3QgZm91bmQuCgoKZnVuY3Rpb24gZ2V0UGFyZW50Q29udGFpbmVyKHBvc2l0aW9uKSB7CiAgdmFyIHBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgd2hpbGUgKCFpc0NvbnRhaW5lck9yRnJhZ21lbnQocGFyZW50KSkgewogICAgaWYgKCFwYXJlbnQpIHsKICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgIH0KCiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50OwogIH0KCiAgcmV0dXJuIHBhcmVudDsKfSAvLyBDaGVja3MgaWYgZmlyc3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0gcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uCi8vIGNhbiBiZSB3cmFwcGVkIG90dXNpZGUgc2Vjb25kIGVsZW1lbnQuIEl0IGlzIGRvbmUgYnkgY29tcGFyaW5nIGVsZW1lbnRzJwovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNwcmlvcml0eSBwcmlvcml0aWVzfSwgaWYgYm90aCBoYXZlIHNhbWUgcHJpb3JpdHkKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQjZ2V0SWRlbnRpdHkgaWRlbnRpdGllc30gYXJlIGNvbXBhcmVkLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGEKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBiCi8vIEByZXR1cm5zIHtCb29sZWFufQoKCmZ1bmN0aW9uIHNob3VsZEFCZU91dHNpZGVCKGEsIGIpIHsKICBpZiAoYS5wcmlvcml0eSA8IGIucHJpb3JpdHkpIHsKICAgIHJldHVybiB0cnVlOwogIH0gZWxzZSBpZiAoYS5wcmlvcml0eSA+IGIucHJpb3JpdHkpIHsKICAgIHJldHVybiBmYWxzZTsKICB9IC8vIFdoZW4gcHJpb3JpdGllcyBhcmUgZXF1YWwgYW5kIG5hbWVzIGFyZSBkaWZmZXJlbnQgLSB1c2UgaWRlbnRpdGllcy4KCgogIHJldHVybiBhLmdldElkZW50aXR5KCkgPCBiLmdldElkZW50aXR5KCk7Cn0gLy8gUmV0dXJucyBuZXcgcG9zaXRpb24gdGhhdCBpcyBtb3ZlZCB0byBuZWFyIHRleHQgbm9kZS4gUmV0dXJucyBzYW1lIHBvc2l0aW9uIGlmIHRoZXJlIGlzIG5vIHRleHQgbm9kZSBiZWZvcmUgb2YgYWZ0ZXIKLy8gc3BlY2lmaWVkIHBvc2l0aW9uLgovLwovLwkJPHA+Zm9vW108L3A+ICAtPiAgPHA+Zm9ve308L3A+Ci8vCQk8cD5bXWZvbzwvcD4gIC0+ICA8cD57fWZvbzwvcD4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFBvc2l0aW9uIGxvY2F0ZWQgaW5zaWRlIHRleHQgbm9kZSBvciBzYW1lIHBvc2l0aW9uIGlmIHRoZXJlIGlzIG5vIHRleHQgbm9kZXMKLy8gYmVmb3JlIG9yIGFmdGVyIHBvc2l0aW9uIGxvY2F0aW9uLgoKCmZ1bmN0aW9uIG1vdmVQb3NpdGlvblRvVGV4dE5vZGUocG9zaXRpb24pIHsKICB2YXIgbm9kZUJlZm9yZSA9IHBvc2l0aW9uLm5vZGVCZWZvcmU7CgogIGlmIChub2RlQmVmb3JlICYmIG5vZGVCZWZvcmUuaXMoJ3RleHQnKSkgewogICAgcmV0dXJuIG5ldyBQb3NpdGlvbihub2RlQmVmb3JlLCBub2RlQmVmb3JlLmRhdGEubGVuZ3RoKTsKICB9CgogIHZhciBub2RlQWZ0ZXIgPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogIGlmIChub2RlQWZ0ZXIgJiYgbm9kZUFmdGVyLmlzKCd0ZXh0JykpIHsKICAgIHJldHVybiBuZXcgUG9zaXRpb24obm9kZUFmdGVyLCAwKTsKICB9CgogIHJldHVybiBwb3NpdGlvbjsKfSAvLyBCcmVha3MgdGV4dCBub2RlIGludG8gdHdvIHRleHQgbm9kZXMgd2hlbiBwb3NzaWJsZS4KLy8KLy8JCTxwPmZvb3t9YmFyPC9wPiAtPiA8cD5mb29bXWJhcjwvcD4KLy8JCTxwPnt9Zm9vYmFyPC9wPiAtPiA8cD5bXWZvb2JhcjwvcD4KLy8JCTxwPmZvb2Jhcnt9PC9wPiAtPiA8cD5mb29iYXJbXTwvcD4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHRoYXQgbmVlZCB0byBiZSBwbGFjZWQgaW5zaWRlIHRleHQgbm9kZS4KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gTmV3IHBvc2l0aW9uIGFmdGVyIGJyZWFraW5nIHRleHQgbm9kZS4KCgpmdW5jdGlvbiBicmVha1RleHROb2RlKHBvc2l0aW9uKSB7CiAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBwb3NpdGlvbi5wYXJlbnQuZGF0YS5sZW5ndGgpIHsKICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zaXRpb24ucGFyZW50LnBhcmVudCwgcG9zaXRpb24ucGFyZW50LmluZGV4ICsgMSk7CiAgfQoKICBpZiAocG9zaXRpb24ub2Zmc2V0ID09PSAwKSB7CiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLnBhcmVudC5wYXJlbnQsIHBvc2l0aW9uLnBhcmVudC5pbmRleCk7CiAgfSAvLyBHZXQgcGFydCBvZiB0aGUgdGV4dCB0aGF0IG5lZWQgdG8gYmUgbW92ZWQuCgoKICB2YXIgdGV4dFRvTW92ZSA9IHBvc2l0aW9uLnBhcmVudC5kYXRhLnNsaWNlKHBvc2l0aW9uLm9mZnNldCk7IC8vIExlYXZlIHJlc3Qgb2YgdGhlIHRleHQgaW4gcG9zaXRpb24ncyBwYXJlbnQuCgogIHBvc2l0aW9uLnBhcmVudC5fZGF0YSA9IHBvc2l0aW9uLnBhcmVudC5kYXRhLnNsaWNlKDAsIHBvc2l0aW9uLm9mZnNldCk7IC8vIEluc2VydCBuZXcgdGV4dCBub2RlIGFmdGVyIHBvc2l0aW9uJ3MgcGFyZW50IHRleHQgbm9kZS4KCiAgcG9zaXRpb24ucGFyZW50LnBhcmVudC5faW5zZXJ0Q2hpbGQocG9zaXRpb24ucGFyZW50LmluZGV4ICsgMSwgbmV3IFRleHQocG9zaXRpb24ucm9vdC5kb2N1bWVudCwgdGV4dFRvTW92ZSkpOyAvLyBSZXR1cm4gbmV3IHBvc2l0aW9uIGJldHdlZW4gdHdvIG5ld2x5IGNyZWF0ZWQgdGV4dCBub2Rlcy4KCgogIHJldHVybiBuZXcgUG9zaXRpb24ocG9zaXRpb24ucGFyZW50LnBhcmVudCwgcG9zaXRpb24ucGFyZW50LmluZGV4ICsgMSk7Cn0gLy8gTWVyZ2VzIHR3byB0ZXh0IG5vZGVzIGludG8gZmlyc3Qgbm9kZS4gUmVtb3ZlcyBzZWNvbmQgbm9kZSBhbmQgcmV0dXJucyBtZXJnZSBwb3NpdGlvbi4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSB0MSBGaXJzdCB0ZXh0IG5vZGUgdG8gbWVyZ2UuIERhdGEgZnJvbSBzZWNvbmQgdGV4dCBub2RlIHdpbGwgYmUgbW92ZWQgYXQgdGhlIGVuZCBvZgovLyB0aGlzIHRleHQgbm9kZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSB0MiBTZWNvbmQgdGV4dCBub2RlIHRvIG1lcmdlLiBUaGlzIG5vZGUgd2lsbCBiZSByZW1vdmVkIGFmdGVyIG1lcmdpbmcuCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFBvc2l0aW9uIGFmdGVyIG1lcmdpbmcgdGV4dCBub2Rlcy4KCgpmdW5jdGlvbiBtZXJnZVRleHROb2Rlcyh0MSwgdDIpIHsKICAvLyBNZXJnZSB0ZXh0IGRhdGEgaW50byBmaXJzdCB0ZXh0IG5vZGUgYW5kIHJlbW92ZSBzZWNvbmQgb25lLgogIHZhciBub2RlQmVmb3JlTGVuZ3RoID0gdDEuZGF0YS5sZW5ndGg7CiAgdDEuX2RhdGEgKz0gdDIuZGF0YTsKCiAgdDIuX3JlbW92ZSgpOwoKICByZXR1cm4gbmV3IFBvc2l0aW9uKHQxLCBub2RlQmVmb3JlTGVuZ3RoKTsKfSAvLyBDaGVja3MgaWYgcHJvdmlkZWQgbm9kZXMgYXJlIHZhbGlkIHRvIGluc2VydC4gQ2hlY2tzIGlmIGVhY2ggbm9kZSBpcyBhbiBpbnN0YW5jZSBvZgovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCBUZXh0fSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSwKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgQ29udGFpbmVyRWxlbWVudH0sCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnR9IG9yCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnR9LgovLwovLyBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWluc2VydC1pbnZhbGlkLW5vZGVgIHdoZW4gbm9kZXMgdG8gaW5zZXJ0Ci8vIGNvbnRhaW5zIGluc3RhbmNlcyB0aGF0IGFyZSBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgVGV4dHN9LAovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50c30sCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnRzfSwKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudHN9IG9yCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IENvbnRhaW5lckVsZW1lbnRzfS4KLy8KLy8gQHBhcmFtIEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQKLy8gfG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQ+IG5vZGVzCi8vIEBwYXJhbSB7T2JqZWN0fSBlcnJvckNvbnRleHQKCgpmdW5jdGlvbiB2YWxpZGF0ZU5vZGVzVG9JbnNlcnQobm9kZXMsIGVycm9yQ29udGV4dCkgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjE0ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yMTQgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHsKICAgICAgdmFyIG5vZGUgPSBfc3RlcDE0LnZhbHVlOwoKICAgICAgaWYgKCF2YWxpZE5vZGVzVG9JbnNlcnQuc29tZShmdW5jdGlvbiAodmFsaWROb2RlKSB7CiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB2YWxpZE5vZGU7CiAgICAgIH0pKSB7CiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZQoKICAgICAgICAvKioKICAgICAgICAgKiBJbnNlcnRlZCBub2RlcyBzaG91bGQgYmUgdmFsaWQgdG8gaW5zZXJ0LiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSwKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBDb250YWluZXJFbGVtZW50fSwKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fSwKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50fSwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgVGV4dH0uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItaW5zZXJ0LWludmFsaWQtbm9kZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci1pbnNlcnQtaW52YWxpZC1ub2RlJywgZXJyb3JDb250ZXh0KTsKICAgICAgfQoKICAgICAgaWYgKCFub2RlLmlzKCd0ZXh0JykpIHsKICAgICAgICB2YWxpZGF0ZU5vZGVzVG9JbnNlcnQobm9kZS5nZXRDaGlsZHJlbigpLCBlcnJvckNvbnRleHQpOwogICAgICB9CiAgICB9OwoKICAgIGZvciAodmFyIF9pdGVyYXRvcjE0ID0gbm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDE0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNCA9IChfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE0ID0gdHJ1ZSkgewogICAgICBfbG9vcCgpOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxNCA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjE0ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNCAmJiBfaXRlcmF0b3IxNC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjE0LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxNCkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTQ7CiAgICAgIH0KICAgIH0KICB9Cn0KCnZhciB2YWxpZE5vZGVzVG9JbnNlcnQgPSBbVGV4dCwgQXR0cmlidXRlRWxlbWVudCwgQ29udGFpbmVyRWxlbWVudCwgRW1wdHlFbGVtZW50LCBVSUVsZW1lbnRdOyAvLyBDaGVja3MgaWYgbm9kZSBpcyBDb250YWluZXJFbGVtZW50IG9yIERvY3VtZW50RnJhZ21lbnQsIGJlY2F1c2UgaW4gbW9zdCBjYXNlcyB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIHdheS4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfSBub2RlCi8vIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBub2RlIGlzIGluc3RhbmNlIG9mIENvbnRhaW5lckVsZW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudC4KCmZ1bmN0aW9uIGlzQ29udGFpbmVyT3JGcmFnbWVudChub2RlKSB7CiAgcmV0dXJuIG5vZGUgJiYgKG5vZGUuaXMoJ2NvbnRhaW5lckVsZW1lbnQnKSB8fCBub2RlLmlzKCdkb2N1bWVudEZyYWdtZW50JykpOwp9IC8vIENoZWNrcyBpZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHJhbmdlIHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgcmFuZ2UgZW5kfSBhcmUgcGxhY2VkCi8vIGluc2lkZSBzYW1lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50fS4KLy8gVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UKLy8gQHBhcmFtIHtPYmplY3R9IGVycm9yQ29udGV4dAoKCmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VDb250YWluZXIocmFuZ2UsIGVycm9yQ29udGV4dCkgewogIHZhciBzdGFydENvbnRhaW5lciA9IGdldFBhcmVudENvbnRhaW5lcihyYW5nZS5zdGFydCk7CiAgdmFyIGVuZENvbnRhaW5lciA9IGdldFBhcmVudENvbnRhaW5lcihyYW5nZS5lbmQpOwoKICBpZiAoIXN0YXJ0Q29udGFpbmVyIHx8ICFlbmRDb250YWluZXIgfHwgc3RhcnRDb250YWluZXIgIT09IGVuZENvbnRhaW5lcikgewogICAgLyoqCiAgICAgKiBSYW5nZSBjb250YWluZXIgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgcmFuZ2Ugc3RhcnR9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgcmFuZ2UgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlIHNhbWUgY29udGFpbmVyIG9yCiAgICAgKiBwYXJlbnQgY29udGFpbmVyIGZvciB0aGVzZSBwb3NpdGlvbnMgY2Fubm90IGJlIGZvdW5kLgogICAgICoKICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcgogICAgICovCiAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXInLCBlcnJvckNvbnRleHQpOwogIH0KfSAvLyBDaGVja3MgaWYgdHdvIGF0dHJpYnV0ZSBlbGVtZW50cyBjYW4gYmUgam9pbmVkIHRvZ2V0aGVyLiBFbGVtZW50cyBjYW4gYmUgam9pbmVkIHRvZ2V0aGVyIGlmLCBhbmQgb25seSBpZgovLyB0aGV5IGRvIG5vdCBoYXZlIGlkcyBzcGVjaWZpZWQuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gYQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gY2FuQmVKb2luZWQoYSwgYikgewogIHJldHVybiBhLmlkID09PSBudWxsICYmIGIuaWQgPT09IG51bGw7Cn0="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","document","_cloneGroups","Map","selectable","placeOrOffset","options","selection","_setTo","itemOrPosition","offset","_setFocus","data","name","attributes","attributeElement","priority","_priority","id","_id","editableElement","_document","renderFunction","uiElement","render","key","value","element","_setAttribute","_removeAttribute","className","_addClass","_removeClass","property","undefined","_setStyle","_removeStyle","_setCustomProperty","_removeCustomProperty","positionOrRange","_breakAttributes","_breakAttributesRange","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","positionOffset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","mergeAttributes","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","container","getParentContainer","insertionPosition","length","_insertChild","node","_addToClonedElementsGroup","endPosition","getShiftedBy","start","isEqual","end","rangeOrItem","range","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","setSelection","newRange","_unwrapChildren","newName","viewElement","getAttributes","groupName","delete","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","isEmpty","isUI","_wrapAttributeElement","push","shouldABeOutsideB","newAttribute","_wrapChildren","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","breakTextNode","fakePosition","createAttributeElement","Number","POSITIVE_INFINITY","wrapRange","wrap","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","setAttribute","setStyle","getClassNames","hasClass","addClass","toUnwrap","removeAttribute","removeClass","Array","from","removeStyle","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","errorContext","validNodesToInsert","validNode","startContainer","endContainer"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\n\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n\t/**\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t */\n\tconstructor( document ) {\n\t\t/**\n\t\t * The view document instance in which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String,Set>}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t * Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data The text's data.\n\t * @returns {module:engine/view/text~Text} The created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( this.document, data );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( this.document, name, attributes );\n\n\t\tif ( options.priority ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'p' );\n\t *\n\t *\t\t// Create element with custom attributes.\n\t *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n\t *\n\t *\t\t// Create element with custom styles.\n\t *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n\t *\n\t *\t\t// Create element with custom classes.\n\t *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes ) {\n\t\treturn new ContainerElement( this.document, name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( this.document, name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes ) {\n\t\treturn new EmptyElement( this.document, name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n\t *\n\t * Custom render function can be provided as third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Function} [renderFunction] Custom render function.\n\t * @returns {module:engine/view/uielement~UIElement} Created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction ) {\n\t\tconst uiElement = new UIElement( this.document, name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Adds or overwrite element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * **Note**: The passed style can be normalized if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element ); // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * **Note**: This method can work with normalized style names if\n\t * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.\n\t * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside\n\t * up to a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:\n\t *\n\t *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute\n\t * elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position\n\t * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning\n\t * or at the end of it's parent element.\n\t *\n\t *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n\t *\t\t<p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n\t * @param {module:engine/view/position~Position} position Position where to break element.\n\t * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,\n\t * the returned position is placed either before it or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-break-non-container-element: Trying to break an element which is not a container element.',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root: Trying to break root element.', this.document );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position._createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position._createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position._createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position._createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *\t\t<p><b>[]</b></p> -> <p>[]</p>\n\t *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position: ' +\n\t\t\t\t'Element before and after given position cannot be merged.', this.document );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position._createAt( lastChild, 'end' ) : Position._createAt( prev, 'end' );\n\n\t\tthis.move( Range._createIn( next ), Position._createAt( prev, 'end' ) );\n\t\tthis.remove( Range._createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Insert node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes, this.document );\n\n\t\tconst container = getParentContainer( position );\n\n\t\tif ( !container ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-invalid-position-container', this.document );\n\t\t}\n\n\t\tconst insertionPosition = this._breakAttributes( position, true );\n\t\tconst length = container._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( length === 0 ) {\n\t\t\treturn new Range( start, start );\n\t\t} else {\n\t\t\t// If start position was merged - move end position.\n\t\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\t\tendPosition.offset--;\n\t\t\t}\n\n\t\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n\t * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( rangeOrItem ) {\n\t\tconst range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn( rangeOrItem );\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment( this.document );\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = mergePosition.clone();\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( this.document, removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range._createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( 'textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range._createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n\t * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n\t *\n\t * If a collapsed range was passed and is same as selection, the selection\n\t * will be moved to the inside of the wrapped attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start}\n\t * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n\t * is collapsed and different than view selection.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to wrap.\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n\t * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n\t*/\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError( 'view-writer-wrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * Attribute element need to be instance of attribute element.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-unwrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {String} newName New name for element.\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t */\n\trename( newName, viewElement ) {\n\t\tconst newElement = new ContainerElement( this.document, newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position._createAfter( viewElement ), newElement );\n\t\tthis.move( Range._createIn( viewElement ), Position._createAt( newElement, 0 ) );\n\t\tthis.remove( Range._createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Cleans up memory by removing obsolete cloned elements group from the writer.\n\t *\n\t * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n\t * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n\t * the group will no longer be needed.\n\t *\n\t * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n\t * were removed from the view.\n\t *\n\t * Keep in mind that group names are equal to the `id` property of the attribute element.\n\t *\n\t * @param {String} groupName Name of the group to clear.\n\t */\n\tclearClonedElementsGroup( groupName ) {\n\t\tthis._cloneGroups.delete( groupName );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link #createPositionBefore},\n\t * * {@link #createPositionAfter},\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn Position._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn Position._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn Position._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn Range._createOn( item );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn Range._createIn( element );\n\t}\n\n\t/**\n\t Creates new {@link module:engine/view/selection~Selection} instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t * @returns {module:engine/view/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new Selection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} wrapElement\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, wrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( 'text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isEmpty = child.is( 'emptyElement' );\n\t\t\tconst isUI = child.is( 'uiElement' );\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n\t\t\t// If possible, join elements.\n\t\t\t//\n\t\t\t// <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n\t\t\t//\n\t\t\tif ( isAttribute && this._wrapAttributeElement( wrapElement, child ) ) {\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n\t\t\t// `wrapElement` (due to priority).\n\t\t\t//\n\t\t\t// <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n\t\t\t// <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n\t\t\t//\n\t\t\telse if ( isText || isEmpty || isUI || ( isAttribute && shouldABeOutsideB( wrapElement, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = wrapElement._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n\t\t\t//\n\t\t\t// <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n\t\t\t//\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, wrapElement );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} unwrapElement\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, unwrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\t// We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n\t\t// so it could get messy. It is safer to it manually in this case.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// Skip all text nodes. There should be no container element's here either.\n\t\t\tif ( !child.is( 'attributeElement' ) ) {\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n\t\t\t//\n\t\t\t// <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n\t\t\t//\n\t\t\tif ( child.isSimilar( unwrapElement ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n\t\t\t// Partial unwrapping will happen only if the elements have the same name.\n\t\t\t//\n\t\t\t// <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n\t\t\t// <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n\t\t\t//\n\t\t\tif ( this._unwrapAttributeElement( unwrapElement, child ) ) {\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + 1 )\n\t\t\t\t);\n\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If other nested attribute is found, look through it's children for elements to unwrap.\n\t\t\t//\n\t\t\t// <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n\t\t\t//\n\t\t\tthis._unwrapChildren( child, 0, child.childCount, unwrapElement );\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( position.clone() );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( 'text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside EmptyElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside UIElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element', this.document );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( 'text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else {\n\t\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\t\tif ( positionOffset === 0 ) {\n\t\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\t\telse {\n\t\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t\t// Break element.\n\t\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t\t// Insert cloned node to position's parent node.\n\t\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t\t// Get nodes to move.\n\t\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t\t// Move nodes to cloned node.\n\t\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t\t// Create new position to work on.\n\t\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * Attribute element need to be instance of attribute element.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped otuside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( 'text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( 'text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( position.root.document, textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Checks if provided nodes are valid to insert. Checks if each node is an instance of\n// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n// {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or\n// {@link module:engine/view/uielement~UIElement UIElement}.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not {@link module:engine/view/text~Text Texts},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n// {@link module:engine/view/uielement~UIElement UIElements},\n// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or\n// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement\n// |module:engine/view/containerelement~ContainerElement> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert( nodes, errorContext ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node', errorContext );\n\t\t}\n\n\t\tif ( !node.is( 'text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren(), errorContext );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer( range, errorContext ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or\n\t\t * parent container for these positions cannot be found.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container', errorContext );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n"]}]}