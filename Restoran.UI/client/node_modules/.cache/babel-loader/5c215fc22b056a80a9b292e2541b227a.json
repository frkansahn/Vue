{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\operation\\utils.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\operation\\utils.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdXRpbHMKICovCmltcG9ydCBOb2RlIGZyb20gJy4uL25vZGUnOwppbXBvcnQgVGV4dCBmcm9tICcuLi90ZXh0JzsKaW1wb3J0IFRleHRQcm94eSBmcm9tICcuLi90ZXh0cHJveHknOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi4vcmFuZ2UnOwppbXBvcnQgRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuLi9kb2N1bWVudGZyYWdtZW50JzsKaW1wb3J0IE5vZGVMaXN0IGZyb20gJy4uL25vZGVsaXN0JzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7Ci8qKgogKiBDb250YWlucyBmdW5jdGlvbnMgdXNlZCBmb3IgY29tcG9zaW5nIG1vZGVsIHRyZWUgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9uc30uCiAqIFRob3NlIGZ1bmN0aW9ucyBhcmUgYnVpbHQgb24gdG9wIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2RlfSwgYW5kIGl0J3MgY2hpbGQgY2xhc3NlcycsIEFQSXMuCiAqCiAqIEBwcm90ZWN0ZWQKICogQG5hbWVzcGFjZSB1dGlscwogKi8KCi8qKgogKiBJbnNlcnRzIGdpdmVuIG5vZGVzIGF0IGdpdmVuIHBvc2l0aW9uLgogKgogKiBAcHJvdGVjdGVkCiAqIEBmdW5jdGlvbiBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi91dGlsc351dGlscy5pbnNlcnQKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBhdCB3aGljaCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGVTZXR9IG5vZGVzIE5vZGVzIHRvIGluc2VydC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IFJhbmdlIHNwYW5uaW5nIG92ZXIgaW5zZXJ0ZWQgZWxlbWVudHMuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIF9pbnNlcnQocG9zaXRpb24sIG5vZGVzKSB7CiAgbm9kZXMgPSBfbm9ybWFsaXplTm9kZXMobm9kZXMpOyAvLyBXZSBoYXZlIHRvIGNvdW50IG9mZnNldCBiZWZvcmUgaW5zZXJ0aW5nIG5vZGVzIGJlY2F1c2UgdGhleSBjYW4gZ2V0IG1lcmdlZCBhbmQgd2Ugd291bGQgZ2V0IHdyb25nIG9mZnNldHMuCgogIHZhciBvZmZzZXQgPSBub2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgbm9kZSkgewogICAgcmV0dXJuIHN1bSArIG5vZGUub2Zmc2V0U2l6ZTsKICB9LCAwKTsKICB2YXIgcGFyZW50ID0gcG9zaXRpb24ucGFyZW50OyAvLyBJbnNlcnRpb24gbWlnaHQgYmUgaW4gYSB0ZXh0IG5vZGUsIHdlIHNob3VsZCBzcGxpdCBpdCBpZiB0aGF0J3MgdGhlIGNhc2UuCgogIF9zcGxpdE5vZGVBdFBvc2l0aW9uKHBvc2l0aW9uKTsKCiAgdmFyIGluZGV4ID0gcG9zaXRpb24uaW5kZXg7IC8vIEluc2VydCBub2RlcyBhdCBnaXZlbiBpbmRleC4gQWZ0ZXIgc3BsaXR0aW5nIHdlIGhhdmUgYSBwcm9wZXIgaW5kZXggYW5kIGluc2VydGlvbiBpcyBiZXR3ZWVuIG5vZGVzLAogIC8vIHVzaW5nIGJhc2ljIGBFbGVtZW50YCBBUEkuCgogIHBhcmVudC5faW5zZXJ0Q2hpbGQoaW5kZXgsIG5vZGVzKTsgLy8gTWVyZ2UgdGV4dCBub2RlcywgaWYgcG9zc2libGUuIE1lcmdpbmcgaXMgbmVlZGVkIG9ubHkgYXQgcG9pbnRzIHdoZXJlIGluc2VydGVkIG5vZGVzICJ0b3VjaCIgIm9sZCIgbm9kZXMuCgoKICBfbWVyZ2VOb2Rlc0F0SW5kZXgocGFyZW50LCBpbmRleCArIG5vZGVzLmxlbmd0aCk7CgogIF9tZXJnZU5vZGVzQXRJbmRleChwYXJlbnQsIGluZGV4KTsKCiAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24uZ2V0U2hpZnRlZEJ5KG9mZnNldCkpOwp9Ci8qKgogKiBSZW1vdmVkIG5vZGVzIGluIGdpdmVuIHJhbmdlLiBPbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlI2lzRmxhdCBmbGF0fSByYW5nZXMgYXJlIGFjY2VwdGVkLgogKgogKiBAcHJvdGVjdGVkCiAqIEBmdW5jdGlvbiBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi91dGlsc351dGlscy5fcmVtb3ZlCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgY29udGFpbmluZyBub2RlcyB0byByZW1vdmUuCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fQogKi8KCmV4cG9ydCBmdW5jdGlvbiBfcmVtb3ZlKHJhbmdlKSB7CiAgaWYgKCFyYW5nZS5pc0ZsYXQpIHsKICAgIC8qKgogICAgICogVHJ5aW5nIHRvIHJlbW92ZSBhIHJhbmdlIHdoaWNoIHN0YXJ0cyBhbmQgZW5kcyBpbiBkaWZmZXJlbnQgZWxlbWVudC4KICAgICAqCiAgICAgKiBAZXJyb3Igb3BlcmF0aW9uLXV0aWxzLXJlbW92ZS1yYW5nZS1ub3QtZmxhdAogICAgICovCiAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignb3BlcmF0aW9uLXV0aWxzLXJlbW92ZS1yYW5nZS1ub3QtZmxhdDogJyArICdUcnlpbmcgdG8gcmVtb3ZlIGEgcmFuZ2Ugd2hpY2ggc3RhcnRzIGFuZCBlbmRzIGluIGRpZmZlcmVudCBlbGVtZW50LicsIHRoaXMpOwogIH0KCiAgdmFyIHBhcmVudCA9IHJhbmdlLnN0YXJ0LnBhcmVudDsgLy8gUmFuZ2UgbWF5IGJlIGluc2lkZSB0ZXh0IG5vZGVzLCB3ZSBoYXZlIHRvIHNwbGl0IHRoZW0gaWYgdGhhdCdzIHRoZSBjYXNlLgoKICBfc3BsaXROb2RlQXRQb3NpdGlvbihyYW5nZS5zdGFydCk7CgogIF9zcGxpdE5vZGVBdFBvc2l0aW9uKHJhbmdlLmVuZCk7IC8vIFJlbW92ZSB0aGUgdGV4dCBub2RlcyB1c2luZyBiYXNpYyBgRWxlbWVudGAgQVBJLgoKCiAgdmFyIHJlbW92ZWQgPSBwYXJlbnQuX3JlbW92ZUNoaWxkcmVuKHJhbmdlLnN0YXJ0LmluZGV4LCByYW5nZS5lbmQuaW5kZXggLSByYW5nZS5zdGFydC5pbmRleCk7IC8vIE1lcmdlIHRleHQgbm9kZXMsIGlmIHBvc3NpYmxlLiBBZnRlciBzb21lIG5vZGVzIHdlcmUgcmVtb3ZlZCwgbm9kZSBiZWZvcmUgYW5kIGFmdGVyIHJlbW92ZWQgcmFuZ2Ugd2lsbCBiZQogIC8vIHRvdWNoaW5nIGF0IHRoZSBwb3NpdGlvbiBlcXVhbCB0byB0aGUgcmVtb3ZlZCByYW5nZSBiZWdpbm5pbmcuIFdlIGNoZWNrIG1lcmdpbmcgcG9zc2liaWxpdHkgdGhlcmUuCgoKICBfbWVyZ2VOb2Rlc0F0SW5kZXgocGFyZW50LCByYW5nZS5zdGFydC5pbmRleCk7CgogIHJldHVybiByZW1vdmVkOwp9Ci8qKgogKiBNb3ZlcyBub2RlcyBpbiBnaXZlbiByYW5nZSB0byBnaXZlbiB0YXJnZXQgcG9zaXRpb24uIE9ubHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UjaXNGbGF0IGZsYXR9IHJhbmdlcyBhcmUgYWNjZXB0ZWQuCiAqCiAqIEBwcm90ZWN0ZWQKICogQGZ1bmN0aW9uIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3V0aWxzfnV0aWxzLm1vdmUKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBzb3VyY2VSYW5nZSBSYW5nZSBjb250YWluaW5nIG5vZGVzIHRvIG1vdmUuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0UG9zaXRpb24gUG9zaXRpb24gdG8gd2hpY2ggbm9kZXMgc2hvdWxkIGJlIG1vdmVkLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gUmFuZ2UgY29udGFpbmluZyBtb3ZlZCBub2Rlcy4KICovCgpleHBvcnQgZnVuY3Rpb24gX21vdmUoc291cmNlUmFuZ2UsIHRhcmdldFBvc2l0aW9uKSB7CiAgaWYgKCFzb3VyY2VSYW5nZS5pc0ZsYXQpIHsKICAgIC8qKgogICAgICogVHJ5aW5nIHRvIG1vdmUgYSByYW5nZSB3aGljaCBzdGFydHMgYW5kIGVuZHMgaW4gZGlmZmVyZW50IGVsZW1lbnQuCiAgICAgKgogICAgICogQGVycm9yIG9wZXJhdGlvbi11dGlscy1tb3ZlLXJhbmdlLW5vdC1mbGF0CiAgICAgKi8KICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdvcGVyYXRpb24tdXRpbHMtbW92ZS1yYW5nZS1ub3QtZmxhdDogJyArICdUcnlpbmcgdG8gbW92ZSBhIHJhbmdlIHdoaWNoIHN0YXJ0cyBhbmQgZW5kcyBpbiBkaWZmZXJlbnQgZWxlbWVudC4nLCB0aGlzKTsKICB9CgogIHZhciBub2RlcyA9IF9yZW1vdmUoc291cmNlUmFuZ2UpOyAvLyBXZSBoYXZlIHRvIGZpeCBgdGFyZ2V0UG9zaXRpb25gIGJlY2F1c2UgbW9kZWwgY2hhbmdlZCBhZnRlciBub2RlcyBmcm9tIGBzb3VyY2VSYW5nZWAgZ290IHJlbW92ZWQgYW5kCiAgLy8gdGhhdCBjaGFuZ2UgbWlnaHQgaGF2ZSBhbiBpbXBhY3Qgb24gYHRhcmdldFBvc2l0aW9uYC4KCgogIHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VSYW5nZS5zdGFydCwgc291cmNlUmFuZ2UuZW5kLm9mZnNldCAtIHNvdXJjZVJhbmdlLnN0YXJ0Lm9mZnNldCk7CiAgcmV0dXJuIF9pbnNlcnQodGFyZ2V0UG9zaXRpb24sIG5vZGVzKTsKfQovKioKICogU2V0cyBnaXZlbiBhdHRyaWJ1dGUgb24gbm9kZXMgaW4gZ2l2ZW4gcmFuZ2UuIFRoZSBhdHRyaWJ1dGVzIGFyZSBvbmx5IHNldCBvbiB0b3AtbGV2ZWwgbm9kZXMgb2YgdGhlIHJhbmdlLCBub3Qgb24gaXRzIGNoaWxkcmVuLgogKgogKiBAcHJvdGVjdGVkCiAqIEBmdW5jdGlvbiBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi91dGlsc351dGlscy5fc2V0QXR0cmlidXRlCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgY29udGFpbmluZyBub2RlcyB0aGF0IHNob3VsZCBoYXZlIHRoZSBhdHRyaWJ1dGUgc2V0LiBNdXN0IGJlIGEgZmxhdCByYW5nZS4KICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIHNldC4KICogQHBhcmFtIHsqfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIF9zZXRBdHRyaWJ1dGUocmFuZ2UsIGtleSwgdmFsdWUpIHsKICAvLyBSYW5nZSBtaWdodCBzdGFydCBvciBlbmQgaW4gdGV4dCBub2Rlcywgc28gd2UgaGF2ZSB0byBzcGxpdCB0aGVtLgogIF9zcGxpdE5vZGVBdFBvc2l0aW9uKHJhbmdlLnN0YXJ0KTsKCiAgX3NwbGl0Tm9kZUF0UG9zaXRpb24ocmFuZ2UuZW5kKTsgLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgcmFuZ2UuCgoKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcmFuZ2UuZ2V0SXRlbXMoewogICAgICBzaGFsbG93OiB0cnVlCiAgICB9KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgdmFyIGl0ZW0gPSBfc3RlcC52YWx1ZTsKICAgICAgLy8gSXRlcmF0b3Igd2lsbCByZXR1cm4gYFRleHRQcm94eWAgaW5zdGFuY2VzIGJ1dCB3ZSBrbm93IHRoYXQgdGhvc2UgdGV4dCBwcm94aWVzIHdpbGwKICAgICAgLy8gYWx3YXlzIHJlcHJlc2VudCBmdWxsIHRleHQgbm9kZXMgKHRoaXMgaXMgZ3VhcmFudGVlZCB0aGFua3MgdG8gc3BsaXR0aW5nIHdlIGRpZCBiZWZvcmUpLgogICAgICAvLyBTbywgd2UgY2FuIG9wZXJhdGUgb24gdGhvc2UgdGV4dCBwcm94aWVzJyB0ZXh0IG5vZGVzLgogICAgICB2YXIgbm9kZSA9IGl0ZW0uaXMoJ3RleHRQcm94eScpID8gaXRlbS50ZXh0Tm9kZSA6IGl0ZW07CgogICAgICBpZiAodmFsdWUgIT09IG51bGwpIHsKICAgICAgICBub2RlLl9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbm9kZS5fcmVtb3ZlQXR0cmlidXRlKGtleSk7CiAgICAgIH0gLy8gQWZ0ZXIgYXR0cmlidXRlcyBjaGFuZ2luZyBpdCBtYXkgaGFwcGVuIHRoYXQgc29tZSB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQuIFRyeSB0byBtZXJnZSB3aXRoIHByZXZpb3VzIG5vZGUuCgoKICAgICAgX21lcmdlTm9kZXNBdEluZGV4KG5vZGUucGFyZW50LCBub2RlLmluZGV4KTsKICAgIH0gLy8gVHJ5IHRvIG1lcmdlIGxhc3QgY2hhbmdlZCBub2RlIHdpdGggaXQncyBwcmV2aW91cyBzaWJsaW5nIChub3QgY292ZXJlZCBieSB0aGUgbG9vcCBhYm92ZSkuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICB9CiAgICB9CiAgfQoKICBfbWVyZ2VOb2Rlc0F0SW5kZXgocmFuZ2UuZW5kLnBhcmVudCwgcmFuZ2UuZW5kLmluZGV4KTsKfQovKioKICogTm9ybWFsaXplcyBnaXZlbiBvYmplY3Qgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBhbiBhcnJheSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgbm9kZXN9LiBTZWUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlU2V0IE5vZGVTZXR9IGZvciBkZXRhaWxzIG9uIGhvdyBub3JtYWxpemF0aW9uIGlzIHBlcmZvcm1lZC4KICoKICogQHByb3RlY3RlZAogKiBAZnVuY3Rpb24gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdXRpbHN+dXRpbHMubm9ybWFsaXplTm9kZXMKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZVNldH0gbm9kZXMgT2JqZWN0cyB0byBub3JtYWxpemUuCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBOb3JtYWxpemVkIG5vZGVzLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBfbm9ybWFsaXplTm9kZXMobm9kZXMpIHsKICB2YXIgbm9ybWFsaXplZCA9IFtdOwoKICBpZiAoIShub2RlcyBpbnN0YW5jZW9mIEFycmF5KSkgewogICAgbm9kZXMgPSBbbm9kZXNdOwogIH0gLy8gQ29udmVydCBpbnN0YW5jZXMgb2YgY2xhc3NlcyBvdGhlciB0aGFuIE5vZGUuCgoKICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7CiAgICBpZiAodHlwZW9mIG5vZGVzW2ldID09ICdzdHJpbmcnKSB7CiAgICAgIG5vcm1hbGl6ZWQucHVzaChuZXcgVGV4dChub2Rlc1tpXSkpOwogICAgfSBlbHNlIGlmIChub2Rlc1tpXSBpbnN0YW5jZW9mIFRleHRQcm94eSkgewogICAgICBub3JtYWxpemVkLnB1c2gobmV3IFRleHQobm9kZXNbaV0uZGF0YSwgbm9kZXNbaV0uZ2V0QXR0cmlidXRlcygpKSk7CiAgICB9IGVsc2UgaWYgKG5vZGVzW2ldIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBub2Rlc1tpXSBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG5vZGVzW2ldW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICBub3JtYWxpemVkLnB1c2goY2hpbGQpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSBpZiAobm9kZXNbaV0gaW5zdGFuY2VvZiBOb2RlKSB7CiAgICAgIG5vcm1hbGl6ZWQucHVzaChub2Rlc1tpXSk7CiAgICB9IC8vIFNraXAgdW5yZWNvZ25pemVkIHR5cGUuCgogIH0gLy8gTWVyZ2UgdGV4dCBub2Rlcy4KCgogIGZvciAodmFyIF9pID0gMTsgX2kgPCBub3JtYWxpemVkLmxlbmd0aDsgX2krKykgewogICAgdmFyIG5vZGUgPSBub3JtYWxpemVkW19pXTsKICAgIHZhciBwcmV2ID0gbm9ybWFsaXplZFtfaSAtIDFdOwoKICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBwcmV2IGluc3RhbmNlb2YgVGV4dCAmJiBfaGF2ZVNhbWVBdHRyaWJ1dGVzKG5vZGUsIHByZXYpKSB7CiAgICAgIC8vIERvaW5nIHRoaXMgaW5zdGVhZCBjaGFuZ2luZyBgcHJldi5kYXRhYCBiZWNhdXNlIGBkYXRhYCBpcyByZWFkb25seS4KICAgICAgbm9ybWFsaXplZC5zcGxpY2UoX2kgLSAxLCAyLCBuZXcgVGV4dChwcmV2LmRhdGEgKyBub2RlLmRhdGEsIHByZXYuZ2V0QXR0cmlidXRlcygpKSk7CiAgICAgIF9pLS07CiAgICB9CiAgfQoKICByZXR1cm4gbm9ybWFsaXplZDsKfSAvLyBDaGVja3MgaWYgbm9kZXMgYmVmb3JlIGFuZCBhZnRlciBnaXZlbiBpbmRleCBpbiBnaXZlbiBlbGVtZW50IGFyZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHQgdGV4dCBub2Rlc30gYW5kCi8vIG1lcmdlcyB0aGVtIGludG8gb25lIG5vZGUgaWYgdGhleSBoYXZlIHNhbWUgYXR0cmlidXRlcy4KLy8KLy8gTWVyZ2luZyBpcyBkb25lIGJ5IHJlbW92aW5nIHR3byB0ZXh0IG5vZGVzIGFuZCBpbnNlcnRpbmcgYSBuZXcgdGV4dCBub2RlIGNvbnRhaW5pbmcgZGF0YSBmcm9tIGJvdGggbWVyZ2VkIHRleHQgbm9kZXMuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgUGFyZW50IGVsZW1lbnQgb2Ygbm9kZXMgdG8gbWVyZ2UuCi8vIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBiZXR3ZWVuIG5vZGVzIHRvIG1lcmdlLgoKZnVuY3Rpb24gX21lcmdlTm9kZXNBdEluZGV4KGVsZW1lbnQsIGluZGV4KSB7CiAgdmFyIG5vZGVCZWZvcmUgPSBlbGVtZW50LmdldENoaWxkKGluZGV4IC0gMSk7CiAgdmFyIG5vZGVBZnRlciA9IGVsZW1lbnQuZ2V0Q2hpbGQoaW5kZXgpOyAvLyBDaGVjayBpZiBib3RoIG9mIHRob3NlIG5vZGVzIGFyZSB0ZXh0IG9iamVjdHMgd2l0aCBzYW1lIGF0dHJpYnV0ZXMuCgogIGlmIChub2RlQmVmb3JlICYmIG5vZGVBZnRlciAmJiBub2RlQmVmb3JlLmlzKCd0ZXh0JykgJiYgbm9kZUFmdGVyLmlzKCd0ZXh0JykgJiYgX2hhdmVTYW1lQXR0cmlidXRlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpKSB7CiAgICAvLyBBcHBlbmQgdGV4dCBvZiB0ZXh0IG5vZGUgYWZ0ZXIgaW5kZXggdG8gdGhlIGJlZm9yZSBvbmUuCiAgICB2YXIgbWVyZ2VkTm9kZSA9IG5ldyBUZXh0KG5vZGVCZWZvcmUuZGF0YSArIG5vZGVBZnRlci5kYXRhLCBub2RlQmVmb3JlLmdldEF0dHJpYnV0ZXMoKSk7IC8vIFJlbW92ZSBzZXBhcmF0ZSB0ZXh0IG5vZGVzLgoKICAgIGVsZW1lbnQuX3JlbW92ZUNoaWxkcmVuKGluZGV4IC0gMSwgMik7IC8vIEluc2VydCBtZXJnZWQgdGV4dCBub2RlLgoKCiAgICBlbGVtZW50Ll9pbnNlcnRDaGlsZChpbmRleCAtIDEsIG1lcmdlZE5vZGUpOwogIH0KfSAvLyBDaGVja3MgaWYgZ2l2ZW4gcG9zaXRpb24gaXMgaW4gYSB0ZXh0IG5vZGUsIGFuZCBpZiBzbywgc3BsaXRzIHRoZSB0ZXh0IG5vZGUgaW4gdHdvIHRleHQgbm9kZXMsIGVhY2ggb2YgdGhlbQovLyBjb250YWluaW5nIGEgcGFydCBvZiBvcmlnaW5hbCB0ZXh0IG5vZGUuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gYXQgd2hpY2ggbm9kZSBzaG91bGQgYmUgc3BsaXQuCgoKZnVuY3Rpb24gX3NwbGl0Tm9kZUF0UG9zaXRpb24ocG9zaXRpb24pIHsKICB2YXIgdGV4dE5vZGUgPSBwb3NpdGlvbi50ZXh0Tm9kZTsKICB2YXIgZWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgaWYgKHRleHROb2RlKSB7CiAgICB2YXIgb2Zmc2V0RGlmZiA9IHBvc2l0aW9uLm9mZnNldCAtIHRleHROb2RlLnN0YXJ0T2Zmc2V0OwogICAgdmFyIGluZGV4ID0gdGV4dE5vZGUuaW5kZXg7CgogICAgZWxlbWVudC5fcmVtb3ZlQ2hpbGRyZW4oaW5kZXgsIDEpOwoKICAgIHZhciBmaXJzdFBhcnQgPSBuZXcgVGV4dCh0ZXh0Tm9kZS5kYXRhLnN1YnN0cigwLCBvZmZzZXREaWZmKSwgdGV4dE5vZGUuZ2V0QXR0cmlidXRlcygpKTsKICAgIHZhciBzZWNvbmRQYXJ0ID0gbmV3IFRleHQodGV4dE5vZGUuZGF0YS5zdWJzdHIob2Zmc2V0RGlmZiksIHRleHROb2RlLmdldEF0dHJpYnV0ZXMoKSk7CgogICAgZWxlbWVudC5faW5zZXJ0Q2hpbGQoaW5kZXgsIFtmaXJzdFBhcnQsIHNlY29uZFBhcnRdKTsKICB9Cn0gLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIGdpdmVuIG5vZGVzIGhhdmUgc2FtZSBhdHRyaWJ1dGVzLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlQSBOb2RlIHRvIGNoZWNrLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlQiBOb2RlIHRvIGNoZWNrLgovLyBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIG5vZGVzIGhhdmUgc2FtZSBhdHRyaWJ1dGVzLCBgZmFsc2VgIG90aGVyd2lzZS4KCgpmdW5jdGlvbiBfaGF2ZVNhbWVBdHRyaWJ1dGVzKG5vZGVBLCBub2RlQikgewogIHZhciBpdGVyYXRvckEgPSBub2RlQS5nZXRBdHRyaWJ1dGVzKCk7CiAgdmFyIGl0ZXJhdG9yQiA9IG5vZGVCLmdldEF0dHJpYnV0ZXMoKTsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGl0ZXJhdG9yQVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICB2YXIgYXR0ciA9IF9zdGVwMy52YWx1ZTsKCiAgICAgIGlmIChhdHRyWzFdICE9PSBub2RlQi5nZXRBdHRyaWJ1dGUoYXR0clswXSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIGl0ZXJhdG9yQi5uZXh0KCk7CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gaXRlcmF0b3JCLm5leHQoKS5kb25lOwp9Ci8qKgogKiBWYWx1ZSB0aGF0IGNhbiBiZSBub3JtYWxpemVkIHRvIGFuIGFycmF5IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2Rlc30uCiAqCiAqIE5vbi1hcnJheXMgYXJlIG5vcm1hbGl6ZWQgYXMgZm9sbG93czoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgTm9kZX0gaXMgbGVmdCBhcyBpcywKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5IFRleHRQcm94eX0gYW5kIGBTdHJpbmdgIGFyZSBub3JtYWxpemVkIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCBUZXh0fSwKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2RlbGlzdH5Ob2RlTGlzdCBOb2RlTGlzdH0gaXMgbm9ybWFsaXplZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBub2RlcyB0aGF0IGFyZSBpbiB0aGF0IG5vZGUgbGlzdCwKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgRG9jdW1lbnRGcmFnbWVudH0gaXMgbm9ybWFsaXplZCB0byBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiBpdCdzCiAqICogY2hpbGRyZW4uCiAqCiAqIEFycmF5cyBhcmUgcHJvY2Vzc2VkIGl0ZW0gYnkgaXRlbSBsaWtlIG5vbi1hcnJheSB2YWx1ZXMgYW5kIGZsYXR0ZW5lZCB0byBvbmUgYXJyYXkuIE5vcm1hbGl6YXRpb24gYWx3YXlzIHJlc3VsdHMgaW4KICogYSBmbGF0IGFycmF5IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2Rlc30uIENvbnNlY3V0aXZlIHRleHQgbm9kZXMgKG9yIGl0ZW1zIG5vcm1hbGl6ZWQgdG8gdGV4dCBub2Rlcykgd2lsbCBiZQogKiBtZXJnZWQgaWYgdGhleSBoYXZlIHNhbWUgYXR0cmlidXRlcy4KICoKICogQHR5cGVkZWYge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eXxTdHJpbmd8CiAqIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZWxpc3R+Tm9kZUxpc3R8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8SXRlcmFibGV9CiAqIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlU2V0CiAqLw=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js"],"names":["Node","Text","TextProxy","Range","DocumentFragment","NodeList","CKEditorError","_insert","position","nodes","_normalizeNodes","offset","reduce","sum","node","offsetSize","parent","_splitNodeAtPosition","index","_insertChild","_mergeNodesAtIndex","length","getShiftedBy","_remove","range","isFlat","start","end","removed","_removeChildren","_move","sourceRange","targetPosition","_getTransformedByDeletion","_setAttribute","key","value","getItems","shallow","item","is","textNode","_removeAttribute","normalized","Array","i","push","data","getAttributes","child","prev","_haveSameAttributes","splice","element","nodeBefore","getChild","nodeAfter","mergedNode","offsetDiff","startOffset","firstPart","substr","secondPart","nodeA","nodeB","iteratorA","iteratorB","attr","getAttribute","next","done"],"mappings":";;;;;;;;;AAAA;;;;;AAKA;;;AAIA,OAAOA,IAAP,MAAiB,SAAjB;AACA,OAAOC,IAAP,MAAiB,SAAjB;AACA,OAAOC,SAAP,MAAsB,cAAtB;AACA,OAAOC,KAAP,MAAkB,UAAlB;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AACA,OAAOC,QAAP,MAAqB,aAArB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA;;;;;;;;AAQA;;;;;;;;;;AASA,OAAO,SAASC,OAAT,CAAkBC,QAAlB,EAA4BC,KAA5B,EAAoC;AAC1CA,EAAAA,KAAK,GAAGC,eAAe,CAAED,KAAF,CAAvB,CAD0C,CAG1C;;AACA,MAAME,MAAM,GAAGF,KAAK,CAACG,MAAN,CAAc,UAAEC,GAAF,EAAOC,IAAP;AAAA,WAAiBD,GAAG,GAAGC,IAAI,CAACC,UAA5B;AAAA,GAAd,EAAsD,CAAtD,CAAf;AACA,MAAMC,MAAM,GAAGR,QAAQ,CAACQ,MAAxB,CAL0C,CAO1C;;AACAC,EAAAA,oBAAoB,CAAET,QAAF,CAApB;;AACA,MAAMU,KAAK,GAAGV,QAAQ,CAACU,KAAvB,CAT0C,CAW1C;AACA;;AACAF,EAAAA,MAAM,CAACG,YAAP,CAAqBD,KAArB,EAA4BT,KAA5B,EAb0C,CAe1C;;;AACAW,EAAAA,kBAAkB,CAAEJ,MAAF,EAAUE,KAAK,GAAGT,KAAK,CAACY,MAAxB,CAAlB;;AACAD,EAAAA,kBAAkB,CAAEJ,MAAF,EAAUE,KAAV,CAAlB;;AAEA,SAAO,IAAIf,KAAJ,CAAWK,QAAX,EAAqBA,QAAQ,CAACc,YAAT,CAAuBX,MAAvB,CAArB,CAAP;AACA;AAED;;;;;;;;;AAQA,OAAO,SAASY,OAAT,CAAkBC,KAAlB,EAA0B;AAChC,MAAK,CAACA,KAAK,CAACC,MAAZ,EAAqB;AACpB;;;;;AAKA,UAAM,IAAInB,aAAJ,CACL,4CACA,sEAFK,EAGL,IAHK,CAAN;AAKA;;AAED,MAAMU,MAAM,GAAGQ,KAAK,CAACE,KAAN,CAAYV,MAA3B,CAdgC,CAgBhC;;AACAC,EAAAA,oBAAoB,CAAEO,KAAK,CAACE,KAAR,CAApB;;AACAT,EAAAA,oBAAoB,CAAEO,KAAK,CAACG,GAAR,CAApB,CAlBgC,CAoBhC;;;AACA,MAAMC,OAAO,GAAGZ,MAAM,CAACa,eAAP,CAAwBL,KAAK,CAACE,KAAN,CAAYR,KAApC,EAA2CM,KAAK,CAACG,GAAN,CAAUT,KAAV,GAAkBM,KAAK,CAACE,KAAN,CAAYR,KAAzE,CAAhB,CArBgC,CAuBhC;AACA;;;AACAE,EAAAA,kBAAkB,CAAEJ,MAAF,EAAUQ,KAAK,CAACE,KAAN,CAAYR,KAAtB,CAAlB;;AAEA,SAAOU,OAAP;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASE,KAAT,CAAgBC,WAAhB,EAA6BC,cAA7B,EAA8C;AACpD,MAAK,CAACD,WAAW,CAACN,MAAlB,EAA2B;AAC1B;;;;;AAKA,UAAM,IAAInB,aAAJ,CACL,0CACA,oEAFK,EAGL,IAHK,CAAN;AAKA;;AAED,MAAMG,KAAK,GAAGc,OAAO,CAAEQ,WAAF,CAArB,CAdoD,CAgBpD;AACA;;;AACAC,EAAAA,cAAc,GAAGA,cAAc,CAACC,yBAAf,CAA0CF,WAAW,CAACL,KAAtD,EAA6DK,WAAW,CAACJ,GAAZ,CAAgBhB,MAAhB,GAAyBoB,WAAW,CAACL,KAAZ,CAAkBf,MAAxG,CAAjB;AAEA,SAAOJ,OAAO,CAAEyB,cAAF,EAAkBvB,KAAlB,CAAd;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASyB,aAAT,CAAwBV,KAAxB,EAA+BW,GAA/B,EAAoCC,KAApC,EAA4C;AAClD;AACAnB,EAAAA,oBAAoB,CAAEO,KAAK,CAACE,KAAR,CAApB;;AACAT,EAAAA,oBAAoB,CAAEO,KAAK,CAACG,GAAR,CAApB,CAHkD,CAKlD;;;AALkD;AAAA;AAAA;;AAAA;AAMlD,yBAAoBH,KAAK,CAACa,QAAN,CAAgB;AAAEC,MAAAA,OAAO,EAAE;AAAX,KAAhB,CAApB,8HAA0D;AAAA,UAA9CC,IAA8C;AACzD;AACA;AACA;AACA,UAAMzB,IAAI,GAAGyB,IAAI,CAACC,EAAL,CAAS,WAAT,IAAyBD,IAAI,CAACE,QAA9B,GAAyCF,IAAtD;;AAEA,UAAKH,KAAK,KAAK,IAAf,EAAsB;AACrBtB,QAAAA,IAAI,CAACoB,aAAL,CAAoBC,GAApB,EAAyBC,KAAzB;AACA,OAFD,MAEO;AACNtB,QAAAA,IAAI,CAAC4B,gBAAL,CAAuBP,GAAvB;AACA,OAVwD,CAYzD;;;AACAf,MAAAA,kBAAkB,CAAEN,IAAI,CAACE,MAAP,EAAeF,IAAI,CAACI,KAApB,CAAlB;AACA,KApBiD,CAsBlD;;AAtBkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBlDE,EAAAA,kBAAkB,CAAEI,KAAK,CAACG,GAAN,CAAUX,MAAZ,EAAoBQ,KAAK,CAACG,GAAN,CAAUT,KAA9B,CAAlB;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASR,eAAT,CAA0BD,KAA1B,EAAkC;AACxC,MAAMkC,UAAU,GAAG,EAAnB;;AAEA,MAAK,EAAGlC,KAAK,YAAYmC,KAApB,CAAL,EAAmC;AAClCnC,IAAAA,KAAK,GAAG,CAAEA,KAAF,CAAR;AACA,GALuC,CAOxC;;;AACA,OAAM,IAAIoC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGpC,KAAK,CAACY,MAA3B,EAAmCwB,CAAC,EAApC,EAAyC;AACxC,QAAK,OAAOpC,KAAK,CAAEoC,CAAF,CAAZ,IAAqB,QAA1B,EAAqC;AACpCF,MAAAA,UAAU,CAACG,IAAX,CAAiB,IAAI7C,IAAJ,CAAUQ,KAAK,CAAEoC,CAAF,CAAf,CAAjB;AACA,KAFD,MAEO,IAAKpC,KAAK,CAAEoC,CAAF,CAAL,YAAsB3C,SAA3B,EAAuC;AAC7CyC,MAAAA,UAAU,CAACG,IAAX,CAAiB,IAAI7C,IAAJ,CAAUQ,KAAK,CAAEoC,CAAF,CAAL,CAAWE,IAArB,EAA2BtC,KAAK,CAAEoC,CAAF,CAAL,CAAWG,aAAX,EAA3B,CAAjB;AACA,KAFM,MAEA,IAAKvC,KAAK,CAAEoC,CAAF,CAAL,YAAsBzC,gBAAtB,IAA0CK,KAAK,CAAEoC,CAAF,CAAL,YAAsBxC,QAArE,EAAgF;AAAA;AAAA;AAAA;;AAAA;AACtF,8BAAqBI,KAAK,CAAEoC,CAAF,CAA1B,mIAAkC;AAAA,cAAtBI,KAAsB;AACjCN,UAAAA,UAAU,CAACG,IAAX,CAAiBG,KAAjB;AACA;AAHqF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAItF,KAJM,MAIA,IAAKxC,KAAK,CAAEoC,CAAF,CAAL,YAAsB7C,IAA3B,EAAkC;AACxC2C,MAAAA,UAAU,CAACG,IAAX,CAAiBrC,KAAK,CAAEoC,CAAF,CAAtB;AACA,KAXuC,CAYxC;;AACA,GArBuC,CAuBxC;;;AACA,OAAM,IAAIA,EAAC,GAAG,CAAd,EAAiBA,EAAC,GAAGF,UAAU,CAACtB,MAAhC,EAAwCwB,EAAC,EAAzC,EAA8C;AAC7C,QAAM/B,IAAI,GAAG6B,UAAU,CAAEE,EAAF,CAAvB;AACA,QAAMK,IAAI,GAAGP,UAAU,CAAEE,EAAC,GAAG,CAAN,CAAvB;;AAEA,QAAK/B,IAAI,YAAYb,IAAhB,IAAwBiD,IAAI,YAAYjD,IAAxC,IAAgDkD,mBAAmB,CAAErC,IAAF,EAAQoC,IAAR,CAAxE,EAAyF;AACxF;AACAP,MAAAA,UAAU,CAACS,MAAX,CAAmBP,EAAC,GAAG,CAAvB,EAA0B,CAA1B,EAA6B,IAAI5C,IAAJ,CAAUiD,IAAI,CAACH,IAAL,GAAYjC,IAAI,CAACiC,IAA3B,EAAiCG,IAAI,CAACF,aAAL,EAAjC,CAA7B;AACAH,MAAAA,EAAC;AACD;AACD;;AAED,SAAOF,UAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASvB,kBAAT,CAA6BiC,OAA7B,EAAsCnC,KAAtC,EAA8C;AAC7C,MAAMoC,UAAU,GAAGD,OAAO,CAACE,QAAR,CAAkBrC,KAAK,GAAG,CAA1B,CAAnB;AACA,MAAMsC,SAAS,GAAGH,OAAO,CAACE,QAAR,CAAkBrC,KAAlB,CAAlB,CAF6C,CAI7C;;AACA,MAAKoC,UAAU,IAAIE,SAAd,IAA2BF,UAAU,CAACd,EAAX,CAAe,MAAf,CAA3B,IAAsDgB,SAAS,CAAChB,EAAV,CAAc,MAAd,CAAtD,IAAgFW,mBAAmB,CAAEG,UAAF,EAAcE,SAAd,CAAxG,EAAoI;AACnI;AACA,QAAMC,UAAU,GAAG,IAAIxD,IAAJ,CAAUqD,UAAU,CAACP,IAAX,GAAkBS,SAAS,CAACT,IAAtC,EAA4CO,UAAU,CAACN,aAAX,EAA5C,CAAnB,CAFmI,CAInI;;AACAK,IAAAA,OAAO,CAACxB,eAAR,CAAyBX,KAAK,GAAG,CAAjC,EAAoC,CAApC,EALmI,CAOnI;;;AACAmC,IAAAA,OAAO,CAAClC,YAAR,CAAsBD,KAAK,GAAG,CAA9B,EAAiCuC,UAAjC;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASxC,oBAAT,CAA+BT,QAA/B,EAA0C;AACzC,MAAMiC,QAAQ,GAAGjC,QAAQ,CAACiC,QAA1B;AACA,MAAMY,OAAO,GAAG7C,QAAQ,CAACQ,MAAzB;;AAEA,MAAKyB,QAAL,EAAgB;AACf,QAAMiB,UAAU,GAAGlD,QAAQ,CAACG,MAAT,GAAkB8B,QAAQ,CAACkB,WAA9C;AACA,QAAMzC,KAAK,GAAGuB,QAAQ,CAACvB,KAAvB;;AAEAmC,IAAAA,OAAO,CAACxB,eAAR,CAAyBX,KAAzB,EAAgC,CAAhC;;AAEA,QAAM0C,SAAS,GAAG,IAAI3D,IAAJ,CAAUwC,QAAQ,CAACM,IAAT,CAAcc,MAAd,CAAsB,CAAtB,EAAyBH,UAAzB,CAAV,EAAiDjB,QAAQ,CAACO,aAAT,EAAjD,CAAlB;AACA,QAAMc,UAAU,GAAG,IAAI7D,IAAJ,CAAUwC,QAAQ,CAACM,IAAT,CAAcc,MAAd,CAAsBH,UAAtB,CAAV,EAA8CjB,QAAQ,CAACO,aAAT,EAA9C,CAAnB;;AAEAK,IAAAA,OAAO,CAAClC,YAAR,CAAsBD,KAAtB,EAA6B,CAAE0C,SAAF,EAAaE,UAAb,CAA7B;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASX,mBAAT,CAA8BY,KAA9B,EAAqCC,KAArC,EAA6C;AAC5C,MAAMC,SAAS,GAAGF,KAAK,CAACf,aAAN,EAAlB;AACA,MAAMkB,SAAS,GAAGF,KAAK,CAAChB,aAAN,EAAlB;AAF4C;AAAA;AAAA;;AAAA;AAI5C,0BAAoBiB,SAApB,mIAAgC;AAAA,UAApBE,IAAoB;;AAC/B,UAAKA,IAAI,CAAE,CAAF,CAAJ,KAAcH,KAAK,CAACI,YAAN,CAAoBD,IAAI,CAAE,CAAF,CAAxB,CAAnB,EAAqD;AACpD,eAAO,KAAP;AACA;;AAEDD,MAAAA,SAAS,CAACG,IAAV;AACA;AAV2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY5C,SAAOH,SAAS,CAACG,IAAV,GAAiBC,IAAxB;AACA;AAED","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/operation/utils\n */\n\nimport Node from '../node';\nimport Text from '../text';\nimport TextProxy from '../textproxy';\nimport Range from '../range';\nimport DocumentFragment from '../documentfragment';\nimport NodeList from '../nodelist';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.\n * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.\n *\n * @protected\n * @namespace utils\n */\n\n/**\n * Inserts given nodes at given position.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.insert\n * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.\n * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.\n * @returns {module:engine/model/range~Range} Range spanning over inserted elements.\n */\nexport function _insert( position, nodes ) {\n\tnodes = _normalizeNodes( nodes );\n\n\t// We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.\n\tconst offset = nodes.reduce( ( sum, node ) => sum + node.offsetSize, 0 );\n\tconst parent = position.parent;\n\n\t// Insertion might be in a text node, we should split it if that's the case.\n\t_splitNodeAtPosition( position );\n\tconst index = position.index;\n\n\t// Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,\n\t// using basic `Element` API.\n\tparent._insertChild( index, nodes );\n\n\t// Merge text nodes, if possible. Merging is needed only at points where inserted nodes \"touch\" \"old\" nodes.\n\t_mergeNodesAtIndex( parent, index + nodes.length );\n\t_mergeNodesAtIndex( parent, index );\n\n\treturn new Range( position, position.getShiftedBy( offset ) );\n}\n\n/**\n * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._remove\n * @param {module:engine/model/range~Range} range Range containing nodes to remove.\n * @returns {Array.<module:engine/model/node~Node>}\n */\nexport function _remove( range ) {\n\tif ( !range.isFlat ) {\n\t\t/**\n\t\t * Trying to remove a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-remove-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-remove-range-not-flat: ' +\n\t\t\t'Trying to remove a range which starts and ends in different element.',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst parent = range.start.parent;\n\n\t// Range may be inside text nodes, we have to split them if that's the case.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Remove the text nodes using basic `Element` API.\n\tconst removed = parent._removeChildren( range.start.index, range.end.index - range.start.index );\n\n\t// Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be\n\t// touching at the position equal to the removed range beginning. We check merging possibility there.\n\t_mergeNodesAtIndex( parent, range.start.index );\n\n\treturn removed;\n}\n\n/**\n * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.move\n * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.\n * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.\n * @returns {module:engine/model/range~Range} Range containing moved nodes.\n */\nexport function _move( sourceRange, targetPosition ) {\n\tif ( !sourceRange.isFlat ) {\n\t\t/**\n\t\t * Trying to move a range which starts and ends in different element.\n\t\t *\n\t\t * @error operation-utils-move-range-not-flat\n\t\t */\n\t\tthrow new CKEditorError(\n\t\t\t'operation-utils-move-range-not-flat: ' +\n\t\t\t'Trying to move a range which starts and ends in different element.',\n\t\t\tthis\n\t\t);\n\t}\n\n\tconst nodes = _remove( sourceRange );\n\n\t// We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and\n\t// that change might have an impact on `targetPosition`.\n\ttargetPosition = targetPosition._getTransformedByDeletion( sourceRange.start, sourceRange.end.offset - sourceRange.start.offset );\n\n\treturn _insert( targetPosition, nodes );\n}\n\n/**\n * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils._setAttribute\n * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.\n * @param {String} key Key of attribute to set.\n * @param {*} value Attribute value.\n */\nexport function _setAttribute( range, key, value ) {\n\t// Range might start or end in text nodes, so we have to split them.\n\t_splitNodeAtPosition( range.start );\n\t_splitNodeAtPosition( range.end );\n\n\t// Iterate over all items in the range.\n\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t// Iterator will return `TextProxy` instances but we know that those text proxies will\n\t\t// always represent full text nodes (this is guaranteed thanks to splitting we did before).\n\t\t// So, we can operate on those text proxies' text nodes.\n\t\tconst node = item.is( 'textProxy' ) ? item.textNode : item;\n\n\t\tif ( value !== null ) {\n\t\t\tnode._setAttribute( key, value );\n\t\t} else {\n\t\t\tnode._removeAttribute( key );\n\t\t}\n\n\t\t// After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.\n\t\t_mergeNodesAtIndex( node.parent, node.index );\n\t}\n\n\t// Try to merge last changed node with it's previous sibling (not covered by the loop above).\n\t_mergeNodesAtIndex( range.end.parent, range.end.index );\n}\n\n/**\n * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See\n * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.\n *\n * @protected\n * @function module:engine/model/operation/utils~utils.normalizeNodes\n * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.\n * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.\n */\nexport function _normalizeNodes( nodes ) {\n\tconst normalized = [];\n\n\tif ( !( nodes instanceof Array ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Convert instances of classes other than Node.\n\tfor ( let i = 0; i < nodes.length; i++ ) {\n\t\tif ( typeof nodes[ i ] == 'string' ) {\n\t\t\tnormalized.push( new Text( nodes[ i ] ) );\n\t\t} else if ( nodes[ i ] instanceof TextProxy ) {\n\t\t\tnormalized.push( new Text( nodes[ i ].data, nodes[ i ].getAttributes() ) );\n\t\t} else if ( nodes[ i ] instanceof DocumentFragment || nodes[ i ] instanceof NodeList ) {\n\t\t\tfor ( const child of nodes[ i ] ) {\n\t\t\t\tnormalized.push( child );\n\t\t\t}\n\t\t} else if ( nodes[ i ] instanceof Node ) {\n\t\t\tnormalized.push( nodes[ i ] );\n\t\t}\n\t\t// Skip unrecognized type.\n\t}\n\n\t// Merge text nodes.\n\tfor ( let i = 1; i < normalized.length; i++ ) {\n\t\tconst node = normalized[ i ];\n\t\tconst prev = normalized[ i - 1 ];\n\n\t\tif ( node instanceof Text && prev instanceof Text && _haveSameAttributes( node, prev ) ) {\n\t\t\t// Doing this instead changing `prev.data` because `data` is readonly.\n\t\t\tnormalized.splice( i - 1, 2, new Text( prev.data + node.data, prev.getAttributes() ) );\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn normalized;\n}\n\n// Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and\n// merges them into one node if they have same attributes.\n//\n// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.\n//\n// @private\n// @param {module:engine/model/element~Element} element Parent element of nodes to merge.\n// @param {Number} index Index between nodes to merge.\nfunction _mergeNodesAtIndex( element, index ) {\n\tconst nodeBefore = element.getChild( index - 1 );\n\tconst nodeAfter = element.getChild( index );\n\n\t// Check if both of those nodes are text objects with same attributes.\n\tif ( nodeBefore && nodeAfter && nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) && _haveSameAttributes( nodeBefore, nodeAfter ) ) {\n\t\t// Append text of text node after index to the before one.\n\t\tconst mergedNode = new Text( nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes() );\n\n\t\t// Remove separate text nodes.\n\t\telement._removeChildren( index - 1, 2 );\n\n\t\t// Insert merged text node.\n\t\telement._insertChild( index - 1, mergedNode );\n\t}\n}\n\n// Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them\n// containing a part of original text node.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position at which node should be split.\nfunction _splitNodeAtPosition( position ) {\n\tconst textNode = position.textNode;\n\tconst element = position.parent;\n\n\tif ( textNode ) {\n\t\tconst offsetDiff = position.offset - textNode.startOffset;\n\t\tconst index = textNode.index;\n\n\t\telement._removeChildren( index, 1 );\n\n\t\tconst firstPart = new Text( textNode.data.substr( 0, offsetDiff ), textNode.getAttributes() );\n\t\tconst secondPart = new Text( textNode.data.substr( offsetDiff ), textNode.getAttributes() );\n\n\t\telement._insertChild( index, [ firstPart, secondPart ] );\n\t}\n}\n\n// Checks whether two given nodes have same attributes.\n//\n// @private\n// @param {module:engine/model/node~Node} nodeA Node to check.\n// @param {module:engine/model/node~Node} nodeB Node to check.\n// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.\nfunction _haveSameAttributes( nodeA, nodeB ) {\n\tconst iteratorA = nodeA.getAttributes();\n\tconst iteratorB = nodeB.getAttributes();\n\n\tfor ( const attr of iteratorA ) {\n\t\tif ( attr[ 1 ] !== nodeB.getAttribute( attr[ 0 ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\titeratorB.next();\n\t}\n\n\treturn iteratorB.next().done;\n}\n\n/**\n * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.\n *\n * Non-arrays are normalized as follows:\n * * {@link module:engine/model/node~Node Node} is left as is,\n * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},\n * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,\n * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's\n * * children.\n *\n * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in\n * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be\n * merged if they have same attributes.\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|\n * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}\n * module:engine/model/node~NodeSet\n */\n"]}]}