{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\writer.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\writer.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5hbmNob3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL3dyaXRlcgogKi8KaW1wb3J0IEF0dHJpYnV0ZU9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9hdHRyaWJ1dGVvcGVyYXRpb24nOwppbXBvcnQgRGV0YWNoT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL2RldGFjaG9wZXJhdGlvbic7CmltcG9ydCBJbnNlcnRPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24vaW5zZXJ0b3BlcmF0aW9uJzsKaW1wb3J0IE1hcmtlck9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9tYXJrZXJvcGVyYXRpb24nOwppbXBvcnQgTW92ZU9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9uJzsKaW1wb3J0IFJlbmFtZU9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9yZW5hbWVvcGVyYXRpb24nOwppbXBvcnQgUm9vdEF0dHJpYnV0ZU9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbi9yb290YXR0cmlidXRlb3BlcmF0aW9uJzsKaW1wb3J0IFNwbGl0T3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL3NwbGl0b3BlcmF0aW9uJzsKaW1wb3J0IE1lcmdlT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uL21lcmdlb3BlcmF0aW9uJzsKaW1wb3J0IERvY3VtZW50RnJhZ21lbnQgZnJvbSAnLi9kb2N1bWVudGZyYWdtZW50JzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IFJvb3RFbGVtZW50IGZyb20gJy4vcm9vdGVsZW1lbnQnOwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBSYW5nZSBmcm9tICcuL3JhbmdlLmpzJzsKaW1wb3J0IERvY3VtZW50U2VsZWN0aW9uIGZyb20gJy4vZG9jdW1lbnRzZWxlY3Rpb24nOwppbXBvcnQgdG9NYXAgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvdG9tYXAnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKLyoqCiAqIFRoZSBtb2RlbCBjYW4gb25seSBiZSBtb2RpZmllZCBieSB1c2luZyB0aGUgd3JpdGVyLiBJdCBzaG91bGQgYmUgdXNlZCB3aGVuZXZlciB5b3Ugd2FudCB0byBjcmVhdGUgYSBub2RlLCBtb2RpZnkKICogY2hpbGQgbm9kZXMsIGF0dHJpYnV0ZXMgb3IgdGV4dCwgc2V0IHRoZSBzZWxlY3Rpb24ncyBwb3NpdGlvbiBhbmQgaXRzIGF0dHJpYnV0ZXMuCiAqCiAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgd3JpdGVyIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2UgYGNoYW5nZSgpYH0gb3IKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZSBgZW5xdWV1ZUNoYW5nZSgpYH0uCiAqCiAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAqCQl9ICk7CiAqCiAqIE5vdGUgdGhhdCB0aGUgd3JpdGVyIHNob3VsZCBuZXZlciBiZSBzdG9yZWQgYW5kIHVzZWQgb3V0c2lkZSBvZiB0aGUgYGNoYW5nZSgpYCBhbmQKICogYGVucXVldWVDaGFuZ2UoKWAgYmxvY2tzLgogKgogKiBOb3RlIHRoYXQgd3JpdGVyJ3MgbWV0aG9kcyBkbyBub3QgY2hlY2sgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9LiBJdCBpcyBwb3NzaWJsZQogKiB0byBjcmVhdGUgaW5jb3JyZWN0IG1vZGVsIHN0cnVjdHVyZXMgYnkgdXNpbmcgdGhlIHdyaXRlci4gUmVhZCBtb3JlIGFib3V0IGluCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hI3doby1jaGVja3MtdGhlLXNjaGVtYSAiV2hvIGNoZWNrcyB0aGUgc2NoZW1hPyJ9LgogKgogKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlCiAqLwoKdmFyIFdyaXRlciA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSB3cml0ZXIgaW5zdGFuY2UuCiAgICoKICAgKiAqKk5vdGU6KiogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIHVzZSBpdCBkaXJlY3RseS4gVXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZSBgTW9kZWwjY2hhbmdlKClgfSBvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2UgYE1vZGVsI2VucXVldWVDaGFuZ2UoKWB9IGluc3RlYWQuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gYmF0Y2gKICAgKi8KICBmdW5jdGlvbiBXcml0ZXIobW9kZWwsIGJhdGNoKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV3JpdGVyKTsKCiAgICAvKioKICAgICAqIEluc3RhbmNlIG9mIHRoZSBtb2RlbCBvbiB3aGljaCB0aGlzIHdyaXRlciBvcGVyYXRlcy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfQogICAgICovCiAgICB0aGlzLm1vZGVsID0gbW9kZWw7CiAgICAvKioKICAgICAqIFRoZSBiYXRjaCB0byB3aGljaCB0aGlzIHdyaXRlciB3aWxsIGFkZCBjaGFuZ2VzLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvYmF0Y2h+QmF0Y2h9CiAgICAgKi8KCiAgICB0aGlzLmJhdGNoID0gYmF0Y2g7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZX0uCiAgICoKICAgKgkJd3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICoJCXdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJywgeyBib2xkOiB0cnVlIH0gKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRleHQgZGF0YS4KICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIFRleHQgYXR0cmlidXRlcy4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR9IENyZWF0ZWQgdGV4dCBub2RlLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFdyaXRlciwgW3sKICAgIGtleTogImNyZWF0ZVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRleHQoZGF0YSwgYXR0cmlidXRlcykgewogICAgICByZXR1cm4gbmV3IFRleHQoZGF0YSwgYXR0cmlidXRlcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9LgogICAgICoKICAgICAqCQl3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgICAqCQl3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcsIHsgYWxpZ25tZW50OiAnY2VudGVyJyB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgICByZXR1cm4gbmV3IEVsZW1lbnQobmFtZSwgYXR0cmlidXRlcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IGRvY3VtZW50IGZyYWdtZW50fS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IENyZWF0ZWQgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIHsKICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KCk7CiAgICB9CiAgICAvKioKICAgICAqIEluc2VydHMgaXRlbSBvbiBnaXZlbiBwb3NpdGlvbi4KICAgICAqCiAgICAgKgkJY29uc3QgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJd3JpdGVyLmluc2VydCggcGFyYWdyYXBoLCBwb3NpdGlvbiApOwogICAgICoKICAgICAqIEluc3RlYWQgb2YgdXNpbmcgcG9zaXRpb24geW91IGNhbiB1c2UgcGFyZW50IGFuZCBvZmZzZXQ6CiAgICAgKgogICAgICoJCWNvbnN0IHRleHQgPSB3cml0ZXIuY3JlYXRlVGV4dCggJ2ZvbycgKTsKICAgICAqCQl3cml0ZXIuaW5zZXJ0KCB0ZXh0LCBwYXJhZ3JhcGgsIDUgKTsKICAgICAqCiAgICAgKiBZb3UgY2FuIGFsc28gdXNlIGBlbmRgIGluc3RlYWQgb2YgdGhlIG9mZnNldCB0byBpbnNlcnQgYXQgdGhlIGVuZDoKICAgICAqCiAgICAgKgkJY29uc3QgdGV4dCA9IHdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAgICoJCXdyaXRlci5pbnNlcnQoIHRleHQsIHBhcmFncmFwaCwgJ2VuZCcgKTsKICAgICAqCiAgICAgKiBPciBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyIGFub3RoZXIgZWxlbWVudDoKICAgICAqCiAgICAgKgkJY29uc3QgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJd3JpdGVyLmluc2VydCggcGFyYWdyYXBoLCBhbm90aGVyUGFyYWdyYXBoLCAnYWZ0ZXInICk7CiAgICAgKgogICAgICogVGhlc2UgcGFyYW1ldGVycyB3b3JrcyB0aGUgc2FtZSB3YXkgYXMge0BsaW5rICNjcmVhdGVQb3NpdGlvbkF0IGB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCgpYH0uCiAgICAgKgogICAgICogTm90ZSB0aGF0IGlmIHRoZSBpdGVtIGFscmVhZHkgaGFzIHBhcmVudCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgcHJldmlvdXMgcGFyZW50LgogICAgICoKICAgICAqIE5vdGUgdGhhdCB5b3UgY2Fubm90IHJlLWluc2VydCBhIG5vZGUgZnJvbSBhIGRvY3VtZW50IHRvIGEgZGlmZmVyZW50IGRvY3VtZW50IG9yIGEgZG9jdW1lbnQgZnJhZ21lbnQuIEluIHRoaXMgY2FzZSwKICAgICAqIGBtb2RlbC13cml0ZXItaW5zZXJ0LWZvcmJpZGRlbi1tb3ZlYCBpcyB0aHJvd24uCiAgICAgKgogICAgICogSWYgeW91IHdhbnQgdG8gbW92ZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0gaW5zdGVhZCBvZiBhbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI21vdmUgYFdyaXRlciNtb3ZlKClgfS4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogRm9yIGEgcGFzdGUtbGlrZSBjb250ZW50IGluc2VydGlvbiBtZWNoYW5pc20gc2VlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNpbnNlcnRDb250ZW50IGBtb2RlbC5pbnNlcnRDb250ZW50KClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBpdGVtIEl0ZW0gb3IgZG9jdW1lbnQKICAgICAqIGZyYWdtZW50IHRvIGluc2VydC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdlbmQnfCdiZWZvcmUnfCdhZnRlcid9IFtvZmZzZXRdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogc2Vjb25kIHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpbnNlcnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChpdGVtLCBpdGVtT3JQb3NpdGlvbikgewogICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwOwoKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0ICYmIGl0ZW0uZGF0YSA9PSAnJykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIHBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOyAvLyBJZiBpdGVtIGhhcyBhIHBhcmVudCBhbHJlYWR5LgoKCiAgICAgIGlmIChpdGVtLnBhcmVudCkgewogICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXRlbSBpcyBnb2luZyB0byBiZSBpbnNlcnRlZCB3aXRoaW4gdGhlIHNhbWUgZG9jdW1lbnQuCiAgICAgICAgaWYgKGlzU2FtZVRyZWUoaXRlbS5yb290LCBwb3NpdGlvbi5yb290KSkgewogICAgICAgICAgLy8gSWYgaXQncyB3ZSBqdXN0IG5lZWQgdG8gbW92ZSBpdC4KICAgICAgICAgIHRoaXMubW92ZShSYW5nZS5fY3JlYXRlT24oaXRlbSksIHBvc2l0aW9uKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9IC8vIElmIGl0IGlzbid0IHRoZSBzYW1lIHJvb3QuCiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGlmIChpdGVtLnJvb3QuZG9jdW1lbnQpIHsKICAgICAgICAgICAgICAvKioKICAgICAgICAgICAgICAgKiBDYW5ub3QgbW92ZSBhIG5vZGUgZnJvbSBhIGRvY3VtZW50IHRvIGEgZGlmZmVyZW50IHRyZWUuCiAgICAgICAgICAgICAgICogSXQgaXMgZm9yYmlkZGVuIHRvIG1vdmUgYSBub2RlIHRoYXQgd2FzIGFscmVhZHkgaW4gYSBkb2N1bWVudCBvdXRzaWRlIG9mIGl0LgogICAgICAgICAgICAgICAqCiAgICAgICAgICAgICAgICogQGVycm9yIG1vZGVsLXdyaXRlci1pbnNlcnQtZm9yYmlkZGVuLW1vdmUKICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtd3JpdGVyLWluc2VydC1mb3JiaWRkZW4tbW92ZTogJyArICdDYW5ub3QgbW92ZSBhIG5vZGUgZnJvbSBhIGRvY3VtZW50IHRvIGEgZGlmZmVyZW50IHRyZWUuICcgKyAnSXQgaXMgZm9yYmlkZGVuIHRvIG1vdmUgYSBub2RlIHRoYXQgd2FzIGFscmVhZHkgaW4gYSBkb2N1bWVudCBvdXRzaWRlIG9mIGl0LicsIHRoaXMpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIE1vdmUgYmV0d2VlbiB0d28gZGlmZmVyZW50IGRvY3VtZW50IGZyYWdtZW50cyBvciBmcm9tIGRvY3VtZW50IGZyYWdtZW50IHRvIGEgZG9jdW1lbnQgaXMgcG9zc2libGUuCiAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCByZW1vdmUgdGhlIGl0ZW0gZnJvbSBpdCdzIG9yaWdpbmFsIHBhcmVudC4KICAgICAgICAgICAgICB0aGlzLnJlbW92ZShpdGVtKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgdmVyc2lvbiA9IHBvc2l0aW9uLnJvb3QuZG9jdW1lbnQgPyBwb3NpdGlvbi5yb290LmRvY3VtZW50LnZlcnNpb24gOiBudWxsOwogICAgICB2YXIgaW5zZXJ0ID0gbmV3IEluc2VydE9wZXJhdGlvbihwb3NpdGlvbiwgaXRlbSwgdmVyc2lvbik7CgogICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHQpIHsKICAgICAgICBpbnNlcnQuc2hvdWxkUmVjZWl2ZUF0dHJpYnV0ZXMgPSB0cnVlOwogICAgICB9CgogICAgICB0aGlzLmJhdGNoLmFkZE9wZXJhdGlvbihpbnNlcnQpOwogICAgICB0aGlzLm1vZGVsLmFwcGx5T3BlcmF0aW9uKGluc2VydCk7IC8vIFdoZW4gZWxlbWVudCBpcyBhIERvY3VtZW50RnJhZ21lbnQgd2UgbmVlZCB0byBtb3ZlIGl0cyBtYXJrZXJzIHRvIERvY3VtZW50I21hcmtlcnMuCgogICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gaXRlbS5tYXJrZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkgewogICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksCiAgICAgICAgICAgICAgICBtYXJrZXJOYW1lID0gX3N0ZXAkdmFsdWVbMF0sCiAgICAgICAgICAgICAgICBtYXJrZXJSYW5nZSA9IF9zdGVwJHZhbHVlWzFdOwoKICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtaWdyYXRlIG1hcmtlciByYW5nZSBmcm9tIERvY3VtZW50RnJhZ21lbnQgdG8gRG9jdW1lbnQuCiAgICAgICAgICAgIHZhciByYW5nZVJvb3RQb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBdChtYXJrZXJSYW5nZS5yb290LCAwKTsKCiAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShtYXJrZXJSYW5nZS5zdGFydC5fZ2V0Q29tYmluZWQocmFuZ2VSb290UG9zaXRpb24sIHBvc2l0aW9uKSwgbWFya2VyUmFuZ2UuZW5kLl9nZXRDb21iaW5lZChyYW5nZVJvb3RQb3NpdGlvbiwgcG9zaXRpb24pKTsKICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7CiAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLAogICAgICAgICAgICAgIHVzaW5nT3BlcmF0aW9uOiB0cnVlLAogICAgICAgICAgICAgIGFmZmVjdHNEYXRhOiB0cnVlCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5tYXJrZXJzLmhhcyhtYXJrZXJOYW1lKSkgewogICAgICAgICAgICAgIHRoaXMudXBkYXRlTWFya2VyKG1hcmtlck5hbWUsIG9wdGlvbnMpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyKG1hcmtlck5hbWUsIG9wdGlvbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhbmQgaW5zZXJ0cyB0ZXh0IG9uIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuIG9wdGlvbmFsbHkgc2V0IHRleHQgYXR0cmlidXRlczoKICAgICAqCiAgICAgKgkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwb3NpdGlvbiApOwogICAgICoJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgeyBib2xkOiB0cnVlIH0sIHBvc2l0aW9uICk7CiAgICAgKgogICAgICogSW5zdGVhZCBvZiB1c2luZyBwb3NpdGlvbiB5b3UgY2FuIHVzZSBwYXJlbnQgYW5kIG9mZnNldCBvciBkZWZpbmUgdGhhdCB0ZXh0IHNob3VsZCBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kCiAgICAgKiBvciBiZWZvcmUgb3IgYWZ0ZXIgb3RoZXIgbm9kZToKICAgICAqCiAgICAgKgkJLy8gSW5zZXJ0cyAnZm9vJyBpbiBwYXJhZ3JhcGgsIGF0IG9mZnNldCA1OgogICAgICoJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgcGFyYWdyYXBoLCA1ICk7CiAgICAgKgkJLy8gSW5zZXJ0cyAnZm9vJyBhdCB0aGUgZW5kIG9mIGEgcGFyYWdyYXBoOgogICAgICoJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgcGFyYWdyYXBoLCAnZW5kJyApOwogICAgICoJCS8vIEluc2VydHMgJ2ZvbycgYWZ0ZXIgYW4gaW1hZ2U6CiAgICAgKgkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBpbWFnZSwgJ2FmdGVyJyApOwogICAgICoKICAgICAqIFRoZXNlIHBhcmFtZXRlcnMgd29yayBpbiB0aGUgc2FtZSB3YXkgYXMge0BsaW5rICNjcmVhdGVQb3NpdGlvbkF0IGB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCgpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGV4dCBkYXRhLgogICAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBUZXh0IGF0dHJpYnV0ZXMuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIHRoaXJkIHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpbnNlcnRUZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUZXh0KHRleHQsIGF0dHJpYnV0ZXMsIGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpIHsKICAgICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8IGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBQb3NpdGlvbikgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlVGV4dCh0ZXh0KSwgYXR0cmlidXRlcywgaXRlbU9yUG9zaXRpb24pOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuY3JlYXRlVGV4dCh0ZXh0LCBhdHRyaWJ1dGVzKSwgaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhbmQgaW5zZXJ0cyBlbGVtZW50IG9uIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuIG9wdGlvbmFsbHkgc2V0IGF0dHJpYnV0ZXM6CiAgICAgKgogICAgICoJCXdyaXRlci5pbnNlcnRFbGVtZW50KCAncGFyYWdyYXBoJywgcG9zaXRpb24gKTsKICAgICAqCQl3cml0ZXIuaW5zZXJ0RWxlbWVudCggJ3BhcmFncmFwaCcsIHsgYWxpZ25tZW50OiAnY2VudGVyJyB9LCBwb3NpdGlvbiApOwogICAgICoKICAgICAqIEluc3RlYWQgb2YgdXNpbmcgcG9zaXRpb24geW91IGNhbiB1c2UgcGFyZW50IGFuZCBvZmZzZXQgb3IgZGVmaW5lIHRoYXQgdGV4dCBzaG91bGQgYmUgaW5zZXJ0ZWQgYXQgdGhlIGVuZAogICAgICogb3IgYmVmb3JlIG9yIGFmdGVyIG90aGVyIG5vZGU6CiAgICAgKgogICAgICoJCS8vIEluc2VydHMgcGFyYWdyYXBoIGluIHRoZSByb290IGF0IG9mZnNldCA1OgogICAgICoJCXdyaXRlci5pbnNlcnRFbGVtZW50KCAncGFyYWdyYXBoJywgcm9vdCwgNSApOwogICAgICoJCS8vIEluc2VydHMgcGFyYWdyYXBoIGF0IHRoZSBlbmQgb2YgYSBibG9ja3F1b3RlOgogICAgICoJCXdyaXRlci5pbnNlcnRFbGVtZW50KCAncGFyYWdyYXBoJywgYmxvY2txdW90ZSwgJ2VuZCcgKTsKICAgICAqCQkvLyBJbnNlcnRzIGFmdGVyIGFuIGltYWdlOgogICAgICoJCXdyaXRlci5pbnNlcnRFbGVtZW50KCAncGFyYWdyYXBoJywgaW1hZ2UsICdhZnRlcicgKTsKICAgICAqCiAgICAgKiBUaGVzZSBwYXJhbWV0ZXJzIHdvcmtzIHRoZSBzYW1lIHdheSBhcyB7QGxpbmsgI2NyZWF0ZVBvc2l0aW9uQXQgYHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBFbGVtZW50cyBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiB0aGlyZCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaW5zZXJ0RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0RWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRWxlbWVudCB8fCBhdHRyaWJ1dGVzIGluc3RhbmNlb2YgUG9zaXRpb24pIHsKICAgICAgICB0aGlzLmluc2VydCh0aGlzLmNyZWF0ZUVsZW1lbnQobmFtZSksIGF0dHJpYnV0ZXMsIGl0ZW1PclBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmluc2VydCh0aGlzLmNyZWF0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcyksIGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEluc2VydHMgaXRlbSBhdCB0aGUgZW5kIG9mIHRoZSBnaXZlbiBwYXJlbnQuCiAgICAgKgogICAgICoJCWNvbnN0IHBhcmFncmFwaCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAncGFyYWdyYXBoJyApOwogICAgICoJCXdyaXRlci5hcHBlbmQoIHBhcmFncmFwaCwgcm9vdCApOwogICAgICoKICAgICAqIE5vdGUgdGhhdCBpZiB0aGUgaXRlbSBhbHJlYWR5IGhhcyBwYXJlbnQgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHByZXZpb3VzIHBhcmVudC4KICAgICAqCiAgICAgKiBJZiB5b3Ugd2FudCB0byBtb3ZlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSBpbnN0ZWFkIG9mIGFuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjbW92ZSBgV3JpdGVyI21vdmUoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiBpdGVtIEl0ZW0gb3IgZG9jdW1lbnQgZnJhZ21lbnQgdG8gaW5zZXJ0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gcGFyZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXBwZW5kIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoaXRlbSwgcGFyZW50KSB7CiAgICAgIHRoaXMuaW5zZXJ0KGl0ZW0sIHBhcmVudCwgJ2VuZCcpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIHRleHQgbm9kZSBhbmQgaW5zZXJ0cyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQuIFlvdSBjYW4gb3B0aW9uYWxseSBzZXQgdGV4dCBhdHRyaWJ1dGVzOgogICAgICoKICAgICAqCQl3cml0ZXIuYXBwZW5kVGV4dCggJ2ZvbycsIHBhcmFncmFwaCApOwogICAgICoJCXdyaXRlci5hcHBlbmRUZXh0KCAnZm9vJywgeyBib2xkOiB0cnVlIH0sIHBhcmFncmFwaCApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgZGF0YS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gVGV4dCBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gcGFyZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXBwZW5kVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVGV4dCh0ZXh0LCBhdHRyaWJ1dGVzLCBwYXJlbnQpIHsKICAgICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8IGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVUZXh0KHRleHQpLCBhdHRyaWJ1dGVzLCAnZW5kJyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVUZXh0KHRleHQsIGF0dHJpYnV0ZXMpLCBwYXJlbnQsICdlbmQnKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGVsZW1lbnQgYW5kIGluc2VydHMgaXQgYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50LiBZb3UgY2FuIG9wdGlvbmFsbHkgc2V0IGF0dHJpYnV0ZXM6CiAgICAgKgogICAgICoJCXdyaXRlci5hcHBlbmRFbGVtZW50KCAncGFyYWdyYXBoJywgcm9vdCApOwogICAgICoJCXdyaXRlci5hcHBlbmRFbGVtZW50KCAncGFyYWdyYXBoJywgeyBhbGlnbm1lbnQ6ICdjZW50ZXInIH0sIHJvb3QgKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBFbGVtZW50cyBhdHRyaWJ1dGVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gcGFyZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXBwZW5kRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBwYXJlbnQpIHsKICAgICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8IGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVFbGVtZW50KG5hbWUpLCBhdHRyaWJ1dGVzLCAnZW5kJyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5pbnNlcnQodGhpcy5jcmVhdGVFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpLCBwYXJlbnQsICdlbmQnKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgb24gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0KICAgICAqIG9yIG9uIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2V9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgQXR0cmlidXRlIGtleS4KICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQXR0cmlidXRlIG5ldyB2YWx1ZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gaXRlbU9yUmFuZ2UKICAgICAqIE1vZGVsIGl0ZW0gb3IgcmFuZ2Ugb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBpdGVtT3JSYW5nZSkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoaXRlbU9yUmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkgewogICAgICAgIHZhciByYW5nZXMgPSBpdGVtT3JSYW5nZS5nZXRNaW5pbWFsRmxhdFJhbmdlcygpOwogICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcmFuZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciByYW5nZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgc2V0QXR0cmlidXRlT25SYW5nZSh0aGlzLCBrZXksIHZhbHVlLCByYW5nZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHNldEF0dHJpYnV0ZU9uSXRlbSh0aGlzLCBrZXksIHZhbHVlLCBpdGVtT3JSYW5nZSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB2YWx1ZXMgb2YgYXR0cmlidXRlcyBvbiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfQogICAgICogb3Igb24gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICoJCXdyaXRlci5zZXRBdHRyaWJ1dGVzKCB7CiAgICAgKgkJCWJvbGQ6IHRydWUsCiAgICAgKgkJCWl0YWxpYzogdHJ1ZQogICAgICoJCX0sIHJhbmdlICk7CiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgQXR0cmlidXRlcyBrZXlzIGFuZCB2YWx1ZXMuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGl0ZW1PclJhbmdlCiAgICAgKiBNb2RlbCBpdGVtIG9yIHJhbmdlIG9uIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldEF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaXRlbU9yUmFuZ2UpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdG9NYXAoYXR0cmlidXRlcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHsKICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMudmFsdWUsIDIpLAogICAgICAgICAgICAgIGtleSA9IF9zdGVwMyR2YWx1ZVswXSwKICAgICAgICAgICAgICB2YWwgPSBfc3RlcDMkdmFsdWVbMV07CgogICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwsIGl0ZW1PclJhbmdlKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIHdpdGggZ2l2ZW4ga2V5IGZyb20gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0KICAgICAqIG9yIGZyb20gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBBdHRyaWJ1dGUga2V5LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtT3JSYW5nZQogICAgICogTW9kZWwgaXRlbSBvciByYW5nZSBmcm9tIHdoaWNoIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZUF0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGtleSwgaXRlbU9yUmFuZ2UpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgaWYgKGl0ZW1PclJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHsKICAgICAgICB2YXIgcmFuZ2VzID0gaXRlbU9yUmFuZ2UuZ2V0TWluaW1hbEZsYXRSYW5nZXMoKTsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHJhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkgewogICAgICAgICAgICB2YXIgcmFuZ2UgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICAgIHNldEF0dHJpYnV0ZU9uUmFuZ2UodGhpcywga2V5LCBudWxsLCByYW5nZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHNldEF0dHJpYnV0ZU9uSXRlbSh0aGlzLCBrZXksIG51bGwsIGl0ZW1PclJhbmdlKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBhdHRyaWJ1dGVzIGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSByYW5nZSBvciBmcm9tIHRoZSBnaXZlbiBpdGVtLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gaXRlbU9yUmFuZ2UKICAgICAqIE1vZGVsIGl0ZW0gb3IgcmFuZ2UgZnJvbSB3aGljaCBhbGwgYXR0cmlidXRlcyB3aWxsIGJlIHJlbW92ZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2xlYXJBdHRyaWJ1dGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMoaXRlbU9yUmFuZ2UpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHZhciByZW1vdmVBdHRyaWJ1dGVzRnJvbUl0ZW0gPSBmdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGVzRnJvbUl0ZW0oaXRlbSkgewogICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gaXRlbS5nZXRBdHRyaWJ1dGVLZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICAgIF90aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIGl0ZW0pOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfTsKCiAgICAgIGlmICghKGl0ZW1PclJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7CiAgICAgICAgcmVtb3ZlQXR0cmlidXRlc0Zyb21JdGVtKGl0ZW1PclJhbmdlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IGl0ZW1PclJhbmdlLmdldEl0ZW1zKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDYudmFsdWU7CiAgICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZXNGcm9tSXRlbShpdGVtKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHsKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogTW92ZXMgYWxsIGl0ZW1zIGluIHRoZSBzb3VyY2UgcmFuZ2UgdG8gdGhlIHRhcmdldCBwb3NpdGlvbi4KICAgICAqCiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCB0YXJnZXRQb3NpdGlvbiApOwogICAgICoKICAgICAqIEluc3RlYWQgb2YgdGhlIHRhcmdldCBwb3NpdGlvbiB5b3UgY2FuIHVzZSBwYXJlbnQgYW5kIG9mZnNldCBvciBkZWZpbmUgdGhhdCByYW5nZSBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGVuZAogICAgICogb3IgYmVmb3JlIG9yIGFmdGVyIGNob3NlbiBpdGVtOgogICAgICoKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIHRoZSBwYXJhZ3JhcGggYXQgb2Zmc2V0IDU6CiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCBwYXJhZ3JhcGgsIDUgKTsKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIHRoZSBlbmQgb2YgYSBibG9ja3F1b3RlOgogICAgICoJCXdyaXRlci5tb3ZlKCBzb3VyY2VSYW5nZSwgYmxvY2txdW90ZSwgJ2VuZCcgKTsKICAgICAqCQkvLyBNb3ZlcyBhbGwgaXRlbXMgaW4gdGhlIHJhbmdlIHRvIGEgcG9zaXRpb24gYWZ0ZXIgYW4gaW1hZ2U6CiAgICAgKgkJd3JpdGVyLm1vdmUoIHNvdXJjZVJhbmdlLCBpbWFnZSwgJ2FmdGVyJyApOwogICAgICoKICAgICAqIFRoZXNlIHBhcmFtZXRlcnMgd29ya3MgdGhlIHNhbWUgd2F5IGFzIHtAbGluayAjY3JlYXRlUG9zaXRpb25BdCBgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoKWB9LgogICAgICoKICAgICAqIE5vdGUgdGhhdCBpdGVtcyBjYW4gYmUgbW92ZWQgb25seSB3aXRoaW4gdGhlIHNhbWUgdHJlZS4gSXQgbWVhbnMgdGhhdCB5b3UgY2FuIG1vdmUgaXRlbXMgd2l0aGluIHRoZSBzYW1lIHJvb3QKICAgICAqIChlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50KSBvciBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3Jvb3RzIGRvY3VtZW50cyByb290c30sCiAgICAgKiBidXQgeW91IGNhbiBub3QgbW92ZSBpdGVtcyBmcm9tIGRvY3VtZW50IGZyYWdtZW50IHRvIHRoZSBkb2N1bWVudCBvciBmcm9tIG9uZSBkZXRhY2hlZCBlbGVtZW50IHRvIGFub3RoZXIuIFVzZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnR9IGluIHN1Y2ggY2FzZXMuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBTb3VyY2UgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIHNlY29uZCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShyYW5nZSwgaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkgewogICAgICAgIC8qKgogICAgICAgICAqIEludmFsaWQgcmFuZ2UgdG8gbW92ZS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItbW92ZS1pbnZhbGlkLXJhbmdlCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tb3ZlLWludmFsaWQtcmFuZ2U6IEludmFsaWQgcmFuZ2UgdG8gbW92ZS4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCFyYW5nZS5pc0ZsYXQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBSYW5nZSB0byBtb3ZlIGlzIG5vdCBmbGF0LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1tb3ZlLXJhbmdlLW5vdC1mbGF0CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tb3ZlLXJhbmdlLW5vdC1mbGF0OiBSYW5nZSB0byBtb3ZlIGlzIG5vdCBmbGF0LicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgcG9zaXRpb24gPSBQb3NpdGlvbi5fY3JlYXRlQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7IC8vIERvIG5vdCBtb3ZlIGFueXRoaW5nIGlmIHRoZSBtb3ZlIHRhcmdldCBpcyBzYW1lIGFzIG1vdmVkIHJhbmdlIHN0YXJ0LgoKCiAgICAgIGlmIChwb3NpdGlvbi5pc0VxdWFsKHJhbmdlLnN0YXJ0KSkgewogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBJZiBwYXJ0IG9mIHRoZSBtYXJrZXIgaXMgcmVtb3ZlZCwgY3JlYXRlIGFkZGl0aW9uYWwgbWFya2VyIG9wZXJhdGlvbiBmb3IgdW5kbyBwdXJwb3Nlcy4KCgogICAgICB0aGlzLl9hZGRPcGVyYXRpb25Gb3JBZmZlY3RlZE1hcmtlcnMoJ21vdmUnLCByYW5nZSk7CgogICAgICBpZiAoIWlzU2FtZVRyZWUocmFuZ2Uucm9vdCwgcG9zaXRpb24ucm9vdCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBSYW5nZSBpcyBnb2luZyB0byBiZSBtb3ZlZCB3aXRoaW4gbm90IHRoZSBzYW1lIGRvY3VtZW50LiBQbGVhc2UgdXNlCiAgICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnQgaW5zZXJ0fSBpbnN0ZWFkLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1tb3ZlLWRpZmZlcmVudC1kb2N1bWVudAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItbW92ZS1kaWZmZXJlbnQtZG9jdW1lbnQ6IFJhbmdlIGlzIGdvaW5nIHRvIGJlIG1vdmVkIGJldHdlZW4gZGlmZmVyZW50IGRvY3VtZW50cy4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgdmFyIHZlcnNpb24gPSByYW5nZS5yb290LmRvY3VtZW50ID8gcmFuZ2Uucm9vdC5kb2N1bWVudC52ZXJzaW9uIDogbnVsbDsKICAgICAgdmFyIG9wZXJhdGlvbiA9IG5ldyBNb3ZlT3BlcmF0aW9uKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQub2Zmc2V0IC0gcmFuZ2Uuc3RhcnQub2Zmc2V0LCBwb3NpdGlvbiwgdmVyc2lvbik7CiAgICAgIHRoaXMuYmF0Y2guYWRkT3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgIHRoaXMubW9kZWwuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBnaXZlbiBtb2RlbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2V9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gaXRlbU9yUmFuZ2UgTW9kZWwgaXRlbSBvciByYW5nZSB0byByZW1vdmUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaXRlbU9yUmFuZ2UpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIHJhbmdlVG9SZW1vdmUgPSBpdGVtT3JSYW5nZSBpbnN0YW5jZW9mIFJhbmdlID8gaXRlbU9yUmFuZ2UgOiBSYW5nZS5fY3JlYXRlT24oaXRlbU9yUmFuZ2UpOwogICAgICB2YXIgcmFuZ2VzID0gcmFuZ2VUb1JlbW92ZS5nZXRNaW5pbWFsRmxhdFJhbmdlcygpLnJldmVyc2UoKTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I3ID0gcmFuZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgZmxhdCA9IF9zdGVwNy52YWx1ZTsKCiAgICAgICAgICAvLyBJZiBwYXJ0IG9mIHRoZSBtYXJrZXIgaXMgcmVtb3ZlZCwgY3JlYXRlIGFkZGl0aW9uYWwgbWFya2VyIG9wZXJhdGlvbiBmb3IgdW5kbyBwdXJwb3Nlcy4KICAgICAgICAgIHRoaXMuX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2VycygnbW92ZScsIGZsYXQpOwoKICAgICAgICAgIGFwcGx5UmVtb3ZlT3BlcmF0aW9uKGZsYXQuc3RhcnQsIGZsYXQuZW5kLm9mZnNldCAtIGZsYXQuc3RhcnQub2Zmc2V0LCB0aGlzLmJhdGNoLCB0aGlzLm1vZGVsKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I3ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjc7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIE1lcmdlcyB0d28gc2libGluZ3MgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqIE5vZGUgYmVmb3JlIGFuZCBhZnRlciB0aGUgcG9zaXRpb24gaGF2ZSB0byBiZSBhbiBlbGVtZW50LiBPdGhlcndpc2UgYHdyaXRlci1tZXJnZS1uby1lbGVtZW50LWJlZm9yZWAgb3IKICAgICAqIGB3cml0ZXItbWVyZ2Utbm8tZWxlbWVudC1hZnRlcmAgZXJyb3Igd2lsbCBiZSB0aHJvd24uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBiZXR3ZWVuIG1lcmdlZCBlbGVtZW50cy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJtZXJnZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UocG9zaXRpb24pIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICB2YXIgbm9kZUFmdGVyID0gcG9zaXRpb24ubm9kZUFmdGVyOyAvLyBJZiBwYXJ0IG9mIHRoZSBtYXJrZXIgaXMgcmVtb3ZlZCwgY3JlYXRlIGFkZGl0aW9uYWwgbWFya2VyIG9wZXJhdGlvbiBmb3IgdW5kbyBwdXJwb3Nlcy4KCiAgICAgIHRoaXMuX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2VycygnbWVyZ2UnLCBwb3NpdGlvbik7CgogICAgICBpZiAoIShub2RlQmVmb3JlIGluc3RhbmNlb2YgRWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBOb2RlIGJlZm9yZSBtZXJnZSBwb3NpdGlvbiBtdXN0IGJlIGFuIGVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLW1lcmdlLW5vLWVsZW1lbnQtYmVmb3JlCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tZXJnZS1uby1lbGVtZW50LWJlZm9yZTogTm9kZSBiZWZvcmUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LicsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoIShub2RlQWZ0ZXIgaW5zdGFuY2VvZiBFbGVtZW50KSkgewogICAgICAgIC8qKgogICAgICAgICAqIE5vZGUgYWZ0ZXIgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1tZXJnZS1uby1lbGVtZW50LWFmdGVyCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1tZXJnZS1uby1lbGVtZW50LWFmdGVyOiBOb2RlIGFmdGVyIG1lcmdlIHBvc2l0aW9uIG11c3QgYmUgYW4gZWxlbWVudC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCFwb3NpdGlvbi5yb290LmRvY3VtZW50KSB7CiAgICAgICAgdGhpcy5fbWVyZ2VEZXRhY2hlZChwb3NpdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fbWVyZ2UocG9zaXRpb24pOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkZyb21QYXRoIGBNb2RlbCNjcmVhdGVQb3NpdGlvbkZyb21QYXRoKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSByb290IFJvb3Qgb2YgdGhlIHBvc2l0aW9uLgogICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcGF0aCBQb3NpdGlvbiBwYXRoLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4KICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25Gcm9tUGF0aChyb290LCBwYXRoLCBzdGlja2luZXNzKSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgocm9vdCwgcGF0aCwgc3RpY2tpbmVzcyk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkF0IGBNb2RlbCNjcmVhdGVQb3NpdGlvbkF0KClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgICAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uQXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVQb3NpdGlvbkF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG9ydGN1dCBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUG9zaXRpb25BZnRlciBgTW9kZWwjY3JlYXRlUG9zaXRpb25BZnRlcigpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BZnRlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BZnRlcihpdGVtKSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIoaXRlbSk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkJlZm9yZSBgTW9kZWwjY3JlYXRlUG9zaXRpb25CZWZvcmUoKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0gSXRlbSBhZnRlciB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uQmVmb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbkJlZm9yZShpdGVtKSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBTaG9ydGN1dCBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUmFuZ2UgYE1vZGVsI2NyZWF0ZVJhbmdlKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBbZW5kXSBFbmQgcG9zaXRpb24uIElmIG5vdCBzZXQsIHJhbmdlIHdpbGwgYmUgY29sbGFwc2VkIGF0IGBzdGFydGAgcG9zaXRpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2Uoc3RhcnQsIGVuZCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogU2hvcnRjdXQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVJhbmdlSW4gYE1vZGVsI2NyZWF0ZVJhbmdlSW4oKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2VJbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2VJbihlbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZVJhbmdlSW4oZWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIFNob3J0Y3V0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVSYW5nZU9uIGBNb2RlbCNjcmVhdGVSYW5nZU9uKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgd2hpY2ggaXMgYSBwYXJlbnQgZm9yIHRoZSByYW5nZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhbmdlT24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlT24oZWxlbWVudCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVSYW5nZU9uKGVsZW1lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBTaG9ydGN1dCBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlU2VsZWN0aW9uIGBNb2RlbCNjcmVhdGVTZWxlY3Rpb24oKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlU2VsZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucykgewogICAgICByZXR1cm4gdGhpcy5tb2RlbC5jcmVhdGVTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIFBlcmZvcm1zIG1lcmdlIGFjdGlvbiBpbiBhIGRldGFjaGVkIHRyZWUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gYmV0d2VlbiBtZXJnZWQgZWxlbWVudHMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21lcmdlRGV0YWNoZWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZURldGFjaGVkKHBvc2l0aW9uKSB7CiAgICAgIHZhciBub2RlQmVmb3JlID0gcG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5vZGVBZnRlciA9IHBvc2l0aW9uLm5vZGVBZnRlcjsKICAgICAgdGhpcy5tb3ZlKFJhbmdlLl9jcmVhdGVJbihub2RlQWZ0ZXIpLCBQb3NpdGlvbi5fY3JlYXRlQXQobm9kZUJlZm9yZSwgJ2VuZCcpKTsKICAgICAgdGhpcy5yZW1vdmUobm9kZUFmdGVyKTsKICAgIH0KICAgIC8qKgogICAgICogUGVyZm9ybXMgbWVyZ2UgYWN0aW9uIGluIGEgbm9uLWRldGFjaGVkIHRyZWUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gYmV0d2VlbiBtZXJnZWQgZWxlbWVudHMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21lcmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVyZ2UocG9zaXRpb24pIHsKICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KHBvc2l0aW9uLm5vZGVCZWZvcmUsICdlbmQnKTsKCiAgICAgIHZhciBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBdChwb3NpdGlvbi5ub2RlQWZ0ZXIsIDApOwoKICAgICAgdmFyIGdyYXZleWFyZCA9IHBvc2l0aW9uLnJvb3QuZG9jdW1lbnQuZ3JhdmV5YXJkOwogICAgICB2YXIgZ3JhdmV5YXJkUG9zaXRpb24gPSBuZXcgUG9zaXRpb24oZ3JhdmV5YXJkLCBbMF0pOwogICAgICB2YXIgdmVyc2lvbiA9IHBvc2l0aW9uLnJvb3QuZG9jdW1lbnQudmVyc2lvbjsKICAgICAgdmFyIG1lcmdlID0gbmV3IE1lcmdlT3BlcmF0aW9uKHNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbi5ub2RlQWZ0ZXIubWF4T2Zmc2V0LCB0YXJnZXRQb3NpdGlvbiwgZ3JhdmV5YXJkUG9zaXRpb24sIHZlcnNpb24pOwogICAgICB0aGlzLmJhdGNoLmFkZE9wZXJhdGlvbihtZXJnZSk7CiAgICAgIHRoaXMubW9kZWwuYXBwbHlPcGVyYXRpb24obWVyZ2UpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW5hbWVzIHRoZSBnaXZlbiBlbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gcmVuYW1lLgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld05hbWUgTmV3IGVsZW1lbnQgbmFtZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZW5hbWUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmFtZShlbGVtZW50LCBuZXdOYW1lKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkgewogICAgICAgIC8qKgogICAgICAgICAqIFRyeWluZyB0byByZW5hbWUgYW4gb2JqZWN0IHdoaWNoIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci1yZW5hbWUtbm90LWVsZW1lbnQtaW5zdGFuY2UKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXJlbmFtZS1ub3QtZWxlbWVudC1pbnN0YW5jZTogVHJ5aW5nIHRvIHJlbmFtZSBhbiBvYmplY3Qgd2hpY2ggaXMgbm90IGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciB2ZXJzaW9uID0gZWxlbWVudC5yb290LmRvY3VtZW50ID8gZWxlbWVudC5yb290LmRvY3VtZW50LnZlcnNpb24gOiBudWxsOwogICAgICB2YXIgcmVuYW1lT3BlcmF0aW9uID0gbmV3IFJlbmFtZU9wZXJhdGlvbihQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGVsZW1lbnQpLCBlbGVtZW50Lm5hbWUsIG5ld05hbWUsIHZlcnNpb24pOwogICAgICB0aGlzLmJhdGNoLmFkZE9wZXJhdGlvbihyZW5hbWVPcGVyYXRpb24pOwogICAgICB0aGlzLm1vZGVsLmFwcGx5T3BlcmF0aW9uKHJlbmFtZU9wZXJhdGlvbik7CiAgICB9CiAgICAvKioKICAgICAqIFNwbGl0cyBlbGVtZW50cyBzdGFydGluZyBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgZ29pbmcgdG8gdGhlIHRvcCBvZiB0aGUgbW9kZWwgdHJlZSBhcyBsb25nIGFzIGdpdmVuCiAgICAgKiBgbGltaXRFbGVtZW50YCBpcyByZWFjaGVkLiBXaGVuIGBsaW1pdEVsZW1lbnRgIGlzIG5vdCBkZWZpbmVkIHRoZW4gb25seSB0aGUgcGFyZW50IG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB3aWxsIGJlIHNwbGl0LgogICAgICoKICAgICAqIFRoZSBlbGVtZW50IG5lZWRzIHRvIGhhdmUgYSBwYXJlbnQuIEl0IGNhbm5vdCBiZSBhIHJvb3QgZWxlbWVudCBub3IgYSBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqIFRoZSBgd3JpdGVyLXNwbGl0LWVsZW1lbnQtbm8tcGFyZW50YCBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgdHJ5IHRvIHNwbGl0IGFuIGVsZW1lbnQgd2l0aCBubyBwYXJlbnQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBvZiBzcGxpdC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IFtsaW1pdEVsZW1lbnRdIFN0b3Agc3BsaXR0aW5nIHdoZW4gdGhpcyBlbGVtZW50IHdpbGwgYmUgcmVhY2hlZC4KICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCBTcGxpdCByZXN1bHQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcmVzdWx0LnBvc2l0aW9uIFBvc2l0aW9uIGJldHdlZW4gc3BsaXQgZWxlbWVudHMuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmVzdWx0LnJhbmdlIFJhbmdlIHRoYXQgc3RhcnMgZnJvbSB0aGUgZW5kIG9mIHRoZSBmaXJzdCBzcGxpdCBlbGVtZW50IGFuZCBlbmRzCiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaXJzdCBjb3B5IGVsZW1lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic3BsaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KHBvc2l0aW9uLCBsaW1pdEVsZW1lbnQpIHsKICAgICAgdGhpcy5fYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSgpOwoKICAgICAgdmFyIHNwbGl0RWxlbWVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIGlmICghc3BsaXRFbGVtZW50LnBhcmVudCkgewogICAgICAgIC8qKgogICAgICAgICAqIEVsZW1lbnQgd2l0aCBubyBwYXJlbnQgY2FuIG5vdCBiZSBzcGxpdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItc3BsaXQtZWxlbWVudC1uby1wYXJlbnQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXNwbGl0LWVsZW1lbnQtbm8tcGFyZW50OiBFbGVtZW50IHdpdGggbm8gcGFyZW50IGNhbiBub3QgYmUgc3BsaXQuJywgdGhpcyk7CiAgICAgIH0gLy8gV2hlbiBsaW1pdCBlbGVtZW50IGlzIG5vdCBkZWZpbmVkIGxldHMgc2V0IHNwbGl0RWxlbWVudCBwYXJlbnQgYXMgbGltaXQuCgoKICAgICAgaWYgKCFsaW1pdEVsZW1lbnQpIHsKICAgICAgICBsaW1pdEVsZW1lbnQgPSBzcGxpdEVsZW1lbnQucGFyZW50OwogICAgICB9CgogICAgICBpZiAoIXBvc2l0aW9uLnBhcmVudC5nZXRBbmNlc3RvcnMoewogICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgIH0pLmluY2x1ZGVzKGxpbWl0RWxlbWVudCkpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXNwbGl0LWludmFsaWQtbGltaXQtZWxlbWVudDogTGltaXQgZWxlbWVudCBpcyBub3QgYSBwb3NpdGlvbiBhbmNlc3Rvci4nLCB0aGlzKTsKICAgICAgfSAvLyBXZSBuZWVkIHRvIGNhY2hlIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgcmVzdWx0IG9mIHRoZSBmaXJzdCBzcGxpdCBiZWNhdXNlCiAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgcmFuZ2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBmaXJzdCBzcGxpdCBlbGVtZW50IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlCiAgICAgIC8vIGZpcnN0IGNvcHkgZWxlbWVudC4gVGhpcyBzaG91bGQgYmUgaGFuZGxlZCBieSBMaXZlUmFuZ2UgYnV0IGl0IGRvZXNuJ3Qgd29yayBvbiBkZXRhY2hlZCBub2Rlcy4KCgogICAgICB2YXIgZmlyc3RTcGxpdEVsZW1lbnQsIGZpcnN0Q29weUVsZW1lbnQ7CgogICAgICBkbyB7CiAgICAgICAgdmFyIHZlcnNpb24gPSBzcGxpdEVsZW1lbnQucm9vdC5kb2N1bWVudCA/IHNwbGl0RWxlbWVudC5yb290LmRvY3VtZW50LnZlcnNpb24gOiBudWxsOwogICAgICAgIHZhciBob3dNYW55ID0gc3BsaXRFbGVtZW50Lm1heE9mZnNldCAtIHBvc2l0aW9uLm9mZnNldDsKICAgICAgICB2YXIgc3BsaXQgPSBuZXcgU3BsaXRPcGVyYXRpb24ocG9zaXRpb24sIGhvd01hbnksIG51bGwsIHZlcnNpb24pOwogICAgICAgIHRoaXMuYmF0Y2guYWRkT3BlcmF0aW9uKHNwbGl0KTsKICAgICAgICB0aGlzLm1vZGVsLmFwcGx5T3BlcmF0aW9uKHNwbGl0KTsgLy8gQ2FjaGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBzcGxpdC4KCiAgICAgICAgaWYgKCFmaXJzdFNwbGl0RWxlbWVudCAmJiAhZmlyc3RDb3B5RWxlbWVudCkgewogICAgICAgICAgZmlyc3RTcGxpdEVsZW1lbnQgPSBzcGxpdEVsZW1lbnQ7CiAgICAgICAgICBmaXJzdENvcHlFbGVtZW50ID0gcG9zaXRpb24ucGFyZW50Lm5leHRTaWJsaW5nOwogICAgICAgIH0KCiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIocG9zaXRpb24ucGFyZW50KTsKICAgICAgICBzcGxpdEVsZW1lbnQgPSBwb3NpdGlvbi5wYXJlbnQ7CiAgICAgIH0gd2hpbGUgKHNwbGl0RWxlbWVudCAhPT0gbGltaXRFbGVtZW50KTsKCiAgICAgIHJldHVybiB7CiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLAogICAgICAgIHJhbmdlOiBuZXcgUmFuZ2UoUG9zaXRpb24uX2NyZWF0ZUF0KGZpcnN0U3BsaXRFbGVtZW50LCAnZW5kJyksIFBvc2l0aW9uLl9jcmVhdGVBdChmaXJzdENvcHlFbGVtZW50LCAwKSkKICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogV3JhcHMgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGVsZW1lbnQgb3Igd2l0aCBhIG5ldyBlbGVtZW50IChpZiBhIHN0cmluZyB3YXMgcGFzc2VkKS4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogcmFuZ2UgdG8gd3JhcCBzaG91bGQgYmUgYSAiZmxhdCByYW5nZSIgKHNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNpc0ZsYXQgYFJhbmdlI2lzRmxhdGB9KS4KICAgICAqIElmIG5vdCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBSYW5nZSB0byB3cmFwLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRPclN0cmluZyBFbGVtZW50IG9yIG5hbWUgb2YgZWxlbWVudCB0byB3cmFwIHRoZSByYW5nZSB3aXRoLgogICAgICovCgogIH0sIHsKICAgIGtleTogIndyYXAiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHdyYXAocmFuZ2UsIGVsZW1lbnRPclN0cmluZykgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoIXJhbmdlLmlzRmxhdCkgewogICAgICAgIC8qKgogICAgICAgICAqIFJhbmdlIHRvIHdyYXAgaXMgbm90IGZsYXQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLXdyYXAtcmFuZ2Utbm90LWZsYXQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXdyYXAtcmFuZ2Utbm90LWZsYXQ6IFJhbmdlIHRvIHdyYXAgaXMgbm90IGZsYXQuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudE9yU3RyaW5nIGluc3RhbmNlb2YgRWxlbWVudCA/IGVsZW1lbnRPclN0cmluZyA6IG5ldyBFbGVtZW50KGVsZW1lbnRPclN0cmluZyk7CgogICAgICBpZiAoZWxlbWVudC5jaGlsZENvdW50ID4gMCkgewogICAgICAgIC8qKgogICAgICAgICAqIEVsZW1lbnQgdG8gd3JhcCB3aXRoIGlzIG5vdCBlbXB0eS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItd3JhcC1lbGVtZW50LW5vdC1lbXB0eQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItd3JhcC1lbGVtZW50LW5vdC1lbXB0eTogRWxlbWVudCB0byB3cmFwIHdpdGggaXMgbm90IGVtcHR5LicsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoZWxlbWVudC5wYXJlbnQgIT09IG51bGwpIHsKICAgICAgICAvKioKICAgICAgICAgKiBFbGVtZW50IHRvIHdyYXAgd2l0aCBpcyBhbHJlYWR5IGF0dGFjaGVkIHRvIGEgdHJlZSBtb2RlbC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItd3JhcC1lbGVtZW50LWF0dGFjaGVkCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci13cmFwLWVsZW1lbnQtYXR0YWNoZWQ6IEVsZW1lbnQgdG8gd3JhcCB3aXRoIGlzIGFscmVhZHkgYXR0YWNoZWQgdG8gdHJlZSBtb2RlbC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgdGhpcy5pbnNlcnQoZWxlbWVudCwgcmFuZ2Uuc3RhcnQpOyAvLyBTaGlmdCB0aGUgcmFuZ2UtdG8td3JhcCBiZWNhdXNlIHdlIGp1c3QgaW5zZXJ0ZWQgYW4gZWxlbWVudCBiZWZvcmUgdGhhdCByYW5nZS4KCiAgICAgIHZhciBzaGlmdGVkUmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnQuZ2V0U2hpZnRlZEJ5KDEpLCByYW5nZS5lbmQuZ2V0U2hpZnRlZEJ5KDEpKTsKICAgICAgdGhpcy5tb3ZlKHNoaWZ0ZWRSYW5nZSwgUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIDApKTsKICAgIH0KICAgIC8qKgogICAgICogVW53cmFwcyBjaGlsZHJlbiBvZiB0aGUgZ2l2ZW4gZWxlbWVudCDigJMgYWxsIGl0cyBjaGlsZHJlbiBhcmUgbW92ZWQgYmVmb3JlIGl0IGFuZCB0aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQuCiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgeW91IHRyeSB0byB1bndyYXAgYW4gZWxlbWVudCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgcGFyZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB1bndyYXAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidW53cmFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1bndyYXAoZWxlbWVudCkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAoZWxlbWVudC5wYXJlbnQgPT09IG51bGwpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gdW53cmFwIGFuIGVsZW1lbnQgd2hpY2ggaGFzIG5vIHBhcmVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItdW53cmFwLWVsZW1lbnQtbm8tcGFyZW50CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci11bndyYXAtZWxlbWVudC1uby1wYXJlbnQ6IFRyeWluZyB0byB1bndyYXAgYW4gZWxlbWVudCB3aGljaCBoYXMgbm8gcGFyZW50LicsIHRoaXMpOwogICAgICB9CgogICAgICB0aGlzLm1vdmUoUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpLCB0aGlzLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIoZWxlbWVudCkpOwogICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlcn0uIE1hcmtlciBpcyBhIG5hbWVkIHJhbmdlLCB3aGljaCB0cmFja3MKICAgICAqIGNoYW5nZXMgaW4gdGhlIGRvY3VtZW50IGFuZCB1cGRhdGVzIGl0cyByYW5nZSBhdXRvbWF0aWNhbGx5LCB3aGVuIG1vZGVsIHRyZWUgY2hhbmdlcy4KICAgICAqCiAgICAgKiBBcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHlvdSBjYW4gc2V0IG1hcmtlciBuYW1lLgogICAgICoKICAgICAqIFRoZSByZXF1aXJlZCBgb3B0aW9ucy51c2luZ09wZXJhdGlvbmAgcGFyYW1ldGVyIGxldHMgeW91IGRlY2lkZSBpZiB0aGUgbWFya2VyIHNob3VsZCBiZSBtYW5hZ2VkIGJ5IG9wZXJhdGlvbnMgb3Igbm90LiBTZWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlciBjbGFzcyBkZXNjcmlwdGlvbn0gdG8gbGVhcm4gYWJvdXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbgogICAgICogbWFya2VycyBtYW5hZ2VkIGJ5IG9wZXJhdGlvbnMgYW5kIG5vdC1tYW5hZ2VkIGJ5IG9wZXJhdGlvbnMuCiAgICAgKgogICAgICogVGhlIGBvcHRpb25zLmFmZmVjdHNEYXRhYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIGBmYWxzZWAsIGFsbG93cyB5b3UgdG8gZGVmaW5lIGlmIGEgbWFya2VyIGFmZmVjdHMgdGhlIGRhdGEuIEl0IHNob3VsZCBiZQogICAgICogYHRydWVgIHdoZW4gdGhlIG1hcmtlciBjaGFuZ2UgY2hhbmdlcyB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6Y29yZS9lZGl0b3IvdXRpbHMvZGF0YWFwaW1peGlufkRhdGFBcGkjZ2V0RGF0YSBgZWRpdG9yLmdldERhdGEoKWB9IG1ldGhvZC4KICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCBpdCBmaXJlcyB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlOmRhdGEgYGNoYW5nZTpkYXRhYH0gZXZlbnQuCiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgIGl0IGZpcmVzIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2UgYGNoYW5nZWB9IGV2ZW50LgogICAgICoKICAgICAqIENyZWF0ZSBtYXJrZXIgZGlyZWN0bHkgYmFzZSBvbiBtYXJrZXIncyBuYW1lOgogICAgICoKICAgICAqCQlhZGRNYXJrZXIoIG1hcmtlck5hbWUsIHsgcmFuZ2UsIHVzaW5nT3BlcmF0aW9uOiBmYWxzZSB9ICk7CiAgICAgKgogICAgICogQ3JlYXRlIG1hcmtlciB1c2luZyBvcGVyYXRpb246CiAgICAgKgogICAgICoJCWFkZE1hcmtlciggbWFya2VyTmFtZSwgeyByYW5nZSwgdXNpbmdPcGVyYXRpb246IHRydWUgfSApOwogICAgICoKICAgICAqIENyZWF0ZSBtYXJrZXIgdGhhdCBhZmZlY3RzIHRoZSBlZGl0b3IgZGF0YToKICAgICAqCiAgICAgKgkJYWRkTWFya2VyKCBtYXJrZXJOYW1lLCB7IHJhbmdlLCB1c2luZ09wZXJhdGlvbjogZmFsc2UsIGFmZmVjdHNEYXRhOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBOb3RlOiBGb3IgZWZmaWNpZW5jeSByZWFzb25zLCBpdCdzIGJlc3QgdG8gY3JlYXRlIGFuZCBrZWVwIGFzIGxpdHRsZSBtYXJrZXJzIGFzIHBvc3NpYmxlLgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlcgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBhIG1hcmtlciB0byBjcmVhdGUgLSBtdXN0IGJlIHVuaXF1ZS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudXNpbmdPcGVyYXRpb24gRmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlIG1hcmtlciBzaG91bGQgYmUgYWRkZWQgYnkgTWFya2VyT3BlcmF0aW9uLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyI21hbmFnZWRVc2luZ09wZXJhdGlvbnN9LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvcHRpb25zLnJhbmdlIE1hcmtlciByYW5nZS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWZmZWN0c0RhdGE9ZmFsc2VdIEZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBtYXJrZXIgY2hhbmdlcyB0aGUgZWRpdG9yIGRhdGEuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlcn0gTWFya2VyIHRoYXQgd2FzIHNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhZGRNYXJrZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcmtlcihuYW1lLCBvcHRpb25zKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy51c2luZ09wZXJhdGlvbiAhPSAnYm9vbGVhbicpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgYG9wdGlvbnMudXNpbmdPcGVyYXRpb25gIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIGFkZGluZyBhIG5ldyBtYXJrZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLWFkZE1hcmtlci1uby11c2luZ09wZXJhdGlvbgogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItYWRkTWFya2VyLW5vLXVzaW5nT3BlcmF0aW9uOiBUaGUgb3B0aW9ucy51c2luZ09wZXJhdGlvbiBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiBhZGRpbmcgYSBuZXcgbWFya2VyLicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgdXNpbmdPcGVyYXRpb24gPSBvcHRpb25zLnVzaW5nT3BlcmF0aW9uOwogICAgICB2YXIgcmFuZ2UgPSBvcHRpb25zLnJhbmdlOwogICAgICB2YXIgYWZmZWN0c0RhdGEgPSBvcHRpb25zLmFmZmVjdHNEYXRhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMuYWZmZWN0c0RhdGE7CgogICAgICBpZiAodGhpcy5tb2RlbC5tYXJrZXJzLmhhcyhuYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIE1hcmtlciB3aXRoIHByb3ZpZGVkIG5hbWUgYWxyZWFkeSBleGlzdHMuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLWFkZE1hcmtlci1tYXJrZXItZXhpc3RzCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci1hZGRNYXJrZXItbWFya2VyLWV4aXN0czogTWFya2VyIHdpdGggcHJvdmlkZWQgbmFtZSBhbHJlYWR5IGV4aXN0cy4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCFyYW5nZSkgewogICAgICAgIC8qKgogICAgICAgICAqIFJhbmdlIHBhcmFtZXRlciBpcyByZXF1aXJlZCB3aGVuIGFkZGluZyBhIG5ldyBtYXJrZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLWFkZE1hcmtlci1uby1yYW5nZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItYWRkTWFya2VyLW5vLXJhbmdlOiBSYW5nZSBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgd2hlbiBhZGRpbmcgYSBuZXcgbWFya2VyLicsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoIXVzaW5nT3BlcmF0aW9uKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubWFya2Vycy5fc2V0KG5hbWUsIHJhbmdlLCB1c2luZ09wZXJhdGlvbiwgYWZmZWN0c0RhdGEpOwogICAgICB9CgogICAgICBhcHBseU1hcmtlck9wZXJhdGlvbih0aGlzLCBuYW1lLCBudWxsLCByYW5nZSwgYWZmZWN0c0RhdGEpOwogICAgICByZXR1cm4gdGhpcy5tb2RlbC5tYXJrZXJzLmdldChuYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcywgdXBkYXRlcyBvciByZWZyZXNoZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciBtYXJrZXJ9LiBNYXJrZXIgaXMgYSBuYW1lZCByYW5nZSwgd2hpY2ggdHJhY2tzCiAgICAgKiBjaGFuZ2VzIGluIHRoZSBkb2N1bWVudCBhbmQgdXBkYXRlcyBpdHMgcmFuZ2UgYXV0b21hdGljYWxseSwgd2hlbiBtb2RlbCB0cmVlIGNoYW5nZXMuIFN0aWxsLCBpdCBpcyBwb3NzaWJsZSB0byBjaGFuZ2UgdGhlCiAgICAgKiBtYXJrZXIncyByYW5nZSBkaXJlY3RseSB1c2luZyB0aGlzIG1ldGhvZC4KICAgICAqCiAgICAgKiBBcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHlvdSBjYW4gc2V0IG1hcmtlciBuYW1lIG9yIGluc3RhbmNlLiBJZiBub25lIG9mIHRoZW0gaXMgcHJvdmlkZWQsIG5ldyBtYXJrZXIsIHdpdGggYSB1bmlxdWUKICAgICAqIG5hbWUgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuCiAgICAgKgogICAgICogQXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgeW91IGNhbiBzZXQgdGhlIG5ldyBtYXJrZXIgZGF0YSBvciBsZWF2ZSB0aGlzIHBhcmFtZXRlciBhcyBlbXB0eSB3aGljaCB3aWxsIGp1c3QgcmVmcmVzaAogICAgICogdGhlIG1hcmtlciBieSB0cmlnZ2VyaW5nIGRvd25jYXN0IGNvbnZlcnNpb24gZm9yIGl0LiBSZWZyZXNoaW5nIHRoZSBtYXJrZXIgaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gY2hhbmdlCiAgICAgKiB0aGUgbWFya2VyIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gd2l0aG91dCBjaGFuZ2luZyBhbnkgbWFya2VyIGRhdGEuCiAgICAgKgogICAgICogCQlsZXQgaXNDb21tZW50QWN0aXZlID0gZmFsc2U7CiAgICAgKgogICAgICogCQltb2RlbC5jb252ZXJzaW9uLm1hcmtlclRvSGlnaGxpZ2h0KCB7CiAgICAgKiAJCQltb2RlbDogJ2NvbW1lbnQnLAogICAgICoJCQl2aWV3OiBkYXRhID0+IHsKICAgICAqCQkJCWNvbnN0IGNsYXNzZXMgPSBbICdjb21tZW50LW1hcmtlcicgXTsKICAgICAqCiAgICAgKgkJCQlpZiAoIGlzQ29tbWVudEFjdGl2ZSApIHsKICAgICAqCQkJCQljbGFzc2VzLnB1c2goICdjb21tZW50LW1hcmtlci0tYWN0aXZlJyApOwogICAgICoJCQkJfQogICAgICoKICAgICAqCQkJCXJldHVybiB7IGNsYXNzZXMgfTsKICAgICAqCQkJfQogICAgICogCQl9ICk7CiAgICAgKgogICAgICogCQkvLyBDaGFuZ2UgdGhlIHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIGlmIG1hcmtlciBpcyBkaXNwbGF5ZWQgYXMgYWN0aXZlIG9yIG5vdC4KICAgICAqIAkJaXNDb21tZW50QWN0aXZlID0gdHJ1ZTsKICAgICAqCiAgICAgKiAJCS8vIEFuZCByZWZyZXNoIHRoZSBtYXJrZXIgdG8gY29udmVydCBpdCB3aXRoIGFkZGl0aW9uYWwgY2xhc3MuCiAgICAgKiAJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHdyaXRlci51cGRhdGVNYXJrZXIoICdjb21tZW50JyApICk7CiAgICAgKgogICAgICogVGhlIGBvcHRpb25zLnVzaW5nT3BlcmF0aW9uYCBwYXJhbWV0ZXIgbGV0cyB5b3UgY2hhbmdlIGlmIHRoZSBtYXJrZXIgc2hvdWxkIGJlIG1hbmFnZWQgYnkgb3BlcmF0aW9ucyBvciBub3QuIFNlZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIgbWFya2VyIGNsYXNzIGRlc2NyaXB0aW9ufSB0byBsZWFybiBhYm91dCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuCiAgICAgKiBtYXJrZXJzIG1hbmFnZWQgYnkgb3BlcmF0aW9ucyBhbmQgbm90LW1hbmFnZWQgYnkgb3BlcmF0aW9ucy4gSXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoaXMgb3B0aW9uIGZvciBhbiBleGlzdGluZyBtYXJrZXIuCiAgICAgKgogICAgICogVGhlIGBvcHRpb25zLmFmZmVjdHNEYXRhYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIGBmYWxzZWAsIGFsbG93cyB5b3UgdG8gZGVmaW5lIGlmIGEgbWFya2VyIGFmZmVjdHMgdGhlIGRhdGEuIEl0IHNob3VsZCBiZQogICAgICogYHRydWVgIHdoZW4gdGhlIG1hcmtlciBjaGFuZ2UgY2hhbmdlcyB0aGUgZGF0YSByZXR1cm5lZCBieQogICAgICogdGhlIHtAbGluayBtb2R1bGU6Y29yZS9lZGl0b3IvdXRpbHMvZGF0YWFwaW1peGlufkRhdGFBcGkjZ2V0RGF0YSBgZWRpdG9yLmdldERhdGEoKWB9IG1ldGhvZC4KICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCBpdCBmaXJlcyB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlOmRhdGEgYGNoYW5nZTpkYXRhYH0gZXZlbnQuCiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgIGl0IGZpcmVzIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2UgYGNoYW5nZWB9IGV2ZW50LgogICAgICoKICAgICAqIFVwZGF0ZSBtYXJrZXIgZGlyZWN0bHkgYmFzZSBvbiBtYXJrZXIncyBuYW1lOgogICAgICoKICAgICAqCQl1cGRhdGVNYXJrZXIoIG1hcmtlck5hbWUsIHsgcmFuZ2UgfSApOwogICAgICoKICAgICAqIFVwZGF0ZSBtYXJrZXIgdXNpbmcgb3BlcmF0aW9uOgogICAgICoKICAgICAqCQl1cGRhdGVNYXJrZXIoIG1hcmtlciwgeyByYW5nZSwgdXNpbmdPcGVyYXRpb246IHRydWUgfSApOwogICAgICoJCXVwZGF0ZU1hcmtlciggbWFya2VyTmFtZSwgeyByYW5nZSwgdXNpbmdPcGVyYXRpb246IHRydWUgfSApOwogICAgICoKICAgICAqIENoYW5nZSBtYXJrZXIncyBvcHRpb24gKHN0YXJ0IHVzaW5nIG9wZXJhdGlvbnMgdG8gbWFuYWdlIGl0KToKICAgICAqCiAgICAgKgkJdXBkYXRlTWFya2VyKCBtYXJrZXIsIHsgdXNpbmdPcGVyYXRpb246IHRydWUgfSApOwogICAgICoKICAgICAqIENoYW5nZSBtYXJrZXIncyBvcHRpb24gKGluZm9ybSB0aGUgZW5naW5lLCB0aGF0IHRoZSBtYXJrZXIgZG9lcyBub3QgYWZmZWN0IHRoZSBkYXRhIGFueW1vcmUpOgogICAgICoKICAgICAqCQl1cGRhdGVNYXJrZXIoIG1hcmtlck5hbWUsIHsgYWZmZWN0c0RhdGE6IGZhbHNlIH0gKTsKICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIKICAgICAqIEBwYXJhbSB7U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ9IG1hcmtlck9yTmFtZSBOYW1lIG9mIGEgbWFya2VyIHRvIHVwZGF0ZSwgb3IgYSBtYXJrZXIgaW5zdGFuY2UuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIElmIG9wdGlvbnMgb2JqZWN0IGlzIG5vdCBkZWZpbmVkIHRoZW4gbWFya2VyIHdpbGwgYmUgcmVmcmVzaGVkIGJ5IHRyaWdnZXJpbmcKICAgICAqIGRvd25jYXN0IGNvbnZlcnNpb24gZm9yIHRoaXMgbWFya2VyIHdpdGggdGhlIHNhbWUgZGF0YS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gW29wdGlvbnMucmFuZ2VdIE1hcmtlciByYW5nZSB0byB1cGRhdGUuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzaW5nT3BlcmF0aW9uXSBGbGFnIGluZGljYXRlZCB3aGV0aGVyIHRoZSBtYXJrZXIgc2hvdWxkIGJlIGFkZGVkIGJ5IE1hcmtlck9wZXJhdGlvbi4KICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlciNtYW5hZ2VkVXNpbmdPcGVyYXRpb25zfS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWZmZWN0c0RhdGFdIEZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBtYXJrZXIgY2hhbmdlcyB0aGUgZWRpdG9yIGRhdGEuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidXBkYXRlTWFya2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXJrZXIobWFya2VyT3JOYW1lLCBvcHRpb25zKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHZhciBtYXJrZXJOYW1lID0gdHlwZW9mIG1hcmtlck9yTmFtZSA9PSAnc3RyaW5nJyA/IG1hcmtlck9yTmFtZSA6IG1hcmtlck9yTmFtZS5uYW1lOwogICAgICB2YXIgY3VycmVudE1hcmtlciA9IHRoaXMubW9kZWwubWFya2Vycy5nZXQobWFya2VyTmFtZSk7CgogICAgICBpZiAoIWN1cnJlbnRNYXJrZXIpIHsKICAgICAgICAvKioKICAgICAgICAgKiBNYXJrZXIgd2l0aCBwcm92aWRlZCBuYW1lIGRvZXMgbm90IGV4aXN0cy4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB3cml0ZXItdXBkYXRlTWFya2VyLW1hcmtlci1ub3QtZXhpc3RzCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3dyaXRlci11cGRhdGVNYXJrZXItbWFya2VyLW5vdC1leGlzdHM6IE1hcmtlciB3aXRoIHByb3ZpZGVkIG5hbWUgZG9lcyBub3QgZXhpc3RzLicsIHRoaXMpOwogICAgICB9CgogICAgICBpZiAoIW9wdGlvbnMpIHsKICAgICAgICB0aGlzLm1vZGVsLm1hcmtlcnMuX3JlZnJlc2goY3VycmVudE1hcmtlcik7CgogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGhhc1VzaW5nT3BlcmF0aW9uRGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLnVzaW5nT3BlcmF0aW9uID09ICdib29sZWFuJzsKICAgICAgdmFyIGFmZmVjdHNEYXRhRGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmFmZmVjdHNEYXRhID09ICdib29sZWFuJzsgLy8gVXNlIHByZXZpb3VzbHkgZGVmaW5lZCBtYXJrZXIncyBhZmZlY3RzRGF0YSBpZiB0aGUgcHJvcGVydHkgaXMgbm90IHByb3ZpZGVkLgoKICAgICAgdmFyIGFmZmVjdHNEYXRhID0gYWZmZWN0c0RhdGFEZWZpbmVkID8gb3B0aW9ucy5hZmZlY3RzRGF0YSA6IGN1cnJlbnRNYXJrZXIuYWZmZWN0c0RhdGE7CgogICAgICBpZiAoIWhhc1VzaW5nT3BlcmF0aW9uRGVmaW5lZCAmJiAhb3B0aW9ucy5yYW5nZSAmJiAhYWZmZWN0c0RhdGFEZWZpbmVkKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogT25lIG9mIHRoZSBvcHRpb25zIGlzIHJlcXVpcmVkIC0gcHJvdmlkZSByYW5nZSwgdXNpbmdPcGVyYXRpb25zIG9yIGFmZmVjdHNEYXRhLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHdyaXRlci11cGRhdGVNYXJrZXItd3Jvbmctb3B0aW9ucwogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItdXBkYXRlTWFya2VyLXdyb25nLW9wdGlvbnM6IE9uZSBvZiB0aGUgb3B0aW9ucyBpcyByZXF1aXJlZCAtIHByb3ZpZGUgcmFuZ2UsIHVzaW5nT3BlcmF0aW9ucyBvciBhZmZlY3RzRGF0YS4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgdmFyIGN1cnJlbnRSYW5nZSA9IGN1cnJlbnRNYXJrZXIuZ2V0UmFuZ2UoKTsKICAgICAgdmFyIHVwZGF0ZWRSYW5nZSA9IG9wdGlvbnMucmFuZ2UgPyBvcHRpb25zLnJhbmdlIDogY3VycmVudFJhbmdlOwoKICAgICAgaWYgKGhhc1VzaW5nT3BlcmF0aW9uRGVmaW5lZCAmJiBvcHRpb25zLnVzaW5nT3BlcmF0aW9uICE9PSBjdXJyZW50TWFya2VyLm1hbmFnZWRVc2luZ09wZXJhdGlvbnMpIHsKICAgICAgICAvLyBUaGUgbWFya2VyIHR5cGUgaXMgY2hhbmdlZCBzbyBpdCdzIG5lY2Vzc2FyeSB0byBjcmVhdGUgcHJvcGVyIG9wZXJhdGlvbnMuCiAgICAgICAgaWYgKG9wdGlvbnMudXNpbmdPcGVyYXRpb24pIHsKICAgICAgICAgIC8vIElmIG1hcmtlciBjaGFuZ2VzIHRvIGEgbWFuYWdlZCBvbmUgdHJlYXQgdGhpcyBhcyBzeW5jaHJvbml6aW5nIGV4aXN0aW5nIG1hcmtlci4KICAgICAgICAgIC8vIENyZWF0ZSBgTWFya2VyT3BlcmF0aW9uYCB3aXRoIGBvbGRSYW5nZWAgc2V0IHRvIGBudWxsYCwgc28gcmV2ZXJzZSBvcGVyYXRpb24gd2lsbCByZW1vdmUgdGhlIG1hcmtlci4KICAgICAgICAgIGFwcGx5TWFya2VyT3BlcmF0aW9uKHRoaXMsIG1hcmtlck5hbWUsIG51bGwsIHVwZGF0ZWRSYW5nZSwgYWZmZWN0c0RhdGEpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiBtYXJrZXIgY2hhbmdlcyB0byBhIG1hcmtlciB0aGF0IGRvIG5vdCB1c2Ugb3BlcmF0aW9ucyB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGFkZGl0aW9uYWwgb3BlcmF0aW9uCiAgICAgICAgICAvLyB0aGF0IHJlbW92ZXMgdGhhdCBtYXJrZXIgZmlyc3QuCiAgICAgICAgICBhcHBseU1hcmtlck9wZXJhdGlvbih0aGlzLCBtYXJrZXJOYW1lLCBjdXJyZW50UmFuZ2UsIG51bGwsIGFmZmVjdHNEYXRhKTsgLy8gQWx0aG91Z2ggbm90IG1hbmFnZWQgdGhlIG1hcmtlciBpdHNlbGYgc2hvdWxkIHN0YXkgaW4gbW9kZWwgYW5kIGl0cyByYW5nZSBzaG91bGQgYmUgcHJlc2VydmVyIG9yIGNoYW5nZWQgdG8gcGFzc2VkIHJhbmdlLgoKICAgICAgICAgIHRoaXMubW9kZWwubWFya2Vycy5fc2V0KG1hcmtlck5hbWUsIHVwZGF0ZWRSYW5nZSwgdW5kZWZpbmVkLCBhZmZlY3RzRGF0YSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm47CiAgICAgIH0gLy8gTWFya2VyJ3MgdHlwZSBkb2Vzbid0IGNoYW5nZSBzbyB1cGRhdGUgaXQgYWNjb3JkaW5nbHkuCgoKICAgICAgaWYgKGN1cnJlbnRNYXJrZXIubWFuYWdlZFVzaW5nT3BlcmF0aW9ucykgewogICAgICAgIGFwcGx5TWFya2VyT3BlcmF0aW9uKHRoaXMsIG1hcmtlck5hbWUsIGN1cnJlbnRSYW5nZSwgdXBkYXRlZFJhbmdlLCBhZmZlY3RzRGF0YSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5tb2RlbC5tYXJrZXJzLl9zZXQobWFya2VyTmFtZSwgdXBkYXRlZFJhbmdlLCB1bmRlZmluZWQsIGFmZmVjdHNEYXRhKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlcn0gb3IgbWFya2VyIHdpdGggZ2l2ZW4gbmFtZS4KICAgICAqIFRoZSBtYXJrZXIgaXMgcmVtb3ZlZCBhY2NvcmRpbmdseSB0byBob3cgaXQgaGFzIGJlZW4gY3JlYXRlZCwgc28gaWYgdGhlIG1hcmtlciB3YXMgY3JlYXRlZCB1c2luZyBvcGVyYXRpb24sCiAgICAgKiBpdCB3aWxsIGJlIGRlc3Ryb3llZCB1c2luZyBvcGVyYXRpb24uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyfFN0cmluZ30gbWFya2VyT3JOYW1lIE1hcmtlciBvciBtYXJrZXIgbmFtZSB0byByZW1vdmUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlTWFya2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVNYXJrZXIobWFya2VyT3JOYW1lKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHZhciBuYW1lID0gdHlwZW9mIG1hcmtlck9yTmFtZSA9PSAnc3RyaW5nJyA/IG1hcmtlck9yTmFtZSA6IG1hcmtlck9yTmFtZS5uYW1lOwoKICAgICAgaWYgKCF0aGlzLm1vZGVsLm1hcmtlcnMuaGFzKG5hbWUpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogVHJ5aW5nIHRvIHJlbW92ZSBtYXJrZXIgd2hpY2ggZG9lcyBub3QgZXhpc3QuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3Igd3JpdGVyLXJlbW92ZU1hcmtlci1uby1tYXJrZXIKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignd3JpdGVyLXJlbW92ZU1hcmtlci1uby1tYXJrZXI6IFRyeWluZyB0byByZW1vdmUgbWFya2VyIHdoaWNoIGRvZXMgbm90IGV4aXN0LicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgbWFya2VyID0gdGhpcy5tb2RlbC5tYXJrZXJzLmdldChuYW1lKTsKCiAgICAgIGlmICghbWFya2VyLm1hbmFnZWRVc2luZ09wZXJhdGlvbnMpIHsKICAgICAgICB0aGlzLm1vZGVsLm1hcmtlcnMuX3JlbW92ZShuYW1lKTsKCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgb2xkUmFuZ2UgPSBtYXJrZXIuZ2V0UmFuZ2UoKTsKICAgICAgYXBwbHlNYXJrZXJPcGVyYXRpb24odGhpcywgbmFtZSwgb2xkUmFuZ2UsIG51bGwsIG1hcmtlci5hZmZlY3RzRGF0YSk7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdGhlIGRvY3VtZW50J3Mgc2VsZWN0aW9uIChyYW5nZXMgYW5kIGRpcmVjdGlvbikgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlIHNlbGVjdGFibGV9IG9yIGNyZWF0ZXMgYW4gZW1wdHkgc2VsZWN0aW9uIGlmIG5vIGFyZ3VtZW50cyB3ZXJlIHBhc3NlZC4KICAgICAqCiAgICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gdGhlIGdpdmVuIHJhbmdlLgogICAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UgKTsKICAgICAqCiAgICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gZ2l2ZW4gcmFuZ2VzLgogICAgICoJCWNvbnN0IHJhbmdlcyA9IFsgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydDEsIGVuZDIgKSwgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFyMiwgZW5kMiApIF07CiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2VzICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIG90aGVyIHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBvdGhlclNlbGVjdGlvbiApOwogICAgICoKICAgICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQgc2VsZWN0aW9uLgogICAgICoJCWNvbnN0IGRvY3VtZW50U2VsZWN0aW9uID0gbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uOwogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIGRvY3VtZW50U2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgY29sbGFwc2VkIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgkJY29uc3QgcG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb24oIHJvb3QsIHBhdGggKTsKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwb3NpdGlvbiApOwogICAgICoKICAgICAqCQkvLyBTZXRzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbiBvZmZzZXQuCiAgICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgICAqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgCSAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ2luJyApOwogICAgICoKICAgICAqIENyZWF0ZXMgYSByYW5nZSBvbiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gaXRlbX0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgaXRlbSBhbmQgZW5kcyBqdXN0IGFmdGVyIHRoZSBpdGVtLgogICAgICoKICAgICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdvbicgKTsKICAgICAqCiAgICAgKgkJLy8gUmVtb3ZlcyBhbGwgc2VsZWN0aW9uJ3MgcmFuZ2VzLgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIG51bGwgKTsKICAgICAqCiAgICAgKiBgV3JpdGVyI3NldFNlbGVjdGlvbigpYCBhbGxvdyBwYXNzaW5nIGFkZGl0aW9uYWwgb3B0aW9ucyAoYGJhY2t3YXJkYCkgYXMgdGhlIGxhc3QgYXJndW1lbnQuCiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIGFzIGJhY2t3YXJkLgogICAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlLCB7IGJhY2t3YXJkOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBUaHJvd3MgYHdyaXRlci1pbmNvcnJlY3QtdXNlYCBlcnJvciB3aGVuIHRoZSB3cml0ZXIgaXMgdXNlZCBvdXRzaWRlIHRoZSBgY2hhbmdlKClgIGJsb2NrLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRTZWxlY3Rpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogTW92ZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24jZm9jdXN9IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uCiAgICAgKgogICAgICogVGhlIGxvY2F0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIHNhbWUgZm9ybSBhcwogICAgICoge0BsaW5rICNjcmVhdGVQb3NpdGlvbkF0IGB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCgpYH0gcGFyYW1ldGVycy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0PTBdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldFNlbGVjdGlvbkZvY3VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Gb2N1cyhpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHRoaXMuX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKTsKCiAgICAgIHRoaXMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRGb2N1cyhpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBhdHRyaWJ1dGUocykgb24gdGhlIHNlbGVjdGlvbi4gSWYgYXR0cmlidXRlIHdpdGggdGhlIHNhbWUga2V5IGFscmVhZHkgaXMgc2V0LCBpdCdzIHZhbHVlIGlzIG92ZXJ3cml0dGVuLgogICAgICoKICAgICAqIFVzaW5nIGtleSBhbmQgdmFsdWUgcGFpcjoKICAgICAqCiAgICAgKiAJd3JpdGVyLnNldFNlbGVjdGlvbkF0dHJpYnV0ZSggJ2l0YWxpYycsIHRydWUgKTsKICAgICAqCiAgICAgKiBVc2luZyBrZXktdmFsdWUgb2JqZWN0OgogICAgICoKICAgICAqIAl3cml0ZXIuc2V0U2VsZWN0aW9uQXR0cmlidXRlKCB7IGl0YWxpYzogdHJ1ZSwgYm9sZDogZmFsc2UgfSApOwogICAgICoKICAgICAqIFVzaW5nIGl0ZXJhYmxlIG9iamVjdDoKICAgICAqCiAgICAgKiAJd3JpdGVyLnNldFNlbGVjdGlvbkF0dHJpYnV0ZSggbmV3IE1hcCggWyBbICdpdGFsaWMnLCB0cnVlIF0gXSApICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fEl0ZXJhYmxlLjwqPn0ga2V5T3JPYmplY3RPckl0ZXJhYmxlIEtleSBvZiB0aGUgYXR0cmlidXRlIHRvIHNldAogICAgICogb3Igb2JqZWN0IC8gaXRlcmFibGUgb2Yga2V5ID0+IHZhbHVlIGF0dHJpYnV0ZSBwYWlycy4KICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBBdHRyaWJ1dGUgdmFsdWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0U2VsZWN0aW9uQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JPYmplY3RPckl0ZXJhYmxlLCB2YWx1ZSkgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0T3JJdGVyYWJsZSA9PT0gJ3N0cmluZycpIHsKICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JPYmplY3RPckl0ZXJhYmxlLCB2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZTsKICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gZmFsc2U7CiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjggPSB0b01hcChrZXlPck9iamVjdE9ySXRlcmFibGUpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA4OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLAogICAgICAgICAgICAgICAga2V5ID0gX3N0ZXA4JHZhbHVlWzBdLAogICAgICAgICAgICAgICAgX3ZhbHVlID0gX3N0ZXA4JHZhbHVlWzFdOwoKICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uQXR0cmlidXRlKGtleSwgX3ZhbHVlKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yOCA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjgpIHsKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjg7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhdHRyaWJ1dGUocykgd2l0aCBnaXZlbiBrZXkocykgZnJvbSB0aGUgc2VsZWN0aW9uLgogICAgICoKICAgICAqIFJlbW92ZSBvbmUgYXR0cmlidXRlOgogICAgICoKICAgICAqCQl3cml0ZXIucmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKCAnaXRhbGljJyApOwogICAgICoKICAgICAqIFJlbW92ZSBtdWx0aXBsZSBhdHRyaWJ1dGVzOgogICAgICoKICAgICAqCQl3cml0ZXIucmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKCBbICdpdGFsaWMnLCAnYm9sZCcgXSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfEl0ZXJhYmxlLjxTdHJpbmc+fSBrZXlPckl0ZXJhYmxlT2ZLZXlzIEtleSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZSBvciBhbiBpdGVyYWJsZSBvZiBhdHRyaWJ1dGUga2V5cyB0byByZW1vdmUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5T3JJdGVyYWJsZU9mS2V5cykgewogICAgICB0aGlzLl9hc3NlcnRXcml0ZXJVc2VkQ29ycmVjdGx5KCk7CgogICAgICBpZiAodHlwZW9mIGtleU9ySXRlcmFibGVPZktleXMgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgdGhpcy5fcmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKGtleU9ySXRlcmFibGVPZktleXMpOwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjkgPSB1bmRlZmluZWQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0ga2V5T3JJdGVyYWJsZU9mS2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkgewogICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA5LnZhbHVlOwoKICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2VsZWN0aW9uQXR0cmlidXRlKGtleSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I5OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFRlbXBvcmFyaWx5IGNoYW5nZXMgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uI2lzR3Jhdml0eU92ZXJyaWRkZW4gZ3Jhdml0eX0KICAgICAqIG9mIHRoZSBzZWxlY3Rpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0LgogICAgICoKICAgICAqIFRoZSBncmF2aXR5IGRlZmluZXMgZnJvbSB3aGljaCBkaXJlY3Rpb24gdGhlIHNlbGVjdGlvbiBpbmhlcml0cyBpdHMgYXR0cmlidXRlcy4gSWYgaXQncyB0aGUgZGVmYXVsdCBsZWZ0IGdyYXZpdHksCiAgICAgKiB0aGVuIHRoZSBzZWxlY3Rpb24gKGFmdGVyIGJlaW5nIG1vdmVkIGJ5IHRoZSB1c2VyKSBpbmhlcml0cyBhdHRyaWJ1dGVzIGZyb20gaXRzIGxlZnQtaGFuZCBzaWRlLgogICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHRvIHRlbXBvcmFyaWx5IG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgZm9yY2luZyB0aGUgZ3Jhdml0eSB0byB0aGUgcmlnaHQuCiAgICAgKgogICAgICogRm9yIHRoZSBmb2xsb3dpbmcgbW9kZWwgZnJhZ21lbnQ6CiAgICAgKgogICAgICoJCTwkdGV4dCBib2xkPSJ0cnVlIiBsaW5rSHJlZj0idXJsIj5iYXJbXTwvJHRleHQ+PCR0ZXh0IGJvbGQ9InRydWUiPmJpejwvJHRleHQ+CiAgICAgKgogICAgICogKiBEZWZhdWx0IGdyYXZpdHk6IHNlbGVjdGlvbiB3aWxsIGhhdmUgdGhlIGBib2xkYCBhbmQgYGxpbmtIcmVmYCBhdHRyaWJ1dGVzLgogICAgICogKiBPdmVycmlkZGVuIGdyYXZpdHk6IHNlbGVjdGlvbiB3aWxsIGhhdmUgYGJvbGRgIGF0dHJpYnV0ZS4KICAgICAqCiAgICAgKiAqKk5vdGUqKjogSXQgcmV0dXJucyBhbiB1bmlxdWUgaWRlbnRpZmllciB3aGljaCBpcyByZXF1aXJlZCB0byByZXN0b3JlIHRoZSBncmF2aXR5LiBJdCBndWFyYW50ZWVzIHRoZSBzeW1tZXRyeQogICAgICogb2YgdGhlIHByb2Nlc3MuCiAgICAgKgogICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHVuaXF1ZSBpZCB3aGljaCBhbGxvd3MgcmVzdG9yaW5nIHRoZSBncmF2aXR5LgogICAgICovCgogIH0sIHsKICAgIGtleTogIm92ZXJyaWRlU2VsZWN0aW9uR3Jhdml0eSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcnJpZGVTZWxlY3Rpb25HcmF2aXR5KCkgewogICAgICByZXR1cm4gdGhpcy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb24uX292ZXJyaWRlR3Jhdml0eSgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXN0b3JlcyB7QGxpbmsgfldyaXRlciNvdmVycmlkZVNlbGVjdGlvbkdyYXZpdHl9IGdyYXZpdHkgdG8gZGVmYXVsdC4KICAgICAqCiAgICAgKiBSZXN0b3JpbmcgdGhlIGdyYXZpdHkgaXMgb25seSBwb3NzaWJsZSB1c2luZyB0aGUgdW5pcXVlIGlkZW50aWZpZXIgcmV0dXJuZWQgYnkKICAgICAqIHtAbGluayB+V3JpdGVyI292ZXJyaWRlU2VsZWN0aW9uR3Jhdml0eX0uIE5vdGUgdGhhdCB0aGUgZ3Jhdml0eSByZW1haW5zIG92ZXJyaWRkZW4gYXMgbG9uZyBhcyB3b24ndCBiZSByZXN0b3JlZAogICAgICogdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzIGl0IHdhcyBvdmVycmlkZGVuLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1aWQgVGhlIHVuaXF1ZSBpZCByZXR1cm5lZCBieSB7QGxpbmsgfldyaXRlciNvdmVycmlkZVNlbGVjdGlvbkdyYXZpdHl9LgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlc3RvcmVTZWxlY3Rpb25HcmF2aXR5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uR3Jhdml0eSh1aWQpIHsKICAgICAgdGhpcy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb24uX3Jlc3RvcmVHcmF2aXR5KHVpZCk7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS4KICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQXR0cmlidXRlIHZhbHVlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zZXRTZWxlY3Rpb25BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgewogICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb247IC8vIFN0b3JlIGF0dHJpYnV0ZSBpbiBwYXJlbnQgZWxlbWVudCBpZiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCBpbiBhbiBlbXB0eSBub2RlLgoKICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiBzZWxlY3Rpb24uYW5jaG9yLnBhcmVudC5pc0VtcHR5KSB7CiAgICAgICAgdmFyIHN0b3JlS2V5ID0gRG9jdW1lbnRTZWxlY3Rpb24uX2dldFN0b3JlQXR0cmlidXRlS2V5KGtleSk7CgogICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHN0b3JlS2V5LCB2YWx1ZSwgc2VsZWN0aW9uLmFuY2hvci5wYXJlbnQpOwogICAgICB9CgogICAgICBzZWxlY3Rpb24uX3NldEF0dHJpYnV0ZShrZXksIHZhbHVlKTsKICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIHRoZSBhdHRyaWJ1dGUgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoa2V5KSB7CiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLm1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbjsgLy8gUmVtb3ZlIHN0b3JlZCBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgZWxlbWVudCBpZiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCBpbiBhbiBlbXB0eSBub2RlLgoKICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiBzZWxlY3Rpb24uYW5jaG9yLnBhcmVudC5pc0VtcHR5KSB7CiAgICAgICAgdmFyIHN0b3JlS2V5ID0gRG9jdW1lbnRTZWxlY3Rpb24uX2dldFN0b3JlQXR0cmlidXRlS2V5KGtleSk7CgogICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHN0b3JlS2V5LCBzZWxlY3Rpb24uYW5jaG9yLnBhcmVudCk7CiAgICAgIH0KCiAgICAgIHNlbGVjdGlvbi5fcmVtb3ZlQXR0cmlidXRlKGtleSk7CiAgICB9CiAgICAvKioKICAgICAqIFRocm93cyBgd3JpdGVyLWRldGFjaGVkLXdyaXRlci10cmllcy10by1tb2RpZnktbW9kZWxgIGVycm9yIHdoZW4gdGhlIHdyaXRlciBpcyB1c2VkIG91dHNpZGUgb2YgdGhlIGBjaGFuZ2UoKWAgYmxvY2suCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfYXNzZXJ0V3JpdGVyVXNlZENvcnJlY3RseSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2Fzc2VydFdyaXRlclVzZWRDb3JyZWN0bHkoKSB7CiAgICAgIC8qKgogICAgICAgKiBUcnlpbmcgdG8gdXNlIGEgd3JpdGVyIG91dHNpZGUgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2UgYGNoYW5nZSgpYH0gb3IKICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZSBgZW5xdWV1ZUNoYW5nZSgpYH0gYmxvY2tzLgogICAgICAgKgogICAgICAgKiBUaGUgd3JpdGVyIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHRoZXNlIGJsb2NrcyB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIG1vZGVsCiAgICAgICAqIGNhbiBvbmx5IGJlIGNoYW5nZWQgZHVyaW5nIHN1Y2ggInNlc3Npb25zIi4KICAgICAgICoKICAgICAgICogQGVycm9yIHdyaXRlci1pbmNvcnJlY3QtdXNlCiAgICAgICAqLwogICAgICBpZiAodGhpcy5tb2RlbC5fY3VycmVudFdyaXRlciAhPT0gdGhpcykgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd3cml0ZXItaW5jb3JyZWN0LXVzZTogVHJ5aW5nIHRvIHVzZSBhIHdyaXRlciBvdXRzaWRlIHRoZSBjaGFuZ2UoKSBibG9jay4nLCB0aGlzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBGb3IgZ2l2ZW4gYWN0aW9uIGB0eXBlYCBhbmQgYHBvc2l0aW9uT3JSYW5nZWAgd2hlcmUgdGhlIGFjdGlvbiBoYXBwZW5zLCB0aGlzIGZ1bmN0aW9uIGZpbmRzIGFsbCBhZmZlY3RlZCBtYXJrZXJzCiAgICAgKiBhbmQgYXBwbGllcyBhIG1hcmtlciBvcGVyYXRpb24gd2l0aCB0aGUgbmV3IG1hcmtlciByYW5nZSBlcXVhbCB0byB0aGUgY3VycmVudCByYW5nZS4gVGhhbmtzIHRvIHRoaXMsIHRoZSBtYXJrZXIgcmFuZ2UKICAgICAqIGNhbiBiZSBsYXRlciBjb3JyZWN0bHkgcHJvY2Vzc2VkIGR1cmluZyB1bmRvLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0geydtb3ZlJ3wnbWVyZ2UnfSB0eXBlIFdyaXRlciBhY3Rpb24gdHlwZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBwb3NpdGlvbk9yUmFuZ2UgUG9zaXRpb24gb3IgcmFuZ2UKICAgICAqIHdoZXJlIHRoZSB3cml0ZXIgYWN0aW9uIGhhcHBlbnMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2VycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZE9wZXJhdGlvbkZvckFmZmVjdGVkTWFya2Vycyh0eXBlLCBwb3NpdGlvbk9yUmFuZ2UpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IHRoaXMubW9kZWwubWFya2Vyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgbWFya2VyID0gX3N0ZXAxMC52YWx1ZTsKCiAgICAgICAgICBpZiAoIW1hcmtlci5tYW5hZ2VkVXNpbmdPcGVyYXRpb25zKSB7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBtYXJrZXJSYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICAgICAgdmFyIGlzQWZmZWN0ZWQgPSBmYWxzZTsKCiAgICAgICAgICBpZiAodHlwZSA9PSAnbW92ZScpIHsKICAgICAgICAgICAgaXNBZmZlY3RlZCA9IHBvc2l0aW9uT3JSYW5nZS5jb250YWluc1Bvc2l0aW9uKG1hcmtlclJhbmdlLnN0YXJ0KSB8fCBwb3NpdGlvbk9yUmFuZ2Uuc3RhcnQuaXNFcXVhbChtYXJrZXJSYW5nZS5zdGFydCkgfHwgcG9zaXRpb25PclJhbmdlLmNvbnRhaW5zUG9zaXRpb24obWFya2VyUmFuZ2UuZW5kKSB8fCBwb3NpdGlvbk9yUmFuZ2UuZW5kLmlzRXF1YWwobWFya2VyUmFuZ2UuZW5kKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIGlmIHR5cGUgPT0gJ21lcmdlJy4KICAgICAgICAgICAgdmFyIGVsZW1lbnRCZWZvcmUgPSBwb3NpdGlvbk9yUmFuZ2Uubm9kZUJlZm9yZTsKICAgICAgICAgICAgdmFyIGVsZW1lbnRBZnRlciA9IHBvc2l0aW9uT3JSYW5nZS5ub2RlQWZ0ZXI7IC8vICAgICAgICAgICAgICAgU3RhcnQ6ICA8cD5Gb29bPC9wPjxwPkJhcl08L3A+CiAgICAgICAgICAgIC8vICAgICAgICAgQWZ0ZXIgbWVyZ2U6ICA8cD5Gb29bQmFyXTwvcD4KICAgICAgICAgICAgLy8gQWZ0ZXIgdW5kb2luZyBzcGxpdDogIDxwPkZvbzwvcD48cD5bQmFyXTwvcD4gICAgIDwtLSBpbmNvcnJlY3QsIG5lZWRzIHJlbWVtYmVyaW5nIGZvciB1bmRvLgogICAgICAgICAgICAvLwoKICAgICAgICAgICAgdmFyIGFmZmVjdGVkSW5MZWZ0RWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LnBhcmVudCA9PSBlbGVtZW50QmVmb3JlICYmIG1hcmtlclJhbmdlLnN0YXJ0LmlzQXRFbmQ7IC8vICAgICAgICAgICAgICAgU3RhcnQ6ICA8cD5bRm9vPC9wPjxwPl1CYXI8L3A+CiAgICAgICAgICAgIC8vICAgICAgICAgQWZ0ZXIgbWVyZ2U6ICA8cD5bRm9vXUJhcjwvcD4KICAgICAgICAgICAgLy8gQWZ0ZXIgdW5kb2luZyBzcGxpdDogIDxwPltGb29dPC9wPjxwPkJhcjwvcD4gICAgIDwtLSBpbmNvcnJlY3QsIG5lZWRzIHJlbWVtYmVyaW5nIGZvciB1bmRvLgogICAgICAgICAgICAvLwoKICAgICAgICAgICAgdmFyIGFmZmVjdGVkSW5SaWdodEVsZW1lbnQgPSBtYXJrZXJSYW5nZS5lbmQucGFyZW50ID09IGVsZW1lbnRBZnRlciAmJiBtYXJrZXJSYW5nZS5lbmQub2Zmc2V0ID09IDA7IC8vICAgICAgICAgICAgICAgU3RhcnQ6ICA8cD5bRm9vPC9wPl08cD5CYXI8L3A+CiAgICAgICAgICAgIC8vICAgICAgICAgQWZ0ZXIgbWVyZ2U6ICA8cD5bRm9vXUJhcjwvcD4KICAgICAgICAgICAgLy8gQWZ0ZXIgdW5kb2luZyBzcGxpdDogIDxwPltGb29dPC9wPjxwPkJhcjwvcD4gICAgIDwtLSBpbmNvcnJlY3QsIG5lZWRzIHJlbWVtYmVyaW5nIGZvciB1bmRvLgogICAgICAgICAgICAvLwoKICAgICAgICAgICAgdmFyIGFmZmVjdGVkQWZ0ZXJMZWZ0RWxlbWVudCA9IG1hcmtlclJhbmdlLmVuZC5ub2RlQWZ0ZXIgPT0gZWxlbWVudEFmdGVyOyAvLyAgICAgICAgICAgICAgIFN0YXJ0OiAgPHA+Rm9vPC9wPls8cD5CYXJdPC9wPgogICAgICAgICAgICAvLyAgICAgICAgIEFmdGVyIG1lcmdlOiAgPHA+Rm9vW0Jhcl08L3A+CiAgICAgICAgICAgIC8vIEFmdGVyIHVuZG9pbmcgc3BsaXQ6ICA8cD5Gb288L3A+PHA+W0Jhcl08L3A+ICAgICA8LS0gaW5jb3JyZWN0LCBuZWVkcyByZW1lbWJlcmluZyBmb3IgdW5kby4KICAgICAgICAgICAgLy8KCiAgICAgICAgICAgIHZhciBhZmZlY3RlZEJlZm9yZVJpZ2h0RWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0Lm5vZGVBZnRlciA9PSBlbGVtZW50QWZ0ZXI7CiAgICAgICAgICAgIGlzQWZmZWN0ZWQgPSBhZmZlY3RlZEluTGVmdEVsZW1lbnQgfHwgYWZmZWN0ZWRJblJpZ2h0RWxlbWVudCB8fCBhZmZlY3RlZEFmdGVyTGVmdEVsZW1lbnQgfHwgYWZmZWN0ZWRCZWZvcmVSaWdodEVsZW1lbnQ7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGlzQWZmZWN0ZWQpIHsKICAgICAgICAgICAgdGhpcy51cGRhdGVNYXJrZXIobWFya2VyLm5hbWUsIHsKICAgICAgICAgICAgICByYW5nZTogbWFya2VyUmFuZ2UKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEwID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjEwID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCAmJiBfaXRlcmF0b3IxMC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IxMC5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTApIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9XSk7CgogIHJldHVybiBXcml0ZXI7Cn0oKTsgLy8gU2V0cyBnaXZlbiBhdHRyaWJ1dGUgdG8gZWFjaCBub2RlIGluIGdpdmVuIHJhbmdlLiBXaGVuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBudWxsIHRoZW4gYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC4KLy8KLy8gQmVjYXVzZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIG5lZWRzIHRvIGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlIHZhbHVlIG9uIHRoZSB3aG9sZSByYW5nZSwgdGhpcyBmdW5jdGlvbiBzcGxpdHMKLy8gdGhlIHJhbmdlIGludG8gc21hbGxlciBwYXJ0cy4KLy8KLy8gR2l2ZW4gYHJhbmdlYCBtdXN0IGJlIGZsYXQuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHtTdHJpbmd9IGtleSBBdHRyaWJ1dGUga2V5LgovLyBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSBuZXcgdmFsdWUuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgTW9kZWwgcmFuZ2Ugb24gd2hpY2ggdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldC4KCgpleHBvcnQgeyBXcml0ZXIgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gc2V0QXR0cmlidXRlT25SYW5nZSh3cml0ZXIsIGtleSwgdmFsdWUsIHJhbmdlKSB7CiAgdmFyIG1vZGVsID0gd3JpdGVyLm1vZGVsOwogIHZhciBkb2MgPSBtb2RlbC5kb2N1bWVudDsgLy8gUG9zaXRpb24gb2YgdGhlIGxhc3Qgc3BsaXQsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyByYW5nZS4KCiAgdmFyIGxhc3RTcGxpdFBvc2l0aW9uID0gcmFuZ2Uuc3RhcnQ7IC8vIEN1cnJlbnRseSBwb3NpdGlvbiBpbiB0aGUgc2Nhbm5pbmcgcmFuZ2UuIEJlY2F1c2Ugd2UgbmVlZCB2YWx1ZSBhZnRlciB0aGUgcG9zaXRpb24sIGl0IGlzIG5vdCBhIGN1cnJlbnQKICAvLyBwb3NpdGlvbiBvZiB0aGUgaXRlcmF0b3IgYnV0IHRoZSBwcmV2aW91cyBvbmUgKHdlIG5lZWQgdG8gaXRlcmF0ZSBvbmUgbW9yZSB0aW1lIHRvIGdldCB0aGUgdmFsdWUgYWZ0ZXIpLgoKICB2YXIgcG9zaXRpb247IC8vIFZhbHVlIGJlZm9yZSB0aGUgY3VycmVudGx5IHBvc2l0aW9uLgoKICB2YXIgdmFsdWVCZWZvcmU7IC8vIFZhbHVlIGFmdGVyIHRoZSBjdXJyZW50bHkgcG9zaXRpb24uCgogIHZhciB2YWx1ZUFmdGVyOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjExID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yMTEgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3IxMSA9IHJhbmdlLmdldFdhbGtlcih7CiAgICAgIHNoYWxsb3c6IHRydWUKICAgIH0pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSAoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWUpIHsKICAgICAgdmFyIHZhbCA9IF9zdGVwMTEudmFsdWU7CiAgICAgIHZhbHVlQWZ0ZXIgPSB2YWwuaXRlbS5nZXRBdHRyaWJ1dGUoa2V5KTsgLy8gQXQgdGhlIGZpcnN0IHJ1biBvZiB0aGUgaXRlcmF0b3IgdGhlIHBvc2l0aW9uIGluIHVuZGVmaW5lZC4gV2UgYWxzbyBkbyBub3QgaGF2ZSBhIHZhbHVlQmVmb3JlLCBidXQKICAgICAgLy8gYmVjYXVzZSB2YWx1ZUFmdGVyIG1heSBiZSBudWxsLCB2YWx1ZUJlZm9yZSBtYXkgYmUgZXF1YWwgdmFsdWVBZnRlciAoIHVuZGVmaW5lZCA9PSBudWxsICkuCgogICAgICBpZiAocG9zaXRpb24gJiYgdmFsdWVCZWZvcmUgIT0gdmFsdWVBZnRlcikgewogICAgICAgIC8vIGlmIHZhbHVlQmVmb3JlID09IHZhbHVlIHRoZXJlIGlzIG5vdGhpbmcgdG8gY2hhbmdlLCBzbyB3ZSBhZGQgb3BlcmF0aW9uIG9ubHkgaWYgdGhlc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQuCiAgICAgICAgaWYgKHZhbHVlQmVmb3JlICE9IHZhbHVlKSB7CiAgICAgICAgICBhZGRPcGVyYXRpb24oKTsKICAgICAgICB9CgogICAgICAgIGxhc3RTcGxpdFBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgIH0KCiAgICAgIHBvc2l0aW9uID0gdmFsLm5leHRQb3NpdGlvbjsKICAgICAgdmFsdWVCZWZvcmUgPSB2YWx1ZUFmdGVyOwogICAgfSAvLyBCZWNhdXNlIHBvc2l0aW9uIGluIHRoZSBsb29wIGlzIG5vdCB0aGUgaXRlcmF0b3IgcG9zaXRpb24gKHNlZSBsZXQgcG9zaXRpb24gY29tbWVudCksIHRoZSBsYXN0IHBvc2l0aW9uIGluCiAgICAvLyB0aGUgd2hpbGUgbG9vcCB3aWxsIGJlIGxhc3QgYnV0IG9uZSBwb3NpdGlvbiBpbiB0aGUgcmFuZ2UuIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGxhc3QgcG9zaXRpb24gbWFudWFsbHkuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjExID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjExLnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMSkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTE7CiAgICAgIH0KICAgIH0KICB9CgogIGlmIChwb3NpdGlvbiBpbnN0YW5jZW9mIFBvc2l0aW9uICYmIHBvc2l0aW9uICE9IGxhc3RTcGxpdFBvc2l0aW9uICYmIHZhbHVlQmVmb3JlICE9IHZhbHVlKSB7CiAgICBhZGRPcGVyYXRpb24oKTsKICB9CgogIGZ1bmN0aW9uIGFkZE9wZXJhdGlvbigpIHsKICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShsYXN0U3BsaXRQb3NpdGlvbiwgcG9zaXRpb24pOwogICAgdmFyIHZlcnNpb24gPSByYW5nZS5yb290LmRvY3VtZW50ID8gZG9jLnZlcnNpb24gOiBudWxsOwogICAgdmFyIG9wZXJhdGlvbiA9IG5ldyBBdHRyaWJ1dGVPcGVyYXRpb24ocmFuZ2UsIGtleSwgdmFsdWVCZWZvcmUsIHZhbHVlLCB2ZXJzaW9uKTsKICAgIHdyaXRlci5iYXRjaC5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgIG1vZGVsLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgfQp9IC8vIFNldHMgZ2l2ZW4gYXR0cmlidXRlIHRvIHRoZSBnaXZlbiBub2RlLiBXaGVuIGF0dHJpYnV0ZSB2YWx1ZSBpcyBudWxsIHRoZW4gYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlcgovLyBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCi8vIEBwYXJhbSB7Kn0gdmFsdWUgQXR0cmlidXRlIG5ldyB2YWx1ZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBNb2RlbCBpdGVtIG9uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQuCgoKZnVuY3Rpb24gc2V0QXR0cmlidXRlT25JdGVtKHdyaXRlciwga2V5LCB2YWx1ZSwgaXRlbSkgewogIHZhciBtb2RlbCA9IHdyaXRlci5tb2RlbDsKICB2YXIgZG9jID0gbW9kZWwuZG9jdW1lbnQ7CiAgdmFyIHByZXZpb3VzVmFsdWUgPSBpdGVtLmdldEF0dHJpYnV0ZShrZXkpOwogIHZhciByYW5nZSwgb3BlcmF0aW9uOwoKICBpZiAocHJldmlvdXNWYWx1ZSAhPSB2YWx1ZSkgewogICAgdmFyIGlzUm9vdENoYW5nZWQgPSBpdGVtLnJvb3QgPT09IGl0ZW07CgogICAgaWYgKGlzUm9vdENoYW5nZWQpIHsKICAgICAgLy8gSWYgd2UgY2hhbmdlIGF0dHJpYnV0ZXMgb2Ygcm9vdCBlbGVtZW50LCB3ZSBoYXZlIHRvIHVzZSBgUm9vdEF0dHJpYnV0ZU9wZXJhdGlvbmAuCiAgICAgIHZhciB2ZXJzaW9uID0gaXRlbS5kb2N1bWVudCA/IGRvYy52ZXJzaW9uIDogbnVsbDsKICAgICAgb3BlcmF0aW9uID0gbmV3IFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24oaXRlbSwga2V5LCBwcmV2aW91c1ZhbHVlLCB2YWx1ZSwgdmVyc2lvbik7CiAgICB9IGVsc2UgewogICAgICByYW5nZSA9IG5ldyBSYW5nZShQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGl0ZW0pLCB3cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlcihpdGVtKSk7CgogICAgICB2YXIgX3ZlcnNpb24gPSByYW5nZS5yb290LmRvY3VtZW50ID8gZG9jLnZlcnNpb24gOiBudWxsOwoKICAgICAgb3BlcmF0aW9uID0gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwga2V5LCBwcmV2aW91c1ZhbHVlLCB2YWx1ZSwgX3ZlcnNpb24pOwogICAgfQoKICAgIHdyaXRlci5iYXRjaC5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgIG1vZGVsLmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgfQp9IC8vIENyZWF0ZXMgYW5kIGFwcGxpZXMgbWFya2VyIG9wZXJhdGlvbiB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb259LgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyCi8vIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG9sZFJhbmdlIE1hcmtlciByYW5nZSBiZWZvcmUgdGhlIGNoYW5nZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBuZXdSYW5nZSBNYXJrZXIgcmFuZ2UgYWZ0ZXIgdGhlIGNoYW5nZS4KLy8gQHBhcmFtIHtCb29sZWFufSBhZmZlY3RzRGF0YQoKCmZ1bmN0aW9uIGFwcGx5TWFya2VyT3BlcmF0aW9uKHdyaXRlciwgbmFtZSwgb2xkUmFuZ2UsIG5ld1JhbmdlLCBhZmZlY3RzRGF0YSkgewogIHZhciBtb2RlbCA9IHdyaXRlci5tb2RlbDsKICB2YXIgZG9jID0gbW9kZWwuZG9jdW1lbnQ7CiAgdmFyIG9wZXJhdGlvbiA9IG5ldyBNYXJrZXJPcGVyYXRpb24obmFtZSwgb2xkUmFuZ2UsIG5ld1JhbmdlLCBtb2RlbC5tYXJrZXJzLCBhZmZlY3RzRGF0YSwgZG9jLnZlcnNpb24pOwogIHdyaXRlci5iYXRjaC5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICBtb2RlbC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pOwp9IC8vIENyZWF0ZXMgYE1vdmVPcGVyYXRpb25gIG9yIGBEZXRhY2hPcGVyYXRpb25gIHRoYXQgcmVtb3ZlcyBgaG93TWFueWAgbm9kZXMgc3RhcnRpbmcgZnJvbSBgcG9zaXRpb25gLgovLyBUaGUgb3BlcmF0aW9uIHdpbGwgYmUgYXBwbGllZCBvbiBnaXZlbiBtb2RlbCBpbnN0YW5jZSBhbmQgYWRkZWQgdG8gZ2l2ZW4gb3BlcmF0aW9uIGluc3RhbmNlLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIGZyb20gd2hpY2ggbm9kZXMgYXJlIHJlbW92ZWQuCi8vIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IE51bWJlciBvZiBub2RlcyB0byByZW1vdmUuCi8vIEBwYXJhbSB7QmF0Y2h9IGJhdGNoIEJhdGNoIHRvIHdoaWNoIHRoZSBvcGVyYXRpb24gd2lsbCBiZSBhZGRlZC4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbCBNb2RlbCBpbnN0YW5jZSBvbiB3aGljaCBvcGVyYXRpb24gd2lsbCBiZSBhcHBsaWVkLgoKCmZ1bmN0aW9uIGFwcGx5UmVtb3ZlT3BlcmF0aW9uKHBvc2l0aW9uLCBob3dNYW55LCBiYXRjaCwgbW9kZWwpIHsKICB2YXIgb3BlcmF0aW9uOwoKICBpZiAocG9zaXRpb24ucm9vdC5kb2N1bWVudCkgewogICAgdmFyIGRvYyA9IG1vZGVsLmRvY3VtZW50OwogICAgdmFyIGdyYXZleWFyZFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGRvYy5ncmF2ZXlhcmQsIFswXSk7CiAgICBvcGVyYXRpb24gPSBuZXcgTW92ZU9wZXJhdGlvbihwb3NpdGlvbiwgaG93TWFueSwgZ3JhdmV5YXJkUG9zaXRpb24sIGRvYy52ZXJzaW9uKTsKICB9IGVsc2UgewogICAgb3BlcmF0aW9uID0gbmV3IERldGFjaE9wZXJhdGlvbihwb3NpdGlvbiwgaG93TWFueSk7CiAgfQoKICBiYXRjaC5hZGRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICBtb2RlbC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24pOwp9IC8vIFJldHVybnMgYHRydWVgIGlmIGJvdGggcm9vdCBlbGVtZW50cyBhcmUgdGhlIHNhbWUgZWxlbWVudCBvciBib3RoIGFyZSBkb2N1bWVudHMgcm9vdCBlbGVtZW50cy4KLy8KLy8gRWxlbWVudHMgaW4gdGhlIHNhbWUgdHJlZSBjYW4gYmUgbW92ZWQgKGZvciBpbnN0YW5jZSB5b3UgY2FuIG1vdmUgZWxlbWVudCBmb3JtIG9uZSBkb2N1bWVudHMgcm9vdCB0byBhbm90aGVyLCBvcgovLyB3aXRoaW4gdGhlIHNhbWUgZG9jdW1lbnQgZnJhZ21lbnQpLCBidXQgd2hlbiBlbGVtZW50IHN1cHBvc2VkIHRvIGJlIG1vdmVkIGZyb20gZG9jdW1lbnQgZnJhZ21lbnQgdG8gdGhlIGRvY3VtZW50LCBvcgovLyB0byBhbm90aGVyIGRvY3VtZW50IGl0IHNob3VsZCBiZSByZW1vdmVkIGFuZCBpbnNlcnRlZCB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIE9ULiBUaGlzIGlzIGJlY2F1c2UgZmVhdHVyZXMgbGlrZSB1bmRvIG9yCi8vIGNvbGxhYm9yYXRpb24gbWF5IHRyYWNrIGNoYW5nZXMgb24gdGhlIGRvY3VtZW50IGJ1dCBpZ25vcmUgY2hhbmdlcyBvbiBkZXRhY2hlZCBmcmFnbWVudHMgYW5kIHNob3VsZCBub3QgZ2V0Ci8vIHVuZXhwZWN0ZWQgYG1vdmVgIG9wZXJhdGlvbi4KCgpmdW5jdGlvbiBpc1NhbWVUcmVlKHJvb3RBLCByb290QikgewogIC8vIElmIGl0IGlzIHRoZSBzYW1lIHJvb3QgdGhpcyBpcyB0aGUgc2FtZSB0cmVlLgogIGlmIChyb290QSA9PT0gcm9vdEIpIHsKICAgIHJldHVybiB0cnVlOwogIH0gLy8gSWYgYm90aCByb290cyBhcmUgZG9jdW1lbnRzIHJvb3QgaXQgaXMgb3BlcmF0aW9uIHdpdGhpbiB0aGUgZG9jdW1lbnQgd2hhdCB3ZSBzdGlsbCB0cmVhdCBhcyB0aGUgc2FtZSB0cmVlLgoKCiAgaWYgKHJvb3RBIGluc3RhbmNlb2YgUm9vdEVsZW1lbnQgJiYgcm9vdEIgaW5zdGFuY2VvZiBSb290RWxlbWVudCkgewogICAgcmV0dXJuIHRydWU7CiAgfQoKICByZXR1cm4gZmFsc2U7Cn0="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js"],"names":["AttributeOperation","DetachOperation","InsertOperation","MarkerOperation","MoveOperation","RenameOperation","RootAttributeOperation","SplitOperation","MergeOperation","DocumentFragment","Text","Element","RootElement","Position","Range","DocumentSelection","toMap","CKEditorError","Writer","model","batch","data","attributes","name","item","itemOrPosition","offset","_assertWriterUsedCorrectly","position","_createAt","parent","isSameTree","root","move","_createOn","document","remove","version","insert","shouldReceiveAttributes","addOperation","applyOperation","markers","markerName","markerRange","rangeRootPosition","range","start","_getCombined","end","options","usingOperation","affectsData","has","updateMarker","addMarker","text","createText","createElement","key","value","itemOrRange","ranges","getMinimalFlatRanges","setAttributeOnRange","setAttributeOnItem","val","setAttribute","removeAttributesFromItem","getAttributeKeys","attribute","removeAttribute","getItems","isFlat","isEqual","_addOperationForAffectedMarkers","operation","rangeToRemove","reverse","flat","applyRemoveOperation","nodeBefore","nodeAfter","_mergeDetached","_merge","path","stickiness","createPositionFromPath","createPositionAt","createPositionAfter","createPositionBefore","createRange","element","createRangeIn","createRangeOn","selectable","placeOrOffset","createSelection","_createIn","targetPosition","sourcePosition","graveyard","graveyardPosition","merge","maxOffset","newName","renameOperation","_createBefore","limitElement","splitElement","getAncestors","includeSelf","includes","firstSplitElement","firstCopyElement","howMany","split","nextSibling","elementOrString","childCount","shiftedRange","getShiftedBy","undefined","_set","applyMarkerOperation","get","markerOrName","currentMarker","_refresh","hasUsingOperationDefined","affectsDataDefined","currentRange","getRange","updatedRange","managedUsingOperations","marker","_remove","oldRange","selection","_setTo","_setFocus","keyOrObjectOrIterable","_setSelectionAttribute","keyOrIterableOfKeys","_removeSelectionAttribute","_overrideGravity","uid","_restoreGravity","isCollapsed","anchor","isEmpty","storeKey","_getStoreAttributeKey","_setAttribute","_removeAttribute","_currentWriter","type","positionOrRange","isAffected","containsPosition","elementBefore","elementAfter","affectedInLeftElement","isAtEnd","affectedInRightElement","affectedAfterLeftElement","affectedBeforeRightElement","writer","doc","lastSplitPosition","valueBefore","valueAfter","getWalker","shallow","getAttribute","nextPosition","previousValue","isRootChanged","newRange","rootA","rootB"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/writer\n */\n\nimport AttributeOperation from './operation/attributeoperation';\nimport DetachOperation from './operation/detachoperation';\nimport InsertOperation from './operation/insertoperation';\nimport MarkerOperation from './operation/markeroperation';\nimport MoveOperation from './operation/moveoperation';\nimport RenameOperation from './operation/renameoperation';\nimport RootAttributeOperation from './operation/rootattributeoperation';\nimport SplitOperation from './operation/splitoperation';\nimport MergeOperation from './operation/mergeoperation';\n\nimport DocumentFragment from './documentfragment';\nimport Text from './text';\nimport Element from './element';\nimport RootElement from './rootelement';\nimport Position from './position';\nimport Range from './range.js';\nimport DocumentSelection from './documentselection';\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify\n * child nodes, attributes or text, set the selection's position and its attributes.\n *\n * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or\n * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.\n *\n *\t\tmodel.change( writer => {\n *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n *\t\t} );\n *\n * Note that the writer should never be stored and used outside of the `change()` and\n * `enqueueChange()` blocks.\n *\n * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible\n * to create incorrect model structures by using the writer. Read more about in\n * {@glink framework/guides/deep-dive/schema#who-checks-the-schema \"Who checks the schema?\"}.\n *\n * @see module:engine/model/model~Model#change\n * @see module:engine/model/model~Model#enqueueChange\n */\nexport default class Writer {\n\t/**\n\t * Creates a writer instance.\n\t *\n\t * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or\n\t * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/model~Model} model\n\t * @param {module:engine/model/batch~Batch} batch\n\t */\n\tconstructor( model, batch ) {\n\t\t/**\n\t\t * Instance of the model on which this writer operates.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The batch to which this writer will add changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/batch~Batch}\n\t\t */\n\t\tthis.batch = batch;\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\t\twriter.createText( 'foo', { bold: true } );\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @returns {module:engine/model/text~Text} Created text node.\n\t */\n\tcreateText( data, attributes ) {\n\t\treturn new Text( data, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/element~Element element}.\n\t *\n\t *\t\twriter.createElement( 'paragraph' );\n\t *\t\twriter.createElement( 'paragraph', { alignment: 'center' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/model/element~Element} Created element.\n\t */\n\tcreateElement( name, attributes ) {\n\t\treturn new Element( name, attributes );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.\n\t *\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.\n\t */\n\tcreateDocumentFragment() {\n\t\treturn new DocumentFragment();\n\t}\n\n\t/**\n\t * Inserts item on given position.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, position );\n\t *\n\t * Instead of using position you can use parent and offset:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 5 );\n\t *\n\t * You can also use `end` instead of the offset to insert at the end:\n\t *\n\t *\t\tconst text = writer.createText( 'foo' );\n\t *\t\twriter.insert( text, paragraph, 'end' );\n\t *\n\t * Or insert before or after another element:\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.insert( paragraph, anotherParagraph, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,\n\t * `model-writer-insert-forbidden-move` is thrown.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * **Note:** For a paste-like content insertion mechanism see\n\t * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document\n\t * fragment to insert.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsert( item, itemOrPosition, offset = 0 ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( item instanceof Text && item.data == '' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// If item has a parent already.\n\t\tif ( item.parent ) {\n\t\t\t// We need to check if item is going to be inserted within the same document.\n\t\t\tif ( isSameTree( item.root, position.root ) ) {\n\t\t\t\t// If it's we just need to move it.\n\t\t\t\tthis.move( Range._createOn( item ), position );\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// If it isn't the same root.\n\t\t\telse {\n\t\t\t\tif ( item.root.document ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * Cannot move a node from a document to a different tree.\n\t\t\t\t\t * It is forbidden to move a node that was already in a document outside of it.\n\t\t\t\t\t *\n\t\t\t\t\t * @error model-writer-insert-forbidden-move\n\t\t\t\t\t */\n\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t'model-writer-insert-forbidden-move: ' +\n\t\t\t\t\t\t'Cannot move a node from a document to a different tree. ' +\n\t\t\t\t\t\t'It is forbidden to move a node that was already in a document outside of it.',\n\t\t\t\t\t\tthis\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// Move between two different document fragments or from document fragment to a document is possible.\n\t\t\t\t\t// In that case, remove the item from it's original parent.\n\t\t\t\t\tthis.remove( item );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst version = position.root.document ? position.root.document.version : null;\n\n\t\tconst insert = new InsertOperation( position, item, version );\n\n\t\tif ( item instanceof Text ) {\n\t\t\tinsert.shouldReceiveAttributes = true;\n\t\t}\n\n\t\tthis.batch.addOperation( insert );\n\t\tthis.model.applyOperation( insert );\n\n\t\t// When element is a DocumentFragment we need to move its markers to Document#markers.\n\t\tif ( item instanceof DocumentFragment ) {\n\t\t\tfor ( const [ markerName, markerRange ] of item.markers ) {\n\t\t\t\t// We need to migrate marker range from DocumentFragment to Document.\n\t\t\t\tconst rangeRootPosition = Position._createAt( markerRange.root, 0 );\n\t\t\t\tconst range = new Range(\n\t\t\t\t\tmarkerRange.start._getCombined( rangeRootPosition, position ),\n\t\t\t\t\tmarkerRange.end._getCombined( rangeRootPosition, position )\n\t\t\t\t);\n\n\t\t\t\tconst options = { range, usingOperation: true, affectsData: true };\n\n\t\t\t\tif ( this.model.markers.has( markerName ) ) {\n\t\t\t\t\tthis.updateMarker( markerName, options );\n\t\t\t\t} else {\n\t\t\t\t\tthis.addMarker( markerName, options );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts text on given position. You can optionally set text attributes:\n\t *\n\t *\t\twriter.insertText( 'foo', position );\n\t *\t\twriter.insertText( 'foo', { bold: true }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts 'foo' in paragraph, at offset 5:\n\t *\t\twriter.insertText( 'foo', paragraph, 5 );\n\t *\t\t// Inserts 'foo' at the end of a paragraph:\n\t *\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t// Inserts 'foo' after an image:\n\t *\t\twriter.insertText( 'foo', image, 'after' );\n\t *\n\t * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} data Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertText( text, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createText( text ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and inserts element on given position. You can optionally set attributes:\n\t *\n\t *\t\twriter.insertElement( 'paragraph', position );\n\t *\t\twriter.insertElement( 'paragraph', { alignment: 'center' }, position );\n\t *\n\t * Instead of using position you can use parent and offset or define that text should be inserted at the end\n\t * or before or after other node:\n\t *\n\t *\t\t// Inserts paragraph in the root at offset 5:\n\t *\t\twriter.insertElement( 'paragraph', root, 5 );\n\t *\t\t// Inserts paragraph at the end of a blockquote:\n\t *\t\twriter.insertElement( 'paragraph', blockquote, 'end' );\n\t *\t\t// Inserts after an image:\n\t *\t\twriter.insertElement( 'paragraph', image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * third parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tinsertElement( name, attributes, itemOrPosition, offset ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, itemOrPosition );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), itemOrPosition, offset );\n\t\t}\n\t}\n\n\t/**\n\t * Inserts item at the end of the given parent.\n\t *\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\twriter.append( paragraph, root );\n\t *\n\t * Note that if the item already has parent it will be removed from the previous parent.\n\t *\n\t * If you want to move {@link module:engine/model/range~Range range} instead of an\n\t * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}\n\t * item Item or document fragment to insert.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappend( item, parent ) {\n\t\tthis.insert( item, parent, 'end' );\n\t}\n\n\t/**\n\t * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:\n\t *\n\t *\t\twriter.appendText( 'foo', paragraph );\n\t *\t\twriter.appendText( 'foo', { bold: true }, paragraph );\n\t *\n\t * @param {String} text Text data.\n\t * @param {Object} [attributes] Text attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendText( text, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createText( text ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createText( text, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Creates element and inserts it at the end of the parent. You can optionally set attributes:\n\t *\n\t *\t\twriter.appendElement( 'paragraph', root );\n\t *\t\twriter.appendElement( 'paragraph', { alignment: 'center' }, root );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent\n\t */\n\tappendElement( name, attributes, parent ) {\n\t\tif ( attributes instanceof DocumentFragment || attributes instanceof Element ) {\n\t\t\tthis.insert( this.createElement( name ), attributes, 'end' );\n\t\t} else {\n\t\t\tthis.insert( this.createElement( name, attributes ), parent, 'end' );\n\t\t}\n\t}\n\n\t/**\n\t * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {*} value Attribute new value.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attribute will be set.\n\t */\n\tsetAttribute( key, value, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, value, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, value, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Sets values of attributes on a {@link module:engine/model/item~Item model item}\n\t * or on a {@link module:engine/model/range~Range range}.\n\t *\n\t *\t\twriter.setAttributes( {\n\t *\t\t\tbold: true,\n\t *\t\t\titalic: true\n\t *\t\t}, range );\n\t *\n\t * @param {Object} attributes Attributes keys and values.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range on which the attributes will be set.\n\t */\n\tsetAttributes( attributes, itemOrRange ) {\n\t\tfor ( const [ key, val ] of toMap( attributes ) ) {\n\t\t\tthis.setAttribute( key, val, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}\n\t * or from a {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which the attribute will be removed.\n\t */\n\tremoveAttribute( key, itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( itemOrRange instanceof Range ) {\n\t\t\tconst ranges = itemOrRange.getMinimalFlatRanges();\n\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tsetAttributeOnRange( this, key, null, range );\n\t\t\t}\n\t\t} else {\n\t\t\tsetAttributeOnItem( this, key, null, itemOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Removes all attributes from all elements in the range or from the given item.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange\n\t * Model item or range from which all attributes will be removed.\n\t */\n\tclearAttributes( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst removeAttributesFromItem = item => {\n\t\t\tfor ( const attribute of item.getAttributeKeys() ) {\n\t\t\t\tthis.removeAttribute( attribute, item );\n\t\t\t}\n\t\t};\n\n\t\tif ( !( itemOrRange instanceof Range ) ) {\n\t\t\tremoveAttributesFromItem( itemOrRange );\n\t\t} else {\n\t\t\tfor ( const item of itemOrRange.getItems() ) {\n\t\t\t\tremoveAttributesFromItem( item );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves all items in the source range to the target position.\n\t *\n\t *\t\twriter.move( sourceRange, targetPosition );\n\t *\n\t * Instead of the target position you can use parent and offset or define that range should be moved to the end\n\t * or before or after chosen item:\n\t *\n\t *\t\t// Moves all items in the range to the paragraph at offset 5:\n\t *\t\twriter.move( sourceRange, paragraph, 5 );\n\t *\t\t// Moves all items in the range to the end of a blockquote:\n\t *\t\twriter.move( sourceRange, blockquote, 'end' );\n\t *\t\t// Moves all items in the range to a position after an image:\n\t *\t\twriter.move( sourceRange, image, 'after' );\n\t *\n\t * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.\n\t *\n\t * Note that items can be moved only within the same tree. It means that you can move items within the same root\n\t * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},\n\t * but you can not move items from document fragment to the document or from one detached element to another. Use\n\t * {@link module:engine/model/writer~Writer#insert} in such cases.\n\t *\n\t * @param {module:engine/model/range~Range} range Source range.\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * second parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tmove( range, itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( range instanceof Range ) ) {\n\t\t\t/**\n\t\t\t * Invalid range to move.\n\t\t\t *\n\t\t\t * @error writer-move-invalid-range\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-invalid-range: Invalid range to move.', this );\n\t\t}\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to move is not flat.\n\t\t\t *\n\t\t\t * @error writer-move-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-range-not-flat: Range to move is not flat.', this );\n\t\t}\n\n\t\tconst position = Position._createAt( itemOrPosition, offset );\n\n\t\t// Do not move anything if the move target is same as moved range start.\n\t\tif ( position.isEqual( range.start ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'move', range );\n\n\t\tif ( !isSameTree( range.root, position.root ) ) {\n\t\t\t/**\n\t\t\t * Range is going to be moved within not the same document. Please use\n\t\t\t * {@link module:engine/model/writer~Writer#insert insert} instead.\n\t\t\t *\n\t\t\t * @error writer-move-different-document\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-move-different-document: Range is going to be moved between different documents.', this );\n\t\t}\n\n\t\tconst version = range.root.document ? range.root.document.version : null;\n\t\tconst operation = new MoveOperation( range.start, range.end.offset - range.start.offset, position, version );\n\n\t\tthis.batch.addOperation( operation );\n\t\tthis.model.applyOperation( operation );\n\t}\n\n\t/**\n\t * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.\n\t */\n\tremove( itemOrRange ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn( itemOrRange );\n\t\tconst ranges = rangeToRemove.getMinimalFlatRanges().reverse();\n\n\t\tfor ( const flat of ranges ) {\n\t\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\t\tthis._addOperationForAffectedMarkers( 'move', flat );\n\n\t\t\tapplyRemoveOperation( flat.start, flat.end.offset - flat.start.offset, this.batch, this.model );\n\t\t}\n\t}\n\n\t/**\n\t * Merges two siblings at the given position.\n\t *\n\t * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or\n\t * `writer-merge-no-element-after` error will be thrown.\n\t *\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\tmerge( position ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\t// If part of the marker is removed, create additional marker operation for undo purposes.\n\t\tthis._addOperationForAffectedMarkers( 'merge', position );\n\n\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node before merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-before\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-before: Node before merge position must be an element.', this );\n\t\t}\n\n\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Node after merge position must be an element.\n\t\t\t *\n\t\t\t * @error writer-merge-no-element-after\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-merge-no-element-after: Node after merge position must be an element.', this );\n\t\t}\n\n\t\tif ( !position.root.document ) {\n\t\t\tthis._mergeDetached( position );\n\t\t} else {\n\t\t\tthis._merge( position );\n\t\t}\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn this.model.createPositionFromPath( root, path, stickiness );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn this.model.createPositionAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn this.model.createPositionAfter( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn this.model.createPositionBefore( item );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn this.model.createRange( start, end );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn this.model.createRangeIn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( element ) {\n\t\treturn this.model.createRangeOn( element );\n\t}\n\n\t/**\n\t * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn this.model.createSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Performs merge action in a detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_mergeDetached( position ) {\n\t\tconst nodeBefore = position.nodeBefore;\n\t\tconst nodeAfter = position.nodeAfter;\n\n\t\tthis.move( Range._createIn( nodeAfter ), Position._createAt( nodeBefore, 'end' ) );\n\t\tthis.remove( nodeAfter );\n\t}\n\n\t/**\n\t * Performs merge action in a non-detached tree.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position Position between merged elements.\n\t */\n\t_merge( position ) {\n\t\tconst targetPosition = Position._createAt( position.nodeBefore, 'end' );\n\t\tconst sourcePosition = Position._createAt( position.nodeAfter, 0 );\n\n\t\tconst graveyard = position.root.document.graveyard;\n\t\tconst graveyardPosition = new Position( graveyard, [ 0 ] );\n\n\t\tconst version = position.root.document.version;\n\n\t\tconst merge = new MergeOperation( sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version );\n\n\t\tthis.batch.addOperation( merge );\n\t\tthis.model.applyOperation( merge );\n\t}\n\n\t/**\n\t * Renames the given element.\n\t *\n\t * @param {module:engine/model/element~Element} element The element to rename.\n\t * @param {String} newName New element name.\n\t */\n\trename( element, newName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !( element instanceof Element ) ) {\n\t\t\t/**\n\t\t\t * Trying to rename an object which is not an instance of Element.\n\t\t\t *\n\t\t\t * @error writer-rename-not-element-instance\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tconst version = element.root.document ? element.root.document.version : null;\n\t\tconst renameOperation = new RenameOperation( Position._createBefore( element ), element.name, newName, version );\n\n\t\tthis.batch.addOperation( renameOperation );\n\t\tthis.model.applyOperation( renameOperation );\n\t}\n\n\t/**\n\t * Splits elements starting from the given position and going to the top of the model tree as long as given\n\t * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.\n\t *\n\t * The element needs to have a parent. It cannot be a root element nor a document fragment.\n\t * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.\n\t *\n\t * @param {module:engine/model/position~Position} position Position of split.\n\t * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.\n\t * @returns {Object} result Split result.\n\t * @returns {module:engine/model/position~Position} result.position Position between split elements.\n\t * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends\n\t * at the beginning of the first copy element.\n\t */\n\tsplit( position, limitElement ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tlet splitElement = position.parent;\n\n\t\tif ( !splitElement.parent ) {\n\t\t\t/**\n\t\t\t * Element with no parent can not be split.\n\t\t\t *\n\t\t\t * @error writer-split-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-split-element-no-parent: Element with no parent can not be split.', this );\n\t\t}\n\n\t\t// When limit element is not defined lets set splitElement parent as limit.\n\t\tif ( !limitElement ) {\n\t\t\tlimitElement = splitElement.parent;\n\t\t}\n\n\t\tif ( !position.parent.getAncestors( { includeSelf: true } ).includes( limitElement ) ) {\n\t\t\tthrow new CKEditorError( 'writer-split-invalid-limit-element: Limit element is not a position ancestor.', this );\n\t\t}\n\n\t\t// We need to cache elements that will be created as a result of the first split because\n\t\t// we need to create a range from the end of the first split element to the beginning of the\n\t\t// first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.\n\t\tlet firstSplitElement, firstCopyElement;\n\n\t\tdo {\n\t\t\tconst version = splitElement.root.document ? splitElement.root.document.version : null;\n\t\t\tconst howMany = splitElement.maxOffset - position.offset;\n\t\t\tconst split = new SplitOperation( position, howMany, null, version );\n\n\t\t\tthis.batch.addOperation( split );\n\t\t\tthis.model.applyOperation( split );\n\n\t\t\t// Cache result of the first split.\n\t\t\tif ( !firstSplitElement && !firstCopyElement ) {\n\t\t\t\tfirstSplitElement = splitElement;\n\t\t\t\tfirstCopyElement = position.parent.nextSibling;\n\t\t\t}\n\n\t\t\tposition = this.createPositionAfter( position.parent );\n\t\t\tsplitElement = position.parent;\n\t\t} while ( splitElement !== limitElement );\n\n\t\treturn {\n\t\t\tposition,\n\t\t\trange: new Range( Position._createAt( firstSplitElement, 'end' ), Position._createAt( firstCopyElement, 0 ) )\n\t\t};\n\t}\n\n\t/**\n\t * Wraps the given range with the given element or with a new element (if a string was passed).\n\t *\n\t * **Note:** range to wrap should be a \"flat range\" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).\n\t * If not, an error will be thrown.\n\t *\n\t * @param {module:engine/model/range~Range} range Range to wrap.\n\t * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.\n\t */\n\twrap( range, elementOrString ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !range.isFlat ) {\n\t\t\t/**\n\t\t\t * Range to wrap is not flat.\n\t\t\t *\n\t\t\t * @error writer-wrap-range-not-flat\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-range-not-flat: Range to wrap is not flat.', this );\n\t\t}\n\n\t\tconst element = elementOrString instanceof Element ? elementOrString : new Element( elementOrString );\n\n\t\tif ( element.childCount > 0 ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is not empty.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-not-empty: Element to wrap with is not empty.', this );\n\t\t}\n\n\t\tif ( element.parent !== null ) {\n\t\t\t/**\n\t\t\t * Element to wrap with is already attached to a tree model.\n\t\t\t *\n\t\t\t * @error writer-wrap-element-attached\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-wrap-element-attached: Element to wrap with is already attached to tree model.', this );\n\t\t}\n\n\t\tthis.insert( element, range.start );\n\n\t\t// Shift the range-to-wrap because we just inserted an element before that range.\n\t\tconst shiftedRange = new Range( range.start.getShiftedBy( 1 ), range.end.getShiftedBy( 1 ) );\n\n\t\tthis.move( shiftedRange, Position._createAt( element, 0 ) );\n\t}\n\n\t/**\n\t * Unwraps children of the given element – all its children are moved before it and then the element is removed.\n\t * Throws error if you try to unwrap an element which does not have a parent.\n\t *\n\t * @param {module:engine/model/element~Element} element Element to unwrap.\n\t */\n\tunwrap( element ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( element.parent === null ) {\n\t\t\t/**\n\t\t\t * Trying to unwrap an element which has no parent.\n\t\t\t *\n\t\t\t * @error writer-unwrap-element-no-parent\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.', this );\n\t\t}\n\n\t\tthis.move( Range._createIn( element ), this.createPositionAfter( element ) );\n\t\tthis.remove( element );\n\t}\n\n\t/**\n\t * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes.\n\t *\n\t * As the first parameter you can set marker name.\n\t *\n\t * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by the\n\t * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Create marker directly base on marker's name:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false } );\n\t *\n\t * Create marker using operation:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Create marker that affects the editor data:\n\t *\n\t *\t\taddMarker( markerName, { range, usingOperation: false, affectsData: true } );\n\t *\n\t * Note: For efficiency reasons, it's best to create and keep as little markers as possible.\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String} name Name of a marker to create - must be unique.\n\t * @param {Object} options\n\t * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {module:engine/model/range~Range} options.range Marker range.\n\t * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.\n\t * @returns {module:engine/model/markercollection~Marker} Marker that was set.\n\t */\n\taddMarker( name, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( !options || typeof options.usingOperation != 'boolean' ) {\n\t\t\t/**\n\t\t\t * The `options.usingOperation` parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addMarker-no-usingOperation\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tconst usingOperation = options.usingOperation;\n\t\tconst range = options.range;\n\t\tconst affectsData = options.affectsData === undefined ? false : options.affectsData;\n\n\t\tif ( this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Marker with provided name already exists.\n\t\t\t *\n\t\t\t * @error writer-addMarker-marker-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-addMarker-marker-exists: Marker with provided name already exists.', this );\n\t\t}\n\n\t\tif ( !range ) {\n\t\t\t/**\n\t\t\t * Range parameter is required when adding a new marker.\n\t\t\t *\n\t\t\t * @error writer-addMarker-no-range\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-addMarker-no-range: Range parameter is required when adding a new marker.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tif ( !usingOperation ) {\n\t\t\treturn this.model.markers._set( name, range, usingOperation, affectsData );\n\t\t}\n\n\t\tapplyMarkerOperation( this, name, null, range, affectsData );\n\n\t\treturn this.model.markers.get( name );\n\t}\n\n\t/**\n\t * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks\n\t * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the\n\t * marker's range directly using this method.\n\t *\n\t * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique\n\t * name is created and returned.\n\t *\n\t * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh\n\t * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change\n\t * the marker {@link module:engine/view/element~Element view element} without changing any marker data.\n\t *\n\t * \t\tlet isCommentActive = false;\n\t *\n\t * \t\tmodel.conversion.markerToHighlight( {\n\t * \t\t\tmodel: 'comment',\n\t *\t\t\tview: data => {\n\t *\t\t\t\tconst classes = [ 'comment-marker' ];\n\t *\n\t *\t\t\t\tif ( isCommentActive ) {\n\t *\t\t\t\t\tclasses.push( 'comment-marker--active' );\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn { classes };\n\t *\t\t\t}\n\t * \t\t} );\n\t *\n\t * \t\t// Change the property that indicates if marker is displayed as active or not.\n\t * \t\tisCommentActive = true;\n\t *\n\t * \t\t// And refresh the marker to convert it with additional class.\n\t * \t\tmodel.change( writer => writer.updateMarker( 'comment' ) );\n\t *\n\t * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See\n\t * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between\n\t * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.\n\t *\n\t * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be\n\t * `true` when the marker change changes the data returned by\n\t * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.\n\t * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.\n\t * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.\n\t *\n\t * Update marker directly base on marker's name:\n\t *\n\t *\t\tupdateMarker( markerName, { range } );\n\t *\n\t * Update marker using operation:\n\t *\n\t *\t\tupdateMarker( marker, { range, usingOperation: true } );\n\t *\t\tupdateMarker( markerName, { range, usingOperation: true } );\n\t *\n\t * Change marker's option (start using operations to manage it):\n\t *\n\t *\t\tupdateMarker( marker, { usingOperation: true } );\n\t *\n\t * Change marker's option (inform the engine, that the marker does not affect the data anymore):\n\t *\n\t *\t\tupdateMarker( markerName, { affectsData: false } );\n\t *\n\t * @see module:engine/model/markercollection~Marker\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.\n\t * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering\n\t * downcast conversion for this marker with the same data.\n\t * @param {module:engine/model/range~Range} [options.range] Marker range to update.\n\t * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.\n\t * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.\n\t * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.\n\t */\n\tupdateMarker( markerOrName, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\t\tconst currentMarker = this.model.markers.get( markerName );\n\n\t\tif ( !currentMarker ) {\n\t\t\t/**\n\t\t\t * Marker with provided name does not exists.\n\t\t\t *\n\t\t\t * @error writer-updateMarker-marker-not-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-updateMarker-marker-not-exists: Marker with provided name does not exists.', this );\n\t\t}\n\n\t\tif ( !options ) {\n\t\t\tthis.model.markers._refresh( currentMarker );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst hasUsingOperationDefined = typeof options.usingOperation == 'boolean';\n\t\tconst affectsDataDefined = typeof options.affectsData == 'boolean';\n\n\t\t// Use previously defined marker's affectsData if the property is not provided.\n\t\tconst affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;\n\n\t\tif ( !hasUsingOperationDefined && !options.range && !affectsDataDefined ) {\n\t\t\t/**\n\t\t\t * One of the options is required - provide range, usingOperations or affectsData.\n\t\t\t *\n\t\t\t * @error writer-updateMarker-wrong-options\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tconst currentRange = currentMarker.getRange();\n\t\tconst updatedRange = options.range ? options.range : currentRange;\n\n\t\tif ( hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations ) {\n\t\t\t// The marker type is changed so it's necessary to create proper operations.\n\t\t\tif ( options.usingOperation ) {\n\t\t\t\t// If marker changes to a managed one treat this as synchronizing existing marker.\n\t\t\t\t// Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.\n\t\t\t\tapplyMarkerOperation( this, markerName, null, updatedRange, affectsData );\n\t\t\t} else {\n\t\t\t\t// If marker changes to a marker that do not use operations then we need to create additional operation\n\t\t\t\t// that removes that marker first.\n\t\t\t\tapplyMarkerOperation( this, markerName, currentRange, null, affectsData );\n\n\t\t\t\t// Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.\n\t\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Marker's type doesn't change so update it accordingly.\n\t\tif ( currentMarker.managedUsingOperations ) {\n\t\t\tapplyMarkerOperation( this, markerName, currentRange, updatedRange, affectsData );\n\t\t} else {\n\t\t\tthis.model.markers._set( markerName, updatedRange, undefined, affectsData );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.\n\t * The marker is removed accordingly to how it has been created, so if the marker was created using operation,\n\t * it will be destroyed using operation.\n\t *\n\t * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.\n\t */\n\tremoveMarker( markerOrName ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tconst name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;\n\n\t\tif ( !this.model.markers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to remove marker which does not exist.\n\t\t\t *\n\t\t\t * @error writer-removeMarker-no-marker\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'writer-removeMarker-no-marker: Trying to remove marker which does not exist.', this );\n\t\t}\n\n\t\tconst marker = this.model.markers.get( name );\n\n\t\tif ( !marker.managedUsingOperations ) {\n\t\t\tthis.model.markers._remove( name );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst oldRange = marker.getRange();\n\n\t\tapplyMarkerOperation( this, name, oldRange, null, marker.affectsData );\n\t}\n\n\t/**\n\t * Sets the document's selection (ranges and direction) to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\twriter.setSelection( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\twriter.setSelection( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPosition( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link #createPositionAt `writer.createPositionAt()`} parameters.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tthis.model.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * Using key and value pair:\n\t *\n\t * \twriter.setSelectionAttribute( 'italic', true );\n\t *\n\t * Using key-value object:\n\t *\n\t * \twriter.setSelectionAttribute( { italic: true, bold: false } );\n\t *\n\t * Using iterable object:\n\t *\n\t * \twriter.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );\n\t *\n\t * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set\n\t * or object / iterable of key => value attribute pairs.\n\t * @param {*} [value] Attribute value.\n\t */\n\tsetSelectionAttribute( keyOrObjectOrIterable, value ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrObjectOrIterable === 'string' ) {\n\t\t\tthis._setSelectionAttribute( keyOrObjectOrIterable, value );\n\t\t} else {\n\t\t\tfor ( const [ key, value ] of toMap( keyOrObjectOrIterable ) ) {\n\t\t\t\tthis._setSelectionAttribute( key, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes attribute(s) with given key(s) from the selection.\n\t *\n\t * Remove one attribute:\n\t *\n\t *\t\twriter.removeSelectionAttribute( 'italic' );\n\t *\n\t * Remove multiple attributes:\n\t *\n\t *\t\twriter.removeSelectionAttribute( [ 'italic', 'bold' ] );\n\t *\n\t * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.\n\t */\n\tremoveSelectionAttribute( keyOrIterableOfKeys ) {\n\t\tthis._assertWriterUsedCorrectly();\n\n\t\tif ( typeof keyOrIterableOfKeys === 'string' ) {\n\t\t\tthis._removeSelectionAttribute( keyOrIterableOfKeys );\n\t\t} else {\n\t\t\tfor ( const key of keyOrIterableOfKeys ) {\n\t\t\t\tthis._removeSelectionAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}\n\t * of the selection from left to right.\n\t *\n\t * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,\n\t * then the selection (after being moved by the user) inherits attributes from its left-hand side.\n\t * This method allows to temporarily override this behavior by forcing the gravity to the right.\n\t *\n\t * For the following model fragment:\n\t *\n\t *\t\t<$text bold=\"true\" linkHref=\"url\">bar[]</$text><$text bold=\"true\">biz</$text>\n\t *\n\t * * Default gravity: selection will have the `bold` and `linkHref` attributes.\n\t * * Overridden gravity: selection will have `bold` attribute.\n\t *\n\t * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry\n\t * of the process.\n\t *\n\t * @returns {String} The unique id which allows restoring the gravity.\n\t */\n\toverrideSelectionGravity() {\n\t\treturn this.model.document.selection._overrideGravity();\n\t}\n\n\t/**\n\t * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.\n\t *\n\t * Restoring the gravity is only possible using the unique identifier returned by\n\t * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored\n\t * the same number of times it was overridden.\n\t *\n\t * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.\n\t */\n\trestoreSelectionGravity( uid ) {\n\t\tthis.model.document.selection._restoreGravity( uid );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t * @param {*} value Attribute value.\n\t */\n\t_setSelectionAttribute( key, value ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Store attribute in parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.setAttribute( storeKey, value, selection.anchor.parent );\n\t\t}\n\n\t\tselection._setAttribute( key, value );\n\t}\n\n\t/**\n\t * @private\n\t * @param {String} key Key of the attribute to remove.\n\t */\n\t_removeSelectionAttribute( key ) {\n\t\tconst selection = this.model.document.selection;\n\n\t\t// Remove stored attribute from parent element if the selection is collapsed in an empty node.\n\t\tif ( selection.isCollapsed && selection.anchor.parent.isEmpty ) {\n\t\t\tconst storeKey = DocumentSelection._getStoreAttributeKey( key );\n\n\t\t\tthis.removeAttribute( storeKey, selection.anchor.parent );\n\t\t}\n\n\t\tselection._removeAttribute( key );\n\t}\n\n\t/**\n\t * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.\n\t *\n\t * @private\n\t */\n\t_assertWriterUsedCorrectly() {\n\t\t/**\n\t\t * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.\n\t\t *\n\t\t * The writer can only be used inside these blocks which ensures that the model\n\t\t * can only be changed during such \"sessions\".\n\t\t *\n\t\t * @error writer-incorrect-use\n\t\t */\n\t\tif ( this.model._currentWriter !== this ) {\n\t\t\tthrow new CKEditorError( 'writer-incorrect-use: Trying to use a writer outside the change() block.', this );\n\t\t}\n\t}\n\n\t/**\n\t * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers\n\t * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range\n\t * can be later correctly processed during undo.\n\t *\n\t * @private\n\t * @param {'move'|'merge'} type Writer action type.\n\t * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range\n\t * where the writer action happens.\n\t */\n\t_addOperationForAffectedMarkers( type, positionOrRange ) {\n\t\tfor ( const marker of this.model.markers ) {\n\t\t\tif ( !marker.managedUsingOperations ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst markerRange = marker.getRange();\n\t\t\tlet isAffected = false;\n\n\t\t\tif ( type == 'move' ) {\n\t\t\t\tisAffected =\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.start.isEqual( markerRange.start ) ||\n\t\t\t\t\tpositionOrRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\tpositionOrRange.end.isEqual( markerRange.end );\n\t\t\t} else {\n\t\t\t\t// if type == 'merge'.\n\t\t\t\tconst elementBefore = positionOrRange.nodeBefore;\n\t\t\t\tconst elementAfter = positionOrRange.nodeAfter;\n\n\t\t\t\t//               Start:  <p>Foo[</p><p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;\n\n\t\t\t\t//               Start:  <p>[Foo</p><p>]Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;\n\n\t\t\t\t//               Start:  <p>[Foo</p>]<p>Bar</p>\n\t\t\t\t//         After merge:  <p>[Foo]Bar</p>\n\t\t\t\t// After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;\n\n\t\t\t\t//               Start:  <p>Foo</p>[<p>Bar]</p>\n\t\t\t\t//         After merge:  <p>Foo[Bar]</p>\n\t\t\t\t// After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.\n\t\t\t\t//\n\t\t\t\tconst affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;\n\n\t\t\t\tisAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;\n\t\t\t}\n\n\t\t\tif ( isAffected ) {\n\t\t\t\tthis.updateMarker( marker.name, { range: markerRange } );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.\n//\n// Because attribute operation needs to have the same attribute value on the whole range, this function splits\n// the range into smaller parts.\n//\n// Given `range` must be flat.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.\nfunction setAttributeOnRange( writer, key, value, range ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\t// Position of the last split, the beginning of the new range.\n\tlet lastSplitPosition = range.start;\n\n\t// Currently position in the scanning range. Because we need value after the position, it is not a current\n\t// position of the iterator but the previous one (we need to iterate one more time to get the value after).\n\tlet position;\n\n\t// Value before the currently position.\n\tlet valueBefore;\n\n\t// Value after the currently position.\n\tlet valueAfter;\n\n\tfor ( const val of range.getWalker( { shallow: true } ) ) {\n\t\tvalueAfter = val.item.getAttribute( key );\n\n\t\t// At the first run of the iterator the position in undefined. We also do not have a valueBefore, but\n\t\t// because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).\n\t\tif ( position && valueBefore != valueAfter ) {\n\t\t\t// if valueBefore == value there is nothing to change, so we add operation only if these values are different.\n\t\t\tif ( valueBefore != value ) {\n\t\t\t\taddOperation();\n\t\t\t}\n\n\t\t\tlastSplitPosition = position;\n\t\t}\n\n\t\tposition = val.nextPosition;\n\t\tvalueBefore = valueAfter;\n\t}\n\n\t// Because position in the loop is not the iterator position (see let position comment), the last position in\n\t// the while loop will be last but one position in the range. We need to check the last position manually.\n\tif ( position instanceof Position && position != lastSplitPosition && valueBefore != value ) {\n\t\taddOperation();\n\t}\n\n\tfunction addOperation() {\n\t\tconst range = new Range( lastSplitPosition, position );\n\t\tconst version = range.root.document ? doc.version : null;\n\t\tconst operation = new AttributeOperation( range, key, valueBefore, value, version );\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Sets given attribute to the given node. When attribute value is null then attribute will be removed.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} key Attribute key.\n// @param {*} value Attribute new value.\n// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.\nfunction setAttributeOnItem( writer, key, value, item ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\tconst previousValue = item.getAttribute( key );\n\tlet range, operation;\n\n\tif ( previousValue != value ) {\n\t\tconst isRootChanged = item.root === item;\n\n\t\tif ( isRootChanged ) {\n\t\t\t// If we change attributes of root element, we have to use `RootAttributeOperation`.\n\t\t\tconst version = item.document ? doc.version : null;\n\n\t\t\toperation = new RootAttributeOperation( item, key, previousValue, value, version );\n\t\t} else {\n\t\t\trange = new Range( Position._createBefore( item ), writer.createPositionAfter( item ) );\n\n\t\t\tconst version = range.root.document ? doc.version : null;\n\n\t\t\toperation = new AttributeOperation( range, key, previousValue, value, version );\n\t\t}\n\n\t\twriter.batch.addOperation( operation );\n\t\tmodel.applyOperation( operation );\n\t}\n}\n\n// Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.\n//\n// @private\n// @param {module:engine/model/writer~Writer} writer\n// @param {String} name Marker name.\n// @param {module:engine/model/range~Range} oldRange Marker range before the change.\n// @param {module:engine/model/range~Range} newRange Marker range after the change.\n// @param {Boolean} affectsData\nfunction applyMarkerOperation( writer, name, oldRange, newRange, affectsData ) {\n\tconst model = writer.model;\n\tconst doc = model.document;\n\n\tconst operation = new MarkerOperation( name, oldRange, newRange, model.markers, affectsData, doc.version );\n\n\twriter.batch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.\n// The operation will be applied on given model instance and added to given operation instance.\n//\n// @private\n// @param {module:engine/model/position~Position} position Position from which nodes are removed.\n// @param {Number} howMany Number of nodes to remove.\n// @param {Batch} batch Batch to which the operation will be added.\n// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.\nfunction applyRemoveOperation( position, howMany, batch, model ) {\n\tlet operation;\n\n\tif ( position.root.document ) {\n\t\tconst doc = model.document;\n\t\tconst graveyardPosition = new Position( doc.graveyard, [ 0 ] );\n\n\t\toperation = new MoveOperation( position, howMany, graveyardPosition, doc.version );\n\t} else {\n\t\toperation = new DetachOperation( position, howMany );\n\t}\n\n\tbatch.addOperation( operation );\n\tmodel.applyOperation( operation );\n}\n\n// Returns `true` if both root elements are the same element or both are documents root elements.\n//\n// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or\n// within the same document fragment), but when element supposed to be moved from document fragment to the document, or\n// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or\n// collaboration may track changes on the document but ignore changes on detached fragments and should not get\n// unexpected `move` operation.\nfunction isSameTree( rootA, rootB ) {\n\t// If it is the same root this is the same tree.\n\tif ( rootA === rootB ) {\n\t\treturn true;\n\t}\n\n\t// If both roots are documents root it is operation within the document what we still treat as the same tree.\n\tif ( rootA instanceof RootElement && rootB instanceof RootElement ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]}]}