{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\controller\\datacontroller.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\controller\\datacontroller.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnRyb2xsZXIvZGF0YWNvbnRyb2xsZXIKICovCmltcG9ydCBtaXggZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvbWl4JzsKaW1wb3J0IE9ic2VydmFibGVNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9vYnNlcnZhYmxlbWl4aW4nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IE1hcHBlciBmcm9tICcuLi9jb252ZXJzaW9uL21hcHBlcic7CmltcG9ydCBEb3duY2FzdERpc3BhdGNoZXIgZnJvbSAnLi4vY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXInOwppbXBvcnQgeyBpbnNlcnRUZXh0IH0gZnJvbSAnLi4vY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnMnOwppbXBvcnQgVXBjYXN0RGlzcGF0Y2hlciBmcm9tICcuLi9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXInOwppbXBvcnQgeyBjb252ZXJ0VGV4dCwgY29udmVydFRvTW9kZWxGcmFnbWVudCB9IGZyb20gJy4uL2NvbnZlcnNpb24vdXBjYXN0aGVscGVycyc7CmltcG9ydCBWaWV3RG9jdW1lbnRGcmFnbWVudCBmcm9tICcuLi92aWV3L2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgVmlld0RvY3VtZW50IGZyb20gJy4uL3ZpZXcvZG9jdW1lbnQnOwppbXBvcnQgVmlld0Rvd25jYXN0V3JpdGVyIGZyb20gJy4uL3ZpZXcvZG93bmNhc3R3cml0ZXInOwppbXBvcnQgTW9kZWxSYW5nZSBmcm9tICcuLi9tb2RlbC9yYW5nZSc7Ci8qKgogKiBDb250cm9sbGVyIGZvciB0aGUgZGF0YSBwaXBlbGluZS4gVGhlIGRhdGEgcGlwZWxpbmUgY29udHJvbHMgaG93IGRhdGEgaXMgcmV0cmlldmVkIGZyb20gdGhlIGRvY3VtZW50CiAqIGFuZCBzZXQgaW5zaWRlIGl0LiBIZW5jZSwgdGhlIGNvbnRyb2xsZXIgZmVhdHVyZXMgdHdvIG1ldGhvZHMgd2hpY2ggYWxsb3cgdG8ge0BsaW5rIH5EYXRhQ29udHJvbGxlciNnZXQgZ2V0fQogKiBhbmQge0BsaW5rIH5EYXRhQ29udHJvbGxlciNzZXQgc2V0fSBkYXRhIG9mIHRoZSB7QGxpbmsgfkRhdGFDb250cm9sbGVyI21vZGVsIG1vZGVsfQogKiB1c2luZyBnaXZlbjoKICoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9kYXRhcHJvY2Vzc29yL2RhdGFwcm9jZXNzb3J+RGF0YVByb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0sCiAqICogZG93bmNhc3QgY29udmVydGVycywKICogKiB1cGNhc3QgY29udmVydGVycy4KICoKICogQW4gaW5zdGFuY2Ugb2YgdGhlIGRhdGEgY29udHJvbGxlciBpcyBhbHdheXMgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL2VkaXRvcn5FZGl0b3IjZGF0YSBgZWRpdG9yLmRhdGFgfQogKiBwcm9wZXJ0eToKICoKICoJCWVkaXRvci5kYXRhLmdldCggeyByb290TmFtZTogJ2N1c3RvbVJvb3QnIH0gKTsgLy8gLT4gJzxwPkhlbGxvITwvcD4nCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbgogKi8KCnZhciBEYXRhQ29udHJvbGxlciA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSBkYXRhIGNvbnRyb2xsZXIgaW5zdGFuY2UuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIERhdGEgbW9kZWwuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc1Byb2Nlc3Nvcn0gc3R5bGVzUHJvY2Vzc29yIFRoZSBzdHlsZXMgcHJvY2Vzc29yIGluc3RhbmNlLgogICAqLwogIGZ1bmN0aW9uIERhdGFDb250cm9sbGVyKG1vZGVsLCBzdHlsZXNQcm9jZXNzb3IpIHsKICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFDb250cm9sbGVyKTsKCiAgICAvKioKICAgICAqIERhdGEgbW9kZWwuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfQogICAgICovCiAgICB0aGlzLm1vZGVsID0gbW9kZWw7CiAgICAvKioKICAgICAqIFN0eWxlcyBwcm9jZXNzb3IgdXNlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc1Byb2Nlc3Nvcn0KICAgICAqLwoKICAgIHRoaXMuc3R5bGVzUHJvY2Vzc29yID0gc3R5bGVzUHJvY2Vzc29yOwogICAgLyoqCiAgICAgKiBEYXRhIHByb2Nlc3NvciB1c2VkIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgICAqCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2RhdGFwcm9jZXNzb3IvZGF0YXByb2Nlc3Nvcn5EYXRhUHJvY2Vzc29yfSAjcHJvY2Vzc29yCiAgICAgKi8KCiAgICB0aGlzLnByb2Nlc3NvcjsKICAgIC8qKgogICAgICogTWFwcGVyIHVzZWQgZm9yIHRoZSBjb252ZXJzaW9uLiBJdCBoYXMgbm8gcGVybWFuZW50IGJpbmRpbmdzLCBiZWNhdXNlIHRoZXkgYXJlIGNyZWF0ZWQgd2hlbiBnZXR0aW5nIGRhdGEgYW5kCiAgICAgKiBjbGVhcmVkIGRpcmVjdGx5IGFmdGVyIHRoZSBkYXRhIGFyZSBjb252ZXJ0ZWQuIEhvd2V2ZXIsIHRoZSBtYXBwZXIgaXMgZGVmaW5lZCBhcyBhIGNsYXNzIHByb3BlcnR5LCBiZWNhdXNlCiAgICAgKiBpdCBuZWVkcyB0byBiZSBwYXNzZWQgdG8gdGhlIGBEb3duY2FzdERpc3BhdGNoZXJgIGFzIGEgY29udmVyc2lvbiBBUEkuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0KICAgICAqLwoKICAgIHRoaXMubWFwcGVyID0gbmV3IE1hcHBlcigpOwogICAgLyoqCiAgICAgKiBEb3duY2FzdCBkaXNwYXRjaGVyIHVzZWQgYnkgdGhlIHtAbGluayAjZ2V0IGdldCBtZXRob2R9LiBEb3duY2FzdCBjb252ZXJ0ZXJzIHNob3VsZCBiZSBhdHRhY2hlZCB0byBpdC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfQogICAgICovCgogICAgdGhpcy5kb3duY2FzdERpc3BhdGNoZXIgPSBuZXcgRG93bmNhc3REaXNwYXRjaGVyKHsKICAgICAgbWFwcGVyOiB0aGlzLm1hcHBlcgogICAgfSk7CiAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5vbignaW5zZXJ0OiR0ZXh0JywgaW5zZXJ0VGV4dCgpLCB7CiAgICAgIHByaW9yaXR5OiAnbG93ZXN0JwogICAgfSk7CiAgICAvKioKICAgICAqIFVwY2FzdCBkaXNwYXRjaGVyIHVzZWQgYnkgdGhlIHtAbGluayAjc2V0IHNldCBtZXRob2R9LiBVcGNhc3QgY29udmVydGVycyBzaG91bGQgYmUgYXR0YWNoZWQgdG8gaXQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyfQogICAgICovCgogICAgdGhpcy51cGNhc3REaXNwYXRjaGVyID0gbmV3IFVwY2FzdERpc3BhdGNoZXIoewogICAgICBzY2hlbWE6IG1vZGVsLnNjaGVtYQogICAgfSk7CiAgICAvKioKICAgICAqIFRoZSB2aWV3IGRvY3VtZW50IHVzZWQgYnkgdGhlIGRhdGEgY29udHJvbGxlci4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwoKICAgIHRoaXMudmlld0RvY3VtZW50ID0gbmV3IFZpZXdEb2N1bWVudChzdHlsZXNQcm9jZXNzb3IpOwogICAgLyoqCiAgICAgKiBUaGUgdmlldyBkb3duY2FzdCB3cml0ZXIganVzdCBmb3IgZGF0YSBjb252ZXJzaW9uIHB1cnBvc2VzLCBpLmUuIHRvIG1vZGlmeQogICAgICogdGhlIHtAbGluayAjdmlld0RvY3VtZW50fS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9CiAgICAgKi8KCiAgICB0aGlzLl92aWV3V3JpdGVyID0gbmV3IFZpZXdEb3duY2FzdFdyaXRlcih0aGlzLnZpZXdEb2N1bWVudCk7IC8vIERlZmluZSBkZWZhdWx0IGNvbnZlcnRlcnMgZm9yIHRleHQgYW5kIGVsZW1lbnRzLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IGNvbnZlcnRlciBmb3IgdGhlIGVsZW1lbnQgaXQgd2lsbCBiZSBza2lwcGVkLCBmb3IgaW5zdGFuY2UgYDxiPmZvbzwvYj5gIHdpbGwgYmUKICAgIC8vIGNvbnZlcnRlZCB0byBub3RoaW5nLiBXZSBhZGQgYGNvbnZlcnRUb01vZGVsRnJhZ21lbnRgIGFzIGEgbGFzdCBjb252ZXJ0ZXIgc28gaXQgY29udmVydHMgY2hpbGRyZW4gb2YgdGhhdAogICAgLy8gZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgZnJhZ21lbnQgc28gYDxiPmZvbzwvYj5gIHdpbGwgYmUgY29udmVydGVkIHRvIGBmb29gIGlmIHRoZXJlIGlzIG5vIGNvbnZlcnRlciBmb3IgYDxiPmAuCgogICAgdGhpcy51cGNhc3REaXNwYXRjaGVyLm9uKCd0ZXh0JywgY29udmVydFRleHQoKSwgewogICAgICBwcmlvcml0eTogJ2xvd2VzdCcKICAgIH0pOwogICAgdGhpcy51cGNhc3REaXNwYXRjaGVyLm9uKCdlbGVtZW50JywgY29udmVydFRvTW9kZWxGcmFnbWVudCgpLCB7CiAgICAgIHByaW9yaXR5OiAnbG93ZXN0JwogICAgfSk7CiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIub24oJ2RvY3VtZW50RnJhZ21lbnQnLCBjb252ZXJ0VG9Nb2RlbEZyYWdtZW50KCksIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsKICAgIHRoaXMuZGVjb3JhdGUoJ2luaXQnKTsgLy8gRmlyZSBgcmVhZHlgIGV2ZW50IHdoZW4gaW5pdGlhbGlzYXRpb24gaGFzIGNvbXBsZXRlZC4gU3VjaCBsb3cgbGV2ZWwgbGlzdGVuZXIgZ2l2ZXMgcG9zc2liaWxpdHkKICAgIC8vIHRvIHBsdWcgaW50byBpbml0aWFsaXNhdGlvbiBwaXBlbGluZSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgaW5pdGlhbGlzYXRpb24gZmxvdy4KCiAgICB0aGlzLm9uKCdpbml0JywgZnVuY3Rpb24gKCkgewogICAgICBfdGhpcy5maXJlKCdyZWFkeScpOwogICAgfSwgewogICAgICBwcmlvcml0eTogJ2xvd2VzdCcKICAgIH0pOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBtb2RlbCdzIGRhdGEgY29udmVydGVkIGJ5IGRvd25jYXN0IGRpc3BhdGNoZXJzIGF0dGFjaGVkIHRvIHtAbGluayAjZG93bmNhc3REaXNwYXRjaGVyfSBhbmQKICAgKiBmb3JtYXR0ZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfS4KICAgKgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucm9vdE5hbWU9J21haW4nXSBSb290IG5hbWUuCiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyaW09J2VtcHR5J10gV2hldGhlciByZXR1cm5lZCBkYXRhIHNob3VsZCBiZSB0cmltbWVkLiBUaGlzIG9wdGlvbiBpcyBzZXQgdG8gYGVtcHR5YCBieSBkZWZhdWx0LAogICAqIHdoaWNoIG1lYW5zIHdoZW5ldmVyIGVkaXRvciBjb250ZW50IGlzIGNvbnNpZGVyZWQgZW1wdHksIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIHJldHVybmVkLiBUbyB0dXJuIG9mZiB0cmltbWluZyBjb21wbGV0ZWx5CiAgICogdXNlIGAnbm9uZSdgLiBJbiBzdWNoIGNhc2VzIGV4YWN0IGNvbnRlbnQgd2lsbCBiZSByZXR1cm5lZCAoZm9yIGV4YW1wbGUgYDxwPiZuYnNwOzwvcD5gIGZvciBhbiBlbXB0eSBlZGl0b3IpLgogICAqIEByZXR1cm5zIHtTdHJpbmd9IE91dHB1dCBkYXRhLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKERhdGFDb250cm9sbGVyLCBbewogICAga2V5OiAiZ2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQob3B0aW9ucykgewogICAgICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sCiAgICAgICAgICBfcmVmJHJvb3ROYW1lID0gX3JlZi5yb290TmFtZSwKICAgICAgICAgIHJvb3ROYW1lID0gX3JlZiRyb290TmFtZSA9PT0gdm9pZCAwID8gJ21haW4nIDogX3JlZiRyb290TmFtZSwKICAgICAgICAgIF9yZWYkdHJpbSA9IF9yZWYudHJpbSwKICAgICAgICAgIHRyaW0gPSBfcmVmJHRyaW0gPT09IHZvaWQgMCA/ICdlbXB0eScgOiBfcmVmJHRyaW07CgogICAgICBpZiAoIXRoaXMuX2NoZWNrSWZSb290c0V4aXN0cyhbcm9vdE5hbWVdKSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBnZXQgZGF0YSBmcm9tIGEgbm9uLWV4aXN0aW5nIHJvb3QuIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4ge0BsaW5rICNnZXQgRGF0YUNvbnRyb2xsZXIjZ2V0KCkgbWV0aG9kfQogICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIG5vbi1leGlzdGVudCByb290IG5hbWUuIEZvciBleGFtcGxlLCBpZiB0aGVyZSBpcyBhbiBlZGl0b3IgaW5zdGFuY2Ugd2l0aCBvbmx5IGBtYWluYCByb290LAogICAgICAgICAqIGNhbGxpbmcge0BsaW5rICNnZXR9IGxpa2U6CiAgICAgICAgICoKICAgICAgICAgKgkJZGF0YS5nZXQoIHsgcm9vdE5hbWU6ICdyb290MicgfSApOwogICAgICAgICAqCiAgICAgICAgICogd2lsbCB0aHJvdyB0aGlzIGVycm9yLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIGRhdGFjb250cm9sbGVyLWdldC1ub24tZXhpc3RlbnQtcm9vdAogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdkYXRhY29udHJvbGxlci1nZXQtbm9uLWV4aXN0ZW50LXJvb3Q6IEF0dGVtcHRpbmcgdG8gZ2V0IGRhdGEgZnJvbSBhIG5vbi1leGlzdGluZyByb290LicsIHRoaXMpOwogICAgICB9CgogICAgICB2YXIgcm9vdCA9IHRoaXMubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSk7CgogICAgICBpZiAodHJpbSA9PT0gJ2VtcHR5JyAmJiAhdGhpcy5tb2RlbC5oYXNDb250ZW50KHJvb3QsIHsKICAgICAgICBpZ25vcmVXaGl0ZXNwYWNlczogdHJ1ZQogICAgICB9KSkgewogICAgICAgIHJldHVybiAnJzsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KHJvb3QpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgbW9kZWwncyBlbGVtZW50fSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fSBjb252ZXJ0ZWQgYnkgdGhlIGRvd25jYXN0IGNvbnZlcnRlcnMKICAgICAqIGF0dGFjaGVkIHRvIHtAbGluayAjZG93bmNhc3REaXNwYXRjaGVyfSBhbmQgZm9ybWF0dGVkIGJ5IHRoZSB7QGxpbmsgI3Byb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gbW9kZWxFbGVtZW50T3JGcmFnbWVudAogICAgICogRWxlbWVudCB3aG9zZSBjb250ZW50IHdpbGwgYmUgc3RyaW5naWZpZWQuCiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBPdXRwdXQgZGF0YS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzdHJpbmdpZnkiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZ2lmeShtb2RlbEVsZW1lbnRPckZyYWdtZW50KSB7CiAgICAgIC8vIE1vZGVsIC0+IHZpZXcuCiAgICAgIHZhciB2aWV3RG9jdW1lbnRGcmFnbWVudCA9IHRoaXMudG9WaWV3KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpOyAvLyBWaWV3IC0+IGRhdGEuCgogICAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3IudG9EYXRhKHZpZXdEb2N1bWVudEZyYWdtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IG1vZGVsIGVsZW1lbnR9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgbW9kZWwgZG9jdW1lbnQgZnJhZ21lbnR9IGNvbnZlcnRlZCBieSB0aGUgZG93bmNhc3QKICAgICAqIGNvbnZlcnRlcnMgYXR0YWNoZWQgdG8ge0BsaW5rICNkb3duY2FzdERpc3BhdGNoZXJ9IHRvIGEKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IHZpZXcgZG9jdW1lbnQgZnJhZ21lbnR9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IG1vZGVsRWxlbWVudE9yRnJhZ21lbnQKICAgICAqIEVsZW1lbnQgb3IgZG9jdW1lbnQgZnJhZ21lbnQgd2hvc2UgY29udGVudCB3aWxsIGJlIGNvbnZlcnRlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBPdXRwdXQgdmlldyBEb2N1bWVudEZyYWdtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9WaWV3KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpIHsKICAgICAgdmFyIHZpZXdEb2N1bWVudCA9IHRoaXMudmlld0RvY3VtZW50OwogICAgICB2YXIgdmlld1dyaXRlciA9IHRoaXMuX3ZpZXdXcml0ZXI7IC8vIENsZWFyIGJpbmRpbmdzIHNvIHRoZSBjYWxsIHRvIHRoaXMgbWV0aG9kIGdpdmVzIGNvcnJlY3QgcmVzdWx0cy4KCiAgICAgIHRoaXMubWFwcGVyLmNsZWFyQmluZGluZ3MoKTsgLy8gRmlyc3QsIGNvbnZlcnQgZWxlbWVudHMuCgogICAgICB2YXIgbW9kZWxSYW5nZSA9IE1vZGVsUmFuZ2UuX2NyZWF0ZUluKG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpOwoKICAgICAgdmFyIHZpZXdEb2N1bWVudEZyYWdtZW50ID0gbmV3IFZpZXdEb2N1bWVudEZyYWdtZW50KHZpZXdEb2N1bWVudCk7CiAgICAgIHRoaXMubWFwcGVyLmJpbmRFbGVtZW50cyhtb2RlbEVsZW1lbnRPckZyYWdtZW50LCB2aWV3RG9jdW1lbnRGcmFnbWVudCk7IC8vIFdlIGhhdmUgbm8gdmlldyBjb250cm9sbGVyIGFuZCByZW5kZXJpbmcgZG8gRE9NIGluIERhdGFDb250cm9sbGVyIHNvIHZpZXcuY2hhbmdlKCkgYmxvY2sgaXMgbm90IHVzZWQgaGVyZS4KCiAgICAgIHRoaXMuZG93bmNhc3REaXNwYXRjaGVyLmNvbnZlcnRJbnNlcnQobW9kZWxSYW5nZSwgdmlld1dyaXRlcik7CgogICAgICBpZiAoIW1vZGVsRWxlbWVudE9yRnJhZ21lbnQuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgIC8vIFRoZW4sIGlmIGEgZG9jdW1lbnQgZWxlbWVudCBpcyBjb252ZXJ0ZWQsIGNvbnZlcnQgbWFya2Vycy4KICAgICAgICAvLyBGcm9tIGFsbCBkb2N1bWVudCBtYXJrZXJzLCBnZXQgdGhvc2UsIHdoaWNoICJpbnRlcnNlY3QiIHdpdGggdGhlIGNvbnZlcnRlciBlbGVtZW50LgogICAgICAgIHZhciBtYXJrZXJzID0gX2dldE1hcmtlcnNSZWxhdGl2ZVRvRWxlbWVudChtb2RlbEVsZW1lbnRPckZyYWdtZW50KTsKCiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG1hcmtlcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSwKICAgICAgICAgICAgICAgIG5hbWUgPSBfc3RlcCR2YWx1ZVswXSwKICAgICAgICAgICAgICAgIHJhbmdlID0gX3N0ZXAkdmFsdWVbMV07CgogICAgICAgICAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5jb252ZXJ0TWFya2VyQWRkKG5hbWUsIHJhbmdlLCB2aWV3V3JpdGVyKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHsKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHZpZXdEb2N1bWVudEZyYWdtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGluaXRpYWwgaW5wdXQgZGF0YSBwYXJzZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfSBhbmQKICAgICAqIGNvbnZlcnRlZCBieSB0aGUge0BsaW5rICN1cGNhc3REaXNwYXRjaGVyIHZpZXctdG8tbW9kZWwgY29udmVydGVyc30uCiAgICAgKiBJbml0aWFsIGRhdGEgY2FuIGJlIHNldCBvbmx5IHRvIGRvY3VtZW50IHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjdmVyc2lvbn0gaXMgZXF1YWwgMC4KICAgICAqCiAgICAgKiAqKk5vdGUqKiBUaGlzIG1ldGhvZCBpcyB7QGxpbmsgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4jZGVjb3JhdGUgZGVjb3JhdGVkfSB3aGljaCBpcwogICAgICogdXNlZCBieSBlLmcuIGNvbGxhYm9yYXRpdmUgZWRpdGluZyBwbHVnaW4gdGhhdCBzeW5jcyByZW1vdGUgZGF0YSBvbiBpbml0LgogICAgICoKICAgICAqIFdoZW4gZGF0YSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcgaXQgaXMgaW5pdGlhbGl6ZWQgb24gYSBkZWZhdWx0IGBtYWluYCByb290OgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5pbml0KCAnPHA+Rm9vPC9wPicgKTsgLy8gSW5pdGlhbGl6ZXMgZGF0YSBvbiB0aGUgYG1haW5gIHJvb3QuCiAgICAgKgogICAgICogVG8gaW5pdGlhbGl6ZSBkYXRhIG9uIGEgZGlmZmVyZW50IHJvb3Qgb3IgbXVsdGlwbGUgcm9vdHMgYXQgb25jZSwgb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYCBwYWlycyBzaG91bGQgYmUgcGFzc2VkOgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5pbml0KCB7IG1haW46ICc8cD5Gb288L3A+JywgdGl0bGU6ICc8aDE+QmFyPC9oMT4nIH0gKTsgLy8gSW5pdGlhbGl6ZXMgZGF0YSBvbiB0aGUgYG1haW5gIGFuZCBgdGl0bGVgIHJvb3RzLgogICAgICoKICAgICAqIEBmaXJlcyBpbml0CiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZyxTdHJpbmc+fSBkYXRhIElucHV0IGRhdGEgYXMgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYAogICAgICogcGFpcnMgdG8gaW5pdGlhbGl6ZSBkYXRhIG9uIG11bHRpcGxlIHJvb3RzIGF0IG9uY2UuCiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIGFmdGVyIHRoZSBkYXRhIGlzIHNldCBvbiB0aGUgZWRpdG9yLgogICAgICovCgogIH0sIHsKICAgIGtleTogImluaXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoZGF0YSkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIGlmICh0aGlzLm1vZGVsLmRvY3VtZW50LnZlcnNpb24pIHsKICAgICAgICAvKioKICAgICAgICAgKiBDYW5ub3Qgc2V0IGluaXRpYWwgZGF0YSB0byBub3QgZW1wdHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9LgogICAgICAgICAqIEluaXRpYWwgZGF0YSBzaG91bGQgYmUgc2V0IG9uY2UsIGR1cmluZyB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL2VkaXRvcn5FZGl0b3J9IGluaXRpYWxpemF0aW9uLAogICAgICAgICAqIHdoZW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3ZlcnNpb259IGlzIGVxdWFsIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItaW5pdC1kb2N1bWVudC1ub3QtZW1wdHkKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItaW5pdC1kb2N1bWVudC1ub3QtZW1wdHk6IFRyeWluZyB0byBzZXQgaW5pdGlhbCBkYXRhIHRvIG5vdCBlbXB0eSBkb2N1bWVudC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgdmFyIGluaXRpYWxEYXRhID0ge307CgogICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgaW5pdGlhbERhdGEubWFpbiA9IGRhdGE7IC8vIERlZmF1bHQgcm9vdCBpcyAnbWFpbicuIFRvIGluaXRpYXRlIGRhdGEgb24gYSBkaWZmZXJlbnQgcm9vdCwgb2JqZWN0IHNob3VsZCBiZSBwYXNzZWQuCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW5pdGlhbERhdGEgPSBkYXRhOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuX2NoZWNrSWZSb290c0V4aXN0cyhPYmplY3Qua2V5cyhpbml0aWFsRGF0YSkpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGluaXQgZGF0YSBvbiBhIG5vbi1leGlzdGluZyByb290LiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHtAbGluayAjaW5pdCBEYXRhQ29udHJvbGxlciNpbml0KCkgbWV0aG9kfQogICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIG5vbi1leGlzdGVudCByb290IG5hbWUuIEZvciBleGFtcGxlLCBpZiB0aGVyZSBpcyBhbiBlZGl0b3IgaW5zdGFuY2Ugd2l0aCBvbmx5IGBtYWluYCByb290LAogICAgICAgICAqIGNhbGxpbmcge0BsaW5rICNpbml0fSBsaWtlOgogICAgICAgICAqCiAgICAgICAgICogCQlkYXRhLmluaXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCByb290MjogJzxwPkJhcjwvcD4nIH0gKTsKICAgICAgICAgKgogICAgICAgICAqIHdpbGwgdGhyb3cgdGhpcyBlcnJvci4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBkYXRhY29udHJvbGxlci1pbml0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2RhdGFjb250cm9sbGVyLWluaXQtbm9uLWV4aXN0ZW50LXJvb3Q6IEF0dGVtcHRpbmcgdG8gaW5pdCBkYXRhIG9uIGEgbm9uLWV4aXN0aW5nIHJvb3QuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHRoaXMubW9kZWwuZW5xdWV1ZUNoYW5nZSgndHJhbnNwYXJlbnQnLCBmdW5jdGlvbiAod3JpdGVyKSB7CiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhpbml0aWFsRGF0YSk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykgewogICAgICAgICAgdmFyIHJvb3ROYW1lID0gX09iamVjdCRrZXlzW19pXTsKCiAgICAgICAgICB2YXIgbW9kZWxSb290ID0gX3RoaXMyLm1vZGVsLmRvY3VtZW50LmdldFJvb3Qocm9vdE5hbWUpOwoKICAgICAgICAgIHdyaXRlci5pbnNlcnQoX3RoaXMyLnBhcnNlKGluaXRpYWxEYXRhW3Jvb3ROYW1lXSwgbW9kZWxSb290KSwgbW9kZWxSb290LCAwKTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgaW5wdXQgZGF0YSBwYXJzZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfSBhbmQKICAgICAqIGNvbnZlcnRlZCBieSB0aGUge0BsaW5rICN1cGNhc3REaXNwYXRjaGVyIHZpZXctdG8tbW9kZWwgY29udmVydGVyc30uCiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBhbnkgdGltZSB0byByZXBsYWNlIGV4aXN0aW5nIGVkaXRvciBkYXRhIGJ5IHRoZSBuZXcgb25lIHdpdGhvdXQgY2xlYXJpbmcgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNoaXN0b3J5IGRvY3VtZW50IGhpc3Rvcnl9LgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGFsc28gY3JlYXRlcyBhIGJhdGNoIHdpdGggYWxsIHRoZSBjaGFuZ2VzIGFwcGxpZWQuIElmIGFsbCB5b3UgbmVlZCBpcyB0byBwYXJzZSBkYXRhLCB1c2UKICAgICAqIHRoZSB7QGxpbmsgI3BhcnNlfSBtZXRob2QuCiAgICAgKgogICAgICogV2hlbiBkYXRhIGlzIHBhc3NlZCBhcyBhIHN0cmluZyBpdCBpcyBzZXQgb24gYSBkZWZhdWx0IGBtYWluYCByb290OgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5zZXQoICc8cD5Gb288L3A+JyApOyAvLyBTZXRzIGRhdGEgb24gdGhlIGBtYWluYCByb290LgogICAgICoKICAgICAqIFRvIHNldCBkYXRhIG9uIGEgZGlmZmVyZW50IHJvb3Qgb3IgbXVsdGlwbGUgcm9vdHMgYXQgb25jZSwgb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYCBwYWlycyBzaG91bGQgYmUgcGFzc2VkOgogICAgICoKICAgICAqCQlkYXRhQ29udHJvbGxlci5zZXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCB0aXRsZTogJzxoMT5CYXI8L2gxPicgfSApOyAvLyBTZXRzIGRhdGEgb24gdGhlIGBtYWluYCBhbmQgYHRpdGxlYCByb290cy4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3QuPFN0cmluZyxTdHJpbmc+fSBkYXRhIElucHV0IGRhdGEgYXMgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHJvb3ROYW1lYCAtIGBkYXRhYAogICAgICogcGFpcnMgdG8gc2V0IGRhdGEgb24gbXVsdGlwbGUgcm9vdHMgYXQgb25jZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldChkYXRhKSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgdmFyIG5ld0RhdGEgPSB7fTsKCiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHsKICAgICAgICBuZXdEYXRhLm1haW4gPSBkYXRhOyAvLyBEZWZhdWx0IHJvb3QgaXMgJ21haW4nLiBUbyBzZXQgZGF0YSBvbiBhIGRpZmZlcmVudCByb290LCBvYmplY3Qgc2hvdWxkIGJlIHBhc3NlZC4KICAgICAgfSBlbHNlIHsKICAgICAgICBuZXdEYXRhID0gZGF0YTsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLl9jaGVja0lmUm9vdHNFeGlzdHMoT2JqZWN0LmtleXMobmV3RGF0YSkpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IHNldCBkYXRhIG9uIGEgbm9uLWV4aXN0aW5nIHJvb3QuIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4ge0BsaW5rICNzZXQgRGF0YUNvbnRyb2xsZXIjc2V0KCkgbWV0aG9kfQogICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIG5vbi1leGlzdGVudCByb290IG5hbWUuIEZvciBleGFtcGxlLCBpZiB0aGVyZSBpcyBhbiBlZGl0b3IgaW5zdGFuY2Ugd2l0aCBvbmx5IGBtYWluYCByb290LAogICAgICAgICAqIGNhbGxpbmcge0BsaW5rICNzZXR9IGxpa2U6CiAgICAgICAgICoKICAgICAgICAgKiAJCWRhdGEuc2V0KCB7IG1haW46ICc8cD5Gb288L3A+Jywgcm9vdDI6ICc8cD5CYXI8L3A+JyB9ICk7CiAgICAgICAgICoKICAgICAgICAgKiB3aWxsIHRocm93IHRoaXMgZXJyb3IuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItc2V0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2RhdGFjb250cm9sbGVyLXNldC1ub24tZXhpc3RlbnQtcm9vdDogQXR0ZW1wdGluZyB0byBzZXQgZGF0YSBvbiBhIG5vbi1leGlzdGluZyByb290LicsIHRoaXMpOwogICAgICB9CgogICAgICB0aGlzLm1vZGVsLmVucXVldWVDaGFuZ2UoJ3RyYW5zcGFyZW50JywgZnVuY3Rpb24gKHdyaXRlcikgewogICAgICAgIHdyaXRlci5zZXRTZWxlY3Rpb24obnVsbCk7CiAgICAgICAgd3JpdGVyLnJlbW92ZVNlbGVjdGlvbkF0dHJpYnV0ZShfdGhpczMubW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uLmdldEF0dHJpYnV0ZUtleXMoKSk7CgogICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTsgX2kyIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICB2YXIgcm9vdE5hbWUgPSBfT2JqZWN0JGtleXMyW19pMl07CgogICAgICAgICAgLy8gU2F2ZSB0byBtb2RlbC4KICAgICAgICAgIHZhciBtb2RlbFJvb3QgPSBfdGhpczMubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSk7CgogICAgICAgICAgd3JpdGVyLnJlbW92ZSh3cml0ZXIuY3JlYXRlUmFuZ2VJbihtb2RlbFJvb3QpKTsKICAgICAgICAgIHdyaXRlci5pbnNlcnQoX3RoaXMzLnBhcnNlKG5ld0RhdGFbcm9vdE5hbWVdLCBtb2RlbFJvb3QpLCBtb2RlbFJvb3QsIDApOwogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGRhdGEgcGFyc2VkIGJ5IHRoZSB7QGxpbmsgI3Byb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0gYW5kIHRoZW4gY29udmVydGVkIGJ5IHVwY2FzdCBjb252ZXJ0ZXJzCiAgICAgKiBhdHRhY2hlZCB0byB0aGUge0BsaW5rICN1cGNhc3REaXNwYXRjaGVyfS4KICAgICAqCiAgICAgKiBAc2VlICNzZXQKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIERhdGEgdG8gcGFyc2UuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBbY29udGV4dD0nJHJvb3QnXSBCYXNlIGNvbnRleHQgaW4gd2hpY2ggdGhlIHZpZXcgd2lsbAogICAgICogYmUgY29udmVydGVkIHRvIHRoZSBtb2RlbC4gU2VlOiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNjb252ZXJ0fS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gUGFyc2VkIGRhdGEuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicGFyc2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHsKICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICckcm9vdCc7CiAgICAgIC8vIGRhdGEgLT4gdmlldwogICAgICB2YXIgdmlld0RvY3VtZW50RnJhZ21lbnQgPSB0aGlzLnByb2Nlc3Nvci50b1ZpZXcoZGF0YSk7IC8vIHZpZXcgLT4gbW9kZWwKCiAgICAgIHJldHVybiB0aGlzLnRvTW9kZWwodmlld0RvY3VtZW50RnJhZ21lbnQsIGNvbnRleHQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IHZpZXcgZG9jdW1lbnQgZnJhZ21lbnR9IGNvbnZlcnRlZCBieSB0aGUKICAgICAqIHtAbGluayAjdXBjYXN0RGlzcGF0Y2hlciB2aWV3LXRvLW1vZGVsIGNvbnZlcnRlcnN9LCB3cmFwcGVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0uCiAgICAgKgogICAgICogV2hlbiBtYXJrZXIgZWxlbWVudHMgd2VyZSBjb252ZXJ0ZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MsIGl0IHdpbGwgYmUgc2V0IGFzIGEgZG9jdW1lbnQgZnJhZ21lbnQncwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I21hcmtlcnMgc3RhdGljIG1hcmtlcnMgbWFwfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gdmlld0VsZW1lbnRPckZyYWdtZW50CiAgICAgKiBFbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50IHdob3NlIGNvbnRlbnQgd2lsbCBiZSBjb252ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBbY29udGV4dD0nJHJvb3QnXSBCYXNlIGNvbnRleHQgaW4gd2hpY2ggdGhlIHZpZXcgd2lsbAogICAgICogYmUgY29udmVydGVkIHRvIHRoZSBtb2RlbC4gU2VlOiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNjb252ZXJ0fS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gT3V0cHV0IGRvY3VtZW50IGZyYWdtZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvTW9kZWwiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvTW9kZWwodmlld0VsZW1lbnRPckZyYWdtZW50KSB7CiAgICAgIHZhciBfdGhpczQgPSB0aGlzOwoKICAgICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICckcm9vdCc7CiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNoYW5nZShmdW5jdGlvbiAod3JpdGVyKSB7CiAgICAgICAgcmV0dXJuIF90aGlzNC51cGNhc3REaXNwYXRjaGVyLmNvbnZlcnQodmlld0VsZW1lbnRPckZyYWdtZW50LCB3cml0ZXIsIGNvbnRleHQpOwogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBhIHN0eWxlIHByb2Nlc3NvciBub3JtYWxpemF0aW9uIHJ1bGVzLgogICAgICoKICAgICAqIFlvdSBjYW4gaW1wbGVtZW50IHlvdXIgb3duIHJ1bGVzIGFzIHdlbGwgYXMgdXNlIG9uZSBvZiB0aGUgYXZhaWxhYmxlIHByb2Nlc3NvciBydWxlczoKICAgICAqCiAgICAgKiAqIGJhY2tncm91bmQ6IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzL2JhY2tncm91bmR+YWRkQmFja2dyb3VuZFJ1bGVzfQogICAgICogKiBib3JkZXI6IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzL2JvcmRlcn5hZGRCb3JkZXJSdWxlc30KICAgICAqICogbWFyZ2luOiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlcy9tYXJnaW5+YWRkTWFyZ2luUnVsZXN9CiAgICAgKiAqIHBhZGRpbmc6IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzL3BhZGRpbmd+YWRkUGFkZGluZ1J1bGVzfQogICAgICoKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyhjYWxsYmFjaykgewogICAgICBjYWxsYmFjayh0aGlzLnN0eWxlc1Byb2Nlc3Nvcik7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBzZXQgYnkgdGhlIERhdGFDb250cm9sbGVyLgogICAgICovCgogIH0sIHsKICAgIGtleTogImRlc3Ryb3kiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7CiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgYWxsIHByb3ZpZGVkIHJvb3QgbmFtZXMgYXJlIGV4aXN0aW5nIGVkaXRvciByb290cy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gcm9vdE5hbWVzIFJvb3QgbmFtZXMgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBhbGwgcHJvdmlkZWQgcm9vdCBuYW1lcyBhcmUgZXhpc3RpbmcgZWRpdG9yIHJvb3RzLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jaGVja0lmUm9vdHNFeGlzdHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja0lmUm9vdHNFeGlzdHMocm9vdE5hbWVzKSB7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHJvb3ROYW1lc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkgewogICAgICAgICAgdmFyIHJvb3ROYW1lID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgIGlmICghdGhpcy5tb2RlbC5kb2N1bWVudC5nZXRSb290TmFtZXMoKS5pbmNsdWRlcyhyb290TmFtZSkpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBFdmVudCBmaXJlZCBvbmNlIGRhdGEgaW5pdGlhbGlzYXRpb24gaGFzIGZpbmlzaGVkLgogICAgICoKICAgICAqIEBldmVudCByZWFkeQogICAgICovCgogICAgLyoqCiAgICAgKiBFdmVudCBmaXJlZCBhZnRlciB7QGxpbmsgI2luaXQgaW5pdCgpIG1ldGhvZH0gaGFzIGJlZW4gcnVuLiBJdCBjYW4gYmUge0BsaW5rICNsaXN0ZW5UbyBsaXN0ZW5lZCB0b30gdG8gYWRqdXN0L21vZGlmeQogICAgICogdGhlIGluaXRpYWxpc2F0aW9uIGZsb3cuIEhvd2V2ZXIsIGlmIHRoZSBgaW5pdGAgZXZlbnQgaXMgc3RvcHBlZCBvciBwcmV2ZW50ZWQsIHRoZSB7QGxpbmsgI2V2ZW50OnJlYWR5IHJlYWR5IGV2ZW50fQogICAgICogc2hvdWxkIGJlIGZpcmVkIG1hbnVhbGx5LgogICAgICoKICAgICAqIFRoZSBgaW5pdGAgZXZlbnQgaXMgZmlyZWQgYnkgZGVjb3JhdGVkIHtAbGluayAjaW5pdH0gbWV0aG9kLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIHNhbXBsZXMuCiAgICAgKgogICAgICogQGV2ZW50IGluaXQKICAgICAqLwoKICB9XSk7CgogIHJldHVybiBEYXRhQ29udHJvbGxlcjsKfSgpOwoKZXhwb3J0IHsgRGF0YUNvbnRyb2xsZXIgYXMgZGVmYXVsdCB9OwptaXgoRGF0YUNvbnRyb2xsZXIsIE9ic2VydmFibGVNaXhpbik7IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZG93bmNhc3QgY29udmVyc2lvbi4KLy8KLy8gVGFrZXMgYSBkb2N1bWVudCBlbGVtZW50IChlbGVtZW50IHRoYXQgaXMgYWRkZWQgdG8gYSBtb2RlbCBkb2N1bWVudCkgYW5kIGNoZWNrcyB3aGljaCBtYXJrZXJzIGFyZSBpbnNpZGUgaXQKLy8gYW5kIHdoaWNoIG1hcmtlcnMgYXJlIGNvbnRhaW5pbmcgaXQuIElmIHRoZSBtYXJrZXIgaXMgaW50ZXJzZWN0aW5nIHdpdGggZWxlbWVudCwgdGhlIGludGVyc2VjdGlvbiBpcyByZXR1cm5lZC4KCmZ1bmN0aW9uIF9nZXRNYXJrZXJzUmVsYXRpdmVUb0VsZW1lbnQoZWxlbWVudCkgewogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgZG9jID0gZWxlbWVudC5yb290LmRvY3VtZW50OwoKICBpZiAoIWRvYykgewogICAgcmV0dXJuIFtdOwogIH0KCiAgdmFyIGVsZW1lbnRSYW5nZSA9IE1vZGVsUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpOwoKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRvYy5tb2RlbC5tYXJrZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7CiAgICAgIHZhciBtYXJrZXIgPSBfc3RlcDMudmFsdWU7CiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBlbGVtZW50UmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKG1hcmtlci5nZXRSYW5nZSgpKTsKCiAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHsKICAgICAgICByZXN1bHQucHVzaChbbWFya2VyLm5hbWUsIGludGVyc2VjdGlvbl0pOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gcmVzdWx0Owp9"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","DataController","model","stylesProcessor","processor","mapper","downcastDispatcher","on","priority","upcastDispatcher","schema","viewDocument","_viewWriter","decorate","fire","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","viewWriter","clearBindings","modelRange","_createIn","bindElements","convertInsert","is","markers","_getMarkersRelativeToElement","name","range","convertMarkerAdd","data","version","initialData","main","Object","keys","enqueueChange","writer","modelRoot","insert","parse","Promise","resolve","newData","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","convert","callback","stopListening","rootNames","getRootNames","includes","element","result","doc","elementRange","marker","intersection","getIntersection","getRange","push"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.\n\t */\n\tconstructor( model, stylesProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Styles processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis.stylesProcessor = stylesProcessor;\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t *\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor\n\t\t */\n\t\tthis.processor;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t/**\n\t\t * The view document used by the data controller.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/document~Document}\n\t\t */\n\t\tthis.viewDocument = new ViewDocument( stylesProcessor );\n\n\t\t/**\n\t\t * The view downcast writer just for data conversion purposes, i.e. to modify\n\t\t * the {@link #viewDocument}.\n\t\t *\n\t\t * @private\n\t\t * @readonly\n\t\t * @member {module:engine/view/downcastwriter~DowncastWriter}\n\t\t */\n\t\tthis._viewWriter = new ViewDowncastWriter( this.viewDocument );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\n\t\t// Fire `ready` event when initialisation has completed. Such low level listener gives possibility\n\t\t// to plug into initialisation pipeline without interrupting the initialisation flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @param {Object} [options]\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options || {};\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment ) {\n\t\tconst viewDocument = this.viewDocument;\n\t\tconst viewWriter = this._viewWriter;\n\n\t\t// Clear bindings so the call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\t\tconst viewDocumentFragment = new ViewDocumentFragment( viewDocument );\n\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\t// We have no view controller and rendering do DOM in DataController so view.change() block is not used here.\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\tif ( !modelElementOrFragment.is( 'documentFragment' ) ) {\n\t\t\t// Then, if a document element is converted, convert markers.\n\t\t\t// From all document markers, get those, which \"intersect\" with the converter element.\n\t\t\tconst markers = _getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\t\tfor ( const [ name, range ] of markers ) {\n\t\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t\t}\n\t\t}\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string it is initialized on a default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n\t *\n\t * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty: Trying to set initial data to not empty document.', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on a default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n\t *\n\t * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n\t *\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t */\n\tset( data ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Adds a style processor normalization rules.\n\t *\n\t * You can implement your own rules as well as use one of the available processor rules:\n\t *\n\t * * background: {@link module:engine/view/styles/background~addBackgroundRules}\n\t * * border: {@link module:engine/view/styles/border~addBorderRules}\n\t * * margin: {@link module:engine/view/styles/margin~addMarginRules}\n\t * * padding: {@link module:engine/view/styles/padding~addPaddingRules}\n\t *\n\t * @param {Function} callback\n\t */\n\taddStyleProcessorRules( callback ) {\n\t\tcallback( this.stylesProcessor );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks if all provided root names are existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once data initialisation has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Event fired after {@link #init init() method} has been run. It can be {@link #listenTo listened to} to adjust/modify\n\t * the initialisation flow. However, if the `init` event is stopped or prevented, the {@link #event:ready ready event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst intersection = elementRange.getIntersection( marker.getRange() );\n\n\t\tif ( intersection ) {\n\t\t\tresult.push( [ marker.name, intersection ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n"]}]}