{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\documentfragment.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\documentfragment.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5tYXAiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi51cmwudG8tanNvbiI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50CiAqLwppbXBvcnQgTm9kZUxpc3QgZnJvbSAnLi9ub2RlbGlzdCc7CmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudCc7CmltcG9ydCBUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBUZXh0UHJveHkgZnJvbSAnLi90ZXh0cHJveHknOwppbXBvcnQgaXNJdGVyYWJsZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9pc2l0ZXJhYmxlJzsgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjb25zdCB7IHN0cmluZ2lmeU1hcCB9ID0gcmVxdWlyZSggJy4uL2Rldi11dGlscy91dGlscycgKTsKCi8qKgogKiBEb2N1bWVudEZyYWdtZW50IHJlcHJlc2VudHMgYSBwYXJ0IG9mIG1vZGVsIHdoaWNoIGRvZXMgbm90IGhhdmUgYSBjb21tb24gcm9vdCBidXQgaXQncyB0b3AtbGV2ZWwgbm9kZXMKICogY2FuIGJlIHNlZW4gYXMgc2libGluZ3MuIEluIG90aGVyIHdvcmRzLCBpdCBpcyBhIGRldGFjaGVkIHBhcnQgb2YgbW9kZWwgdHJlZSwgd2l0aG91dCBhIHJvb3QuCiAqCiAqIERvY3VtZW50RnJhZ21lbnQgaGFzIG93biB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb259LiBNYXJrZXJzIGZyb20gdGhpcyBjb2xsZWN0aW9uCiAqIHdpbGwgYmUgc2V0IHRvIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNtYXJrZXJzIG1vZGVsIG1hcmtlcnN9IGJ5IGEKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNpbnNlcnR9IGZ1bmN0aW9uLgogKi8KCnZhciBEb2N1bWVudEZyYWdtZW50ID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBlbXB0eSBgRG9jdW1lbnRGcmFnbWVudGAuCiAgICoKICAgKiAqKk5vdGU6KiogQ29uc3RydWN0b3Igb2YgdGhpcyBjbGFzcyBzaG91bGRuJ3QgYmUgdXNlZCBkaXJlY3RseSBpbiB0aGUgY29kZS4KICAgKiBVc2UgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlRG9jdW1lbnRGcmFnbWVudH0gbWV0aG9kIGluc3RlYWQuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBbY2hpbGRyZW5dCiAgICogTm9kZXMgdG8gYmUgY29udGFpbmVkIGluc2lkZSB0aGUgYERvY3VtZW50RnJhZ21lbnRgLgogICAqLwogIGZ1bmN0aW9uIERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudEZyYWdtZW50KTsKCiAgICAvKioKICAgICAqIERvY3VtZW50RnJhZ21lbnQgc3RhdGljIG1hcmtlcnMgbWFwLiBUaGlzIGlzIGEgbGlzdCBvZiBuYW1lcyBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2VzfQogICAgICogd2hpY2ggd2lsbCBiZSBzZXQgYXMgTWFya2VycyB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNtYXJrZXJzIG1vZGVsIG1hcmtlcnMgY29sbGVjdGlvbn0KICAgICAqIHdoZW4gRG9jdW1lbnRGcmFnbWVudCB3aWxsIGJlIGluc2VydGVkIHRvIHRoZSBkb2N1bWVudC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge01hcDxTdHJpbmcsbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I21hcmtlcnMKICAgICAqLwogICAgdGhpcy5tYXJrZXJzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBMaXN0IG9mIG5vZGVzIGNvbnRhaW5lZCBpbnNpZGUgdGhlIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGVsaXN0fk5vZGVMaXN0fSBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCNfY2hpbGRyZW4KICAgICAqLwoKICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IE5vZGVMaXN0KCk7CgogICAgaWYgKGNoaWxkcmVuKSB7CiAgICAgIHRoaXMuX2luc2VydENoaWxkKDAsIGNoaWxkcmVuKTsKICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIG5vZGVzIGNvbnRhaW5lZCBpbnNpZGUgdGhpcyBkb2N1bWVudCBmcmFnbWVudC4KICAgKgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKERvY3VtZW50RnJhZ21lbnQsIFt7CiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvciwKICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKTsKICAgIH0KICAgIC8qKgogICAgICogTnVtYmVyIG9mIHRoaXMgZG9jdW1lbnQgZnJhZ21lbnQncyBjaGlsZHJlbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtOdW1iZXJ9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXMiLAoKICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2YgdGhlIGdpdmVuIHR5cGUuCiAgICAgKgogICAgICoJCWRvY0ZyYWcuaXMoICdkb2N1bWVudEZyYWdtZW50JyApOyAvLyAtPiB0cnVlCiAgICAgKgkJZG9jRnJhZy5pcyggJ21vZGVsOmRvY3VtZW50RnJhZ21lbnQnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJZG9jRnJhZy5pcyggJ3ZpZXc6ZG9jdW1lbnRGcmFnbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCQlkb2NGcmFnLmlzKCAnZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCQlkb2NGcmFnLmlzKCAnbm9kZScgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaXMgQ2hlY2sgdGhlIGVudGlyZSBsaXN0IG9mIG1vZGVsIG9iamVjdHN9IHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBpcyh0eXBlKSB7CiAgICAgIHJldHVybiB0eXBlID09ICdkb2N1bWVudEZyYWdtZW50JyB8fCB0eXBlID09ICdtb2RlbDpkb2N1bWVudEZyYWdtZW50JzsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LiBSZXR1cm5zIGBudWxsYCBpZiBpbmNvcnJlY3QgaW5kZXggd2FzIHBhc3NlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgY2hpbGQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8bnVsbH0gQ2hpbGQgbm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hpbGQoaW5kZXgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldE5vZGUoaW5kZXgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwgb2YgdGhpcyBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpbmRleCBvZiB0aGUgZ2l2ZW4gY2hpbGQgbm9kZS4gUmV0dXJucyBgbnVsbGAgaWYgZ2l2ZW4gbm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgQ2hpbGQgbm9kZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH0gQ2hpbGQgbm9kZSdzIGluZGV4LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoaWxkSW5kZXgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkSW5kZXgobm9kZSkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0Tm9kZUluZGV4KG5vZGUpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBvZmZzZXQgb2YgZ2l2ZW4gY2hpbGQuIFN0YXJ0aW5nIG9mZnNldCBpcyBlcXVhbCB0byB0aGUgc3VtIG9mCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjb2Zmc2V0U2l6ZSBvZmZzZXQgc2l6ZXN9IG9mIGFsbCBub2RlJ3Mgc2libGluZ3MgdGhhdCBhcmUgYmVmb3JlIGl0LiBSZXR1cm5zIGBudWxsYCBpZgogICAgICogZ2l2ZW4gbm9kZSBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgQ2hpbGQgbm9kZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH0gQ2hpbGQgbm9kZSdzIHN0YXJ0aW5nIG9mZnNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDaGlsZFN0YXJ0T2Zmc2V0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZFN0YXJ0T2Zmc2V0KG5vZGUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmdldE5vZGVTdGFydE9mZnNldChub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBwYXRoIHRvIGEgYERvY3VtZW50RnJhZ21lbnRgLCB3aGljaCBpcyBhbiBlbXB0eSBhcnJheS4gQWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXl9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UGF0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aCgpIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgZGVzY2VuZGFudCBub2RlIGJ5IGl0cyBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgZWxlbWVudC4KICAgICAqCiAgICAgKgkJLy8gPHRoaXM+YTxiPmM8L2I+PC90aGlzPgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAwIF0gKTsgICAgIC8vIC0+ICJhIgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAxIF0gKTsgICAgIC8vIC0+IDxiPgogICAgICoJCXRoaXMuZ2V0Tm9kZUJ5UGF0aCggWyAxLCAwIF0gKTsgIC8vIC0+ICJjIgogICAgICoKICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IHJlbGF0aXZlUGF0aCBQYXRoIG9mIHRoZSBub2RlIHRvIGZpbmQsIHJlbGF0aXZlIHRvIHRoaXMgZWxlbWVudC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROb2RlQnlQYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQnlQYXRoKHJlbGF0aXZlUGF0aCkgewogICAgICB2YXIgbm9kZSA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzCgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHJlbGF0aXZlUGF0aFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBpbmRleCA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0Q2hpbGQobm9kZS5vZmZzZXRUb0luZGV4KGluZGV4KSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgb2Zmc2V0ICJwb3NpdGlvbiIgdG8gaW5kZXggInBvc2l0aW9uIi4KICAgICAqCiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGEgbm9kZSB0aGF0IG9jY3VwaWVzIGdpdmVuIG9mZnNldC4gSWYgZ2l2ZW4gb2Zmc2V0IGlzIHRvbyBsb3csIHJldHVybnMgYDBgLiBJZiBnaXZlbiBvZmZzZXQgaXMKICAgICAqIHRvbyBoaWdoLCByZXR1cm5zIGluZGV4IGFmdGVyIGxhc3QgY2hpbGR9LgogICAgICoKICAgICAqCQljb25zdCB0ZXh0Tm9kZSA9IG5ldyBUZXh0KCAnZm9vJyApOwogICAgICoJCWNvbnN0IHBFbGVtZW50ID0gbmV3IEVsZW1lbnQoICdwJyApOwogICAgICoJCWNvbnN0IGRvY0ZyYWcgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCggWyB0ZXh0Tm9kZSwgcEVsZW1lbnQgXSApOwogICAgICoJCWRvY0ZyYWcub2Zmc2V0VG9JbmRleCggLTEgKTsgLy8gUmV0dXJucyAwLCBiZWNhdXNlIG9mZnNldCBpcyB0b28gbG93LgogICAgICoJCWRvY0ZyYWcub2Zmc2V0VG9JbmRleCggMCApOyAvLyBSZXR1cm5zIDAsIGJlY2F1c2Ugb2Zmc2V0IDAgaXMgdGFrZW4gYnkgYHRleHROb2RlYCB3aGljaCBpcyBhdCBpbmRleCAwLgogICAgICoJCWRvY0ZyYWcub2Zmc2V0VG9JbmRleCggMSApOyAvLyBSZXR1cm5zIDAsIGJlY2F1c2UgYHRleHROb2RlYCBoYXMgYG9mZnNldFNpemVgIGVxdWFsIHRvIDMsIHNvIGl0IG9jY3VwaWVzIG9mZnNldCAxIHRvby4KICAgICAqCQlkb2NGcmFnLm9mZnNldFRvSW5kZXgoIDIgKTsgLy8gUmV0dXJucyAwLgogICAgICoJCWRvY0ZyYWcub2Zmc2V0VG9JbmRleCggMyApOyAvLyBSZXR1cm5zIDEuCiAgICAgKgkJZG9jRnJhZy5vZmZzZXRUb0luZGV4KCA0ICk7IC8vIFJldHVybnMgMi4gVGhlcmUgYXJlIG5vIG5vZGVzIGF0IG9mZnNldCA0LCBzbyBsYXN0IGF2YWlsYWJsZSBpbmRleCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE9mZnNldCB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IEluZGV4IG9mIGEgbm9kZSB0aGF0IG9jY3VwaWVzIGdpdmVuIG9mZnNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJvZmZzZXRUb0luZGV4IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZzZXRUb0luZGV4KG9mZnNldCkgewogICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ub2Zmc2V0VG9JbmRleChvZmZzZXQpOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgRG9jdW1lbnRGcmFnbWVudGAgaW5zdGFuY2UgdG8gcGxhaW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LgogICAgICogVGFrZXMgY2FyZSBvZiBjb252ZXJ0aW5nIGFsbCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50J3MgY2hpbGRyZW4uCiAgICAgKgogICAgICogQHJldHVybnMge09iamVjdH0gYERvY3VtZW50RnJhZ21lbnRgIGluc3RhbmNlIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9KU09OIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7CiAgICAgIHZhciBqc29uID0gW107CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuX2NoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgIGpzb24ucHVzaChub2RlLnRvSlNPTigpKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4ganNvbjsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGBEb2N1bWVudEZyYWdtZW50YCBpbnN0YW5jZSBmcm9tIGdpdmVuIHBsYWluIG9iamVjdCAoaS5lLiBwYXJzZWQgSlNPTiBzdHJpbmcpLgogICAgICogQ29udmVydHMgYERvY3VtZW50RnJhZ21lbnRgIGNoaWxkcmVuIHRvIHByb3BlciBub2Rlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBEb2N1bWVudEZyYWdtZW50YC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gYERvY3VtZW50RnJhZ21lbnRgIGluc3RhbmNlIGNyZWF0ZWQgdXNpbmcgZ2l2ZW4gcGxhaW4gb2JqZWN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9hcHBlbmRDaGlsZCIsCgogICAgLyoqCiAgICAgKiB7QGxpbmsgI19pbnNlcnRDaGlsZCBJbnNlcnRzfSBvbmUgb3IgbW9yZSBub2RlcyBhdCB0aGUgZW5kIG9mIHRoaXMgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0+fSBpdGVtcyBJdGVtcyB0byBiZSBpbnNlcnRlZC4KICAgICAqLwogICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRDaGlsZChpdGVtcykgewogICAgICB0aGlzLl9pbnNlcnRDaGlsZCh0aGlzLmNoaWxkQ291bnQsIGl0ZW1zKTsKICAgIH0KICAgIC8qKgogICAgICogSW5zZXJ0cyBvbmUgb3IgbW9yZSBub2RlcyBhdCB0aGUgZ2l2ZW4gaW5kZXggYW5kIHNldHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3BhcmVudCBwYXJlbnR9IG9mIHRoZXNlIG5vZGVzCiAgICAgKiB0byB0aGlzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfEl0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IGl0ZW1zIEl0ZW1zIHRvIGJlIGluc2VydGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9pbnNlcnRDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2luc2VydENoaWxkKGluZGV4LCBpdGVtcykgewogICAgICB2YXIgbm9kZXMgPSBub3JtYWxpemUoaXRlbXMpOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBub2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDMudmFsdWU7CgogICAgICAgICAgLy8gSWYgbm9kZSB0aGF0IGlzIGJlaW5nIGFkZGVkIHRvIHRoaXMgZWxlbWVudCBpcyBhbHJlYWR5IGluc2lkZSBhbm90aGVyIGVsZW1lbnQsIGZpcnN0IHJlbW92ZSBpdCBmcm9tIHRoZSBvbGQgcGFyZW50LgogICAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSBudWxsKSB7CiAgICAgICAgICAgIG5vZGUuX3JlbW92ZSgpOwogICAgICAgICAgfQoKICAgICAgICAgIG5vZGUucGFyZW50ID0gdGhpczsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLl9jaGlsZHJlbi5faW5zZXJ0Tm9kZXMoaW5kZXgsIG5vZGVzKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBvbmUgb3IgbW9yZSBub2RlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gaW5kZXgKICAgICAqIGFuZCBzZXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNwYXJlbnQgcGFyZW50fSBvZiB0aGVzZSBub2RlcyB0byBgbnVsbGAuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBmaXJzdCBub2RlIHRvIHJlbW92ZS4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaG93TWFueT0xXSBOdW1iZXIgb2Ygbm9kZXMgdG8gcmVtb3ZlLgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IEFycmF5IGNvbnRhaW5pbmcgcmVtb3ZlZCBub2Rlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVtb3ZlQ2hpbGRyZW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDaGlsZHJlbihpbmRleCkgewogICAgICB2YXIgaG93TWFueSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTsKCiAgICAgIHZhciBub2RlcyA9IHRoaXMuX2NoaWxkcmVuLl9yZW1vdmVOb2RlcyhpbmRleCwgaG93TWFueSk7CgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBub2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICBub2RlLnBhcmVudCA9IG51bGw7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5vZGVzOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuICdkb2N1bWVudEZyYWdtZW50JzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAljb25zb2xlLmxvZyggJ01vZGVsRG9jdW1lbnRGcmFnbWVudDogJyArIHRoaXMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBwcmludFRyZWUoKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCWxldCBzdHJpbmcgPSAnTW9kZWxEb2N1bWVudEZyYWdtZW50OiBbJzsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JZm9yICggY29uc3QgY2hpbGQgb2YgdGhpcy5nZXRDaGlsZHJlbigpICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJc3RyaW5nICs9ICdcbic7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQlpZiAoIGNoaWxkLmlzKCAndGV4dCcgKSApIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQljb25zdCB0ZXh0QXR0cnMgPSBzdHJpbmdpZnlNYXAoIGNoaWxkLl9hdHRycyApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJCXN0cmluZyArPSAnXHQnLnJlcGVhdCggMSApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJCWlmICggdGV4dEF0dHJzICE9PSAnJyApIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQkJc3RyaW5nICs9IGA8JHRleHQkeyB0ZXh0QXR0cnMgfT5gICsgY2hpbGQuZGF0YSArICc8LyR0ZXh0Pic7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJfSBlbHNlIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQkJc3RyaW5nICs9IGNoaWxkLmRhdGE7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQkJfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJfSBlbHNlIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCQlzdHJpbmcgKz0gY2hpbGQucHJpbnRUcmVlKCAxICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCQl9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCX0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8Jc3RyaW5nICs9ICdcbl0nOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwlyZXR1cm4gc3RyaW5nOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZ1RyZWUoKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAljb25zb2xlLmxvZyggdGhpcy5wcmludFRyZWUoKSApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CgogIH0sIHsKICAgIGtleTogImNoaWxkQ291bnQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7CiAgICB9CiAgICAvKioKICAgICAqIFN1bSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjb2Zmc2V0U2l6ZSBvZmZzZXQgc2l6ZXN9IG9mIGFsbCBvZiB0aGlzIGRvY3VtZW50IGZyYWdtZW50J3MgY2hpbGRyZW4uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm1heE9mZnNldCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLm1heE9mZnNldDsKICAgIH0KICAgIC8qKgogICAgICogSXMgYHRydWVgIGlmIHRoZXJlIGFyZSBubyBub2RlcyBpbnNpZGUgdGhpcyBkb2N1bWVudCBmcmFnbWVudCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VtcHR5IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5jaGlsZENvdW50ID09PSAwOwogICAgfQogICAgLyoqCiAgICAgKiBBcnRpZmljaWFsIHJvb3Qgb2YgYERvY3VtZW50RnJhZ21lbnRgLiBSZXR1cm5zIGl0c2VsZi4gQWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyb290IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIC8qKgogICAgICogQXJ0aWZpY2lhbCBwYXJlbnQgb2YgYERvY3VtZW50RnJhZ21lbnRgLiBSZXR1cm5zIGBudWxsYC4gQWRkZWQgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogInBhcmVudCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgfV0sIFt7CiAgICBrZXk6ICJmcm9tSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikgewogICAgICB2YXIgY2hpbGRyZW4gPSBbXTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0ganNvbltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXA1LnZhbHVlOwoKICAgICAgICAgIGlmIChjaGlsZC5uYW1lKSB7CiAgICAgICAgICAgIC8vIElmIGNoaWxkIGhhcyBuYW1lIHByb3BlcnR5LCBpdCBpcyBhbiBFbGVtZW50LgogICAgICAgICAgICBjaGlsZHJlbi5wdXNoKEVsZW1lbnQuZnJvbUpTT04oY2hpbGQpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBUZXh0IG5vZGUuCiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goVGV4dC5mcm9tSlNPTihjaGlsZCkpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gRG9jdW1lbnRGcmFnbWVudDsKfSgpOyAvLyBDb252ZXJ0cyBzdHJpbmdzIHRvIFRleHQgYW5kIG5vbi1pdGVyYWJsZXMgdG8gYXJyYXlzLgovLwovLyBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0+fQovLyBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0KCgpleHBvcnQgeyBEb2N1bWVudEZyYWdtZW50IGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIG5vcm1hbGl6ZShub2RlcykgewogIC8vIFNlcGFyYXRlIGNvbmRpdGlvbiBiZWNhdXNlIHN0cmluZyBpcyBpdGVyYWJsZS4KICBpZiAodHlwZW9mIG5vZGVzID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gW25ldyBUZXh0KG5vZGVzKV07CiAgfQoKICBpZiAoIWlzSXRlcmFibGUobm9kZXMpKSB7CiAgICBub2RlcyA9IFtub2Rlc107CiAgfSAvLyBBcnJheS5mcm9tIHRvIGVuYWJsZSAubWFwKCkgb24gbm9uLWFycmF5cy4KCgogIHJldHVybiBBcnJheS5mcm9tKG5vZGVzKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHsKICAgIGlmICh0eXBlb2Ygbm9kZSA9PSAnc3RyaW5nJykgewogICAgICByZXR1cm4gbmV3IFRleHQobm9kZSk7CiAgICB9CgogICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgcmV0dXJuIG5ldyBUZXh0KG5vZGUuZGF0YSwgbm9kZS5nZXRBdHRyaWJ1dGVzKCkpOwogICAgfQoKICAgIHJldHVybiBub2RlOwogIH0pOwp9"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js"],"names":["NodeList","Element","Text","TextProxy","isIterable","DocumentFragment","children","markers","Map","_children","_insertChild","Symbol","iterator","getChildren","type","index","getNode","node","getNodeIndex","getNodeStartOffset","relativePath","getChild","offsetToIndex","offset","json","push","toJSON","items","childCount","nodes","normalize","parent","_remove","_insertNodes","howMany","_removeNodes","length","maxOffset","child","name","fromJSON","Array","from","map","data","getAttributes"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/model/documentfragment\n */\n\nimport NodeList from './nodelist';\nimport Element from './element';\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n// @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );\n\n/**\n * DocumentFragment represents a part of model which does not have a common root but it's top-level nodes\n * can be seen as siblings. In other words, it is a detached part of model tree, without a root.\n *\n * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection\n * will be set to the {@link module:engine/model/model~Model#markers model markers} by a\n * {@link module:engine/model/writer~Writer#insert} function.\n */\nexport default class DocumentFragment {\n\t/**\n\t * Creates an empty `DocumentFragment`.\n\t *\n\t * **Note:** Constructor of this class shouldn't be used directly in the code.\n\t * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]\n\t * Nodes to be contained inside the `DocumentFragment`.\n\t */\n\tconstructor( children ) {\n\t\t/**\n\t\t * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}\n\t\t * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}\n\t\t * when DocumentFragment will be inserted to the document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers\n\t\t */\n\t\tthis.markers = new Map();\n\n\t\t/**\n\t\t * List of nodes contained inside the document fragment.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children\n\t\t */\n\t\tthis._children = new NodeList();\n\n\t\tif ( children ) {\n\t\t\tthis._insertChild( 0, children );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all nodes contained inside this document fragment.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this.getChildren();\n\t}\n\n\t/**\n\t * Number of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget childCount() {\n\t\treturn this._children.length;\n\t}\n\n\t/**\n\t * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget maxOffset() {\n\t\treturn this._children.maxOffset;\n\t}\n\n\t/**\n\t * Is `true` if there are no nodes inside this document fragment, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this.childCount === 0;\n\t}\n\n\t/**\n\t * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.\n\t *\n\t * @readonly\n\t * @type {null}\n\t */\n\tget parent() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\tdocFrag.is( 'documentFragment' ); // -> true\n\t *\t\tdocFrag.is( 'model:documentFragment' ); // -> true\n\t *\n\t *\t\tdocFrag.is( 'view:documentFragment' ); // -> false\n\t *\t\tdocFrag.is( 'element' ); // -> false\n\t *\t\tdocFrag.is( 'node' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'documentFragment' || type == 'model:documentFragment';\n\t}\n\n\t/**\n\t * Gets the child at the given index. Returns `null` if incorrect index was passed.\n\t *\n\t * @param {Number} index Index of child.\n\t * @returns {module:engine/model/node~Node|null} Child node.\n\t */\n\tgetChild( index ) {\n\t\treturn this._children.getNode( index );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all of this document fragment's children.\n\t *\n\t * @returns {Iterable.<module:engine/model/node~Node>}\n\t */\n\tgetChildren() {\n\t\treturn this._children[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's index.\n\t */\n\tgetChildIndex( node ) {\n\t\treturn this._children.getNodeIndex( node );\n\t}\n\n\t/**\n\t * Returns the starting offset of given child. Starting offset is equal to the sum of\n\t * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if\n\t * given node is not a child of this document fragment.\n\t *\n\t * @param {module:engine/model/node~Node} node Child node to look for.\n\t * @returns {Number|null} Child node's starting offset.\n\t */\n\tgetChildStartOffset( node ) {\n\t\treturn this._children.getNodeStartOffset( node );\n\t}\n\n\t/**\n\t * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.\n\t *\n\t * @returns {Array}\n\t */\n\tgetPath() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Returns a descendant node by its path relative to this element.\n\t *\n\t *\t\t// <this>a<b>c</b></this>\n\t *\t\tthis.getNodeByPath( [ 0 ] );     // -> \"a\"\n\t *\t\tthis.getNodeByPath( [ 1 ] );     // -> <b>\n\t *\t\tthis.getNodeByPath( [ 1, 0 ] );  // -> \"c\"\n\t *\n\t * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.\n\t * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetNodeByPath( relativePath ) {\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\tfor ( const index of relativePath ) {\n\t\t\tnode = node.getChild( node.offsetToIndex( index ) );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Converts offset \"position\" to index \"position\".\n\t *\n\t * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is\n\t * too high, returns index after last child}.\n\t *\n\t *\t\tconst textNode = new Text( 'foo' );\n\t *\t\tconst pElement = new Element( 'p' );\n\t *\t\tconst docFrag = new DocumentFragment( [ textNode, pElement ] );\n\t *\t\tdocFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.\n\t *\t\tdocFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.\n\t *\t\tdocFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.\n\t *\t\tdocFrag.offsetToIndex( 2 ); // Returns 0.\n\t *\t\tdocFrag.offsetToIndex( 3 ); // Returns 1.\n\t *\t\tdocFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.\n\t *\n\t * @param {Number} offset Offset to look for.\n\t * @returns {Number} Index of a node that occupies given offset.\n\t */\n\toffsetToIndex( offset ) {\n\t\treturn this._children.offsetToIndex( offset );\n\t}\n\n\t/**\n\t * Converts `DocumentFragment` instance to plain object and returns it.\n\t * Takes care of converting all of this document fragment's children.\n\t *\n\t * @returns {Object} `DocumentFragment` instance converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = [];\n\n\t\tfor ( const node of this._children ) {\n\t\t\tjson.push( node.toJSON() );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).\n\t * Converts `DocumentFragment` children to proper nodes.\n\t *\n\t * @param {Object} json Plain object to be converted to `DocumentFragment`.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.\n\t */\n\tstatic fromJSON( json ) {\n\t\tconst children = [];\n\n\t\tfor ( const child of json ) {\n\t\t\tif ( child.name ) {\n\t\t\t\t// If child has name property, it is an Element.\n\t\t\t\tchildren.push( Element.fromJSON( child ) );\n\t\t\t} else {\n\t\t\t\t// Otherwise, it is a Text node.\n\t\t\t\tchildren.push( Text.fromJSON( child ) );\n\t\t\t}\n\t\t}\n\n\t\treturn new DocumentFragment( children );\n\t}\n\n\t/**\n\t * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_appendChild( items ) {\n\t\tthis._insertChild( this.childCount, items );\n\t}\n\n\t/**\n\t * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes\n\t * to this document fragment.\n\t *\n\t * @protected\n\t * @param {Number} index Index at which nodes should be inserted.\n\t * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.\n\t */\n\t_insertChild( index, items ) {\n\t\tconst nodes = normalize( items );\n\n\t\tfor ( const node of nodes ) {\n\t\t\t// If node that is being added to this element is already inside another element, first remove it from the old parent.\n\t\t\tif ( node.parent !== null ) {\n\t\t\t\tnode._remove();\n\t\t\t}\n\n\t\t\tnode.parent = this;\n\t\t}\n\n\t\tthis._children._insertNodes( index, nodes );\n\t}\n\n\t/**\n\t * Removes one or more nodes starting at the given index\n\t * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.\n\t *\n\t * @protected\n\t * @param {Number} index Index of the first node to remove.\n\t * @param {Number} [howMany=1] Number of nodes to remove.\n\t * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.\n\t */\n\t_removeChildren( index, howMany = 1 ) {\n\t\tconst nodes = this._children._removeNodes( index, howMany );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tnode.parent = null;\n\t\t}\n\n\t\treturn nodes;\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn 'documentFragment';\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelDocumentFragment: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // printTree() {\n\t// @if CK_DEBUG_ENGINE //\tlet string = 'ModelDocumentFragment: [';\n\n\t// @if CK_DEBUG_ENGINE //\tfor ( const child of this.getChildren() ) {\n\t// @if CK_DEBUG_ENGINE //\t\tstring += '\\n';\n\n\t// @if CK_DEBUG_ENGINE //\t\tif ( child.is( 'text' ) ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\tconst textAttrs = stringifyMap( child._attrs );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += '\\t'.repeat( 1 );\n\n\t// @if CK_DEBUG_ENGINE //\t\t\tif ( textAttrs !== '' ) {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += `<$text${ textAttrs }>` + child.data + '</$text>';\n\t// @if CK_DEBUG_ENGINE //\t\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\t\tstring += child.data;\n\t// @if CK_DEBUG_ENGINE //\t\t\t}\n\t// @if CK_DEBUG_ENGINE //\t\t} else {\n\t// @if CK_DEBUG_ENGINE //\t\t\tstring += child.printTree( 1 );\n\t// @if CK_DEBUG_ENGINE //\t\t}\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\tstring += '\\n]';\n\n\t// @if CK_DEBUG_ENGINE //\treturn string;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // logTree() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( this.printTree() );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n// Converts strings to Text and non-iterables to arrays.\n//\n// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}\n// @returns {Iterable.<module:engine/model/node~Node>}\nfunction normalize( nodes ) {\n\t// Separate condition because string is iterable.\n\tif ( typeof nodes == 'string' ) {\n\t\treturn [ new Text( nodes ) ];\n\t}\n\n\tif ( !isIterable( nodes ) ) {\n\t\tnodes = [ nodes ];\n\t}\n\n\t// Array.from to enable .map() on non-arrays.\n\treturn Array.from( nodes )\n\t\t.map( node => {\n\t\t\tif ( typeof node == 'string' ) {\n\t\t\t\treturn new Text( node );\n\t\t\t}\n\n\t\t\tif ( node instanceof TextProxy ) {\n\t\t\t\treturn new Text( node.data, node.getAttributes() );\n\t\t\t}\n\n\t\t\treturn node;\n\t\t} );\n}\n"]}]}