{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\markercollection.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\markercollection.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGgiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0ICJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9uCiAqLwppbXBvcnQgTGl2ZVJhbmdlIGZyb20gJy4vbGl2ZXJhbmdlJzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwovKioKICogVGhlIGNvbGxlY3Rpb24gb2YgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlcnN9IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudC4KICogSXQgbGV0cyB5b3Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9uI2dldCBnZXR9IG1hcmtlcnMgb3IgdHJhY2sgdGhlbSB1c2luZwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb24jZXZlbnQ6dXBkYXRlfSBldmVudC4KICoKICogVG8gY3JlYXRlLCBjaGFuZ2Ugb3IgcmVtb3ZlIG1ha2VycyB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBtb2RlbCB3cml0ZXJzJ30gbWV0aG9kczoKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNhZGRNYXJrZXJ9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjcmVtb3ZlTWFya2VyfS4gU2luY2UKICogdGhlIHdyaXRlciBpcyB0aGUgb25seSBwcm9wZXIgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBtb2RlbCBpdCBpcyBub3QgcG9zc2libGUgdG8gY2hhbmdlIG1hcmtlcnMgZGlyZWN0bHkgdXNpbmcgdGhpcwogKiBjb2xsZWN0aW9uLiBBbGwgbWFya2VycyBjcmVhdGVkIGJ5IHRoZSB3cml0ZXIgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoaXMgY29sbGVjdGlvbi4KICoKICogQnkgZGVmYXVsdCB0aGVyZSBpcyBvbmUgbWFya2VyIGNvbGxlY3Rpb24gYXZhaWxhYmxlIGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI21hcmtlcnMgbW9kZWwgcHJvcGVydHl9LgogKgogKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIKICovCgp2YXIgTWFya2VyQ29sbGVjdGlvbiA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSBtYXJrZXJzIGNvbGxlY3Rpb24uCiAgICovCiAgZnVuY3Rpb24gTWFya2VyQ29sbGVjdGlvbigpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrZXJDb2xsZWN0aW9uKTsKCiAgICAvKioKICAgICAqIFN0b3JlcyB7QGxpbmsgfk1hcmtlciBtYXJrZXJzfSBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwfSAjX21hcmtlcnMKICAgICAqLwogICAgdGhpcy5fbWFya2VycyA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogSXRlcmFibGUgaW50ZXJmYWNlLgogICAqCiAgICogSXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIH5NYXJrZXIgbWFya2Vyc30gYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uCiAgICoKICAgKiBAcmV0dXJucyB7SXRlcmFibGV9CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoTWFya2VyQ29sbGVjdGlvbiwgW3sKICAgIGtleTogU3ltYm9sLml0ZXJhdG9yLAogICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy52YWx1ZXMoKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIG1hcmtlciB3aXRoIGdpdmVuIGBtYXJrZXJOYW1lYCBpcyBpbiB0aGUgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFya2VyTmFtZSBNYXJrZXIgbmFtZS4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgbWFya2VyIHdpdGggZ2l2ZW4gYG1hcmtlck5hbWVgIGlzIGluIHRoZSBjb2xsZWN0aW9uLCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJoYXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhtYXJrZXJOYW1lKSB7CiAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmhhcyhtYXJrZXJOYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB7QGxpbmsgfk1hcmtlciBtYXJrZXJ9IHdpdGggZ2l2ZW4gYG1hcmtlck5hbWVgLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrZXJOYW1lIE5hbWUgb2YgbWFya2VyIHRvIGdldC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyfG51bGx9IE1hcmtlciB3aXRoIGdpdmVuIG5hbWUgb3IgYG51bGxgIGlmIHN1Y2ggbWFya2VyIHdhcwogICAgICogbm90IGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG1hcmtlck5hbWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlck5hbWUpIHx8IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgYSB7QGxpbmsgfk1hcmtlciBtYXJrZXJ9IHRvIHRoZSBgTWFya2VyQ29sbGVjdGlvbmAgd2l0aCBnaXZlbiBuYW1lIG9uIGdpdmVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogSWYgYE1hcmtlckNvbGxlY3Rpb25gIGFscmVhZHkgaGFkIGEgbWFya2VyIHdpdGggZ2l2ZW4gbmFtZSAob3Ige0BsaW5rIH5NYXJrZXIgbWFya2VyfSB3YXMgcGFzc2VkKSwgdGhlIG1hcmtlciBpbgogICAgICogY29sbGVjdGlvbiBpcyB1cGRhdGVkIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb24jZXZlbnQ6dXBkYXRlfSBldmVudCBpcyBmaXJlZAogICAgICogYnV0IG9ubHkgaWYgdGhlcmUgd2FzIGEgY2hhbmdlIChtYXJrZXIgcmFuZ2Ugb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIjbWFuYWdlZFVzaW5nT3BlcmF0aW9uc30KICAgICAqIGZsYWcgaGFzIGNoYW5nZWQuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQGZpcmVzIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9uI2V2ZW50OnVwZGF0ZQogICAgICogQHBhcmFtIHtTdHJpbmd8bW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlcn0gbWFya2VyT3JOYW1lIE5hbWUgb2YgbWFya2VyIHRvIHNldCBvciBtYXJrZXIgaW5zdGFuY2UgdG8gdXBkYXRlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBNYXJrZXIgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW5hZ2VkVXNpbmdPcGVyYXRpb25zPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWFya2VyIGlzIG1hbmFnZWQgdXNpbmcgb3BlcmF0aW9ucy4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FmZmVjdHNEYXRhPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWFya2VyIGFmZmVjdHMgdGhlIGRhdGEgcHJvZHVjZWQgYnkgdGhlIGRhdGEgcGlwZWxpbmUKICAgICAqIChpcyBwZXJzaXN0ZWQgaW4gdGhlIGVkaXRvcidzIGRhdGEpLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ9IGBNYXJrZXJgIGluc3RhbmNlIHdoaWNoIHdhcyBhZGRlZCBvciB1cGRhdGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQobWFya2VyT3JOYW1lLCByYW5nZSkgewogICAgICB2YXIgbWFuYWdlZFVzaW5nT3BlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7CiAgICAgIHZhciBhZmZlY3RzRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7CiAgICAgIHZhciBtYXJrZXJOYW1lID0gbWFya2VyT3JOYW1lIGluc3RhbmNlb2YgTWFya2VyID8gbWFya2VyT3JOYW1lLm5hbWUgOiBtYXJrZXJPck5hbWU7CgogICAgICB2YXIgb2xkTWFya2VyID0gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyTmFtZSk7CgogICAgICBpZiAob2xkTWFya2VyKSB7CiAgICAgICAgdmFyIG9sZFJhbmdlID0gb2xkTWFya2VyLmdldFJhbmdlKCk7CiAgICAgICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTsKCiAgICAgICAgaWYgKCFvbGRSYW5nZS5pc0VxdWFsKHJhbmdlKSkgewogICAgICAgICAgb2xkTWFya2VyLl9hdHRhY2hMaXZlUmFuZ2UoTGl2ZVJhbmdlLmZyb21SYW5nZShyYW5nZSkpOwoKICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlOwogICAgICAgIH0KCiAgICAgICAgaWYgKG1hbmFnZWRVc2luZ09wZXJhdGlvbnMgIT0gb2xkTWFya2VyLm1hbmFnZWRVc2luZ09wZXJhdGlvbnMpIHsKICAgICAgICAgIG9sZE1hcmtlci5fbWFuYWdlZFVzaW5nT3BlcmF0aW9ucyA9IG1hbmFnZWRVc2luZ09wZXJhdGlvbnM7CiAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgYWZmZWN0c0RhdGEgPT09ICdib29sZWFuJyAmJiBhZmZlY3RzRGF0YSAhPSBvbGRNYXJrZXIuYWZmZWN0c0RhdGEpIHsKICAgICAgICAgIG9sZE1hcmtlci5fYWZmZWN0c0RhdGEgPSBhZmZlY3RzRGF0YTsKICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlOwogICAgICAgIH0KCiAgICAgICAgaWYgKGhhc0NoYW5nZWQpIHsKICAgICAgICAgIHRoaXMuZmlyZSgndXBkYXRlOicgKyBtYXJrZXJOYW1lLCBvbGRNYXJrZXIsIG9sZFJhbmdlLCByYW5nZSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gb2xkTWFya2VyOwogICAgICB9CgogICAgICB2YXIgbGl2ZVJhbmdlID0gTGl2ZVJhbmdlLmZyb21SYW5nZShyYW5nZSk7CiAgICAgIHZhciBtYXJrZXIgPSBuZXcgTWFya2VyKG1hcmtlck5hbWUsIGxpdmVSYW5nZSwgbWFuYWdlZFVzaW5nT3BlcmF0aW9ucywgYWZmZWN0c0RhdGEpOwoKICAgICAgdGhpcy5fbWFya2Vycy5zZXQobWFya2VyTmFtZSwgbWFya2VyKTsKCiAgICAgIHRoaXMuZmlyZSgndXBkYXRlOicgKyBtYXJrZXJOYW1lLCBtYXJrZXIsIG51bGwsIHJhbmdlKTsKICAgICAgcmV0dXJuIG1hcmtlcjsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBnaXZlbiB7QGxpbmsgfk1hcmtlciBtYXJrZXJ9IG9yIGEgbWFya2VyIHdpdGggZ2l2ZW4gbmFtZSBmcm9tIHRoZSBgTWFya2VyQ29sbGVjdGlvbmAuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQGZpcmVzIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9uI2V2ZW50OnVwZGF0ZQogICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcmtlck9yTmFtZSBNYXJrZXIgb3IgbmFtZSBvZiBhIG1hcmtlciB0byByZW1vdmUuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIG1hcmtlciB3YXMgZm91bmQgYW5kIHJlbW92ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmUobWFya2VyT3JOYW1lKSB7CiAgICAgIHZhciBtYXJrZXJOYW1lID0gbWFya2VyT3JOYW1lIGluc3RhbmNlb2YgTWFya2VyID8gbWFya2VyT3JOYW1lLm5hbWUgOiBtYXJrZXJPck5hbWU7CgogICAgICB2YXIgb2xkTWFya2VyID0gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyTmFtZSk7CgogICAgICBpZiAob2xkTWFya2VyKSB7CiAgICAgICAgdGhpcy5fbWFya2Vycy5kZWxldGUobWFya2VyTmFtZSk7CgogICAgICAgIHRoaXMuZmlyZSgndXBkYXRlOicgKyBtYXJrZXJOYW1lLCBvbGRNYXJrZXIsIG9sZE1hcmtlci5nZXRSYW5nZSgpLCBudWxsKTsKCiAgICAgICAgdGhpcy5fZGVzdHJveU1hcmtlcihvbGRNYXJrZXIpOwoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgLyoqCiAgICAgKiBGaXJlcyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb24jZXZlbnQ6dXBkYXRlfSBldmVudCBmb3IgdGhlIGdpdmVuIHtAbGluayB+TWFya2VyIG1hcmtlcn0KICAgICAqIGJ1dCBkb2VzIG5vdCBjaGFuZ2UgdGhlIG1hcmtlci4gVXNlZnVsIHRvIGZvcmNlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciBkb3duY2FzdAogICAgICogY29udmVyc2lvbn0gZm9yIHRoZSBtYXJrZXIuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQGZpcmVzIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9uI2V2ZW50OnVwZGF0ZQogICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcmtlck9yTmFtZSBNYXJrZXIgb3IgbmFtZSBvZiBhIG1hcmtlciB0byByZWZyZXNoLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZWZyZXNoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmcmVzaChtYXJrZXJPck5hbWUpIHsKICAgICAgdmFyIG1hcmtlck5hbWUgPSBtYXJrZXJPck5hbWUgaW5zdGFuY2VvZiBNYXJrZXIgPyBtYXJrZXJPck5hbWUubmFtZSA6IG1hcmtlck9yTmFtZTsKCiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXJOYW1lKTsKCiAgICAgIGlmICghbWFya2VyKSB7CiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21hcmtlcmNvbGxlY3Rpb24tcmVmcmVzaC1tYXJrZXItbm90LWV4aXN0czogTWFya2VyIHdpdGggcHJvdmlkZWQgbmFtZSBkb2VzIG5vdCBleGlzdHMuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciByYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICB0aGlzLmZpcmUoJ3VwZGF0ZTonICsgbWFya2VyTmFtZSwgbWFya2VyLCByYW5nZSwgcmFuZ2UsIG1hcmtlci5tYW5hZ2VkVXNpbmdPcGVyYXRpb25zLCBtYXJrZXIuYWZmZWN0c0RhdGEpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwgbWFya2Vycywgd2hpY2ggcmFuZ2VzIGNvbnRhaW4gZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24KICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlcj59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TWFya2Vyc0F0UG9zaXRpb24iLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRNYXJrZXJzQXRQb3NpdGlvbihwb3NpdGlvbikgewogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBtYXJrZXI7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0TWFya2Vyc0F0UG9zaXRpb24kKF9jb250ZXh0KSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gdGhpc1tTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIG1hcmtlciA9IF9zdGVwLnZhbHVlOwoKICAgICAgICAgICAgICBpZiAoIW1hcmtlci5nZXRSYW5nZSgpLmNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDsKICAgICAgICAgICAgICByZXR1cm4gbWFya2VyOwoKICAgICAgICAgICAgY2FzZSAxMDoKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxNToKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTU7CiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFsiY2F0Y2giXSgzKTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MDsKCiAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5OwogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMDsKCiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDIyOwoKICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwoKICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIyKTsKCiAgICAgICAgICAgIGNhc2UgMjY6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxOSk7CgogICAgICAgICAgICBjYXNlIDI3OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBnZXRNYXJrZXJzQXRQb3NpdGlvbiwgdGhpcywgW1szLCAxNSwgMTksIDI3XSwgWzIwLCwgMjIsIDI2XV0pOwogICAgfSkKICAgIC8qKgogICAgICogUmV0dXJucyBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIG1hcmtlcnMsIHdoaWNoIGludGVyc2VjdHMgd2l0aCBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZQogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRNYXJrZXJzSW50ZXJzZWN0aW5nUmFuZ2UiLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRNYXJrZXJzSW50ZXJzZWN0aW5nUmFuZ2UocmFuZ2UpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yLCBfZGlkSXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBtYXJrZXI7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlJChfY29udGV4dDIpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7CiAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMzsKICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gdGhpc1tTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBtYXJrZXIgPSBfc3RlcDIudmFsdWU7CgogICAgICAgICAgICAgIGlmICghKG1hcmtlci5nZXRSYW5nZSgpLmdldEludGVyc2VjdGlvbihyYW5nZSkgIT09IG51bGwpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwOwogICAgICAgICAgICAgIHJldHVybiBtYXJrZXI7CgogICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDEzOgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE1OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDMpOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQyLnQwOwoKICAgICAgICAgICAgY2FzZSAxOToKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE5OwogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjA7CgogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICBjYXNlIDIyOgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjI7CgogICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI1OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CgogICAgICAgICAgICBjYXNlIDI1OgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDIyKTsKCiAgICAgICAgICAgIGNhc2UgMjY6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMTkpOwoKICAgICAgICAgICAgY2FzZSAyNzoKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIGdldE1hcmtlcnNJbnRlcnNlY3RpbmdSYW5nZSwgdGhpcywgW1szLCAxNSwgMTksIDI3XSwgWzIwLCwgMjIsIDI2XV0pOwogICAgfSkKICAgIC8qKgogICAgICogRGVzdHJveXMgbWFya2VyIGNvbGxlY3Rpb24gYW5kIGFsbCBtYXJrZXJzIGluc2lkZSBpdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkZXN0cm95IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkgewogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB0aGlzLl9tYXJrZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgbWFya2VyID0gX3N0ZXAzLnZhbHVlOwoKICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lNYXJrZXIobWFya2VyKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLl9tYXJrZXJzID0gbnVsbDsKICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7CiAgICB9CiAgICAvKioKICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIG1hcmtlcnMgdGhhdCBzdGFydHMgd2l0aCBnaXZlbiBgcHJlZml4YC4KICAgICAqCiAgICAgKgkJY29uc3QgbWFya2VyRm9vQSA9IG1hcmtlcnNDb2xsZWN0aW9uLnNldCggJ2ZvbzphJywgcmFuZ2VGb29BICk7CiAgICAgKgkJY29uc3QgbWFya2VyRm9vQiA9IG1hcmtlcnNDb2xsZWN0aW9uLnNldCggJ2ZvbzpiJywgcmFuZ2VGb29CICk7CiAgICAgKgkJY29uc3QgbWFya2VyQmFyQSA9IG1hcmtlcnNDb2xsZWN0aW9uLnNldCggJ2JhcjphJywgcmFuZ2VCYXJBICk7CiAgICAgKgkJY29uc3QgbWFya2VyRm9vQmFyQSA9IG1hcmtlcnNDb2xsZWN0aW9uLnNldCggJ2Zvb2JhcjphJywgcmFuZ2VGb29CYXJBICk7CiAgICAgKgkJQXJyYXkuZnJvbSggbWFya2Vyc0NvbGxlY3Rpb24uZ2V0TWFya2Vyc0dyb3VwKCAnZm9vJyApICk7IC8vIFsgbWFya2VyRm9vQSwgbWFya2VyRm9vQiBdCiAgICAgKgkJQXJyYXkuZnJvbSggbWFya2Vyc0NvbGxlY3Rpb24uZ2V0TWFya2Vyc0dyb3VwKCAnYScgKSApOyAvLyBbXQogICAgICoKICAgICAqIEBwYXJhbSBwcmVmaXgKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlcj59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TWFya2Vyc0dyb3VwIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gZ2V0TWFya2Vyc0dyb3VwKHByZWZpeCkgewogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQsIF9kaWRJdGVyYXRvckVycm9yNCwgX2l0ZXJhdG9yRXJyb3I0LCBfaXRlcmF0b3I0LCBfc3RlcDQsIG1hcmtlcjsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRNYXJrZXJzR3JvdXAkKF9jb250ZXh0MykgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzOwogICAgICAgICAgICAgIF9pdGVyYXRvcjQgPSB0aGlzLl9tYXJrZXJzLnZhbHVlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIG1hcmtlciA9IF9zdGVwNC52YWx1ZTsKCiAgICAgICAgICAgICAgaWYgKCFtYXJrZXIubmFtZS5zdGFydHNXaXRoKHByZWZpeCArICc6JykpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgcmV0dXJuIG1hcmtlcjsKCiAgICAgICAgICAgIGNhc2UgMTA6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxOTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNTsKICAgICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbImNhdGNoIl0oMyk7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBfY29udGV4dDMudDA7CgogICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTk7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyMDsKCiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyMjsKCiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKCiAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjIpOwoKICAgICAgICAgICAgY2FzZSAyNjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgxOSk7CgogICAgICAgICAgICBjYXNlIDI3OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0TWFya2Vyc0dyb3VwLCB0aGlzLCBbWzMsIDE1LCAxOSwgMjddLCBbMjAsLCAyMiwgMjZdXSk7CiAgICB9KQogICAgLyoqCiAgICAgKiBEZXN0cm95cyB0aGUgbWFya2VyLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ9IG1hcmtlciBNYXJrZXIgdG8gZGVzdHJveS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZGVzdHJveU1hcmtlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3lNYXJrZXIobWFya2VyKSB7CiAgICAgIG1hcmtlci5zdG9wTGlzdGVuaW5nKCk7CgogICAgICBtYXJrZXIuX2RldGFjaExpdmVSYW5nZSgpOwogICAgfQogICAgLyoqCiAgICAgKiBGaXJlZCB3aGVuZXZlciBtYXJrZXIgaXMgYWRkZWQsIHVwZGF0ZWQgb3IgcmVtb3ZlZCBmcm9tIGBNYXJrZXJDb2xsZWN0aW9uYC4KICAgICAqCiAgICAgKiBAZXZlbnQgdXBkYXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJ9IG1hcmtlciBVcGRhdGVkIE1hcmtlci4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBvbGRSYW5nZSBNYXJrZXIgcmFuZ2UgYmVmb3JlIHRoZSB1cGRhdGUuIFdoZW4gaXMgbm90IGRlZmluZWQgaXQKICAgICAqIG1lYW5zIHRoYXQgbWFya2VyIGlzIGp1c3QgYWRkZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gbmV3UmFuZ2UgTWFya2VyIHJhbmdlIGFmdGVyIHVwZGF0ZS4gV2hlbiBpcyBub3QgZGVmaW5lZCBpdAogICAgICogbWVhbnMgdGhhdCBtYXJrZXIgaXMganVzdCByZW1vdmVkLgogICAgICovCgogIH1dKTsKCiAgcmV0dXJuIE1hcmtlckNvbGxlY3Rpb247Cn0oKTsKCmV4cG9ydCB7IE1hcmtlckNvbGxlY3Rpb24gYXMgZGVmYXVsdCB9OwptaXgoTWFya2VyQ29sbGVjdGlvbiwgRW1pdHRlck1peGluKTsKLyoqCiAqIGBNYXJrZXJgIGlzIGEgY29udGludW91cyBwYXJ0cyBvZiBtb2RlbCAobGlrZSBhIHJhbmdlKSwgaXMgbmFtZWQgYW5kIHJlcHJlc2VudCBzb21lIGtpbmQgb2YgaW5mb3JtYXRpb24gYWJvdXQgbWFya2VkCiAqIHBhcnQgb2YgbW9kZWwgZG9jdW1lbnQuIEluIGNvbnRyYXJ5IHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2Rlc30sIHdoaWNoIGFyZSBidWlsZGluZyBibG9ja3Mgb2YKICogbW9kZWwgZG9jdW1lbnQgdHJlZSwgbWFya2VycyBhcmUgbm90IHN0b3JlZCBkaXJlY3RseSBpbiBkb2N1bWVudCB0cmVlIGJ1dCBpbgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNtYXJrZXJzIG1vZGVsIG1hcmtlcnMnIGNvbGxlY3Rpb259LiBTdGlsbCwgdGhleSBhcmUgZG9jdW1lbnQgZGF0YSwgYnkgZ2l2aW5nCiAqIGFkZGl0aW9uYWwgbWVhbmluZyB0byB0aGUgcGFydCBvZiBhIG1vZGVsIGRvY3VtZW50IGJldHdlZW4gbWFya2VyIHN0YXJ0IGFuZCBtYXJrZXIgZW5kLgogKgogKiBJbiB0aGlzIHNlbnNlLCBtYXJrZXJzIGFyZSBzaW1pbGFyIHRvIGFkZGluZyBhbmQgY29udmVydGluZyBhdHRyaWJ1dGVzIG9uIG5vZGVzLiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IGF0dHJpYnV0ZSBpcwogKiBjb25uZWN0ZWQgd2l0aCBhIGdpdmVuIG5vZGUgKGUuZy4gYSBjaGFyYWN0ZXIgaXMgYm9sZCBubyBtYXR0ZXIgaWYgaXQgZ2V0cyBtb3ZlZCBvciBjb250ZW50IGFyb3VuZCBpdCBjaGFuZ2VzKS4KICogTWFya2VycyBvbiB0aGUgb3RoZXIgaGFuZCBhcmUgY29udGludW91cyByYW5nZXMgYW5kIGFyZSBjaGFyYWN0ZXJpemVkIGJ5IHRoZWlyIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uIFRoaXMgbWVhbnMgdGhhdAogKiBhbnkgY2hhcmFjdGVyIGluIHRoZSBtYXJrZXIgaXMgbWFya2VkIGJ5IHRoZSBtYXJrZXIuIEZvciBleGFtcGxlLCBpZiBhIGNoYXJhY3RlciBpcyBtb3ZlZCBvdXRzaWRlIG9mIG1hcmtlciBpdCBzdG9wcyBiZWluZwogKiAic3BlY2lhbCIgYW5kIHRoZSBtYXJrZXIgaXMgc2hydW5rLiBTaW1pbGFybHksIHdoZW4gYSBjaGFyYWN0ZXIgaXMgbW92ZWQgaW50byB0aGUgbWFya2VyIGZyb20gb3RoZXIgcGxhY2UgaW4gZG9jdW1lbnQKICogbW9kZWwsIGl0IHN0YXJ0cyBiZWluZyAic3BlY2lhbCIgYW5kIHRoZSBtYXJrZXIgaXMgZW5sYXJnZWQuCiAqCiAqIEFub3RoZXIgdXBzaWRlIG9mIG1hcmtlcnMgaXMgdGhhdCBmaW5kaW5nIG1hcmtlZCBwYXJ0IG9mIGRvY3VtZW50IGlzIGZhc3QgYW5kIGVhc3kuIFVzaW5nIGF0dHJpYnV0ZXMgdG8gbWFyayBzb21lIG5vZGVzCiAqIGFuZCB0aGVuIHRyeWluZyB0byBmaW5kIHRoYXQgcGFydCBvZiBkb2N1bWVudCB3b3VsZCByZXF1aXJlIHRyYXZlcnNpbmcgd2hvbGUgZG9jdW1lbnQgdHJlZS4gTWFya2VyIGdpdmVzIGluc3RhbnQgYWNjZXNzCiAqIHRvIHRoZSByYW5nZSB3aGljaCBpdCBpcyBtYXJraW5nIGF0IHRoZSBtb21lbnQuCiAqCiAqIE1hcmtlcnMgYXJlIGJ1aWx0IGZyb20gYSBuYW1lIGFuZCBhIHJhbmdlLgogKgogKiBSYW5nZSBvZiB0aGUgbWFya2VyIGlzIHVwZGF0ZWQgYXV0b21hdGljYWxseSB3aGVuIGRvY3VtZW50IGNoYW5nZXMsIHVzaW5nCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVyYW5nZX5MaXZlUmFuZ2UgbGl2ZSByYW5nZX0gbWVjaGFuaXNtLgogKgogKiBOYW1lIGlzIHVzZWQgdG8gZ3JvdXAgYW5kIGlkZW50aWZ5IG1hcmtlcnMuIE5hbWVzIGhhdmUgdG8gYmUgdW5pcXVlLCBidXQgbWFya2VycyBjYW4gYmUgZ3JvdXBlZCBieQogKiB1c2luZyBjb21tb24gcHJlZml4ZXMsIHNlcGFyYXRlZCB3aXRoIGA6YCwgZm9yIGV4YW1wbGU6IGB1c2VyOmpvaG5gIG9yIGBzZWFyY2g6M2AuIFRoYXQncyB1c2VmdWwgaW4gdGVybSBvZiBjcmVhdGluZwogKiBuYW1lc3BhY2VzIGZvciBjdXN0b20gZWxlbWVudHMgKGUuZy4gY29tbWVudHMsIGhpZ2hsaWdodHMpLiBZb3UgY2FuIHVzZSB0aGlzIHByZWZpeGVzIGluCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbiNldmVudDp1cGRhdGV9IGxpc3RlbmVycyB0byBsaXN0ZW4gb24gY2hhbmdlcyBpbiBhIGdyb3VwIG9mIG1hcmtlcnMuCiAqIEZvciBpbnN0YW5jZTogYG1vZGVsLm1hcmtlcnMub24oICd1cGRhdGU6dXNlcicsIGNhbGxiYWNrICk7YCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhbnkgYHVzZXI6KmAgbWFya2VycyBjaGFuZ2VzLgogKgogKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIG1hcmtlcnMuCiAqCiAqIDEuIE1hcmtlcnMgbWFuYWdlZCBkaXJlY3RseSwgd2l0aG91dCB1c2luZyBvcGVyYXRpb25zLiBUaGV5IGFyZSBhZGRlZCBkaXJlY3RseSBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfQogKiB0byB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufSB3aXRob3V0IGFueSBhZGRpdGlvbmFsIG1lY2hhbmlzbS4gVGhleSBjYW4gYmUgdXNlZAogKiBhcyBib29rbWFya3Mgb3IgdmlzdWFsIG1hcmtlcnMuIFRoZXkgYXJlIGdyZWF0IGZvciBzaG93aW5nIHJlc3VsdHMgb2YgdGhlIGZpbmQsIG9yIHNlbGVjdCBsaW5rIHdoZW4gdGhlIGZvY3VzIGlzIGluIHRoZSBpbnB1dC4KICoKICogMS4gTWFya2VycyBtYW5hZ2VkIHVzaW5nIG9wZXJhdGlvbnMuIFRoZXNlIG1hcmtlcnMgYXJlIGFsc28gc3RvcmVkIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbn0KICogYnV0IGNoYW5nZXMgaW4gdGhlc2UgbWFya2VycyBpcyBtYW5hZ2VkIHRoZSBzYW1lIHdheSBhbGwgb3RoZXIgY2hhbmdlcyBpbiB0aGUgbW9kZWwgc3RydWN0dXJlIC0gdXNpbmcgb3BlcmF0aW9ucy4KICogVGhlcmVmb3JlLCB0aGV5IGFyZSBoYW5kbGVkIGluIHRoZSB1bmRvIHN0YWNrIGFuZCBzeW5jaHJvbml6ZWQgYmV0d2VlbiBjbGllbnRzIGlmIHRoZSBjb2xsYWJvcmF0aW9uIHBsdWdpbiBpcyBlbmFibGVkLgogKiBUaGlzIHR5cGUgb2YgbWFya2VycyBpcyB1c2VmdWwgZm9yIHNvbHV0aW9ucyBsaWtlIHNwZWxsIGNoZWNraW5nIG9yIGNvbW1lbnRzLgogKgogKiBCb3RoIHR5cGUgb2YgdGhlbSBzaG91bGQgYmUgYWRkZWQgLyB1cGRhdGVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjYWRkTWFya2VyfQogKiBhbmQgcmVtb3ZlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3JlbW92ZU1hcmtlcn0gbWV0aG9kcy4KICoKICoJCW1vZGVsLmNoYW5nZSggKCB3cml0ZXIgKSA9PiB7CiAqIAkJCWNvbnN0IG1hcmtlciA9IHdyaXRlci5hZGRNYXJrZXIoIG5hbWUsIHsgcmFuZ2UsIHVzaW5nT3BlcmF0aW9uOiB0cnVlIH0gKTsKICoKICogCQkJLy8gLi4uCiAqCiAqIAkJCXdyaXRlci5yZW1vdmVNYXJrZXIoIG1hcmtlciApOwogKgkJfSApOwogKgogKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gdG8gZmluZCBtb3JlIGV4YW1wbGVzLgogKgogKiBTaW5jZSBtYXJrZXJzIG5lZWQgdG8gdHJhY2sgY2hhbmdlIGluIHRoZSBkb2N1bWVudCwgZm9yIGVmZmljaWVuY3kgcmVhc29ucywgaXQgaXMgYmVzdCB0byBjcmVhdGUgYW5kIGtlZXAgYXMgbGl0dGxlCiAqIG1hcmtlcnMgYXMgcG9zc2libGUgYW5kIHJlbW92ZSB0aGVtIGFzIHNvb24gYXMgdGhleSBhcmUgbm90IG5lZWRlZCBhbnltb3JlLgogKgogKiBNYXJrZXJzIGNhbiBiZSBkb3duY2FzdGVkIGFuZCB1cGNhc3RlZC4KICoKICogTWFya2VycyBkb3duY2FzdCBoYXBwZW5zIG9uIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDphZGRNYXJrZXJ9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6cmVtb3ZlTWFya2VyfSBldmVudHMuCiAqIFVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVycyBkb3duY2FzdCBjb252ZXJ0ZXJzfSBvciBhdHRhY2ggYSBjdXN0b20gY29udmVydGVyIHRvIG1lbnRpb25lZCBldmVudHMuCiAqIEZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyfkRhdGFDb250cm9sbGVyIGRhdGEgcGlwZWxpbmV9LCBtYXJrZXIgc2hvdWxkIGJlIGRvd25jYXN0ZWQgdG8gYW4gZWxlbWVudC4KICogVGhlbiwgaXQgY2FuIGJlIHVwY2FzdGVkIGJhY2sgdG8gYSBtYXJrZXIuIEFnYWluLCB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzIHVwY2FzdCBjb252ZXJ0ZXJzfSBvcgogKiBhdHRhY2ggYSBjdXN0b20gY29udmVydGVyIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OmVsZW1lbnR9LgogKgogKiBgTWFya2VyYCBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBvbmx5IGJ5IHtAbGluayB+TWFya2VyQ29sbGVjdGlvbiBNYXJrZXJDb2xsZWN0aW9ufS4KICovCgp2YXIgTWFya2VyID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIG1hcmtlciBpbnN0YW5jZS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcmFuZ2V+TGl2ZVJhbmdlfSBsaXZlUmFuZ2UgUmFuZ2UgbWFya2VkIGJ5IHRoZSBtYXJrZXIuCiAgICogQHBhcmFtIHtCb29sZWFufSBtYW5hZ2VkVXNpbmdPcGVyYXRpb25zIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtYXJrZXIgaXMgbWFuYWdlZCB1c2luZyBvcGVyYXRpb25zLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWZmZWN0c0RhdGEgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1hcmtlciBhZmZlY3RzIHRoZSBkYXRhIHByb2R1Y2VkIGJ5IHRoZSBkYXRhIHBpcGVsaW5lCiAgICogKGlzIHBlcnNpc3RlZCBpbiB0aGUgZWRpdG9yJ3MgZGF0YSkuCiAgICovCiAgZnVuY3Rpb24gTWFya2VyKG5hbWUsIGxpdmVSYW5nZSwgbWFuYWdlZFVzaW5nT3BlcmF0aW9ucywgYWZmZWN0c0RhdGEpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrZXIpOwoKICAgIC8qKgogICAgICogTWFya2VyJ3MgbmFtZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgKi8KICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAvKioKICAgICAqIFJhbmdlIG1hcmtlZCBieSB0aGUgbWFya2VyLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZX0KICAgICAqLwoKICAgIHRoaXMuX2xpdmVSYW5nZSA9IHRoaXMuX2F0dGFjaExpdmVSYW5nZShsaXZlUmFuZ2UpOwogICAgLyoqCiAgICAgKiBGbGFnIGluZGljYXRlcyBpZiB0aGUgbWFya2VyIGlzIG1hbmFnZWQgdXNpbmcgb3BlcmF0aW9ucyBvciBub3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge0Jvb2xlYW59CiAgICAgKi8KCiAgICB0aGlzLl9tYW5hZ2VkVXNpbmdPcGVyYXRpb25zID0gbWFuYWdlZFVzaW5nT3BlcmF0aW9uczsKICAgIC8qKgogICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIG1hcmtlciBhZmZlY3RzIHRoZSBkYXRhIHByb2R1Y2VkIGJ5IHRoZSBkYXRhIHBpcGVsaW5lCiAgICAgKiAoaXMgcGVyc2lzdGVkIGluIHRoZSBlZGl0b3IncyBkYXRhKS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7Qm9vbGVhbn0KICAgICAqLwoKICAgIHRoaXMuX2FmZmVjdHNEYXRhID0gYWZmZWN0c0RhdGE7CiAgfQogIC8qKgogICAqIEEgdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgbWFya2VyIGlzIG1hbmFnZWQgdXNpbmcgb3BlcmF0aW9ucy4KICAgKiBTZWUge0BsaW5rIH5NYXJrZXIgbWFya2VyIGNsYXNzIGRlc2NyaXB0aW9ufSB0byBsZWFybiBtb3JlIGFib3V0IG1hcmtlciB0eXBlcy4KICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNhZGRNYXJrZXJ9LgogICAqCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoTWFya2VyLCBbewogICAga2V5OiAiZ2V0U3RhcnQiLAoKICAgIC8qKgogICAgICogUmV0dXJucyBjdXJyZW50IG1hcmtlciBzdGFydCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXJ0KCkgewogICAgICBpZiAoIXRoaXMuX2xpdmVSYW5nZSkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtYXJrZXItZGVzdHJveWVkOiBDYW5ub3QgdXNlIGEgZGVzdHJveWVkIG1hcmtlciBpbnN0YW5jZS4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2xpdmVSYW5nZS5zdGFydC5jbG9uZSgpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgbWFya2VyIGVuZCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRFbmQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVuZCgpIHsKICAgICAgaWYgKCF0aGlzLl9saXZlUmFuZ2UpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbWFya2VyLWRlc3Ryb3llZDogQ2Fubm90IHVzZSBhIGRlc3Ryb3llZCBtYXJrZXIgaW5zdGFuY2UuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9saXZlUmFuZ2UuZW5kLmNsb25lKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByYW5nZSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1hcmtlci4KICAgICAqCiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCByZXR1cm5lZCB2YWx1ZSBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIFJhbmdlfSwgbm90IGEKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVyYW5nZX5MaXZlUmFuZ2UgTGl2ZVJhbmdlfS4gVGhpcyBtZWFucyB0aGF0IGl0IGlzIHVwLXRvLWRhdGUgYW5kIHJlbGV2YW50IG9ubHkKICAgICAqIHVudGlsIG5leHQgbW9kZWwgZG9jdW1lbnQgY2hhbmdlLiBEbyBub3Qgc3RvcmUgdmFsdWVzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLiBJbnN0ZWFkLCBzdG9yZSB7QGxpbmsgfk1hcmtlciNuYW1lfQogICAgICogYW5kIGdldCBgTWFya2VyYCBpbnN0YW5jZSBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbiBNYXJrZXJDb2xsZWN0aW9ufSBldmVyeQogICAgICogdGltZSB0aGVyZSBpcyBhIG5lZWQgdG8gcmVhZCBtYXJrZXIgcHJvcGVydGllcy4gVGhpcyB3aWxsIGd1YXJhbnRlZSB0aGF0IHRoZSBtYXJrZXIgaGFzIG5vdCBiZWVuIHJlbW92ZWQgYW5kCiAgICAgKiB0aGF0IGl0J3MgZGF0YSBpcyB1cC10by1kYXRlLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHsKICAgICAgaWYgKCF0aGlzLl9saXZlUmFuZ2UpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbWFya2VyLWRlc3Ryb3llZDogQ2Fubm90IHVzZSBhIGRlc3Ryb3llZCBtYXJrZXIgaW5zdGFuY2UuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9saXZlUmFuZ2UudG9SYW5nZSgpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIG9iamVjdCBpcyBvZiB0aGUgZ2l2ZW4uCiAgICAgKgogICAgICoJCW1hcmtlci5pcyggJ21hcmtlcicgKTsgLy8gLT4gdHJ1ZQogICAgICoJCW1hcmtlci5pcyggJ21vZGVsOm1hcmtlcicgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqCQltYXJrZXIuaXMoICd2aWV3OmVsZW1lbnQnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJbWFya2VyLmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiBtb2RlbCBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUKICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpcyh0eXBlKSB7CiAgICAgIHJldHVybiB0eXBlID09ICdtYXJrZXInIHx8IHR5cGUgPT0gJ21vZGVsOm1hcmtlcic7CiAgICB9CiAgICAvKioKICAgICAqIEJpbmRzIG5ldyBsaXZlIHJhbmdlIHRvIHRoZSBtYXJrZXIgYW5kIGRldGFjaCB0aGUgb2xkIG9uZSBpZiBpcyBhdHRhY2hlZC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZX0gbGl2ZVJhbmdlIExpdmUgcmFuZ2UgdG8gYXR0YWNoCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcmFuZ2V+TGl2ZVJhbmdlfSBBdHRhY2hlZCBsaXZlIHJhbmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9hdHRhY2hMaXZlUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9hdHRhY2hMaXZlUmFuZ2UobGl2ZVJhbmdlKSB7CiAgICAgIGlmICh0aGlzLl9saXZlUmFuZ2UpIHsKICAgICAgICB0aGlzLl9kZXRhY2hMaXZlUmFuZ2UoKTsKICAgICAgfSAvLyBEZWxlZ2F0aW5nIGRvZXMgbm90IHdvcmsgd2l0aCBuYW1lc3BhY2VzLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjb3VsZCBkZWxlZ2F0ZSBhbGwgZXZlbnRzICh1c2luZyBgKmApLgoKCiAgICAgIGxpdmVSYW5nZS5kZWxlZ2F0ZSgnY2hhbmdlOnJhbmdlJykudG8odGhpcyk7CiAgICAgIGxpdmVSYW5nZS5kZWxlZ2F0ZSgnY2hhbmdlOmNvbnRlbnQnKS50byh0aGlzKTsKICAgICAgdGhpcy5fbGl2ZVJhbmdlID0gbGl2ZVJhbmdlOwogICAgICByZXR1cm4gbGl2ZVJhbmdlOwogICAgfQogICAgLyoqCiAgICAgKiBVbmJpbmRzIGFuZCBkZXN0cm95cyBjdXJyZW50bHkgYXR0YWNoZWQgbGl2ZSByYW5nZS4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2RldGFjaExpdmVSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGFjaExpdmVSYW5nZSgpIHsKICAgICAgdGhpcy5fbGl2ZVJhbmdlLnN0b3BEZWxlZ2F0aW5nKCdjaGFuZ2U6cmFuZ2UnLCB0aGlzKTsKCiAgICAgIHRoaXMuX2xpdmVSYW5nZS5zdG9wRGVsZWdhdGluZygnY2hhbmdlOmNvbnRlbnQnLCB0aGlzKTsKCiAgICAgIHRoaXMuX2xpdmVSYW5nZS5kZXRhY2goKTsKCiAgICAgIHRoaXMuX2xpdmVSYW5nZSA9IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIHdoZW5ldmVyIHtAbGluayB+TWFya2VyI19saXZlUmFuZ2UgbWFya2VyIHJhbmdlfSBpcyBjaGFuZ2VkIGR1ZSB0byBjaGFuZ2VzIG9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fS4KICAgICAqIFRoaXMgaXMgYSBkZWxlZ2F0ZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZSNldmVudDpjaGFuZ2U6cmFuZ2UgTGl2ZVJhbmdlIGNoYW5nZTpyYW5nZSBldmVudH0uCiAgICAgKgogICAgICogV2hlbiBtYXJrZXIgaXMgcmVtb3ZlZCBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbiBNYXJrZXJDb2xsZWN0aW9ufSwKICAgICAqIGFsbCBldmVudCBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGl0IHNob3VsZCBiZSByZW1vdmVkLiBJdCBpcyBiZXN0IHRvIGRvIGl0IG9uCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb24jZXZlbnQ6dXBkYXRlIE1hcmtlckNvbGxlY3Rpb24gdXBkYXRlIGV2ZW50fS4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZSNldmVudDpjaGFuZ2U6cmFuZ2UKICAgICAqIEBldmVudCBjaGFuZ2U6cmFuZ2UKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb2xkUmFuZ2UKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhCiAgICAgKi8KCiAgICAvKioKICAgICAqIEZpcmVkIHdoZW5ldmVyIGNoYW5nZSBvbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gaXMgZG9uZSBpbnNpZGUge0BsaW5rIH5NYXJrZXIjX2xpdmVSYW5nZSBtYXJrZXIgcmFuZ2V9LgogICAgICogVGhpcyBpcyBhIGRlbGVnYXRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcmFuZ2V+TGl2ZVJhbmdlI2V2ZW50OmNoYW5nZTpjb250ZW50IExpdmVSYW5nZSBjaGFuZ2U6Y29udGVudCBldmVudH0uCiAgICAgKgogICAgICogV2hlbiBtYXJrZXIgaXMgcmVtb3ZlZCBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbiBNYXJrZXJDb2xsZWN0aW9ufSwKICAgICAqIGFsbCBldmVudCBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGl0IHNob3VsZCBiZSByZW1vdmVkLiBJdCBpcyBiZXN0IHRvIGRvIGl0IG9uCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb24jZXZlbnQ6dXBkYXRlIE1hcmtlckNvbGxlY3Rpb24gdXBkYXRlIGV2ZW50fS4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZSNldmVudDpjaGFuZ2U6Y29udGVudAogICAgICogQGV2ZW50IGNoYW5nZTpjb250ZW50CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG9sZFJhbmdlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YQogICAgICovCgogIH0sIHsKICAgIGtleTogIm1hbmFnZWRVc2luZ09wZXJhdGlvbnMiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIGlmICghdGhpcy5fbGl2ZVJhbmdlKSB7CiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21hcmtlci1kZXN0cm95ZWQ6IENhbm5vdCB1c2UgYSBkZXN0cm95ZWQgbWFya2VyIGluc3RhbmNlLicsIHRoaXMpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5fbWFuYWdlZFVzaW5nT3BlcmF0aW9uczsKICAgIH0KICAgIC8qKgogICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBtYXJrZXIgY2hhbmdlcyB0aGUgZGF0YS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhZmZlY3RzRGF0YSIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgaWYgKCF0aGlzLl9saXZlUmFuZ2UpIHsKICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbWFya2VyLWRlc3Ryb3llZDogQ2Fubm90IHVzZSBhIGRlc3Ryb3llZCBtYXJrZXIgaW5zdGFuY2UuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9hZmZlY3RzRGF0YTsKICAgIH0KICB9XSk7CgogIHJldHVybiBNYXJrZXI7Cn0oKTsKCm1peChNYXJrZXIsIEVtaXR0ZXJNaXhpbik7Ci8qKgogKiBDYW5ub3QgdXNlIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9uI2Rlc3Ryb3kgZGVzdHJveWVkIG1hcmtlcn0gaW5zdGFuY2UuCiAqCiAqIEBlcnJvciBtYXJrZXItZGVzdHJveWVkCiAqLw=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js"],"names":["LiveRange","EmitterMixin","CKEditorError","mix","MarkerCollection","_markers","Map","Symbol","iterator","values","markerName","has","get","markerOrName","range","managedUsingOperations","affectsData","Marker","name","oldMarker","oldRange","getRange","hasChanged","isEqual","_attachLiveRange","fromRange","_managedUsingOperations","_affectsData","fire","liveRange","marker","set","delete","_destroyMarker","position","containsPosition","getIntersection","stopListening","prefix","startsWith","_detachLiveRange","_liveRange","start","clone","end","toRange","type","delegate","to","stopDelegating","detach"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/markercollection\n */\n\nimport LiveRange from './liverange';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.\n * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.\n *\n * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:\n * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since\n * the writer is the only proper way to change the data model it is not possible to change markers directly using this\n * collection. All markers created by the writer will be automatically added to this collection.\n *\n * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.\n *\n * @see module:engine/model/markercollection~Marker\n */\nexport default class MarkerCollection {\n\t/**\n\t * Creates a markers collection.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Stores {@link ~Marker markers} added to the collection.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} #_markers\n\t\t */\n\t\tthis._markers = new Map();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link ~Marker markers} added to the collection.\n\t *\n\t * @returns {Iterable}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._markers.values();\n\t}\n\n\t/**\n\t * Checks if marker with given `markerName` is in the collection.\n\t *\n\t * @param {String} markerName Marker name.\n\t * @returns {Boolean} `true` if marker with given `markerName` is in the collection, `false` otherwise.\n\t */\n\thas( markerName ) {\n\t\treturn this._markers.has( markerName );\n\t}\n\n\t/**\n\t * Returns {@link ~Marker marker} with given `markerName`.\n\t *\n\t * @param {String} markerName Name of marker to get.\n\t * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was\n\t * not added to the collection.\n\t */\n\tget( markerName ) {\n\t\treturn this._markers.get( markerName ) || null;\n\t}\n\n\t/**\n\t * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given\n\t * {@link module:engine/model/range~Range range}.\n\t *\n\t * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in\n\t * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired\n\t * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}\n\t * flag has changed.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.\n\t * @param {module:engine/model/range~Range} range Marker range.\n\t * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.\n\t * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.\n\t */\n\t_set( markerOrName, range, managedUsingOperations = false, affectsData = false ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tconst oldRange = oldMarker.getRange();\n\t\t\tlet hasChanged = false;\n\n\t\t\tif ( !oldRange.isEqual( range ) ) {\n\t\t\t\toldMarker._attachLiveRange( LiveRange.fromRange( range ) );\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( managedUsingOperations != oldMarker.managedUsingOperations ) {\n\t\t\t\toldMarker._managedUsingOperations = managedUsingOperations;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData ) {\n\t\t\t\toldMarker._affectsData = affectsData;\n\t\t\t\thasChanged = true;\n\t\t\t}\n\n\t\t\tif ( hasChanged ) {\n\t\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldRange, range );\n\t\t\t}\n\n\t\t\treturn oldMarker;\n\t\t}\n\n\t\tconst liveRange = LiveRange.fromRange( range );\n\t\tconst marker = new Marker( markerName, liveRange, managedUsingOperations, affectsData );\n\n\t\tthis._markers.set( markerName, marker );\n\t\tthis.fire( 'update:' + markerName, marker, null, range );\n\n\t\treturn marker;\n\t}\n\n\t/**\n\t * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String} markerOrName Marker or name of a marker to remove.\n\t * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.\n\t */\n\t_remove( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst oldMarker = this._markers.get( markerName );\n\n\t\tif ( oldMarker ) {\n\t\t\tthis._markers.delete( markerName );\n\t\t\tthis.fire( 'update:' + markerName, oldMarker, oldMarker.getRange(), null );\n\n\t\t\tthis._destroyMarker( oldMarker );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}\n\t * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast\n\t * conversion} for the marker.\n\t *\n\t * @protected\n\t * @fires module:engine/model/markercollection~MarkerCollection#event:update\n\t * @param {String} markerOrName Marker or name of a marker to refresh.\n\t */\n\t_refresh( markerOrName ) {\n\t\tconst markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;\n\t\tconst marker = this._markers.get( markerName );\n\n\t\tif ( !marker ) {\n\t\t\tthrow new CKEditorError( 'markercollection-refresh-marker-not-exists: Marker with provided name does not exists.', this );\n\t\t}\n\n\t\tconst range = marker.getRange();\n\n\t\tthis.fire( 'update:' + markerName, marker, range, range, marker.managedUsingOperations, marker.affectsData );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersAtPosition( position ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().containsPosition( position ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} range\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersIntersectingRange( range ) {\n\t\tfor ( const marker of this ) {\n\t\t\tif ( marker.getRange().getIntersection( range ) !== null ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys marker collection and all markers inside it.\n\t */\n\tdestroy() {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tthis._destroyMarker( marker );\n\t\t}\n\n\t\tthis._markers = null;\n\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Iterates over all markers that starts with given `prefix`.\n\t *\n\t *\t\tconst markerFooA = markersCollection.set( 'foo:a', rangeFooA );\n\t *\t\tconst markerFooB = markersCollection.set( 'foo:b', rangeFooB );\n\t *\t\tconst markerBarA = markersCollection.set( 'bar:a', rangeBarA );\n\t *\t\tconst markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]\n\t *\t\tArray.from( markersCollection.getMarkersGroup( 'a' ) ); // []\n\t *\n\t * @param prefix\n\t * @returns {Iterable.<module:engine/model/markercollection~Marker>}\n\t */\n\t* getMarkersGroup( prefix ) {\n\t\tfor ( const marker of this._markers.values() ) {\n\t\t\tif ( marker.name.startsWith( prefix + ':' ) ) {\n\t\t\t\tyield marker;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Destroys the marker.\n\t *\n\t * @private\n\t * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.\n\t */\n\t_destroyMarker( marker ) {\n\t\tmarker.stopListening();\n\t\tmarker._detachLiveRange();\n\t}\n\n\t/**\n\t * Fired whenever marker is added, updated or removed from `MarkerCollection`.\n\t *\n\t * @event update\n\t * @param {module:engine/model/markercollection~Marker} marker Updated Marker.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it\n\t * means that marker is just added.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it\n\t * means that marker is just removed.\n\t */\n}\n\nmix( MarkerCollection, EmitterMixin );\n\n/**\n * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked\n * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of\n * model document tree, markers are not stored directly in document tree but in\n * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving\n * additional meaning to the part of a model document between marker start and marker end.\n *\n * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is\n * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).\n * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that\n * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being\n * \"special\" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document\n * model, it starts being \"special\" and the marker is enlarged.\n *\n * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes\n * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access\n * to the range which it is marking at the moment.\n *\n * Markers are built from a name and a range.\n *\n * Range of the marker is updated automatically when document changes, using\n * {@link module:engine/model/liverange~LiveRange live range} mechanism.\n *\n * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by\n * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating\n * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in\n * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.\n * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.\n *\n * There are two types of markers.\n *\n * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}\n * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used\n * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.\n *\n * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}\n * but changes in these markers is managed the same way all other changes in the model structure - using operations.\n * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.\n * This type of markers is useful for solutions like spell checking or comments.\n *\n * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}\n * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.\n *\n *\t\tmodel.change( ( writer ) => {\n * \t\t\tconst marker = writer.addMarker( name, { range, usingOperation: true } );\n *\n * \t\t\t// ...\n *\n * \t\t\twriter.removeMarker( marker );\n *\t\t} );\n *\n * See {@link module:engine/model/writer~Writer} to find more examples.\n *\n * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little\n * markers as possible and remove them as soon as they are not needed anymore.\n *\n * Markers can be downcasted and upcasted.\n *\n * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.\n * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.\n * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.\n * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or\n * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.\n *\n * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.\n */\nclass Marker {\n\t/**\n\t * Creates a marker instance.\n\t *\n\t * @param {String} name Marker name.\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.\n\t * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.\n\t * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline\n\t * (is persisted in the editor's data).\n\t */\n\tconstructor( name, liveRange, managedUsingOperations, affectsData ) {\n\t\t/**\n\t\t * Marker's name.\n\t\t *\n\t\t * @readonly\n\t\t * @type {String}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Range marked by the marker.\n\t\t *\n\t\t * @protected\n\t\t * @member {module:engine/model/liverange~LiveRange}\n\t\t */\n\t\tthis._liveRange = this._attachLiveRange( liveRange );\n\n\t\t/**\n\t\t * Flag indicates if the marker is managed using operations or not.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._managedUsingOperations = managedUsingOperations;\n\n\t\t/**\n\t\t * Specifies whether the marker affects the data produced by the data pipeline\n\t\t * (is persisted in the editor's data).\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._affectsData = affectsData;\n\t}\n\n\t/**\n\t * A value indicating if the marker is managed using operations.\n\t * See {@link ~Marker marker class description} to learn more about marker types.\n\t * See {@link module:engine/model/writer~Writer#addMarker}.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget managedUsingOperations() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.', this );\n\t\t}\n\n\t\treturn this._managedUsingOperations;\n\t}\n\n\t/**\n\t * A value indicating if the marker changes the data.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget affectsData() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.', this );\n\t\t}\n\n\t\treturn this._affectsData;\n\t}\n\n\t/**\n\t * Returns current marker start position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetStart() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.', this );\n\t\t}\n\n\t\treturn this._liveRange.start.clone();\n\t}\n\n\t/**\n\t * Returns current marker end position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tgetEnd() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.', this );\n\t\t}\n\n\t\treturn this._liveRange.end.clone();\n\t}\n\n\t/**\n\t * Returns a range that represents the current state of the marker.\n\t *\n\t * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a\n\t * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only\n\t * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}\n\t * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every\n\t * time there is a need to read marker properties. This will guarantee that the marker has not been removed and\n\t * that it's data is up-to-date.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tgetRange() {\n\t\tif ( !this._liveRange ) {\n\t\t\tthrow new CKEditorError( 'marker-destroyed: Cannot use a destroyed marker instance.', this );\n\t\t}\n\n\t\treturn this._liveRange.toRange();\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tmarker.is( 'marker' ); // -> true\n\t *\t\tmarker.is( 'model:marker' ); // -> true\n\t *\n\t *\t\tmarker.is( 'view:element' ); // -> false\n\t *\t\tmarker.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'marker' || type == 'model:marker';\n\t}\n\n\t/**\n\t * Binds new live range to the marker and detach the old one if is attached.\n\t *\n\t * @protected\n\t * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach\n\t * @returns {module:engine/model/liverange~LiveRange} Attached live range.\n\t */\n\t_attachLiveRange( liveRange ) {\n\t\tif ( this._liveRange ) {\n\t\t\tthis._detachLiveRange();\n\t\t}\n\n\t\t// Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).\n\t\tliveRange.delegate( 'change:range' ).to( this );\n\t\tliveRange.delegate( 'change:content' ).to( this );\n\n\t\tthis._liveRange = liveRange;\n\n\t\treturn liveRange;\n\t}\n\n\t/**\n\t * Unbinds and destroys currently attached live range.\n\t *\n\t * @protected\n\t */\n\t_detachLiveRange() {\n\t\tthis._liveRange.stopDelegating( 'change:range', this );\n\t\tthis._liveRange.stopDelegating( 'change:content', this );\n\t\tthis._liveRange.detach();\n\t\tthis._liveRange = null;\n\t}\n\n\t/**\n\t * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:range\n\t * @event change:range\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n\n\t/**\n\t * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.\n\t * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.\n\t *\n\t * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},\n\t * all event listeners listening to it should be removed. It is best to do it on\n\t * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.\n\t *\n\t * @see module:engine/model/liverange~LiveRange#event:change:content\n\t * @event change:content\n\t * @param {module:engine/model/range~Range} oldRange\n\t * @param {Object} data\n\t */\n}\n\nmix( Marker, EmitterMixin );\n\n/**\n * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.\n *\n * @error marker-destroyed\n */\n"]}]}