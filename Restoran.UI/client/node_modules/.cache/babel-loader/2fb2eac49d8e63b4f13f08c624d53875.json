{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\domconverter.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\domconverter.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy53ZWFrLW1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5IjsKaW1wb3J0ICJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcgogKi8KCi8qIGdsb2JhbHMgZG9jdW1lbnQsIE5vZGUsIE5vZGVGaWx0ZXIsIFRleHQgKi8KaW1wb3J0IFZpZXdUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBWaWV3RWxlbWVudCBmcm9tICcuL2VsZW1lbnQnOwppbXBvcnQgVmlld1Bvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgVmlld1JhbmdlIGZyb20gJy4vcmFuZ2UnOwppbXBvcnQgVmlld1NlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7CmltcG9ydCBWaWV3RG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgVmlld1RyZWVXYWxrZXIgZnJvbSAnLi90cmVld2Fsa2VyJzsKaW1wb3J0IHsgQlJfRklMTEVSLCBnZXREYXRhV2l0aG91dEZpbGxlciwgSU5MSU5FX0ZJTExFUl9MRU5HVEgsIGlzSW5saW5lRmlsbGVyLCBOQlNQX0ZJTExFUiwgc3RhcnRzV2l0aEZpbGxlciB9IGZyb20gJy4vZmlsbGVyJzsKaW1wb3J0IGdsb2JhbCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9kb20vZ2xvYmFsJzsKaW1wb3J0IGluZGV4T2YgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2luZGV4b2YnOwppbXBvcnQgZ2V0QW5jZXN0b3JzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2RvbS9nZXRhbmNlc3RvcnMnOwppbXBvcnQgZ2V0Q29tbW9uQW5jZXN0b3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2dldGNvbW1vbmFuY2VzdG9yJzsKaW1wb3J0IGlzVGV4dCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9kb20vaXN0ZXh0JzsKaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnbG9kYXNoLWVzJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXAKCnZhciBCUl9GSUxMRVJfUkVGID0gQlJfRklMTEVSKGRvY3VtZW50KTsKLyoqCiAqIERvbUNvbnZlcnRlciBpcyBhIHNldCBvZiB0b29scyB0byBkbyB0cmFuc2Zvcm1hdGlvbnMgYmV0d2VlbiBET00gbm9kZXMgYW5kIHZpZXcgbm9kZXMuIEl0IGFsc28gaGFuZGxlcwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJpbmRpbmd9IHRoZXNlIG5vZGVzLgogKgogKiBUaGUgaW5zdGFuY2Ugb2YgRE9NQ29udmVydGVyIGlzIGF2YWlsYWJsZSBpbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3ZpZXd+VmlldyNkb21Db252ZXJ0ZXIgYGVkaXRvci5lZGl0aW5nLnZpZXcuZG9tQ29udmVydGVyYH0uCiAqCiAqIERvbUNvbnZlcnRlciBkb2VzIG5vdCBjaGVjayB3aGljaCBub2RlcyBzaG91bGQgYmUgcmVuZGVyZWQgKHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JlbmRlcmVyflJlbmRlcmVyfSksIGRvZXMgbm90IGtlZXAgYQogKiBzdGF0ZSBvZiBhIHRyZWUgbm9yIGtlZXBzIHN5bmNocm9uaXphdGlvbiBiZXR3ZWVuIHRyZWUgdmlldyBhbmQgRE9NIHRyZWUgKHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50fSkuCiAqCiAqIERvbUNvbnZlcnRlciBrZWVwcyBET00gZWxlbWVudHMgdG8gVmlldyBlbGVtZW50IGJpbmRpbmdzLCBzbyB3aGVuIHRoZSBjb252ZXJ0ZXIgd2lsbCBiZSBkZXN0cm95ZWQsIHRoZSBiaW5kaW5nIHdpbGwKICogYmUgbG9zdC4gVHdvIGNvbnZlcnRlcnMgd2lsbCBrZWVwIHNlcGFyYXRlIGJpbmRpbmcgbWFwcywgc28gb25lIHRyZWUgdmlldyBjYW4gYmUgYm91bmQgd2l0aCB0d28gRE9NIHRyZWVzLgogKi8KCnZhciBEb21Db252ZXJ0ZXIgPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIERPTSBjb252ZXJ0ZXIuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0gZG9jdW1lbnQgVGhlIHZpZXcgZG9jdW1lbnQgaW5zdGFuY2UuCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlcn5CbG9ja0ZpbGxlck1vZGV9IFtvcHRpb25zLmJsb2NrRmlsbGVyTW9kZT0nYnInXSBUaGUgdHlwZSBvZiB0aGUgYmxvY2sgZmlsbGVyIHRvIHVzZS4KICAgKi8KICBmdW5jdGlvbiBEb21Db252ZXJ0ZXIoZG9jdW1lbnQpIHsKICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tQ29udmVydGVyKTsKCiAgICAvKioKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwogICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50OwogICAgLyoqCiAgICAgKiBUaGUgbW9kZSBvZiBhIGJsb2NrIGZpbGxlciB1c2VkIGJ5IERPTSBjb252ZXJ0ZXIuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHsnYnInfCduYnNwJ30gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmxvY2tGaWxsZXJNb2RlCiAgICAgKi8KCiAgICB0aGlzLmJsb2NrRmlsbGVyTW9kZSA9IG9wdGlvbnMuYmxvY2tGaWxsZXJNb2RlIHx8ICdicic7CiAgICAvKioKICAgICAqIEVsZW1lbnRzIHdoaWNoIGFyZSBjb25zaWRlcmVkIHByZS1mb3JtYXR0ZWQgZWxlbWVudHMuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtBcnJheS48U3RyaW5nPn0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjcHJlRWxlbWVudHMKICAgICAqLwoKICAgIHRoaXMucHJlRWxlbWVudHMgPSBbJ3ByZSddOwogICAgLyoqCiAgICAgKiBFbGVtZW50cyB3aGljaCBhcmUgY29uc2lkZXJlZCBibG9jayBlbGVtZW50cyAoYW5kIGhlbmNlIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBhCiAgICAgKiB7QGxpbmsgI2lzQmxvY2tGaWxsZXIgYmxvY2sgZmlsbGVyfSkuCiAgICAgKgogICAgICogV2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgYSBibG9jayBlbGVtZW50IGFsc28gYWZmZWN0cyBoYW5kbGluZyBvZiB0cmFpbGluZyB3aGl0ZXNwYWNlcy4KICAgICAqCiAgICAgKiBZb3UgY2FuIGV4dGVuZCB0aGlzIGFycmF5IGlmIHlvdSBpbnRyb2R1Y2Ugc3VwcG9ydCBmb3IgYmxvY2sgZWxlbWVudHMgd2hpY2ggYXJlIG5vdCB5ZXQgcmVjb2duaXplZCBoZXJlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7QXJyYXkuPFN0cmluZz59IG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2Jsb2NrRWxlbWVudHMKICAgICAqLwoKICAgIHRoaXMuYmxvY2tFbGVtZW50cyA9IFsncCcsICdkaXYnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnbGknLCAnZGQnLCAnZHQnLCAnZmlnY2FwdGlvbiddOwogICAgLyoqCiAgICAgKiBCbG9jayB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlciBmaWxsZXJ9IGNyZWF0b3IsIHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIGFsbCBibG9jayBmaWxsZXJzIGR1cmluZyB0aGUKICAgICAqIHZpZXcgdG8gRE9NIGNvbnZlcnNpb24gYW5kIHRvIHJlY29nbml6ZSBibG9jayBmaWxsZXJzIGR1cmluZyB0aGUgRE9NIHRvIHZpZXcgY29udmVyc2lvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjX2Jsb2NrRmlsbGVyCiAgICAgKi8KCiAgICB0aGlzLl9ibG9ja0ZpbGxlciA9IHRoaXMuYmxvY2tGaWxsZXJNb2RlID09ICdicicgPyBCUl9GSUxMRVIgOiBOQlNQX0ZJTExFUjsKICAgIC8qKgogICAgICogRE9NIHRvIFZpZXcgbWFwcGluZy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7V2Vha01hcH0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjX2RvbVRvVmlld01hcHBpbmcKICAgICAqLwoKICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IHRvIERPTSBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNfdmlld1RvRG9tTWFwcGluZwogICAgICovCgogICAgdGhpcy5fdmlld1RvRG9tTWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgICAvKioKICAgICAqIEhvbGRzIG1hcHBpbmcgYmV0d2VlbiBmYWtlIHNlbGVjdGlvbiBjb250YWluZXJzIGFuZCBjb3JyZXNwb25kaW5nIHZpZXcgc2VsZWN0aW9ucy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7V2Vha01hcH0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjX2Zha2VTZWxlY3Rpb25NYXBwaW5nCiAgICAgKi8KCiAgICB0aGlzLl9mYWtlU2VsZWN0aW9uTWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgfQogIC8qKgogICAqIEJpbmRzIGdpdmVuIERPTSBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBmYWtlIHNlbGVjdGlvbiB0byBhICoqcG9zaXRpb24qKiBvZiBhCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiBkb2N1bWVudCBzZWxlY3Rpb259LgogICAqIERvY3VtZW50IHNlbGVjdGlvbiBjb3B5IGlzIHN0b3JlZCBhbmQgY2FuIGJlIHJldHJpZXZlZCBieQogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNmYWtlU2VsZWN0aW9uVG9WaWV3fSBtZXRob2QuCiAgICoKICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHZpZXdEb2N1bWVudFNlbGVjdGlvbgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKERvbUNvbnZlcnRlciwgW3sKICAgIGtleTogImJpbmRGYWtlU2VsZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRmFrZVNlbGVjdGlvbihkb21FbGVtZW50LCB2aWV3RG9jdW1lbnRTZWxlY3Rpb24pIHsKICAgICAgdGhpcy5fZmFrZVNlbGVjdGlvbk1hcHBpbmcuc2V0KGRvbUVsZW1lbnQsIG5ldyBWaWV3U2VsZWN0aW9uKHZpZXdEb2N1bWVudFNlbGVjdGlvbikpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbiB2aWV3IHNlbGVjdGlvbn0gaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0bwogICAgICogZ2l2ZW4gRE9NIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGZha2Ugc2VsZWN0aW9uLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGJpbmRpbmcgdG8gZ2l2ZW4gRE9NIGVsZW1lbnQgZG9lcyBub3QgZXhpc3RzLgogICAgICoKICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbnx1bmRlZmluZWR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZmFrZVNlbGVjdGlvblRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmFrZVNlbGVjdGlvblRvVmlldyhkb21FbGVtZW50KSB7CiAgICAgIHJldHVybiB0aGlzLl9mYWtlU2VsZWN0aW9uTWFwcGluZy5nZXQoZG9tRWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIEJpbmRzIERPTSBhbmQgVmlldyBlbGVtZW50cywgc28gaXQgd2lsbCBiZSBwb3NzaWJsZSB0byBnZXQgY29ycmVzcG9uZGluZyBlbGVtZW50cyB1c2luZwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI21hcERvbVRvVmlld30gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjbWFwVmlld1RvRG9tfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50IERPTSBlbGVtZW50IHRvIGJpbmQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdFbGVtZW50IFZpZXcgZWxlbWVudCB0byBiaW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogImJpbmRFbGVtZW50cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEVsZW1lbnRzKGRvbUVsZW1lbnQsIHZpZXdFbGVtZW50KSB7CiAgICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcuc2V0KGRvbUVsZW1lbnQsIHZpZXdFbGVtZW50KTsKCiAgICAgIHRoaXMuX3ZpZXdUb0RvbU1hcHBpbmcuc2V0KHZpZXdFbGVtZW50LCBkb21FbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogVW5iaW5kcyBnaXZlbiBgZG9tRWxlbWVudGAgZnJvbSB0aGUgdmlldyBlbGVtZW50IGl0IHdhcyBib3VuZCB0by4gVW5iaW5kaW5nIGlzIGRlZXAsIG1lYW5pbmcgdGhhdCBhbGwgY2hpbGRyZW4gb2YKICAgICAqIGBkb21FbGVtZW50YCB3aWxsIGJlIHVuYm91bmQgdG9vLgogICAgICoKICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQgRE9NIGVsZW1lbnQgdG8gdW5iaW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInVuYmluZERvbUVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZERvbUVsZW1lbnQoZG9tRWxlbWVudCkgewogICAgICB2YXIgdmlld0VsZW1lbnQgPSB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLmdldChkb21FbGVtZW50KTsKCiAgICAgIGlmICh2aWV3RWxlbWVudCkgewogICAgICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZGVsZXRlKGRvbUVsZW1lbnQpOwoKICAgICAgICB0aGlzLl92aWV3VG9Eb21NYXBwaW5nLmRlbGV0ZSh2aWV3RWxlbWVudCk7IC8vIFVzZSBBcnJheS5mcm9tIGJlY2F1c2Ugb2YgTVMgRWRnZSAoIzkyMykuCgoKICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9BcnJheSRmcm9tID0gQXJyYXkuZnJvbShkb21FbGVtZW50LmNoaWxkTm9kZXMpOyBfaSA8IF9BcnJheSRmcm9tLmxlbmd0aDsgX2krKykgewogICAgICAgICAgdmFyIGNoaWxkID0gX0FycmF5JGZyb21bX2ldOwogICAgICAgICAgdGhpcy51bmJpbmREb21FbGVtZW50KGNoaWxkKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQmluZHMgRE9NIGFuZCBWaWV3IGRvY3VtZW50IGZyYWdtZW50cywgc28gaXQgd2lsbCBiZSBwb3NzaWJsZSB0byBnZXQgY29ycmVzcG9uZGluZyBkb2N1bWVudCBmcmFnbWVudHMgdXNpbmcKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNtYXBEb21Ub1ZpZXd9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI21hcFZpZXdUb0RvbX0uCiAgICAgKgogICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBkb21GcmFnbWVudCBET00gZG9jdW1lbnQgZnJhZ21lbnQgdG8gYmluZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gdmlld0ZyYWdtZW50IFZpZXcgZG9jdW1lbnQgZnJhZ21lbnQgdG8gYmluZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJiaW5kRG9jdW1lbnRGcmFnbWVudHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmREb2N1bWVudEZyYWdtZW50cyhkb21GcmFnbWVudCwgdmlld0ZyYWdtZW50KSB7CiAgICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcuc2V0KGRvbUZyYWdtZW50LCB2aWV3RnJhZ21lbnQpOwoKICAgICAgdGhpcy5fdmlld1RvRG9tTWFwcGluZy5zZXQodmlld0ZyYWdtZW50LCBkb21GcmFnbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIHZpZXcgdG8gRE9NLiBGb3IgYWxsIHRleHQgbm9kZXMsIG5vdCBib3VuZCBlbGVtZW50cyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIG5ldyBpdGVtcyB3aWxsCiAgICAgKiBiZSBjcmVhdGVkLiBGb3IgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBmdW5jdGlvbiB3aWxsIHJldHVybiBjb3JyZXNwb25kaW5nIGl0ZW1zLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3Tm9kZQogICAgICogVmlldyBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIHRyYW5zZm9ybS4KICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvbURvY3VtZW50IERvY3VtZW50IHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgRE9NIG5vZGVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnMuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmQ9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBuZXcgZWxlbWVudHMgd2lsbCBiZSBib3VuZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aENoaWxkcmVuPXRydWVdIElmIGB0cnVlYCwgbm9kZSdzIGFuZCBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuIHdpbGwgYmUgY29udmVydGVkIHRvby4KICAgICAqIEByZXR1cm5zIHtOb2RlfERvY3VtZW50RnJhZ21lbnR9IENvbnZlcnRlZCBub2RlIG9yIERvY3VtZW50RnJhZ21lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidmlld1RvRG9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3VG9Eb20odmlld05vZGUsIGRvbURvY3VtZW50KSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTsKCiAgICAgIGlmICh2aWV3Tm9kZS5pcygndGV4dCcpKSB7CiAgICAgICAgdmFyIHRleHREYXRhID0gdGhpcy5fcHJvY2Vzc0RhdGFGcm9tVmlld1RleHQodmlld05vZGUpOwoKICAgICAgICByZXR1cm4gZG9tRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dERhdGEpOwogICAgICB9IGVsc2UgewogICAgICAgIGlmICh0aGlzLm1hcFZpZXdUb0RvbSh2aWV3Tm9kZSkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3Tm9kZSk7CiAgICAgICAgfQoKICAgICAgICB2YXIgZG9tRWxlbWVudDsKCiAgICAgICAgaWYgKHZpZXdOb2RlLmlzKCdkb2N1bWVudEZyYWdtZW50JykpIHsKICAgICAgICAgIC8vIENyZWF0ZSBET00gZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOwoKICAgICAgICAgIGlmIChvcHRpb25zLmJpbmQpIHsKICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRGcmFnbWVudHMoZG9tRWxlbWVudCwgdmlld05vZGUpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAodmlld05vZGUuaXMoJ3VpRWxlbWVudCcpKSB7CiAgICAgICAgICAvLyBVSUVsZW1lbnQgaGFzIGl0cyBvd24gcmVuZGVyKCkgbWV0aG9kIChzZWUgIzc5OSkuCiAgICAgICAgICBkb21FbGVtZW50ID0gdmlld05vZGUucmVuZGVyKGRvbURvY3VtZW50KTsKCiAgICAgICAgICBpZiAob3B0aW9ucy5iaW5kKSB7CiAgICAgICAgICAgIHRoaXMuYmluZEVsZW1lbnRzKGRvbUVsZW1lbnQsIHZpZXdOb2RlKTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gZG9tRWxlbWVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gQ3JlYXRlIERPTSBlbGVtZW50LgogICAgICAgICAgaWYgKHZpZXdOb2RlLmhhc0F0dHJpYnV0ZSgneG1sbnMnKSkgewogICAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHZpZXdOb2RlLmdldEF0dHJpYnV0ZSgneG1sbnMnKSwgdmlld05vZGUubmFtZSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2aWV3Tm9kZS5uYW1lKTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAob3B0aW9ucy5iaW5kKSB7CiAgICAgICAgICAgIHRoaXMuYmluZEVsZW1lbnRzKGRvbUVsZW1lbnQsIHZpZXdOb2RlKTsKICAgICAgICAgIH0gLy8gQ29weSBlbGVtZW50J3MgYXR0cmlidXRlcy4KCgogICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmlld05vZGUuZ2V0QXR0cmlidXRlS2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkgewogICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTsKICAgICAgICAgICAgICBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZpZXdOb2RlLmdldEF0dHJpYnV0ZShrZXkpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChvcHRpb25zLndpdGhDaGlsZHJlbiB8fCBvcHRpb25zLndpdGhDaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy52aWV3Q2hpbGRyZW5Ub0RvbSh2aWV3Tm9kZSwgZG9tRG9jdW1lbnQsIG9wdGlvbnMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgICAgIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHsKICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiBkb21FbGVtZW50OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIGNoaWxkcmVuIG9mIHRoZSB2aWV3IGVsZW1lbnQgdG8gRE9NIHVzaW5nIHRoZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI3ZpZXdUb0RvbX0gbWV0aG9kLgogICAgICogQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZCBhZGRzIGJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4sIGlmIG5lZWRlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gdmlld0VsZW1lbnQgUGFyZW50IHZpZXcgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvbURvY3VtZW50IERvY3VtZW50IHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgRE9NIG5vZGVzLgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciN2aWV3VG9Eb219IG9wdGlvbnMgcGFyYW1ldGVyLgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxOb2RlPn0gRE9NIG5vZGVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogInZpZXdDaGlsZHJlblRvRG9tIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gdmlld0NoaWxkcmVuVG9Eb20odmlld0VsZW1lbnQsIGRvbURvY3VtZW50KSB7CiAgICAgIHZhciBvcHRpb25zLAogICAgICAgICAgZmlsbGVyUG9zaXRpb25PZmZzZXQsCiAgICAgICAgICBvZmZzZXQsCiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMywKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMywKICAgICAgICAgIF9pdGVyYXRvckVycm9yMywKICAgICAgICAgIF9pdGVyYXRvcjMsCiAgICAgICAgICBfc3RlcDMsCiAgICAgICAgICBjaGlsZFZpZXcsCiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiB2aWV3Q2hpbGRyZW5Ub0RvbSQoX2NvbnRleHQpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDIgJiYgX2FyZ3NbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzJdIDoge307CiAgICAgICAgICAgICAgZmlsbGVyUG9zaXRpb25PZmZzZXQgPSB2aWV3RWxlbWVudC5nZXRGaWxsZXJPZmZzZXQgJiYgdmlld0VsZW1lbnQuZ2V0RmlsbGVyT2Zmc2V0KCk7CiAgICAgICAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA2OwogICAgICAgICAgICAgIF9pdGVyYXRvcjMgPSB2aWV3RWxlbWVudC5nZXRDaGlsZHJlbigpW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgICAgIGNhc2UgODoKICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgY2hpbGRWaWV3ID0gX3N0ZXAzLnZhbHVlOwoKICAgICAgICAgICAgICBpZiAoIShmaWxsZXJQb3NpdGlvbk9mZnNldCA9PT0gb2Zmc2V0KSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrRmlsbGVyKGRvbURvY3VtZW50KTsKCiAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1OwogICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdUb0RvbShjaGlsZFZpZXcsIGRvbURvY3VtZW50LCBvcHRpb25zKTsKCiAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgb2Zmc2V0Kys7CgogICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTk6CiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAyMToKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7CiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFsiY2F0Y2giXSg2KTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IF9jb250ZXh0LnQwOwoKICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI2OwoKICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSAyODoKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjg7CgogICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IzKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMzsKCiAgICAgICAgICAgIGNhc2UgMzE6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyOCk7CgogICAgICAgICAgICBjYXNlIDMyOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjUpOwoKICAgICAgICAgICAgY2FzZSAzMzoKICAgICAgICAgICAgICBpZiAoIShmaWxsZXJQb3NpdGlvbk9mZnNldCA9PT0gb2Zmc2V0KSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM2OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzY7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrRmlsbGVyKGRvbURvY3VtZW50KTsKCiAgICAgICAgICAgIGNhc2UgMzY6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIHZpZXdDaGlsZHJlblRvRG9tLCB0aGlzLCBbWzYsIDIxLCAyNSwgMzNdLCBbMjYsLCAyOCwgMzJdXSk7CiAgICB9KQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyB2aWV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHRvIERPTSByYW5nZS4KICAgICAqIElubGluZSBhbmQgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyc30gYXJlIGhhbmRsZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSB2aWV3UmFuZ2UgVmlldyByYW5nZS4KICAgICAqIEByZXR1cm5zIHtSYW5nZX0gRE9NIHJhbmdlLgogICAgICovCgogIH0sIHsKICAgIGtleTogInZpZXdSYW5nZVRvRG9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3UmFuZ2VUb0RvbSh2aWV3UmFuZ2UpIHsKICAgICAgdmFyIGRvbVN0YXJ0ID0gdGhpcy52aWV3UG9zaXRpb25Ub0RvbSh2aWV3UmFuZ2Uuc3RhcnQpOwogICAgICB2YXIgZG9tRW5kID0gdGhpcy52aWV3UG9zaXRpb25Ub0RvbSh2aWV3UmFuZ2UuZW5kKTsKICAgICAgdmFyIGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTsKICAgICAgZG9tUmFuZ2Uuc2V0U3RhcnQoZG9tU3RhcnQucGFyZW50LCBkb21TdGFydC5vZmZzZXQpOwogICAgICBkb21SYW5nZS5zZXRFbmQoZG9tRW5kLnBhcmVudCwgZG9tRW5kLm9mZnNldCk7CiAgICAgIHJldHVybiBkb21SYW5nZTsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB0byBET00gcGFyZW50IGFuZCBvZmZzZXQuCiAgICAgKgogICAgICogSW5saW5lIGFuZCBibG9jayB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlciBmaWxsZXJzfSBhcmUgaGFuZGxlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICAgKiBJZiB0aGUgY29udmVydGVkIHBvc2l0aW9uIGlzIGRpcmVjdGx5IGJlZm9yZSBpbmxpbmUgZmlsbGVyIGl0IGlzIG1vdmVkIGluc2lkZSB0aGUgZmlsbGVyLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB2aWV3UG9zaXRpb24gVmlldyBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gcG9zaXRpb24gRE9NIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB2aWV3IHBvc2l0aW9uIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gRE9NLgogICAgICogQHJldHVybnMge05vZGV9IHBvc2l0aW9uLnBhcmVudCBET00gcG9zaXRpb24gcGFyZW50LgogICAgICogQHJldHVybnMge051bWJlcn0gcG9zaXRpb24ub2Zmc2V0IERPTSBwb3NpdGlvbiBvZmZzZXQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidmlld1Bvc2l0aW9uVG9Eb20iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdQb3NpdGlvblRvRG9tKHZpZXdQb3NpdGlvbikgewogICAgICB2YXIgdmlld1BhcmVudCA9IHZpZXdQb3NpdGlvbi5wYXJlbnQ7CgogICAgICBpZiAodmlld1BhcmVudC5pcygndGV4dCcpKSB7CiAgICAgICAgdmFyIGRvbVBhcmVudCA9IHRoaXMuZmluZENvcnJlc3BvbmRpbmdEb21UZXh0KHZpZXdQYXJlbnQpOwoKICAgICAgICBpZiAoIWRvbVBhcmVudCkgewogICAgICAgICAgLy8gUG9zaXRpb24gaXMgaW4gYSB2aWV3IHRleHQgbm9kZSB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byBET00geWV0LgogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQoKICAgICAgICB2YXIgb2Zmc2V0ID0gdmlld1Bvc2l0aW9uLm9mZnNldDsKCiAgICAgICAgaWYgKHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50KSkgewogICAgICAgICAgb2Zmc2V0ICs9IElOTElORV9GSUxMRVJfTEVOR1RIOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHBhcmVudDogZG9tUGFyZW50LAogICAgICAgICAgb2Zmc2V0OiBvZmZzZXQKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIC8vIHZpZXdQYXJlbnQgaXMgaW5zdGFuY2Ugb2YgVmlld0VsZW1lbnQuCiAgICAgICAgdmFyIF9kb21QYXJlbnQsIGRvbUJlZm9yZSwgZG9tQWZ0ZXI7CgogICAgICAgIGlmICh2aWV3UG9zaXRpb24ub2Zmc2V0ID09PSAwKSB7CiAgICAgICAgICBfZG9tUGFyZW50ID0gdGhpcy5tYXBWaWV3VG9Eb20odmlld1BhcmVudCk7CgogICAgICAgICAgaWYgKCFfZG9tUGFyZW50KSB7CiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGlzIGluIGEgdmlldyBlbGVtZW50IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHRvIERPTSB5ZXQuCiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfQoKICAgICAgICAgIGRvbUFmdGVyID0gX2RvbVBhcmVudC5jaGlsZE5vZGVzWzBdOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IHZpZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICAgICAgZG9tQmVmb3JlID0gbm9kZUJlZm9yZS5pcygndGV4dCcpID8gdGhpcy5maW5kQ29ycmVzcG9uZGluZ0RvbVRleHQobm9kZUJlZm9yZSkgOiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3UG9zaXRpb24ubm9kZUJlZm9yZSk7CgogICAgICAgICAgaWYgKCFkb21CZWZvcmUpIHsKICAgICAgICAgICAgLy8gUG9zaXRpb24gaXMgYWZ0ZXIgYSB2aWV3IGVsZW1lbnQgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gRE9NIHlldC4KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CgogICAgICAgICAgX2RvbVBhcmVudCA9IGRvbUJlZm9yZS5wYXJlbnROb2RlOwogICAgICAgICAgZG9tQWZ0ZXIgPSBkb21CZWZvcmUubmV4dFNpYmxpbmc7CiAgICAgICAgfSAvLyBJZiB0aGVyZSBpcyBhbiBpbmxpbmUgZmlsbGVyIGF0IHBvc2l0aW9uIHJldHVybiBwb3NpdGlvbiBpbnNpZGUgdGhlIGZpbGxlci4gV2Ugc2hvdWxkIG5ldmVyIHJldHVybgogICAgICAgIC8vIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGlubGluZSBmaWxsZXIuCgoKICAgICAgICBpZiAoaXNUZXh0KGRvbUFmdGVyKSAmJiBzdGFydHNXaXRoRmlsbGVyKGRvbUFmdGVyKSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcGFyZW50OiBkb21BZnRlciwKICAgICAgICAgICAgb2Zmc2V0OiBJTkxJTkVfRklMTEVSX0xFTkdUSAogICAgICAgICAgfTsKICAgICAgICB9CgogICAgICAgIHZhciBfb2Zmc2V0ID0gZG9tQmVmb3JlID8gaW5kZXhPZihkb21CZWZvcmUpICsgMSA6IDA7CgogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwYXJlbnQ6IF9kb21QYXJlbnQsCiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQKICAgICAgICB9OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIERPTSB0byB2aWV3LiBGb3IgYWxsIHRleHQgbm9kZXMsIG5vdCBib3VuZCBlbGVtZW50cyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIG5ldyBpdGVtcyB3aWxsCiAgICAgKiBiZSBjcmVhdGVkLiBGb3IgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBmdW5jdGlvbiB3aWxsIHJldHVybiBjb3JyZXNwb25kaW5nIGl0ZW1zLiBGb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcnN9IGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAgICogRm9yIGFsbCBET00gZWxlbWVudHMgcmVuZGVyZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSB0aGF0IFVJRWxlbWVudCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fSBkb21Ob2RlIERPTSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIHRyYW5zZm9ybS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5kPWZhbHNlXSBEZXRlcm1pbmVzIHdoZXRoZXIgbmV3IGVsZW1lbnRzIHdpbGwgYmUgYm91bmQuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhDaGlsZHJlbj10cnVlXSBJZiBgdHJ1ZWAsIG5vZGUncyBhbmQgZG9jdW1lbnQgZnJhZ21lbnQncyBjaGlsZHJlbiB3aWxsIGJlIGNvbnZlcnRlZCB0b28uCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmtlZXBPcmlnaW5hbENhc2U9ZmFsc2VdIElmIGBmYWxzZWAsIG5vZGUncyB0YWcgbmFtZSB3aWxsIGJlIGNvbnZlcnRlciB0byBsb3dlciBjYXNlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfSBDb252ZXJ0ZWQgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudAogICAgICogb3IgYG51bGxgIGlmIERPTSBub2RlIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSBvciB0aGUgZ2l2ZW4gbm9kZSBpcyBhbiBlbXB0eSB0ZXh0IG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZG9tVG9WaWV3IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBkb21Ub1ZpZXcoZG9tTm9kZSkgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307CgogICAgICBpZiAodGhpcy5pc0Jsb2NrRmlsbGVyKGRvbU5vZGUsIHRoaXMuYmxvY2tGaWxsZXJNb2RlKSkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9IC8vIFdoZW4gbm9kZSBpcyBpbnNpZGUgVUlFbGVtZW50IHJldHVybiB0aGF0IFVJRWxlbWVudCBhcyBpdCdzIHZpZXcgcmVwcmVzZW50YXRpb24uCgoKICAgICAgdmFyIHVpRWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50VUlFbGVtZW50KGRvbU5vZGUsIHRoaXMuX2RvbVRvVmlld01hcHBpbmcpOwoKICAgICAgaWYgKHVpRWxlbWVudCkgewogICAgICAgIHJldHVybiB1aUVsZW1lbnQ7CiAgICAgIH0KCiAgICAgIGlmIChpc1RleHQoZG9tTm9kZSkpIHsKICAgICAgICBpZiAoaXNJbmxpbmVGaWxsZXIoZG9tTm9kZSkpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgdGV4dERhdGEgPSB0aGlzLl9wcm9jZXNzRGF0YUZyb21Eb21UZXh0KGRvbU5vZGUpOwoKICAgICAgICAgIHJldHVybiB0ZXh0RGF0YSA9PT0gJycgPyBudWxsIDogbmV3IFZpZXdUZXh0KHRoaXMuZG9jdW1lbnQsIHRleHREYXRhKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbW1lbnQoZG9tTm9kZSkpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5tYXBEb21Ub1ZpZXcoZG9tTm9kZSkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLm1hcERvbVRvVmlldyhkb21Ob2RlKTsKICAgICAgICB9CgogICAgICAgIHZhciB2aWV3RWxlbWVudDsKCiAgICAgICAgaWYgKHRoaXMuaXNEb2N1bWVudEZyYWdtZW50KGRvbU5vZGUpKSB7CiAgICAgICAgICAvLyBDcmVhdGUgdmlldyBkb2N1bWVudCBmcmFnbWVudC4KICAgICAgICAgIHZpZXdFbGVtZW50ID0gbmV3IFZpZXdEb2N1bWVudEZyYWdtZW50KHRoaXMuZG9jdW1lbnQpOwoKICAgICAgICAgIGlmIChvcHRpb25zLmJpbmQpIHsKICAgICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRGcmFnbWVudHMoZG9tTm9kZSwgdmlld0VsZW1lbnQpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBDcmVhdGUgdmlldyBlbGVtZW50LgogICAgICAgICAgdmFyIHZpZXdOYW1lID0gb3B0aW9ucy5rZWVwT3JpZ2luYWxDYXNlID8gZG9tTm9kZS50YWdOYW1lIDogZG9tTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICB2aWV3RWxlbWVudCA9IG5ldyBWaWV3RWxlbWVudCh0aGlzLmRvY3VtZW50LCB2aWV3TmFtZSk7CgogICAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgICB0aGlzLmJpbmRFbGVtZW50cyhkb21Ob2RlLCB2aWV3RWxlbWVudCk7CiAgICAgICAgICB9IC8vIENvcHkgZWxlbWVudCdzIGF0dHJpYnV0ZXMuCgoKICAgICAgICAgIHZhciBhdHRycyA9IGRvbU5vZGUuYXR0cmlidXRlczsKCiAgICAgICAgICBmb3IgKHZhciBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgICAgdmlld0VsZW1lbnQuX3NldEF0dHJpYnV0ZShhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXS52YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob3B0aW9ucy53aXRoQ2hpbGRyZW4gfHwgb3B0aW9ucy53aXRoQ2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHRoaXMuZG9tQ2hpbGRyZW5Ub1ZpZXcoZG9tTm9kZSwgb3B0aW9ucylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDQudmFsdWU7CgogICAgICAgICAgICAgIHZpZXdFbGVtZW50Ll9hcHBlbmRDaGlsZChjaGlsZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlOwogICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHZpZXdFbGVtZW50OwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENvbnZlcnRzIGNoaWxkcmVuIG9mIHRoZSBET00gZWxlbWVudCB0byB2aWV3IG5vZGVzIHVzaW5nCiAgICAgKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2RvbVRvVmlld30gbWV0aG9kLgogICAgICogQWRkaXRpb25hbGx5IHRoaXMgbWV0aG9kIG9taXRzIGJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0sIGlmIGl0IGV4aXN0cyBpbiB0aGUgRE9NIHBhcmVudC4KICAgICAqCiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50IFBhcmVudCBET00gZWxlbWVudC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjZG9tVG9WaWV3fSBvcHRpb25zIHBhcmFtZXRlci4KICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZT59IFZpZXcgbm9kZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZG9tQ2hpbGRyZW5Ub1ZpZXciLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBkb21DaGlsZHJlblRvVmlldyhkb21FbGVtZW50KSB7CiAgICAgIHZhciBvcHRpb25zLAogICAgICAgICAgaSwKICAgICAgICAgIGRvbUNoaWxkLAogICAgICAgICAgdmlld0NoaWxkLAogICAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzOwogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZG9tQ2hpbGRyZW5Ub1ZpZXckKF9jb250ZXh0MikgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczIubGVuZ3RoID4gMSAmJiBfYXJnczJbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlsxXSA6IHt9OwogICAgICAgICAgICAgIGkgPSAwOwoKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIGlmICghKGkgPCBkb21FbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgZG9tQ2hpbGQgPSBkb21FbGVtZW50LmNoaWxkTm9kZXNbaV07CiAgICAgICAgICAgICAgdmlld0NoaWxkID0gdGhpcy5kb21Ub1ZpZXcoZG9tQ2hpbGQsIG9wdGlvbnMpOwoKICAgICAgICAgICAgICBpZiAoISh2aWV3Q2hpbGQgIT09IG51bGwpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODsKICAgICAgICAgICAgICByZXR1cm4gdmlld0NoaWxkOwoKICAgICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICAgIGkrKzsKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZG9tQ2hpbGRyZW5Ub1ZpZXcsIHRoaXMpOwogICAgfSkKICAgIC8qKgogICAgICogQ29udmVydHMgRE9NIHNlbGVjdGlvbiB0byB2aWV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbn0uCiAgICAgKiBSYW5nZXMgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB3aWxsIGJlIG9taXR0ZWQuCiAgICAgKgogICAgICogQHBhcmFtIHtTZWxlY3Rpb259IGRvbVNlbGVjdGlvbiBET00gc2VsZWN0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufSBWaWV3IHNlbGVjdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkb21TZWxlY3Rpb25Ub1ZpZXciLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRvbVNlbGVjdGlvblRvVmlldyhkb21TZWxlY3Rpb24pIHsKICAgICAgLy8gRE9NIHNlbGVjdGlvbiBtaWdodCBiZSBwbGFjZWQgaW4gZmFrZSBzZWxlY3Rpb24gY29udGFpbmVyLgogICAgICAvLyBJZiBjb250YWluZXIgY29udGFpbnMgZmFrZSBzZWxlY3Rpb24gLSByZXR1cm4gY29ycmVzcG9uZGluZyB2aWV3IHNlbGVjdGlvbi4KICAgICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxKSB7CiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLnN0YXJ0Q29udGFpbmVyOyAvLyBUaGUgRE9NIHNlbGVjdGlvbiBtaWdodCBiZSBtb3ZlZCB0byB0aGUgdGV4dCBub2RlIGluc2lkZSB0aGUgZmFrZSBzZWxlY3Rpb24gY29udGFpbmVyLgoKICAgICAgICBpZiAoaXNUZXh0KGNvbnRhaW5lcikpIHsKICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZpZXdTZWxlY3Rpb24gPSB0aGlzLmZha2VTZWxlY3Rpb25Ub1ZpZXcoY29udGFpbmVyKTsKCiAgICAgICAgaWYgKHZpZXdTZWxlY3Rpb24pIHsKICAgICAgICAgIHJldHVybiB2aWV3U2VsZWN0aW9uOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGlzQmFja3dhcmQgPSB0aGlzLmlzRG9tU2VsZWN0aW9uQmFja3dhcmQoZG9tU2VsZWN0aW9uKTsKICAgICAgdmFyIHZpZXdSYW5nZXMgPSBbXTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkrKykgewogICAgICAgIC8vIERPTSBSYW5nZSBoYXZlIGNvcnJlY3Qgc3RhcnQgYW5kIGVuZCwgbm8gbWF0dGVyIHdoYXQgaXMgdGhlIERPTSBTZWxlY3Rpb24gZGlyZWN0aW9uLiBTbyB3ZSBkb24ndCBoYXZlIHRvIGZpeCBhbnl0aGluZy4KICAgICAgICB2YXIgZG9tUmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTsKICAgICAgICB2YXIgdmlld1JhbmdlID0gdGhpcy5kb21SYW5nZVRvVmlldyhkb21SYW5nZSk7CgogICAgICAgIGlmICh2aWV3UmFuZ2UpIHsKICAgICAgICAgIHZpZXdSYW5nZXMucHVzaCh2aWV3UmFuZ2UpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBWaWV3U2VsZWN0aW9uKHZpZXdSYW5nZXMsIHsKICAgICAgICBiYWNrd2FyZDogaXNCYWNrd2FyZAogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgRE9NIFJhbmdlIHRvIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0uCiAgICAgKiBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvc2l0aW9uIGNhbiBub3QgYmUgY29udmVydGVkIGBudWxsYCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge1JhbmdlfSBkb21SYW5nZSBET00gcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfG51bGx9IFZpZXcgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZG9tUmFuZ2VUb1ZpZXciLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRvbVJhbmdlVG9WaWV3KGRvbVJhbmdlKSB7CiAgICAgIHZhciB2aWV3U3RhcnQgPSB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBkb21SYW5nZS5zdGFydE9mZnNldCk7CiAgICAgIHZhciB2aWV3RW5kID0gdGhpcy5kb21Qb3NpdGlvblRvVmlldyhkb21SYW5nZS5lbmRDb250YWluZXIsIGRvbVJhbmdlLmVuZE9mZnNldCk7CgogICAgICBpZiAodmlld1N0YXJ0ICYmIHZpZXdFbmQpIHsKICAgICAgICByZXR1cm4gbmV3IFZpZXdSYW5nZSh2aWV3U3RhcnQsIHZpZXdFbmQpOwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29udmVydHMgRE9NIHBhcmVudCBhbmQgb2Zmc2V0IHRvIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0uCiAgICAgKgogICAgICogSWYgdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gd2hpY2ggaGFzIG5vIGNvcnJlc3BvbmRpbmcgdmlldyBub2RlLAogICAgICogcG9zaXRpb24gb2YgdGhlIGZpbGxlciB3aWxsIGJlIGNvbnZlcnRlZCBhbmQgcmV0dXJuZWQuCiAgICAgKgogICAgICogSWYgdGhlIHBvc2l0aW9uIGlzIGluc2lkZSBET00gZWxlbWVudCByZW5kZXJlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9CiAgICAgKiB0aGF0IHBvc2l0aW9uIHdpbGwgYmUgY29udmVydGVkIHRvIHZpZXcgcG9zaXRpb24gYmVmb3JlIHRoYXQgVUlFbGVtZW50LgogICAgICoKICAgICAqIElmIHN0cnVjdHVyZXMgYXJlIHRvbyBkaWZmZXJlbnQgYW5kIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gdGhlbiBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge05vZGV9IGRvbVBhcmVudCBET00gcG9zaXRpb24gcGFyZW50LgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGRvbU9mZnNldCBET00gcG9zaXRpb24gb2Zmc2V0LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFZpZXcgcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZG9tUG9zaXRpb25Ub1ZpZXciLAogICAgdmFsdWU6IGZ1bmN0aW9uIGRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudCwgZG9tT2Zmc2V0KSB7CiAgICAgIGlmICh0aGlzLmlzQmxvY2tGaWxsZXIoZG9tUGFyZW50LCB0aGlzLmJsb2NrRmlsbGVyTW9kZSkpIHsKICAgICAgICByZXR1cm4gdGhpcy5kb21Qb3NpdGlvblRvVmlldyhkb21QYXJlbnQucGFyZW50Tm9kZSwgaW5kZXhPZihkb21QYXJlbnQpKTsKICAgICAgfSAvLyBJZiBwb3NpdGlvbiBpcyBzb21ld2hlcmUgaW5zaWRlIFVJRWxlbWVudCAtIHJldHVybiBwb3NpdGlvbiBiZWZvcmUgdGhhdCBlbGVtZW50LgoKCiAgICAgIHZhciB2aWV3RWxlbWVudCA9IHRoaXMubWFwRG9tVG9WaWV3KGRvbVBhcmVudCk7CgogICAgICBpZiAodmlld0VsZW1lbnQgJiYgdmlld0VsZW1lbnQuaXMoJ3VpRWxlbWVudCcpKSB7CiAgICAgICAgcmV0dXJuIFZpZXdQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKHZpZXdFbGVtZW50KTsKICAgICAgfQoKICAgICAgaWYgKGlzVGV4dChkb21QYXJlbnQpKSB7CiAgICAgICAgaWYgKGlzSW5saW5lRmlsbGVyKGRvbVBhcmVudCkpIHsKICAgICAgICAgIHJldHVybiB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudC5wYXJlbnROb2RlLCBpbmRleE9mKGRvbVBhcmVudCkpOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZpZXdQYXJlbnQgPSB0aGlzLmZpbmRDb3JyZXNwb25kaW5nVmlld1RleHQoZG9tUGFyZW50KTsKICAgICAgICB2YXIgb2Zmc2V0ID0gZG9tT2Zmc2V0OwoKICAgICAgICBpZiAoIXZpZXdQYXJlbnQpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgaWYgKHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50KSkgewogICAgICAgICAgb2Zmc2V0IC09IElOTElORV9GSUxMRVJfTEVOR1RIOwogICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQ7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbih2aWV3UGFyZW50LCBvZmZzZXQpOwogICAgICB9IC8vIGRvbVBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50LgogICAgICBlbHNlIHsKICAgICAgICAgIGlmIChkb21PZmZzZXQgPT09IDApIHsKICAgICAgICAgICAgdmFyIF92aWV3UGFyZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tUGFyZW50KTsKCiAgICAgICAgICAgIGlmIChfdmlld1BhcmVudCkgewogICAgICAgICAgICAgIHJldHVybiBuZXcgVmlld1Bvc2l0aW9uKF92aWV3UGFyZW50LCAwKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGRvbUJlZm9yZSA9IGRvbVBhcmVudC5jaGlsZE5vZGVzW2RvbU9mZnNldCAtIDFdOwogICAgICAgICAgICB2YXIgdmlld0JlZm9yZSA9IGlzVGV4dChkb21CZWZvcmUpID8gdGhpcy5maW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0KGRvbUJlZm9yZSkgOiB0aGlzLm1hcERvbVRvVmlldyhkb21CZWZvcmUpOyAvLyBUT0RPICM2NjMKCiAgICAgICAgICAgIGlmICh2aWV3QmVmb3JlICYmIHZpZXdCZWZvcmUucGFyZW50KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24odmlld0JlZm9yZS5wYXJlbnQsIHZpZXdCZWZvcmUuaW5kZXggKyAxKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBjb3JyZXNwb25kaW5nIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgRWxlbWVudH0gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBmb3IgcHJvdmlkZWQgRE9NIGVsZW1lbnQgb3IKICAgICAqIGRvY3VtZW50IGZyYWdtZW50LiBJZiB0aGVyZSBpcyBubyB2aWV3IGl0ZW0ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0KICAgICAqIHRvIHRoZSBnaXZlbiBET00gLSBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4KICAgICAqIEZvciBhbGwgRE9NIGVsZW1lbnRzIHJlbmRlcmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gdGhhdCBVSUVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR8RWxlbWVudH0gZG9tRWxlbWVudE9yRG9jdW1lbnRGcmFnbWVudCBET00gZWxlbWVudCBvciBkb2N1bWVudCBmcmFnbWVudC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfQogICAgICogQ29ycmVzcG9uZGluZyB2aWV3IGVsZW1lbnQsIGRvY3VtZW50IGZyYWdtZW50IG9yIGB1bmRlZmluZWRgIGlmIG5vIGVsZW1lbnQgd2FzIGJvdW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1hcERvbVRvVmlldyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwRG9tVG9WaWV3KGRvbUVsZW1lbnRPckRvY3VtZW50RnJhZ21lbnQpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyZW50VUlFbGVtZW50KGRvbUVsZW1lbnRPckRvY3VtZW50RnJhZ21lbnQpIHx8IHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZ2V0KGRvbUVsZW1lbnRPckRvY3VtZW50RnJhZ21lbnQpOwogICAgfQogICAgLyoqCiAgICAgKiBGaW5kcyBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4gVGV4dCBub2RlcyBhcmUgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9LAogICAgICogY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUgaXMgcmV0dXJuZWQgYmFzZWQgb24gdGhlIHNpYmxpbmcgb3IgcGFyZW50LgogICAgICoKICAgICAqIElmIHRoZSBkaXJlY3RseSBwcmV2aW91cyBzaWJsaW5nIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0gZWxlbWVudCwgaXQgaXMgdXNlZAogICAgICogdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogSWYgdGhpcyBpcyBhIGZpcnN0IGNoaWxkIGluIHRoZSBwYXJlbnQgYW5kIHRoZSBwYXJlbnQgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfQogICAgICogZWxlbWVudCwgaXQgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBGb3IgYWxsIHRleHQgbm9kZXMgcmVuZGVyZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSB0aGF0IFVJRWxlbWVudCB3aWxsIGJlIHJldHVybmVkLgogICAgICoKICAgICAqIE90aGVyd2lzZSBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogTm90ZSB0aGF0IGZvciB0aGUgYmxvY2sgb3IgaW5saW5lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAuCiAgICAgKgogICAgICogQHBhcmFtIHtUZXh0fSBkb21UZXh0IERPTSB0ZXh0IG5vZGUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxudWxsfSBDb3JyZXNwb25kaW5nIHZpZXcgdGV4dCBub2RlIG9yIGBudWxsYCwgaWYgaXQgd2FzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGEKICAgICAqIGNvcnJlc3BvbmRpbmcgbm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmaW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0KGRvbVRleHQpIHsKICAgICAgaWYgKGlzSW5saW5lRmlsbGVyKGRvbVRleHQpKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0gLy8gSWYgRE9NIHRleHQgd2FzIHJlbmRlcmVkIGJ5IFVJRWxlbWVudCAtIHJldHVybiB0aGF0IGVsZW1lbnQuCgoKICAgICAgdmFyIHVpRWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50VUlFbGVtZW50KGRvbVRleHQpOwoKICAgICAgaWYgKHVpRWxlbWVudCkgewogICAgICAgIHJldHVybiB1aUVsZW1lbnQ7CiAgICAgIH0KCiAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBkb21UZXh0LnByZXZpb3VzU2libGluZzsgLy8gVHJ5IHRvIHVzZSBwcmV2aW91cyBzaWJsaW5nIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLgoKICAgICAgaWYgKHByZXZpb3VzU2libGluZykgewogICAgICAgIGlmICghdGhpcy5pc0VsZW1lbnQocHJldmlvdXNTaWJsaW5nKSkgewogICAgICAgICAgLy8gVGhlIHByZXZpb3VzIGlzIHRleHQgb3IgY29tbWVudC4KICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZpZXdFbGVtZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcocHJldmlvdXNTaWJsaW5nKTsKCiAgICAgICAgaWYgKHZpZXdFbGVtZW50KSB7CiAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB2aWV3RWxlbWVudC5uZXh0U2libGluZzsgLy8gSXQgbWlnaHQgYmUgZmlsbGVyIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIHZpZXcgbm9kZS4KCiAgICAgICAgICBpZiAobmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBWaWV3VGV4dCkgewogICAgICAgICAgICByZXR1cm4gdmlld0VsZW1lbnQubmV4dFNpYmxpbmc7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gLy8gVHJ5IHRvIHVzZSBwYXJlbnQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICAgIGVsc2UgewogICAgICAgICAgdmFyIF92aWV3RWxlbWVudCA9IHRoaXMubWFwRG9tVG9WaWV3KGRvbVRleHQucGFyZW50Tm9kZSk7CgogICAgICAgICAgaWYgKF92aWV3RWxlbWVudCkgewogICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IF92aWV3RWxlbWVudC5nZXRDaGlsZCgwKTsgLy8gSXQgbWlnaHQgYmUgZmlsbGVyIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIHZpZXcgbm9kZS4KCgogICAgICAgICAgICBpZiAoZmlyc3RDaGlsZCBpbnN0YW5jZW9mIFZpZXdUZXh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQ7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBjb3JyZXNwb25kaW5nIERPTSBpdGVtIGZvciBwcm92aWRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBFbGVtZW50fSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgRG9jdW1lbnRGcmFnbWVudH0uCiAgICAgKiBUbyBmaW5kIGEgY29ycmVzcG9uZGluZyB0ZXh0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB2aWV3IFRleHQgaW5zdGFuY2V9CiAgICAgKiB1c2Uge0BsaW5rICNmaW5kQ29ycmVzcG9uZGluZ0RvbVRleHR9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3Tm9kZQogICAgICogVmlldyBlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50LgogICAgICogQHJldHVybnMge05vZGV8RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9IENvcnJlc3BvbmRpbmcgRE9NIG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWFwVmlld1RvRG9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBWaWV3VG9Eb20oZG9jdW1lbnRGcmFnbWVudE9yRWxlbWVudCkgewogICAgICByZXR1cm4gdGhpcy5fdmlld1RvRG9tTWFwcGluZy5nZXQoZG9jdW1lbnRGcmFnbWVudE9yRWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIEZpbmRzIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLiBUZXh0IG5vZGVzIGFyZSBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0sCiAgICAgKiBjb3JyZXNwb25kaW5nIHRleHQgbm9kZSBpcyByZXR1cm5lZCBiYXNlZCBvbiB0aGUgc2libGluZyBvciBwYXJlbnQuCiAgICAgKgogICAgICogSWYgdGhlIGRpcmVjdGx5IHByZXZpb3VzIHNpYmxpbmcgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfSBlbGVtZW50LCBpdCBpcyB1c2VkCiAgICAgKiB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgICAqCiAgICAgKiBJZiB0aGlzIGlzIGEgZmlyc3QgY2hpbGQgaW4gdGhlIHBhcmVudCBhbmQgdGhlIHBhcmVudCBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9CiAgICAgKiBlbGVtZW50LCBpdCBpcyB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLgogICAgICoKICAgICAqIE90aGVyd2lzZSBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSB2aWV3VGV4dCBWaWV3IHRleHQgbm9kZS4KICAgICAqIEByZXR1cm5zIHtUZXh0fG51bGx9IENvcnJlc3BvbmRpbmcgRE9NIHRleHQgbm9kZSBvciBgbnVsbGAsIGlmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhIGNvcnJlc3BvbmRpbmcgbm9kZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmaW5kQ29ycmVzcG9uZGluZ0RvbVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDb3JyZXNwb25kaW5nRG9tVGV4dCh2aWV3VGV4dCkgewogICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gdmlld1RleHQucHJldmlvdXNTaWJsaW5nOyAvLyBUcnkgdG8gdXNlIHByZXZpb3VzIHNpYmxpbmcgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCgogICAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIHRoaXMubWFwVmlld1RvRG9tKHByZXZpb3VzU2libGluZykpIHsKICAgICAgICByZXR1cm4gdGhpcy5tYXBWaWV3VG9Eb20ocHJldmlvdXNTaWJsaW5nKS5uZXh0U2libGluZzsKICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgZmlyc3Qgbm9kZSwgdHJ5IHRvIHVzZSBwYXJlbnQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCgoKICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcgJiYgdmlld1RleHQucGFyZW50ICYmIHRoaXMubWFwVmlld1RvRG9tKHZpZXdUZXh0LnBhcmVudCkpIHsKICAgICAgICByZXR1cm4gdGhpcy5tYXBWaWV3VG9Eb20odmlld1RleHQucGFyZW50KS5jaGlsZE5vZGVzWzBdOwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogRm9jdXNlcyBET00gZWRpdGFibGUgdGhhdCBpcyBjb3JyZXNwb25kaW5nIHRvIHByb3ZpZGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0gdmlld0VkaXRhYmxlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZm9jdXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKHZpZXdFZGl0YWJsZSkgewogICAgICB2YXIgZG9tRWRpdGFibGUgPSB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3RWRpdGFibGUpOwoKICAgICAgaWYgKGRvbUVkaXRhYmxlICYmIGRvbUVkaXRhYmxlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9tRWRpdGFibGUpIHsKICAgICAgICAvLyBTYXZlIHRoZSBzY3JvbGxYIGFuZCBzY3JvbGxZIHBvc2l0aW9ucyBiZWZvcmUgdGhlIGZvY3VzLgogICAgICAgIHZhciBfZ2xvYmFsJHdpbmRvdyA9IGdsb2JhbC53aW5kb3csCiAgICAgICAgICAgIHNjcm9sbFggPSBfZ2xvYmFsJHdpbmRvdy5zY3JvbGxYLAogICAgICAgICAgICBzY3JvbGxZID0gX2dsb2JhbCR3aW5kb3cuc2Nyb2xsWTsKICAgICAgICB2YXIgc2Nyb2xsUG9zaXRpb25zID0gW107IC8vIFNhdmUgYWxsIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCB2YWx1ZXMgc3RhcnRpbmcgZnJvbSBkb21FZGl0YWJsZSB1cCB0bwogICAgICAgIC8vIGRvY3VtZW50I2RvY3VtZW50RWxlbWVudC4KCiAgICAgICAgZm9yRWFjaERvbU5vZGVBbmNlc3Rvcihkb21FZGl0YWJsZSwgZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gbm9kZS5zY3JvbGxMZWZ0LAogICAgICAgICAgICAgIHNjcm9sbFRvcCA9IG5vZGUuc2Nyb2xsVG9wOwogICAgICAgICAgc2Nyb2xsUG9zaXRpb25zLnB1c2goW3Njcm9sbExlZnQsIHNjcm9sbFRvcF0pOwogICAgICAgIH0pOwogICAgICAgIGRvbUVkaXRhYmxlLmZvY3VzKCk7IC8vIFJlc3RvcmUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIHZhbHVlcyBzdGFydGluZyBmcm9tIGRvbUVkaXRhYmxlIHVwIHRvCiAgICAgICAgLy8gZG9jdW1lbnQjZG9jdW1lbnRFbGVtZW50LgogICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy85NTEKICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvOTU3CgogICAgICAgIGZvckVhY2hEb21Ob2RlQW5jZXN0b3IoZG9tRWRpdGFibGUsIGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB2YXIgX3Njcm9sbFBvc2l0aW9ucyRzaGlmID0gc2Nyb2xsUG9zaXRpb25zLnNoaWZ0KCksCiAgICAgICAgICAgICAgX3Njcm9sbFBvc2l0aW9ucyRzaGlmMiA9IF9zbGljZWRUb0FycmF5KF9zY3JvbGxQb3NpdGlvbnMkc2hpZiwgMiksCiAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IF9zY3JvbGxQb3NpdGlvbnMkc2hpZjJbMF0sCiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gX3Njcm9sbFBvc2l0aW9ucyRzaGlmMlsxXTsKCiAgICAgICAgICBub2RlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0OwogICAgICAgICAgbm9kZS5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7CiAgICAgICAgfSk7IC8vIFJlc3RvcmUgdGhlIHNjcm9sbFggYW5kIHNjcm9sbFkgcG9zaXRpb25zIGFmdGVyIHRoZSBmb2N1cy4KICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvOTUxCgogICAgICAgIGdsb2JhbC53aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgd2hlbiBgbm9kZS5ub2RlVHlwZWAgZXF1YWxzIGBOb2RlLkVMRU1FTlRfTk9ERWAuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7CiAgICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREU7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIHdoZW4gYG5vZGUubm9kZVR5cGVgIGVxdWFscyBgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFYC4KICAgICAqCiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzRG9jdW1lbnRGcmFnbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHsKICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIHdoZW4gYG5vZGUubm9kZVR5cGVgIGVxdWFscyBgTm9kZS5DT01NRU5UX05PREVgLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNDb21tZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0NvbW1lbnQobm9kZSkgewogICAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IE5vZGUuQ09NTUVOVF9OT0RFOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGJsb2NrIGZpbGxlciBmb3IgdGhpcyBET00gY29udmVydGVyLgogICAgICoKICAgICAqCQljb25zdCBjb252ZXJ0ZXIgPSBuZXcgRG9tQ29udmVydGVyKCB2aWV3RG9jdW1lbnQsIHsgYmxvY2tGaWxsZXJNb2RlOiAnYnInIH0gKTsKICAgICAqCiAgICAgKgkJY29udmVydGVyLmlzQmxvY2tGaWxsZXIoIEJSX0ZJTExFUiggZG9jdW1lbnQgKSApOyAvLyB0cnVlCiAgICAgKgkJY29udmVydGVyLmlzQmxvY2tGaWxsZXIoIE5CU1BfRklMTEVSKCBkb2N1bWVudCApICk7IC8vIGZhbHNlCiAgICAgKgogICAgICogKipOb3RlOioqOiBGb3IgdGhlIGAnbmJzcCdgIG1vZGUgdGhlIG1ldGhvZCBhbHNvIGNoZWNrcyBjb250ZXh0IG9mIGEgbm9kZSBzbyBpdCBjYW5ub3QgYmUgYSBkZXRhY2hlZCBub2RlLgogICAgICoKICAgICAqICoqTm90ZToqKiBBIHNwZWNpYWwgY2FzZSBpbiB0aGUgYCduYnNwJ2AgbW9kZSBleGlzdHMgd2hlcmUgdGhlIGA8YnI+YCBpbiBgPHA+PGJyPjwvcD5gIGlzIHRyZWF0ZWQgYXMgYSBibG9jayBmaWxsZXIuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBkb21Ob2RlIERPTSBub2RlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYSBub2RlIGlzIGNvbnNpZGVyZWQgYSBibG9jayBmaWxsZXIgZm9yIGdpdmVuIG1vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNCbG9ja0ZpbGxlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCbG9ja0ZpbGxlcihkb21Ob2RlKSB7CiAgICAgIGlmICh0aGlzLmJsb2NrRmlsbGVyTW9kZSA9PSAnYnInKSB7CiAgICAgICAgcmV0dXJuIGRvbU5vZGUuaXNFcXVhbE5vZGUoQlJfRklMTEVSX1JFRik7CiAgICAgIH0gLy8gU3BlY2lhbCBjYXNlIGZvciA8cD48YnI+PC9wPiBpbiB3aGljaCBjYXNlIHRoZSA8YnI+IHNob3VsZCBiZSB0cmVhdGVkIGFzIGZpbGxlciBldmVuCiAgICAgIC8vIHdoZW4gd2UncmUgaW4gdGhlICduYnNwJyBtb2RlLiBTZWUgY2tlZGl0b3I1IzU1NjQuCgoKICAgICAgaWYgKGRvbU5vZGUudGFnTmFtZSA9PT0gJ0JSJyAmJiBoYXNCbG9ja1BhcmVudChkb21Ob2RlLCB0aGlzLmJsb2NrRWxlbWVudHMpICYmIGRvbU5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CgogICAgICByZXR1cm4gaXNOYnNwQmxvY2tGaWxsZXIoZG9tTm9kZSwgdGhpcy5ibG9ja0VsZW1lbnRzKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gc2VsZWN0aW9uIGlzIGEgYmFja3dhcmQgc2VsZWN0aW9uLCB0aGF0IGlzLCBpZiBpdCdzIGBmb2N1c2AgaXMgYmVmb3JlIGBhbmNob3JgLgogICAgICoKICAgICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBET00gU2VsZWN0aW9uIGluc3RhbmNlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNEb21TZWxlY3Rpb25CYWNrd2FyZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEb21TZWxlY3Rpb25CYWNrd2FyZChzZWxlY3Rpb24pIHsKICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBTaW5jZSBpdCB0YWtlcyBtdWx0aXBsZSBsaW5lcyBvZiBjb2RlIHRvIGNoZWNrIHdoZXRoZXIgYSAiRE9NIFBvc2l0aW9uIiBpcyBiZWZvcmUvYWZ0ZXIgYW5vdGhlciAiRE9NIFBvc2l0aW9uIiwKICAgICAgLy8gd2Ugd2lsbCB1c2UgdGhlIGZhY3QgdGhhdCByYW5nZSB3aWxsIGNvbGxhcHNlIGlmIGl0J3MgZW5kIGlzIGJlZm9yZSBpdCdzIHN0YXJ0LgoKCiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7CiAgICAgIHJhbmdlLnNldFN0YXJ0KHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0KTsKICAgICAgcmFuZ2Uuc2V0RW5kKHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7CiAgICAgIHZhciBiYWNrd2FyZCA9IHJhbmdlLmNvbGxhcHNlZDsKICAgICAgcmFuZ2UuZGV0YWNoKCk7CiAgICAgIHJldHVybiBiYWNrd2FyZDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBwYXJlbnQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fSBmb3IgcHJvdmlkZWQgRE9NIG5vZGUuIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGlzIG5vCiAgICAgKiBwYXJlbnQgVUlFbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZX0gZG9tTm9kZQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UGFyZW50VUlFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJlbnRVSUVsZW1lbnQoZG9tTm9kZSkgewogICAgICB2YXIgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzKGRvbU5vZGUpOyAvLyBSZW1vdmUgZG9tTm9kZSBmcm9tIHRoZSBsaXN0LgoKICAgICAgYW5jZXN0b3JzLnBvcCgpOwoKICAgICAgd2hpbGUgKGFuY2VzdG9ycy5sZW5ndGgpIHsKICAgICAgICB2YXIgX2RvbU5vZGUgPSBhbmNlc3RvcnMucG9wKCk7CgogICAgICAgIHZhciB2aWV3Tm9kZSA9IHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZ2V0KF9kb21Ob2RlKTsKCiAgICAgICAgaWYgKHZpZXdOb2RlICYmIHZpZXdOb2RlLmlzKCd1aUVsZW1lbnQnKSkgewogICAgICAgICAgcmV0dXJuIHZpZXdOb2RlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBpZiBnaXZlbiBzZWxlY3Rpb24ncyBib3VuZGFyaWVzIGFyZSBhdCBjb3JyZWN0IHBsYWNlcy4KICAgICAqCiAgICAgKiBUaGUgZm9sbG93aW5nIHBsYWNlcyBhcmUgY29uc2lkZXJlZCBhcyBpbmNvcnJlY3QgZm9yIHNlbGVjdGlvbiBib3VuZGFyaWVzOgogICAgICogKiBiZWZvcmUgb3IgaW4gdGhlIG1pZGRsZSBvZiB0aGUgaW5saW5lIGZpbGxlciBzZXF1ZW5jZSwKICAgICAqICogaW5zaWRlIHRoZSBET00gZWxlbWVudCB3aGljaCByZXByZXNlbnRzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBhIHZpZXcgdWkgZWxlbWVudH0uCiAgICAgKgogICAgICogQHBhcmFtIHtTZWxlY3Rpb259IGRvbVNlbGVjdGlvbiBET00gU2VsZWN0aW9uIG9iamVjdCB0byBiZSBjaGVja2VkLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gc2VsZWN0aW9uIGlzIGF0IGEgY29ycmVjdCBwbGFjZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNEb21TZWxlY3Rpb25Db3JyZWN0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RvbVNlbGVjdGlvbkNvcnJlY3QoZG9tU2VsZWN0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLl9pc0RvbVNlbGVjdGlvblBvc2l0aW9uQ29ycmVjdChkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSwgZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldCkgJiYgdGhpcy5faXNEb21TZWxlY3Rpb25Qb3NpdGlvbkNvcnJlY3QoZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSwgZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBET00gcG9zaXRpb24gaXMgYSBjb3JyZWN0IHBsYWNlIGZvciBzZWxlY3Rpb24gYm91bmRhcnkuIFNlZSB7QGxpbmsgI2lzRG9tU2VsZWN0aW9uQ29ycmVjdH0uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tUGFyZW50IFBvc2l0aW9uIHBhcmVudC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgUG9zaXRpb24gb2Zmc2V0LgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBwb3NpdGlvbiBpcyBhdCBhIGNvcnJlY3QgcGxhY2UgZm9yIHNlbGVjdGlvbiBib3VuZGFyeSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2lzRG9tU2VsZWN0aW9uUG9zaXRpb25Db3JyZWN0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNEb21TZWxlY3Rpb25Qb3NpdGlvbkNvcnJlY3QoZG9tUGFyZW50LCBvZmZzZXQpIHsKICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIGJlZm9yZSBvciBpbiB0aGUgbWlkZGxlIG9mIGlubGluZSBmaWxsZXIgc3RyaW5nLCBpdCBpcyBpbmNvcnJlY3QuCiAgICAgIGlmIChpc1RleHQoZG9tUGFyZW50KSAmJiBzdGFydHNXaXRoRmlsbGVyKGRvbVBhcmVudCkgJiYgb2Zmc2V0IDwgSU5MSU5FX0ZJTExFUl9MRU5HVEgpIHsKICAgICAgICAvLyBTZWxlY3Rpb24gaW4gYSB0ZXh0IG5vZGUsIGF0IHdyb25nIHBvc2l0aW9uIChiZWZvcmUgb3IgaW4gdGhlIG1pZGRsZSBvZiBmaWxsZXIpLgogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuaXNFbGVtZW50KGRvbVBhcmVudCkgJiYgc3RhcnRzV2l0aEZpbGxlcihkb21QYXJlbnQuY2hpbGROb2Rlc1tvZmZzZXRdKSkgewogICAgICAgIC8vIFNlbGVjdGlvbiBpbiBhbiBlbGVtZW50IG5vZGUsIGJlZm9yZSBmaWxsZXIgdGV4dCBub2RlLgogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIHZpZXdQYXJlbnQgPSB0aGlzLm1hcERvbVRvVmlldyhkb21QYXJlbnQpOyAvLyBJZiBzZWxlY3Rpb24gaXMgaW4gYHZpZXcuVUlFbGVtZW50YCwgaXQgaXMgaW5jb3JyZWN0LiBOb3RlIHRoYXQgYG1hcERvbVRvVmlldygpYCByZXR1cm5zIGB2aWV3LlVJRWxlbWVudGAKICAgICAgLy8gYWxzbyBmb3IgYW55IGRvbSBlbGVtZW50IHRoYXQgaXMgaW5zaWRlIHRoZSB2aWV3IHVpIGVsZW1lbnQgKHNvIHdlIGRvbid0IG5lZWQgdG8gcGVyZm9ybSBhbnkgYWRkaXRpb25hbCBjaGVja3MpLgoKICAgICAgaWYgKHZpZXdQYXJlbnQgJiYgdmlld1BhcmVudC5pcygndWlFbGVtZW50JykpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBUYWtlcyB0ZXh0IGRhdGEgZnJvbSBhIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0I2RhdGF9IGFuZCBwcm9jZXNzZXMgaXQgc28KICAgICAqIGl0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gdGhlIERPTS4KICAgICAqCiAgICAgKiBGb2xsb3dpbmcgY2hhbmdlcyBhcmUgZG9uZToKICAgICAqCiAgICAgKiAqIGEgc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBpcyBjaGFuZ2VkIHRvIGAmbmJzcDtgIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyCiAgICAgKiBlbGVtZW50IG9yIGlmIGEgcHJldmlvdXMgdGV4dCBub2RlIGVuZHMgd2l0aCBhIHNwYWNlIGNoYXJhY3RlciwKICAgICAqICogc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBub2RlIGlzIGNoYW5nZWQgdG8gYCZuYnNwO2AgaWYgdGhlcmUgYXJlIHR3byBzcGFjZXMgYXQgdGhlIGVuZCBvZiBhIG5vZGUgb3IgaWYgbmV4dCBub2RlCiAgICAgKiBzdGFydHMgd2l0aCBhIHNwYWNlIG9yIGlmIGl0IGlzIHRoZSBsYXN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyLAogICAgICogKiByZW1haW5pbmcgc3BhY2VzIGFyZSByZXBsYWNlZCB0byBhIGNoYWluIG9mIHNwYWNlcyBhbmQgYCZuYnNwO2AgKGUuZy4gYCd4ICAgeCdgIGJlY29tZXMgYCd4ICZuYnNwOyB4J2ApLgogICAgICoKICAgICAqIENvbnRlbnQgb2Yge0BsaW5rICNwcmVFbGVtZW50c30gaXMgbm90IHByb2Nlc3NlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBub2RlIFZpZXcgdGV4dCBub2RlIHRvIHByb2Nlc3MuCiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQcm9jZXNzZWQgdGV4dCBkYXRhLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9wcm9jZXNzRGF0YUZyb21WaWV3VGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NEYXRhRnJvbVZpZXdUZXh0KG5vZGUpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhOyAvLyBJZiBhbnkgb2Ygbm9kZSBhbmNlc3RvcnMgaGFzIGEgbmFtZSB3aGljaCBpcyBpbiBgcHJlRWxlbWVudHNgIGFycmF5LCB0aGVuIGN1cnJlbnRseSBwcm9jZXNzZWQKICAgICAgLy8gdmlldyB0ZXh0IG5vZGUgaXMgKHdpbGwgYmUpIGluIHByZWZvcm1hdHRlZCBlbGVtZW50LiBXZSBzaG91bGQgbm90IGNoYW5nZSB3aGl0ZXNwYWNlcyB0aGVuLgoKICAgICAgaWYgKG5vZGUuZ2V0QW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAocGFyZW50KSB7CiAgICAgICAgcmV0dXJuIF90aGlzLnByZUVsZW1lbnRzLmluY2x1ZGVzKHBhcmVudC5uYW1lKTsKICAgICAgfSkpIHsKICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgfSAvLyAxLiBSZXBsYWNlIHRoZSBmaXJzdCBzcGFjZSB3aXRoIGEgbmJzcCBpZiB0aGUgcHJldmlvdXMgbm9kZSBlbmRzIHdpdGggYSBzcGFjZSBvciB0aGVyZSBpcyBubyBwcmV2aW91cyBub2RlCiAgICAgIC8vIChjb250YWluZXIgZWxlbWVudCBib3VuZGFyeSkuCgoKICAgICAgaWYgKGRhdGEuY2hhckF0KDApID09ICcgJykgewogICAgICAgIHZhciBwcmV2Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIGZhbHNlKTsKCiAgICAgICAgdmFyIHByZXZFbmRzV2l0aFNwYWNlID0gcHJldk5vZGUgJiYgdGhpcy5fbm9kZUVuZHNXaXRoU3BhY2UocHJldk5vZGUpOwoKICAgICAgICBpZiAocHJldkVuZHNXaXRoU3BhY2UgfHwgIXByZXZOb2RlKSB7CiAgICAgICAgICBkYXRhID0gIlx4QTAiICsgZGF0YS5zdWJzdHIoMSk7CiAgICAgICAgfQogICAgICB9IC8vIDIuIFJlcGxhY2UgdGhlIGxhc3Qgc3BhY2Ugd2l0aCBuYnNwIGlmIHRoZXJlIGFyZSB0d28gc3BhY2VzIGF0IHRoZSBlbmQgb3IgaWYgdGhlIG5leHQgbm9kZSBzdGFydHMgd2l0aCBzcGFjZSBvciB0aGVyZSBpcyBubwogICAgICAvLyBuZXh0IG5vZGUgKGNvbnRhaW5lciBlbGVtZW50IGJvdW5kYXJ5KS4KICAgICAgLy8KICAgICAgLy8gS2VlcCBpbiBtaW5kIHRoYXQgRmlyZWZveCBwcmVmZXJzICRuYnNwOyBiZWZvcmUgdGFnLCBub3QgaW5zaWRlIGl0OgogICAgICAvLwogICAgICAvLyBGb28gPHNwYW4+Jm5ic3A7YmFyPC9zcGFuPiAgPC0tIGJhZC4KICAgICAgLy8gRm9vJm5ic3A7PHNwYW4+IGJhcjwvc3Bhbj4gIDwtLSBnb29kLgogICAgICAvLwogICAgICAvLyBNb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNzQ3LgoKCiAgICAgIGlmIChkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJykgewogICAgICAgIHZhciBuZXh0Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIHRydWUpOwoKICAgICAgICBpZiAoZGF0YS5jaGFyQXQoZGF0YS5sZW5ndGggLSAyKSA9PSAnICcgfHwgIW5leHROb2RlIHx8IG5leHROb2RlLmRhdGEuY2hhckF0KDApID09ICcgJykgewogICAgICAgICAgZGF0YSA9IGRhdGEuc3Vic3RyKDAsIGRhdGEubGVuZ3RoIC0gMSkgKyAiXHhBMCI7CiAgICAgICAgfQogICAgICB9IC8vIDMuIENyZWF0ZSBzcGFjZStuYnNwIHBhaXJzLgoKCiAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoLyB7Mn0vZywgIiBceEEwIik7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyIGFmdGVyIGNoYW5naW5nIGFwcHJvcHJpYXRlIHNwYWNlIGNoYXJhY3RlcnMgdG8gYCZuYnNwO2BzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IG5vZGUgTm9kZSB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gYG5vZGVgIGVuZHMgd2l0aCBzcGFjZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX25vZGVFbmRzV2l0aFNwYWNlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfbm9kZUVuZHNXaXRoU3BhY2Uobm9kZSkgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIGlmIChub2RlLmdldEFuY2VzdG9ycygpLnNvbWUoZnVuY3Rpb24gKHBhcmVudCkgewogICAgICAgIHJldHVybiBfdGhpczIucHJlRWxlbWVudHMuaW5jbHVkZXMocGFyZW50Lm5hbWUpOwogICAgICB9KSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIGRhdGEgPSB0aGlzLl9wcm9jZXNzRGF0YUZyb21WaWV3VGV4dChub2RlKTsKCiAgICAgIHJldHVybiBkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJzsKICAgIH0KICAgIC8qKgogICAgICogVGFrZXMgdGV4dCBkYXRhIGZyb20gbmF0aXZlIGBUZXh0YCBub2RlIGFuZCBwcm9jZXNzZXMgaXQgdG8gYSBjb3JyZWN0IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHZpZXcgdGV4dCBub2RlfSBkYXRhLgogICAgICoKICAgICAqIEZvbGxvd2luZyBjaGFuZ2VzIGFyZSBkb25lOgogICAgICoKICAgICAqICogbXVsdGlwbGUgd2hpdGVzcGFjZXMgYXJlIHJlcGxhY2VkIHRvIGEgc2luZ2xlIHNwYWNlLAogICAgICogKiBzcGFjZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGV4dCBub2RlIGlzIHJlbW92ZWQgaWYgaXQgaXMgdGhlIGZpcnN0IHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyCiAgICAgKiBlbGVtZW50IG9yIGlmIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyLAogICAgICogKiBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSB0ZXh0IG5vZGUgaXMgcmVtb3ZlZCBpZiB0aGVyZSBhcmUgdHdvIHNwYWNlcyBhdCB0aGUgZW5kIG9mIGEgbm9kZSBvciBpZiBuZXh0IG5vZGUKICAgICAqIHN0YXJ0cyB3aXRoIGEgc3BhY2Ugb3IgaWYgaXQgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGluIGl0cyBjb250YWluZXIKICAgICAqICogbmJzcHMgYXJlIGNvbnZlcnRlZCB0byBzcGFjZXMuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBub2RlIERPTSB0ZXh0IG5vZGUgdG8gcHJvY2Vzcy4KICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCBkYXRhLgogICAgICogQHByaXZhdGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcHJvY2Vzc0RhdGFGcm9tRG9tVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NEYXRhRnJvbURvbVRleHQobm9kZSkgewogICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTsKCiAgICAgIGlmIChfaGFzRG9tUGFyZW50T2ZUeXBlKG5vZGUsIHRoaXMucHJlRWxlbWVudHMpKSB7CiAgICAgICAgcmV0dXJuIGdldERhdGFXaXRob3V0RmlsbGVyKG5vZGUpOwogICAgICB9IC8vIENoYW5nZSBhbGwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChmcm9tIHRoZSBbIFxuXHRccl0gc2V0IOKAkwogICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzgyMiNpc3N1ZWNvbW1lbnQtMzExNjcwMjQ5KSB0byBhIHNpbmdsZSBzcGFjZSBjaGFyYWN0ZXIuCiAgICAgIC8vIFRoYXQncyBob3cgbXVsdGlwbGUgd2hpdGVzcGFjZXMgYXJlIHRyZWF0ZWQgd2hlbiByZW5kZXJlZCwgc28gd2Ugbm9ybWFsaXplIHRob3NlIHdoaXRlc3BhY2VzLgogICAgICAvLyBXZSdyZSByZXBsYWNpbmcgMSsgKGFuZCBub3QgMispIHRvIGFsc28gbm9ybWFsaXplIHNpbmd1bGFyIFxuXHRcciBjaGFyYWN0ZXJzICgjODIyKS4KCgogICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9bIFxuXHRccl17MSx9L2csICcgJyk7CgogICAgICB2YXIgcHJldk5vZGUgPSB0aGlzLl9nZXRUb3VjaGluZ0lubGluZURvbU5vZGUobm9kZSwgZmFsc2UpOwoKICAgICAgdmFyIG5leHROb2RlID0gdGhpcy5fZ2V0VG91Y2hpbmdJbmxpbmVEb21Ob2RlKG5vZGUsIHRydWUpOwoKICAgICAgdmFyIHNob3VsZExlZnRUcmltID0gdGhpcy5fY2hlY2tTaG91bGRMZWZ0VHJpbURvbVRleHQocHJldk5vZGUpOwoKICAgICAgdmFyIHNob3VsZFJpZ2h0VHJpbSA9IHRoaXMuX2NoZWNrU2hvdWxkUmlnaHRUcmltRG9tVGV4dChub2RlLCBuZXh0Tm9kZSk7IC8vIElmIHRoZSBwcmV2aW91cyBkb20gdGV4dCBub2RlIGRvZXMgbm90IGV4aXN0IG9yIGl0IGVuZHMgYnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXIsIHJlbW92ZSBzcGFjZSBjaGFyYWN0ZXIgZnJvbSB0aGUgYmVnaW5uaW5nCiAgICAgIC8vIG9mIHRoaXMgdGV4dCBub2RlLiBTdWNoIHNwYWNlIGNoYXJhY3RlciBpcyB0cmVhdGVkIGFzIGEgd2hpdGVzcGFjZS4KCgogICAgICBpZiAoc2hvdWxkTGVmdFRyaW0pIHsKICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9eIC8sICcnKTsKICAgICAgfSAvLyBJZiB0aGUgbmV4dCB0ZXh0IG5vZGUgZG9lcyBub3QgZXhpc3QgcmVtb3ZlIHNwYWNlIGNoYXJhY3RlciBmcm9tIHRoZSBlbmQgb2YgdGhpcyB0ZXh0IG5vZGUuCgoKICAgICAgaWYgKHNob3VsZFJpZ2h0VHJpbSkgewogICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyAkLywgJycpOwogICAgICB9IC8vIEF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIGJsb2NrIGVsZW1lbnQsIEZpcmVmb3ggaW5zZXJ0cyBub3JtYWwgc3BhY2UgKyA8YnI+IGluc3RlYWQgb2Ygbm9uLWJyZWFraW5nIHNwYWNlLgogICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIHRleHQgbm9kZSBzdGFydHMvZW5kIHdpdGggbm9ybWFsIHNwYWNlIGluc3RlYWQgb2Ygbm9uLWJyZWFraW5nIHNwYWNlLgogICAgICAvLyBUaGlzIGNhdXNlcyBhIHByb2JsZW0gYmVjYXVzZSB0aGUgbm9ybWFsIHNwYWNlIHdvdWxkIGJlIHJlbW92ZWQgaW4gYC5yZXBsYWNlYCBjYWxscyBhYm92ZS4gVG8gcHJldmVudCB0aGF0LAogICAgICAvLyB0aGUgaW5saW5lIGZpbGxlciBpcyByZW1vdmVkIG9ubHkgYWZ0ZXIgdGhlIGRhdGEgaXMgaW5pdGlhbGx5IHByb2Nlc3NlZCAoYnkgdGhlIGAucmVwbGFjZWAgYWJvdmUpLiBTZWUgY2tlZGl0b3I1IzY5Mi4KCgogICAgICBkYXRhID0gZ2V0RGF0YVdpdGhvdXRGaWxsZXIobmV3IFRleHQoZGF0YSkpOyAvLyBBdCB0aGlzIHBvaW50IHdlIHNob3VsZCBoYXZlIHJlbW92ZWQgYWxsIHdoaXRlc3BhY2VzIGZyb20gRE9NIHRleHQgZGF0YS4KICAgICAgLy8KICAgICAgLy8gTm93LCBXZSB3aWxsIHJldmVyc2UgdGhlIHByb2Nlc3MgdGhhdCBoYXBwZW5zIGluIGBfcHJvY2Vzc0RhdGFGcm9tVmlld1RleHRgLgogICAgICAvLwogICAgICAvLyBXZSBoYXZlIHRvIGNoYW5nZSAmbmJzcDsgY2hhcnMsIHRoYXQgd2VyZSBpbiBET00gdGV4dCBkYXRhIGJlY2F1c2Ugb2YgcmVuZGVyaW5nIHJlYXNvbnMsIHRvIHNwYWNlcy4KICAgICAgLy8gRmlyc3QsIGNoYW5nZSBhbGwgYCBcdTAwQTBgIHBhaXJzIChzcGFjZSArICZuYnNwOykgdG8gdHdvIHNwYWNlcy4gRE9NIGNvbnZlcnRlciBjaGFuZ2VzIHR3byBzcGFjZXMgZnJvbSBtb2RlbC92aWV3IHRvCiAgICAgIC8vIGAgXHUwMEEwYCB0byBlbnN1cmUgcHJvcGVyIHJlbmRlcmluZy4gU2luY2UgaGVyZSB3ZSBjb252ZXJ0IGJhY2ssIHdlIHJlY29nbml6ZSB0aG9zZSBwYWlycyBhbmQgY2hhbmdlIHRoZW0gYmFjayB0byBgICBgLgoKICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvIFx1MDBBMC9nLCAnICAnKTsgLy8gVGhlbiwgbGV0J3MgY2hhbmdlIHRoZSBsYXN0IG5ic3AgdG8gYSBzcGFjZS4KCiAgICAgIGlmICgvKCB8XHUwMEEwKVx1MDBBMCQvLnRlc3QoZGF0YSkgfHwgIW5leHROb2RlIHx8IG5leHROb2RlLmRhdGEgJiYgbmV4dE5vZGUuZGF0YS5jaGFyQXQoMCkgPT0gJyAnKSB7CiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXHUwMEEwJC8sICcgJyk7CiAgICAgIH0gLy8gVGhlbiwgY2hhbmdlICZuYnNwOyBjaGFyYWN0ZXIgdGhhdCBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IG5vZGUgdG8gc3BhY2UgY2hhcmFjdGVyLgogICAgICAvLyBXZSBkbyB0aGF0IHJlcGxhY2VtZW50IG9ubHkgaWYgdGhpcyBpcyB0aGUgZmlyc3Qgbm9kZSBvciB0aGUgcHJldmlvdXMgbm9kZSBlbmRzIG9uIHdoaXRlc3BhY2UgY2hhcmFjdGVyLgoKCiAgICAgIGlmIChzaG91bGRMZWZ0VHJpbSkgewogICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL15cdTAwQTAvLCAnICcpOwogICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIGFsbCB3aGl0ZXNwYWNlcyBzaG91bGQgYmUgcmVtb3ZlZCBhbmQgYWxsICZuYnNwOyBjcmVhdGVkIGZvciByZW5kZXJpbmcgcmVhc29ucyBzaG91bGQgYmUKICAgICAgLy8gY2hhbmdlZCB0byBub3JtYWwgc3BhY2UuIEFsbCBsZWZ0ICZuYnNwOyBhcmUgJm5ic3A7IGluc2VydGVkIGludGVudGlvbmFsbHkuCgoKICAgICAgcmV0dXJuIGRhdGE7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjaGVja3MgaWYgYSBET00gdGV4dCBub2RlLCBwcmVjZWRlZCBieSB0aGUgZ2l2ZW4gYHByZXZOb2RlYCBzaG91bGQKICAgICAqIGJlIHRyaW1tZWQgZnJvbSB0aGUgbGVmdCBzaWRlLgogICAgICoKICAgICAqIEBwYXJhbSB7Tm9kZX0gcHJldk5vZGUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY2hlY2tTaG91bGRMZWZ0VHJpbURvbVRleHQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3VsZExlZnRUcmltRG9tVGV4dChwcmV2Tm9kZSkgewogICAgICBpZiAoIXByZXZOb2RlKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIGlmIChpc0VsZW1lbnQocHJldk5vZGUpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiAvW15cU1x1MDBBMF0vLnRlc3QocHJldk5vZGUuZGF0YS5jaGFyQXQocHJldk5vZGUuZGF0YS5sZW5ndGggLSAxKSk7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBjaGVja3MgaWYgYSBET00gdGV4dCBub2RlLCBzdWNjZWVkZWQgYnkgdGhlIGdpdmVuIGBuZXh0Tm9kZWAgc2hvdWxkCiAgICAgKiBiZSB0cmltbWVkIGZyb20gdGhlIHJpZ2h0IHNpZGUuCiAgICAgKgogICAgICogQHBhcmFtIHtOb2RlfSBub2RlCiAgICAgKiBAcGFyYW0ge05vZGV9IG5leHROb2RlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NoZWNrU2hvdWxkUmlnaHRUcmltRG9tVGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrU2hvdWxkUmlnaHRUcmltRG9tVGV4dChub2RlLCBuZXh0Tm9kZSkgewogICAgICBpZiAobmV4dE5vZGUpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiAhc3RhcnRzV2l0aEZpbGxlcihub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIGZ1bmN0aW9uLiBGb3IgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdmlldyB0ZXh0IG5vZGV9LCBpdCBmaW5kcyBwcmV2aW91cyBvciBuZXh0IHNpYmxpbmcKICAgICAqIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSBzYW1lIGNvbnRhaW5lciBlbGVtZW50LiBJZiB0aGVyZSBpcyBubyBzdWNoIHNpYmxpbmcsIGBudWxsYCBpcyByZXR1cm5lZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IG5vZGUgUmVmZXJlbmNlIG5vZGUuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGdldE5leHQKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG51bGx9IFRvdWNoaW5nIHRleHQgbm9kZSBvciBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gbmV4dCBvciBwcmV2aW91cyB0b3VjaGluZyB0ZXh0IG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRvdWNoaW5nVmlld1RleHROb2RlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG91Y2hpbmdWaWV3VGV4dE5vZGUobm9kZSwgZ2V0TmV4dCkgewogICAgICB2YXIgdHJlZVdhbGtlciA9IG5ldyBWaWV3VHJlZVdhbGtlcih7CiAgICAgICAgc3RhcnRQb3NpdGlvbjogZ2V0TmV4dCA/IFZpZXdQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIobm9kZSkgOiBWaWV3UG9zaXRpb24uX2NyZWF0ZUJlZm9yZShub2RlKSwKICAgICAgICBkaXJlY3Rpb246IGdldE5leHQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSB0cmVlV2Fsa2VyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDUudmFsdWU7CgogICAgICAgICAgLy8gVmlld0NvbnRhaW5lckVsZW1lbnQgaXMgZm91bmQgb24gYSB3YXkgdG8gbmV4dCBWaWV3VGV4dCBub2RlLCBzbyBnaXZlbiBgbm9kZWAgd2FzIGZpcnN0L2xhc3QKICAgICAgICAgIC8vIHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICBpZiAodmFsdWUuaXRlbS5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSAvLyA8YnI+IGZvdW5kIOKAkyBpdCB3b3JrcyBsaWtlIGEgYmxvY2sgYm91bmRhcnksIHNvIGRvIG5vdCBzY2FuIGZ1cnRoZXIuCiAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5pdGVtLmlzKCdicicpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0gLy8gRm91bmQgYSB0ZXh0IG5vZGUgaW4gdGhlIHNhbWUgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLml0ZW0uaXMoJ3RleHRQcm94eScpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuaXRlbTsKICAgICAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBmdW5jdGlvbi4gRm9yIHRoZSBnaXZlbiB0ZXh0IG5vZGUsIGl0IGZpbmRzIHRoZSBjbG9zZXN0IHRvdWNoaW5nIG5vZGUgd2hpY2ggaXMgZWl0aGVyCiAgICAgKiBhIHRleHQgbm9kZSBvciBhIGA8YnI+YC4gVGhlIHNlYXJjaCBpcyB0ZXJtaW5hdGVkIGF0IGJsb2NrIGVsZW1lbnQgYm91bmRhcmllcyBhbmQgaWYgYSBtYXRjaGluZyBub2RlCiAgICAgKiB3YXNuJ3QgZm91bmQgc28gZmFyLCBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogSW4gdGhlIGZvbGxvd2luZyBET00gc3RydWN0dXJlOgogICAgICoKICAgICAqCQk8cD5mb288Yj5iYXI8L2I+PGJyPmJvbTwvcD4KICAgICAqCiAgICAgKiAqIGBmb29gIGRvZXNuJ3QgaGF2ZSBpdHMgcHJldmlvdXMgdG91Y2hpbmcgaW5saW5lIG5vZGUgKGBudWxsYCBpcyByZXR1cm5lZCksCiAgICAgKiAqIGBmb29gJ3MgbmV4dCB0b3VjaGluZyBpbmxpbmUgbm9kZSBpcyBgYmFyYAogICAgICogKiBgYmFyYCdzIG5leHQgdG91Y2hpbmcgaW5saW5lIG5vZGUgaXMgYDxicj5gCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0ZXh0IG5vZGVzIGFuZCBgPGJyPmAgZWxlbWVudHMgYmVjYXVzZSB0aGVzZSB0eXBlcyBvZiBub2RlcyBhZmZlY3QgaG93CiAgICAgKiBzcGFjZXMgaW4gdGhlIGdpdmVuIHRleHQgbm9kZSBuZWVkIHRvIGJlIGNvbnZlcnRlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtUZXh0fSBub2RlCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGdldE5leHQKICAgICAqIEByZXR1cm5zIHtUZXh0fEVsZW1lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VG91Y2hpbmdJbmxpbmVEb21Ob2RlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VG91Y2hpbmdJbmxpbmVEb21Ob2RlKG5vZGUsIGdldE5leHQpIHsKICAgICAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIGRpcmVjdGlvbiA9IGdldE5leHQgPyAnbmV4dE5vZGUnIDogJ3ByZXZpb3VzTm9kZSc7CiAgICAgIHZhciBkb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDsKICAgICAgdmFyIHRvcG1vc3RQYXJlbnQgPSBnZXRBbmNlc3RvcnMobm9kZSlbMF07CiAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcih0b3Btb3N0UGFyZW50LCBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7CiAgICAgICAgYWNjZXB0Tm9kZTogZnVuY3Rpb24gYWNjZXB0Tm9kZShub2RlKSB7CiAgICAgICAgICBpZiAoaXNUZXh0KG5vZGUpKSB7CiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PSAnQlInKSB7CiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1NLSVA7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdHJlZVdhbGtlci5jdXJyZW50Tm9kZSA9IG5vZGU7CiAgICAgIHZhciB0b3VjaGluZ05vZGUgPSB0cmVlV2Fsa2VyW2RpcmVjdGlvbl0oKTsKCiAgICAgIGlmICh0b3VjaGluZ05vZGUgIT09IG51bGwpIHsKICAgICAgICB2YXIgbGNhID0gZ2V0Q29tbW9uQW5jZXN0b3Iobm9kZSwgdG91Y2hpbmdOb2RlKTsgLy8gSWYgdGhlcmUgaXMgY29tbW9uIGFuY2VzdG9yIGJldHdlZW4gdGhlIHRleHQgbm9kZSBhbmQgbmV4dC9wcmV2IHRleHQgbm9kZSwKICAgICAgICAvLyBhbmQgdGhlcmUgYXJlIG5vIGJsb2NrIGVsZW1lbnRzIG9uIGEgd2F5IGZyb20gdGhlIHRleHQgbm9kZSB0byB0aGF0IGFuY2VzdG9yLAogICAgICAgIC8vIGFuZCB0aGVyZSBhcmUgbm8gYmxvY2sgZWxlbWVudHMgb24gYSB3YXkgZnJvbSBuZXh0L3ByZXYgdGV4dCBub2RlIHRvIHRoYXQgYW5jZXN0b3IuLi4KCiAgICAgICAgaWYgKGxjYSAmJiAhX2hhc0RvbVBhcmVudE9mVHlwZShub2RlLCB0aGlzLmJsb2NrRWxlbWVudHMsIGxjYSkgJiYgIV9oYXNEb21QYXJlbnRPZlR5cGUodG91Y2hpbmdOb2RlLCB0aGlzLmJsb2NrRWxlbWVudHMsIGxjYSkpIHsKICAgICAgICAgIC8vIFRoZW4gdGhleSBhcmUgaW4gdGhlIHNhbWUgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgICByZXR1cm4gdG91Y2hpbmdOb2RlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gRG9tQ29udmVydGVyOwp9KCk7IC8vIEhlbHBlciBmdW5jdGlvbi4KLy8gVXNlZCB0byBjaGVjayBpZiBnaXZlbiBuYXRpdmUgYEVsZW1lbnRgIG9yIGBUZXh0YCBub2RlIGhhcyBwYXJlbnQgd2l0aCB0YWcgbmFtZSBmcm9tIGB0eXBlc2AgYXJyYXkuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gbm9kZQovLyBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSB0eXBlcwovLyBAcGFyYW0ge0Jvb2xlYW59IFtib3VuZGFyeVBhcmVudF0gQ2FuIGJlIGdpdmVuIGlmIHBhcmVudHMgc2hvdWxkIGJlIGNoZWNrZWQgdXAgdG8gYSBnaXZlbiBlbGVtZW50IChleGNsdWRpbmcgdGhhdCBlbGVtZW50KS4KLy8gQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBzdWNoIHBhcmVudCBleGlzdHMgb3IgYGZhbHNlYCBpZiBpdCBkb2VzIG5vdC4KCgpleHBvcnQgeyBEb21Db252ZXJ0ZXIgYXMgZGVmYXVsdCB9OwoKZnVuY3Rpb24gX2hhc0RvbVBhcmVudE9mVHlwZShub2RlLCB0eXBlcywgYm91bmRhcnlQYXJlbnQpIHsKICB2YXIgcGFyZW50cyA9IGdldEFuY2VzdG9ycyhub2RlKTsKCiAgaWYgKGJvdW5kYXJ5UGFyZW50KSB7CiAgICBwYXJlbnRzID0gcGFyZW50cy5zbGljZShwYXJlbnRzLmluZGV4T2YoYm91bmRhcnlQYXJlbnQpICsgMSk7CiAgfQoKICByZXR1cm4gcGFyZW50cy5zb21lKGZ1bmN0aW9uIChwYXJlbnQpIHsKICAgIHJldHVybiBwYXJlbnQudGFnTmFtZSAmJiB0eXBlcy5pbmNsdWRlcyhwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKTsKICB9KTsKfSAvLyBBIGhlbHBlciB0aGF0IGV4ZWN1dGVzIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIERPTSBub2RlJ3MgYW5jZXN0b3IsIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIG5vZGUKLy8gYW5kIGVuZGluZyBpbiBkb2N1bWVudCNkb2N1bWVudEVsZW1lbnQuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gbm9kZQovLyBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGFuY2VzdG9yLgoKCmZ1bmN0aW9uIGZvckVhY2hEb21Ob2RlQW5jZXN0b3Iobm9kZSwgY2FsbGJhY2spIHsKICB3aGlsZSAobm9kZSAmJiBub2RlICE9IGdsb2JhbC5kb2N1bWVudCkgewogICAgY2FsbGJhY2sobm9kZSk7CiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlOwogIH0KfSAvLyBDaGVja3MgaWYgZ2l2ZW4gbm9kZSBpcyBhIG5ic3AgYmxvY2sgZmlsbGVyLgovLwovLyBBICZuYnNwOyBpcyBhIGJsb2NrIGZpbGxlciBvbmx5IGlmIGl0IGlzIGEgc2luZ2xlIGNoaWxkIG9mIGEgYmxvY2sgZWxlbWVudC4KLy8KLy8gQHBhcmFtIHtOb2RlfSBkb21Ob2RlIERPTSBub2RlLgovLyBAcmV0dXJucyB7Qm9vbGVhbn0KCgpmdW5jdGlvbiBpc05ic3BCbG9ja0ZpbGxlcihkb21Ob2RlLCBibG9ja0VsZW1lbnRzKSB7CiAgdmFyIGlzTkJTUCA9IGlzVGV4dChkb21Ob2RlKSAmJiBkb21Ob2RlLmRhdGEgPT0gIlx4QTAiOwogIHJldHVybiBpc05CU1AgJiYgaGFzQmxvY2tQYXJlbnQoZG9tTm9kZSwgYmxvY2tFbGVtZW50cykgJiYgZG9tTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxOwp9IC8vIENoZWNrcyBpZiBkb21Ob2RlIGhhcyBibG9jayBwYXJlbnQuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gZG9tTm9kZSBET00gbm9kZS4KLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gaGFzQmxvY2tQYXJlbnQoZG9tTm9kZSwgYmxvY2tFbGVtZW50cykgewogIHZhciBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7CiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAmJiBibG9ja0VsZW1lbnRzLmluY2x1ZGVzKHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpOwp9Ci8qKgogKiBFbnVtIHJlcHJlc2VudGluZyB0eXBlIG9mIHRoZSBibG9jayBmaWxsZXIuCiAqCiAqIFBvc3NpYmxlIHZhbHVlczoKICoKICogKiBgYnJgIC0gZm9yIGA8YnI+YCBibG9jayBmaWxsZXIgdXNlZCBpbiBlZGl0aW5nIHZpZXcsCiAqICogYG5ic3BgIC0gZm9yIGAmbmJzcDtgIGJsb2NrIGZpbGxlcnMgdXNlZCBpbiB0aGUgZGF0YS4KICoKICogQHR5cGVkZWYge1N0cmluZ30gbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlcn5CbG9ja0ZpbGxlck1vZGUKICov"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","BR_FILLER","getDataWithoutFiller","INLINE_FILLER_LENGTH","isInlineFiller","NBSP_FILLER","startsWithFiller","global","indexOf","getAncestors","getCommonAncestor","isText","isElement","BR_FILLER_REF","document","DomConverter","options","blockFillerMode","preElements","blockElements","_blockFiller","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","domElement","viewDocumentSelection","set","get","viewElement","delete","Array","from","childNodes","child","unbindDomElement","domFragment","viewFragment","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","createDocumentFragment","bind","bindDocumentFragments","render","bindElements","hasAttribute","createElementNS","getAttribute","name","createElement","getAttributeKeys","key","setAttribute","withChildren","undefined","viewChildrenToDom","appendChild","fillerPositionOffset","getFillerOffset","offset","getChildren","childView","viewToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domNode","isBlockFiller","uiElement","getParentUIElement","_processDataFromDomText","isComment","mapDomToView","isDocumentFragment","viewName","keepOriginalCase","tagName","toLowerCase","attrs","attributes","i","length","_setAttribute","value","domChildrenToView","_appendChild","domChild","viewChild","domToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","fakeSelectionToView","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","push","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","firstChild","getChild","documentFragmentOrElement","viewText","viewEditable","domEditable","ownerDocument","activeElement","window","scrollX","scrollY","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","focus","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","_isDomSelectionPositionCorrect","data","some","includes","charAt","prevNode","_getTouchingViewTextNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextNode","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","test","getNext","treeWalker","startPosition","_createAfter","direction","item","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","types","boundaryParent","parents","slice","callback","isNBSP"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, getDataWithoutFiller, INLINE_FILLER_LENGTH, isInlineFiller, NBSP_FILLER, startsWithFiller } from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n\n// eslint-disable-next-line new-cap\nconst BR_FILLER_REF = BR_FILLER( document );\n\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates DOM converter.\n\t *\n\t * @param {module:engine/view/document~Document} document The view document instance.\n\t * @param {Object} options Object with configuration options.\n\t * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.\n\t */\n\tconstructor( document, options = {} ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * The mode of a block filler used by DOM converter.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'br'|'nbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n\t\t */\n\t\tthis.blockFillerMode = options.blockFillerMode || 'br';\n\n\t\t/**\n\t\t * Elements which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Elements which are considered block elements (and hence should be filled with a\n\t\t * {@link #isBlockFiller block filler}).\n\t\t *\n\t\t * Whether an element is considered a block element also affects handling of trailing whitespaces.\n\t\t *\n\t\t * You can extend this array if you introduce support for block elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption' ];\n\n\t\t/**\n\t\t * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n\t\t * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {Function} module:engine/view/domconverter~DomConverter#_blockFiller\n\t\t */\n\t\tthis._blockFiller = this.blockFillerMode == 'br' ? BR_FILLER : NBSP_FILLER;\n\n\t\t/**\n\t\t * DOM to View mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View to DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\t}\n\n\t/**\n\t * Binds given DOM element that represents fake selection to a **position** of a\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n\t * Document selection copy is stored and can be retrieved by\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n\t * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and View elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement View element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * `domElement` will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\t// Use Array.from because of MS Edge (#923).\n\t\t\tfor ( const child of Array.from( domElement.childNodes ) ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tif ( viewNode.hasAttribute( 'xmlns' ) ) {\n\t\t\t\t\tdomElement = domDocument.createElementNS( viewNode.getAttribute( 'xmlns' ), viewNode.name );\n\t\t\t\t} else {\n\t\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this._blockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this._blockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( 'text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( this.isBlockFiller( domNode, this.blockFillerMode ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside UIElement return that UIElement as it's view representation.\n\t\tconst uiElement = this.getParentUIElement( domNode, this._domToViewMapping );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( this.document, textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment( this.document );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( this.document, viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( this.isBlockFiller( domParent, this.blockFillerMode ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && viewElement.is( 'uiElement' ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\treturn this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by UIElement - return that element.\n\t\tconst uiElement = this.getParentUIElement( domText );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Checks if the node is an instance of the block filler for this DOM converter.\n\t *\n\t *\t\tconst converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );\n\t *\n\t *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n\t *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n\t *\n\t * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n\t *\n\t * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n\t *\n\t * @param {Node} domNode DOM node to check.\n\t * @returns {Boolean} True if a node is considered a block filler for given mode.\n\t */\n\tisBlockFiller( domNode ) {\n\t\tif ( this.blockFillerMode == 'br' ) {\n\t\t\treturn domNode.isEqualNode( BR_FILLER_REF );\n\t\t}\n\n\t\t// Special case for <p><br></p> in which case the <br> should be treated as filler even\n\t\t// when we're in the 'nbsp' mode. See ckeditor5#5564.\n\t\tif ( domNode.tagName === 'BR' && hasBlockParent( domNode, this.blockElements ) && domNode.parentNode.childNodes.length === 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isNbspBlockFiller( domNode, this.blockElements );\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n\t * parent UIElement.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|null}\n\t */\n\tgetParentUIElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && viewNode.is( 'uiElement' ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t * * before or in the middle of the inline filler sequence,\n\t * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n\t *\n\t * @param {Selection} domSelection DOM Selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n\t\t// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\t\tif ( viewParent && viewParent.is( 'uiElement' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextNode.data.charAt( 0 ) == ' ' ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || ( nextNode.data && nextNode.data.charAt( 0 ) == ' ' ) ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @param {Node} node\n\t * @param {Node} nextNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( 'textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction isNbspBlockFiller( domNode, blockElements ) {\n\tconst isNBSP = isText( domNode ) && domNode.data == '\\u00A0';\n\n\treturn isNBSP && hasBlockParent( domNode, blockElements ) && domNode.parentNode.childNodes.length === 1;\n}\n\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction hasBlockParent( domNode, blockElements ) {\n\tconst parent = domNode.parentNode;\n\n\treturn parent && parent.tagName && blockElements.includes( parent.tagName.toLowerCase() );\n}\n\n/**\n * Enum representing type of the block filler.\n *\n * Possible values:\n *\n * * `br` - for `<br>` block filler used in editing view,\n * * `nbsp` - for `&nbsp;` block fillers used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n"]}]}