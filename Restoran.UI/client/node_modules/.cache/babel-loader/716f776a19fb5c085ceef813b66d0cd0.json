{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\viewconsumable.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\viewconsumable.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZQogKi8KaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJ2xvZGFzaC1lcyc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwovKioKICogQ2xhc3MgdXNlZCBmb3IgaGFuZGxpbmcgY29uc3VtcHRpb24gb2YgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50c30sCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZXN9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudHN9LgogKiBFbGVtZW50J3MgbmFtZSBhbmQgaXRzIHBhcnRzIChhdHRyaWJ1dGVzLCBjbGFzc2VzIGFuZCBzdHlsZXMpIGNhbiBiZSBjb25zdW1lZCBzZXBhcmF0ZWx5LiBDb25zdW1pbmcgYW4gZWxlbWVudCdzIG5hbWUKICogZG9lcyBub3QgY29uc3VtZSBpdHMgYXR0cmlidXRlcywgY2xhc3NlcyBhbmQgc3R5bGVzLgogKiBUbyBhZGQgaXRlbXMgZm9yIGNvbnN1bXB0aW9uIHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlI2FkZCBhZGQgbWV0aG9kfS4KICogVG8gdGVzdCBpdGVtcyB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSN0ZXN0IHRlc3QgbWV0aG9kfS4KICogVG8gY29uc3VtZSBpdGVtcyB1c2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSNjb25zdW1lIGNvbnN1bWUgbWV0aG9kfS4KICogVG8gcmV2ZXJ0IGFscmVhZHkgY29uc3VtZWQgaXRlbXMgdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGUjcmV2ZXJ0IHJldmVydCBtZXRob2R9LgogKgogKgkJdmlld0NvbnN1bWFibGUuYWRkKCBlbGVtZW50LCB7IG5hbWU6IHRydWUgfSApOyAvLyBBZGRzIGVsZW1lbnQncyBuYW1lIGFzIHJlYWR5IHRvIGJlIGNvbnN1bWVkLgogKgkJdmlld0NvbnN1bWFibGUuYWRkKCB0ZXh0Tm9kZSApOyAvLyBBZGRzIHRleHQgbm9kZSBmb3IgY29uc3VtcHRpb24uCiAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIGRvY0ZyYWdtZW50ICk7IC8vIEFkZHMgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGNvbnN1bXB0aW9uLgogKgkJdmlld0NvbnN1bWFibGUudGVzdCggZWxlbWVudCwgeyBuYW1lOiB0cnVlIH0gICk7IC8vIFRlc3RzIGlmIGVsZW1lbnQncyBuYW1lIGNhbiBiZSBjb25zdW1lZC4KICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHRleHROb2RlICk7IC8vIFRlc3RzIGlmIHRleHQgbm9kZSBjYW4gYmUgY29uc3VtZWQuCiAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBkb2NGcmFnbWVudCApOyAvLyBUZXN0cyBpZiBkb2N1bWVudCBmcmFnbWVudCBjYW4gYmUgY29uc3VtZWQuCiAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCBlbGVtZW50LCB7IG5hbWU6IHRydWUgfSAgKTsgLy8gQ29uc3VtZSBlbGVtZW50J3MgbmFtZS4KICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHRleHROb2RlICk7IC8vIENvbnN1bWUgdGV4dCBub2RlLgogKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggZG9jRnJhZ21lbnQgKTsgLy8gQ29uc3VtZSBkb2N1bWVudCBmcmFnbWVudC4KICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggZWxlbWVudCwgeyBuYW1lOiB0cnVlIH0gICk7IC8vIFJldmVydCBhbHJlYWR5IGNvbnN1bWVkIGVsZW1lbnQncyBuYW1lLgogKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCB0ZXh0Tm9kZSApOyAvLyBSZXZlcnQgYWxyZWFkeSBjb25zdW1lZCB0ZXh0IG5vZGUuCiAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIGRvY0ZyYWdtZW50ICk7IC8vIFJldmVydCBhbHJlYWR5IGNvbnN1bWVkIGRvY3VtZW50IGZyYWdtZW50LgogKi8KCnZhciBWaWV3Q29uc3VtYWJsZSA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgbmV3IFZpZXdDb25zdW1hYmxlLgogICAqLwogIGZ1bmN0aW9uIFZpZXdDb25zdW1hYmxlKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXdDb25zdW1hYmxlKTsKCiAgICAvKioKICAgICAqIE1hcCBvZiBjb25zdW1hYmxlIGVsZW1lbnRzLiBJZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSBpcyB1c2VkIGFzIGEga2V5LAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3RWxlbWVudENvbnN1bWFibGVzIFZpZXdFbGVtZW50Q29uc3VtYWJsZXN9IGluc3RhbmNlIGlzIHN0b3JlZCBhcyB2YWx1ZS4KICAgICAqIEZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGVzfSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IGRvY3VtZW50IGZyYWdtZW50c30gYm9vbGVhbiB2YWx1ZSBpcyBzdG9yZWQgYXMgdmFsdWUuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQG1lbWJlciB7TWFwLjxtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0VsZW1lbnRDb25zdW1hYmxlc3xCb29sZWFuPn0KICAgICovCiAgICB0aGlzLl9jb25zdW1hYmxlcyA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogQWRkcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnR9IGFzIHJlYWR5IHRvIGJlIGNvbnN1bWVkLgogICAqCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggcCwgeyBuYW1lOiB0cnVlIH0gKTsgLy8gQWRkcyBlbGVtZW50J3MgbmFtZSB0byBjb25zdW1lLgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnIH0gKTsgLy8gQWRkcyBlbGVtZW50J3MgYXR0cmlidXRlLgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBBZGRzIGVsZW1lbnQncyBjbGFzcy4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIEFkZHMgZWxlbWVudCdzIHN0eWxlCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggcCwgeyBhdHRyaWJ1dGVzOiAnbmFtZScsIHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIEFkZHMgYXR0cmlidXRlIGFuZCBzdHlsZS4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IGNsYXNzZXM6IFsgJ2JheicsICdiYXInIF0gfSApOyAvLyBNdWx0aXBsZSBjb25zdW1hYmxlcyBjYW4gYmUgcHJvdmlkZWQuCiAgICoJCXZpZXdDb25zdW1hYmxlLmFkZCggdGV4dE5vZGUgKTsgLy8gQWRkcyB0ZXh0IG5vZGUgdG8gY29uc3VtZS4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBkb2NGcmFnbWVudCApOyAvLyBBZGRzIGRvY3VtZW50IGZyYWdtZW50IHRvIGNvbnN1bWUuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlYCB3aGVuIGBjbGFzc2Agb3IgYHN0eWxlYAogICAqIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCAtIGl0IHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgYnkgcHJvdmlkaW5nIGFjdHVhbCBzdHlsZS9jbGFzcy4KICAgKgogICAqCQl2aWV3Q29uc3VtYWJsZS5hZGQoIHAsIHsgYXR0cmlidXRlczogJ3N0eWxlJyB9ICk7IC8vIFRoaXMgY2FsbCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbi4KICAgKgkJdmlld0NvbnN1bWFibGUuYWRkKCBwLCB7IHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIFRoaXMgaXMgcHJvcGVybHkgaGFuZGxlZCBzdHlsZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVsZW1lbnQKICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnN1bWFibGVzXSBVc2VkIG9ubHkgaWYgZmlyc3QgcGFyYW1ldGVyIGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gaW5zdGFuY2UuCiAgICogQHBhcmFtIHtCb29sZWFufSBjb25zdW1hYmxlcy5uYW1lIElmIHNldCB0byB0cnVlIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgaW5jbHVkZWQuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzLgogICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFZpZXdDb25zdW1hYmxlLCBbewogICAga2V5OiAiYWRkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZWxlbWVudCwgY29uc3VtYWJsZXMpIHsKICAgICAgdmFyIGVsZW1lbnRDb25zdW1hYmxlczsgLy8gRm9yIHRleHQgbm9kZXMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBqdXN0IG1hcmsgdGhlbSBhcyBjb25zdW1hYmxlLgoKICAgICAgaWYgKGVsZW1lbnQuaXMoJ3RleHQnKSB8fCBlbGVtZW50LmlzKCdkb2N1bWVudEZyYWdtZW50JykpIHsKICAgICAgICB0aGlzLl9jb25zdW1hYmxlcy5zZXQoZWxlbWVudCwgdHJ1ZSk7CgogICAgICAgIHJldHVybjsKICAgICAgfSAvLyBGb3IgZWxlbWVudHMgY3JlYXRlIG5ldyBWaWV3RWxlbWVudENvbnN1bWFibGVzIG9yIHVwZGF0ZSBhbHJlYWR5IGV4aXN0aW5nIG9uZS4KCgogICAgICBpZiAoIXRoaXMuX2NvbnN1bWFibGVzLmhhcyhlbGVtZW50KSkgewogICAgICAgIGVsZW1lbnRDb25zdW1hYmxlcyA9IG5ldyBWaWV3RWxlbWVudENvbnN1bWFibGVzKGVsZW1lbnQpOwoKICAgICAgICB0aGlzLl9jb25zdW1hYmxlcy5zZXQoZWxlbWVudCwgZWxlbWVudENvbnN1bWFibGVzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBlbGVtZW50Q29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlcy5nZXQoZWxlbWVudCk7CiAgICAgIH0KCiAgICAgIGVsZW1lbnRDb25zdW1hYmxlcy5hZGQoY29uc3VtYWJsZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBUZXN0cyBpZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0gY2FuIGJlIGNvbnN1bWVkLgogICAgICogSXQgcmV0dXJucyBgdHJ1ZWAgd2hlbiBhbGwgaXRlbXMgaW5jbHVkZWQgaW4gbWV0aG9kJ3MgY2FsbCBjYW4gYmUgY29uc3VtZWQuIFJldHVybnMgYGZhbHNlYCB3aGVuCiAgICAgKiBmaXJzdCBhbHJlYWR5IGNvbnN1bWVkIGl0ZW0gaXMgZm91bmQgYW5kIGBudWxsYCB3aGVuIGZpcnN0IG5vbi1jb25zdW1hYmxlIGl0ZW0gaXMgZm91bmQuCiAgICAgKgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgbmFtZTogdHJ1ZSB9ICk7IC8vIFRlc3RzIGVsZW1lbnQncyBuYW1lLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnIH0gKTsgLy8gVGVzdHMgYXR0cmlidXRlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBUZXN0cyBjbGFzcy4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS50ZXN0KCBwLCB7IHN0eWxlczogJ2NvbG9yJyB9ICk7IC8vIFRlc3RzIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnLCBzdHlsZXM6ICdjb2xvcicgfSApOyAvLyBUZXN0cyBhdHRyaWJ1dGUgYW5kIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgY2xhc3NlczogWyAnYmF6JywgJ2JhcicgXSB9ICk7IC8vIE11bHRpcGxlIGNvbnN1bWFibGVzIGNhbiBiZSB0ZXN0ZWQuCiAgICAgKgkJdmlld0NvbnN1bWFibGUudGVzdCggdGV4dE5vZGUgKTsgLy8gVGVzdHMgdGV4dCBub2RlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIGRvY0ZyYWdtZW50ICk7IC8vIFRlc3RzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIFRlc3RpbmcgY2xhc3NlcyBhbmQgc3R5bGVzIGFzIGF0dHJpYnV0ZSB3aWxsIHRlc3QgaWYgYWxsIGFkZGVkIGNsYXNzZXMvc3R5bGVzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCiAgICAgKgkJdmlld0NvbnN1bWFibGUudGVzdCggcCwgeyBhdHRyaWJ1dGVzOiAnY2xhc3MnIH0gKTsgLy8gVGVzdHMgaWYgYWxsIGFkZGVkIGNsYXNzZXMgY2FuIGJlIGNvbnN1bWVkLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnRlc3QoIHAsIHsgYXR0cmlidXRlczogJ3N0eWxlJyB9ICk7IC8vIFRlc3RzIGlmIGFsbCBhZGRlZCBzdHlsZXMgY2FuIGJlIGNvbnN1bWVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVsZW1lbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uc3VtYWJsZXNdIFVzZWQgb25seSBpZiBmaXJzdCBwYXJhbWV0ZXIgaXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSBpbnN0YW5jZS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gdHJ1ZSBlbGVtZW50J3MgbmFtZSB3aWxsIGJlIGluY2x1ZGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmNsYXNzZXMgQ2xhc3MgbmFtZSBvciBhcnJheSBvZiBjbGFzcyBuYW1lcy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5zdHlsZXMgU3R5bGUgbmFtZSBvciBhcnJheSBvZiBzdHlsZSBuYW1lcy4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IFJldHVybnMgYHRydWVgIHdoZW4gYWxsIGl0ZW1zIGluY2x1ZGVkIGluIG1ldGhvZCdzIGNhbGwgY2FuIGJlIGNvbnN1bWVkLiBSZXR1cm5zIGBmYWxzZWAKICAgICAqIHdoZW4gZmlyc3QgYWxyZWFkeSBjb25zdW1lZCBpdGVtIGlzIGZvdW5kIGFuZCBgbnVsbGAgd2hlbiBmaXJzdCBub24tY29uc3VtYWJsZSBpdGVtIGlzIGZvdW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRlc3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3QoZWxlbWVudCwgY29uc3VtYWJsZXMpIHsKICAgICAgdmFyIGVsZW1lbnRDb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzLmdldChlbGVtZW50KTsKCiAgICAgIGlmIChlbGVtZW50Q29uc3VtYWJsZXMgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9IC8vIEZvciB0ZXh0IG5vZGVzIGFuZCBkb2N1bWVudCBmcmFnbWVudHMgcmV0dXJuIHN0b3JlZCBib29sZWFuIHZhbHVlLgoKCiAgICAgIGlmIChlbGVtZW50LmlzKCd0ZXh0JykgfHwgZWxlbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgcmV0dXJuIGVsZW1lbnRDb25zdW1hYmxlczsKICAgICAgfSAvLyBGb3IgZWxlbWVudHMgdGVzdCBjb25zdW1hYmxlcyBvYmplY3QuCgoKICAgICAgcmV0dXJuIGVsZW1lbnRDb25zdW1hYmxlcy50ZXN0KGNvbnN1bWFibGVzKTsKICAgIH0KICAgIC8qKgogICAgICogQ29uc3VtZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdGV4dCBub2RlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgZG9jdW1lbnQgZnJhZ21lbnR9LgogICAgICogSXQgcmV0dXJucyBgdHJ1ZWAgd2hlbiBhbGwgaXRlbXMgaW5jbHVkZWQgaW4gbWV0aG9kJ3MgY2FsbCBjYW4gYmUgY29uc3VtZWQsIG90aGVyd2lzZSByZXR1cm5zIGBmYWxzZWAuCiAgICAgKgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgbmFtZTogdHJ1ZSB9ICk7IC8vIENvbnN1bWVzIGVsZW1lbnQncyBuYW1lLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnIH0gKTsgLy8gQ29uc3VtZXMgZWxlbWVudCdzIGF0dHJpYnV0ZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCBwLCB7IGNsYXNzZXM6ICdmb29iYXInIH0gKTsgLy8gQ29uc3VtZXMgZWxlbWVudCdzIGNsYXNzLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gQ29uc3VtZXMgZWxlbWVudCdzIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgYXR0cmlidXRlczogJ25hbWUnLCBzdHlsZXM6ICdjb2xvcicgfSApOyAvLyBDb25zdW1lcyBhdHRyaWJ1dGUgYW5kIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgY2xhc3NlczogWyAnYmF6JywgJ2JhcicgXSB9ICk7IC8vIE11bHRpcGxlIGNvbnN1bWFibGVzIGNhbiBiZSBjb25zdW1lZC4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5jb25zdW1lKCB0ZXh0Tm9kZSApOyAvLyBDb25zdW1lcyB0ZXh0IG5vZGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggZG9jRnJhZ21lbnQgKTsgLy8gQ29uc3VtZXMgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgKgogICAgICogQ29uc3VtaW5nIGNsYXNzZXMgYW5kIHN0eWxlcyBhcyBhdHRyaWJ1dGUgd2lsbCB0ZXN0IGlmIGFsbCBhZGRlZCBjbGFzc2VzL3N0eWxlcyBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgogICAgICoJCXZpZXdDb25zdW1hYmxlLmNvbnN1bWUoIHAsIHsgYXR0cmlidXRlczogJ2NsYXNzJyB9ICk7IC8vIENvbnN1bWUgb25seSBpZiBhbGwgYWRkZWQgY2xhc3NlcyBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgkJdmlld0NvbnN1bWFibGUuY29uc3VtZSggcCwgeyBhdHRyaWJ1dGVzOiAnc3R5bGUnIH0gKTsgLy8gQ29uc3VtZSBvbmx5IGlmIGFsbCBhZGRlZCBzdHlsZXMgY2FuIGJlIGNvbnN1bWVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVsZW1lbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uc3VtYWJsZXNdIFVzZWQgb25seSBpZiBmaXJzdCBwYXJhbWV0ZXIgaXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSBpbnN0YW5jZS4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gdHJ1ZSBlbGVtZW50J3MgbmFtZSB3aWxsIGJlIGluY2x1ZGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmNsYXNzZXMgQ2xhc3MgbmFtZSBvciBhcnJheSBvZiBjbGFzcyBuYW1lcy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5zdHlsZXMgU3R5bGUgbmFtZSBvciBhcnJheSBvZiBzdHlsZSBuYW1lcy4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCB3aGVuIGFsbCBpdGVtcyBpbmNsdWRlZCBpbiBtZXRob2QncyBjYWxsIGNhbiBiZSBjb25zdW1lZCwKICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGBmYWxzZWAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29uc3VtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShlbGVtZW50LCBjb25zdW1hYmxlcykgewogICAgICBpZiAodGhpcy50ZXN0KGVsZW1lbnQsIGNvbnN1bWFibGVzKSkgewogICAgICAgIGlmIChlbGVtZW50LmlzKCd0ZXh0JykgfHwgZWxlbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvLyBGb3IgdGV4dCBub2RlcyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIHNldCB2YWx1ZSB0byBmYWxzZS4KICAgICAgICAgIHRoaXMuX2NvbnN1bWFibGVzLnNldChlbGVtZW50LCBmYWxzZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIEZvciBlbGVtZW50cyAtIGNvbnN1bWUgY29uc3VtYWJsZXMgb2JqZWN0LgogICAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuZ2V0KGVsZW1lbnQpLmNvbnN1bWUoY29uc3VtYWJsZXMpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmV2ZXJ0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0gc28gdGhleSBjYW4gYmUgY29uc3VtZWQgb25jZSBhZ2Fpbi4KICAgICAqIE1ldGhvZCBkb2VzIG5vdCByZXZlcnQgaXRlbXMgdGhhdCB3ZXJlIG5ldmVyIHByZXZpb3VzbHkgYWRkZWQgZm9yIGNvbnN1bXB0aW9uLCBldmVuIGlmIHRoZXkgYXJlIGluY2x1ZGVkIGluCiAgICAgKiBtZXRob2QncyBjYWxsLgogICAgICoKICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgbmFtZTogdHJ1ZSB9ICk7IC8vIFJldmVydHMgZWxlbWVudCdzIG5hbWUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJyB9ICk7IC8vIFJldmVydHMgZWxlbWVudCdzIGF0dHJpYnV0ZS4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgY2xhc3NlczogJ2Zvb2JhcicgfSApOyAvLyBSZXZlcnRzIGVsZW1lbnQncyBjbGFzcy4KICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gUmV2ZXJ0cyBlbGVtZW50J3Mgc3R5bGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBwLCB7IGF0dHJpYnV0ZXM6ICduYW1lJywgc3R5bGVzOiAnY29sb3InIH0gKTsgLy8gUmV2ZXJ0cyBhdHRyaWJ1dGUgYW5kIHN0eWxlLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggcCwgeyBjbGFzc2VzOiBbICdiYXonLCAnYmFyJyBdIH0gKTsgLy8gTXVsdGlwbGUgbmFtZXMgY2FuIGJlIHJldmVydGVkLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggdGV4dE5vZGUgKTsgLy8gUmV2ZXJ0cyB0ZXh0IG5vZGUuCiAgICAgKgkJdmlld0NvbnN1bWFibGUucmV2ZXJ0KCBkb2NGcmFnbWVudCApOyAvLyBSZXZlcnRzIGRvY3VtZW50IGZyYWdtZW50LgogICAgICoKICAgICAqIFJldmVydGluZyBjbGFzc2VzIGFuZCBzdHlsZXMgYXMgYXR0cmlidXRlIHdpbGwgcmV2ZXJ0IGFsbCBjbGFzc2VzL3N0eWxlcyB0aGF0IHdlcmUgcHJldmlvdXNseSBhZGRlZCBmb3IKICAgICAqIGNvbnN1bXB0aW9uLgogICAgICoKICAgICAqCQl2aWV3Q29uc3VtYWJsZS5yZXZlcnQoIHAsIHsgYXR0cmlidXRlczogJ2NsYXNzJyB9ICk7IC8vIFJldmVydHMgYWxsIGNsYXNzZXMgYWRkZWQgZm9yIGNvbnN1bXB0aW9uLgogICAgICoJCXZpZXdDb25zdW1hYmxlLnJldmVydCggcCwgeyBhdHRyaWJ1dGVzOiAnc3R5bGUnIH0gKTsgLy8gUmV2ZXJ0cyBhbGwgc3R5bGVzIGFkZGVkIGZvciBjb25zdW1wdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBlbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnN1bWFibGVzXSBVc2VkIG9ubHkgaWYgZmlyc3QgcGFyYW1ldGVyIGlzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gaW5zdGFuY2UuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWFibGVzLm5hbWUgSWYgc2V0IHRvIHRydWUgZWxlbWVudCdzIG5hbWUgd2lsbCBiZSBpbmNsdWRlZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5hdHRyaWJ1dGVzIEF0dHJpYnV0ZSBuYW1lIG9yIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcy4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmV2ZXJ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnQoZWxlbWVudCwgY29uc3VtYWJsZXMpIHsKICAgICAgdmFyIGVsZW1lbnRDb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzLmdldChlbGVtZW50KTsKCiAgICAgIGlmIChlbGVtZW50Q29uc3VtYWJsZXMgIT09IHVuZGVmaW5lZCkgewogICAgICAgIGlmIChlbGVtZW50LmlzKCd0ZXh0JykgfHwgZWxlbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvLyBGb3IgdGV4dCBub2RlcyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIC0gc2V0IGNvbnN1bWFibGUgdG8gdHJ1ZS4KICAgICAgICAgIHRoaXMuX2NvbnN1bWFibGVzLnNldChlbGVtZW50LCB0cnVlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gRm9yIGVsZW1lbnRzIC0gcmV2ZXJ0IGl0ZW1zIGZyb20gY29uc3VtYWJsZXMgb2JqZWN0LgogICAgICAgICAgZWxlbWVudENvbnN1bWFibGVzLnJldmVydChjb25zdW1hYmxlcyk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgY29uc3VtYWJsZSBvYmplY3QgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LiBDb25zdW1hYmxlIG9iamVjdCB3aWxsIGluY2x1ZGUKICAgICAqIGVsZW1lbnQncyBuYW1lIGFuZCBhbGwgaXRzIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kIHN0eWxlcy4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbnN1bWFibGVzCiAgICAgKi8KCiAgfV0sIFt7CiAgICBrZXk6ICJjb25zdW1hYmxlc0Zyb21FbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1hYmxlc0Zyb21FbGVtZW50KGVsZW1lbnQpIHsKICAgICAgdmFyIGNvbnN1bWFibGVzID0gewogICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsCiAgICAgICAgbmFtZTogdHJ1ZSwKICAgICAgICBhdHRyaWJ1dGVzOiBbXSwKICAgICAgICBjbGFzc2VzOiBbXSwKICAgICAgICBzdHlsZXM6IFtdCiAgICAgIH07CiAgICAgIHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGVLZXlzKCk7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gYXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICAvLyBTa2lwIGNsYXNzZXMgYW5kIHN0eWxlcyAtIHdpbGwgYmUgYWRkZWQgc2VwYXJhdGVseS4KICAgICAgICAgIGlmIChhdHRyaWJ1dGUgPT0gJ3N0eWxlJyB8fCBhdHRyaWJ1dGUgPT0gJ2NsYXNzJykgewogICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgIH0KCiAgICAgICAgICBjb25zdW1hYmxlcy5hdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBjbGFzc2VzID0gZWxlbWVudC5nZXRDbGFzc05hbWVzKCk7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGNsYXNzZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgICBjb25zdW1hYmxlcy5jbGFzc2VzLnB1c2goY2xhc3NOYW1lKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgc3R5bGVzID0gZWxlbWVudC5nZXRTdHlsZU5hbWVzKCk7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHN0eWxlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgdmFyIHN0eWxlID0gX3N0ZXAzLnZhbHVlOwogICAgICAgICAgY29uc3VtYWJsZXMuc3R5bGVzLnB1c2goc3R5bGUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBjb25zdW1hYmxlczsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlIFZpZXdDb25zdW1hYmxlfSBpbnN0YW5jZSBmcm9tCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZSBub2RlfSBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBkb2N1bWVudCBmcmFnbWVudH0uCiAgICAgKiBJbnN0YW5jZSB3aWxsIGNvbnRhaW4gYWxsIGVsZW1lbnRzLCBjaGlsZCBub2RlcywgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBjbGFzc2VzIGFkZGVkIGZvciBjb25zdW1wdGlvbi4KICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gZnJvbSBWaWV3IG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQKICAgICAqIGZyb20gd2hpY2ggYFZpZXdDb25zdW1hYmxlYCB3aWxsIGJlIGNyZWF0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZX0gW2luc3RhbmNlXSBJZiBwcm92aWRlZCwgZ2l2ZW4gYFZpZXdDb25zdW1hYmxlYCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQKICAgICAqIHRvIGFkZCBhbGwgY29uc3VtYWJsZXMuIEl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhIG5ldyBpbnN0YW5jZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVGcm9tIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVGcm9tKGZyb20sIGluc3RhbmNlKSB7CiAgICAgIGlmICghaW5zdGFuY2UpIHsKICAgICAgICBpbnN0YW5jZSA9IG5ldyBWaWV3Q29uc3VtYWJsZShmcm9tKTsKICAgICAgfQoKICAgICAgaWYgKGZyb20uaXMoJ3RleHQnKSkgewogICAgICAgIGluc3RhbmNlLmFkZChmcm9tKTsKICAgICAgICByZXR1cm4gaW5zdGFuY2U7CiAgICAgIH0gLy8gQWRkIGBmcm9tYCBpdHNlbGYsIGlmIGl0IGlzIGFuIGVsZW1lbnQuCgoKICAgICAgaWYgKGZyb20uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgIGluc3RhbmNlLmFkZChmcm9tLCBWaWV3Q29uc3VtYWJsZS5jb25zdW1hYmxlc0Zyb21FbGVtZW50KGZyb20pKTsKICAgICAgfQoKICAgICAgaWYgKGZyb20uaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgIGluc3RhbmNlLmFkZChmcm9tKTsKICAgICAgfQoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gZnJvbS5nZXRDaGlsZHJlbigpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICBpbnN0YW5jZSA9IFZpZXdDb25zdW1hYmxlLmNyZWF0ZUZyb20oY2hpbGQsIGluc3RhbmNlKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gaW5zdGFuY2U7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gVmlld0NvbnN1bWFibGU7Cn0oKTsKLyoqCiAqIFRoaXMgaXMgYSBwcml2YXRlIGhlbHBlci1jbGFzcyBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZX0uCiAqIEl0IHJlcHJlc2VudHMgYW5kIG1hbmlwdWxhdGVzIGNvbnN1bWFibGUgcGFydHMgb2YgYSBzaW5nbGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9LgogKgogKiBAcHJpdmF0ZQogKi8KCgpleHBvcnQgeyBWaWV3Q29uc3VtYWJsZSBhcyBkZWZhdWx0IH07Cgp2YXIgVmlld0VsZW1lbnRDb25zdW1hYmxlcyA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgVmlld0VsZW1lbnRDb25zdW1hYmxlcyBpbnN0YW5jZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBmcm9tIFZpZXcgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudAogICAqIGZyb20gd2hpY2ggYFZpZXdFbGVtZW50Q29uc3VtYWJsZXNgIGlzIGJlaW5nIGNyZWF0ZWQuCiAgICovCiAgZnVuY3Rpb24gVmlld0VsZW1lbnRDb25zdW1hYmxlcyhmcm9tKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlld0VsZW1lbnRDb25zdW1hYmxlcyk7CgogICAgLyoqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwogICAgdGhpcy5lbGVtZW50ID0gZnJvbTsKICAgIC8qKgogICAgICogRmxhZyBpbmRpY2F0aW5nIGlmIG5hbWUgb2YgdGhlIGVsZW1lbnQgY2FuIGJlIGNvbnN1bWVkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtCb29sZWFufQogICAgICovCgogICAgdGhpcy5fY2FuQ29uc3VtZU5hbWUgPSBudWxsOwogICAgLyoqCiAgICAgKiBDb250YWlucyBtYXBzIG9mIGVsZW1lbnQncyBjb25zdW1hYmxlczogYXR0cmlidXRlcywgY2xhc3NlcyBhbmQgc3R5bGVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtPYmplY3R9CiAgICAgKi8KCiAgICB0aGlzLl9jb25zdW1hYmxlcyA9IHsKICAgICAgYXR0cmlidXRlczogbmV3IE1hcCgpLAogICAgICBzdHlsZXM6IG5ldyBNYXAoKSwKICAgICAgY2xhc3NlczogbmV3IE1hcCgpCiAgICB9OwogIH0KICAvKioKICAgKiBBZGRzIGNvbnN1bWFibGUgcGFydHMgb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0uCiAgICogRWxlbWVudCdzIG5hbWUgaXRzZWxmIGNhbiBiZSBtYXJrZWQgdG8gYmUgY29uc3VtZWQgKHdoZW4gZWxlbWVudCdzIG5hbWUgaXMgY29uc3VtZWQgaXRzIGF0dHJpYnV0ZXMsIGNsYXNzZXMgYW5kCiAgICogc3R5bGVzIHN0aWxsIGNvdWxkIGJlIGNvbnN1bWVkKToKICAgKgogICAqCQljb25zdW1hYmxlcy5hZGQoIHsgbmFtZTogdHJ1ZSB9ICk7CiAgICoKICAgKiBBdHRyaWJ1dGVzIGNsYXNzZXMgYW5kIHN0eWxlczoKICAgKgogICAqCQljb25zdW1hYmxlcy5hZGQoIHsgYXR0cmlidXRlczogJ3RpdGxlJywgY2xhc3NlczogJ2ZvbycsIHN0eWxlczogJ2NvbG9yJyB9ICk7CiAgICoJCWNvbnN1bWFibGVzLmFkZCggeyBhdHRyaWJ1dGVzOiBbICd0aXRsZScsICduYW1lJyBdLCBjbGFzc2VzOiBbICdmb28nLCAnYmFyJyBdICk7CiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlYCB3aGVuIGBjbGFzc2Agb3IgYHN0eWxlYAogICAqIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCAtIGl0IHNob3VsZCBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgYnkgcHJvdmlkaW5nIGBzdHlsZWAgYW5kIGBjbGFzc2AgaW4gY29uc3VtYWJsZXMgb2JqZWN0LgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN1bWFibGVzIE9iamVjdCBkZXNjcmliaW5nIHdoaWNoIHBhcnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSBjb25zdW1lZC4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWFibGVzLm5hbWUgSWYgc2V0IHRvIGB0cnVlYCBlbGVtZW50J3MgbmFtZSB3aWxsIGJlIGFkZGVkIGFzIGNvbnN1bWFibGUuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFkZCBhcyBjb25zdW1hYmxlLgogICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gYWRkIGFzIGNvbnN1bWFibGUuCiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzIHRvIGFkZCBhcyBjb25zdW1hYmxlLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFZpZXdFbGVtZW50Q29uc3VtYWJsZXMsIFt7CiAgICBrZXk6ICJhZGQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChjb25zdW1hYmxlcykgewogICAgICBpZiAoY29uc3VtYWJsZXMubmFtZSkgewogICAgICAgIHRoaXMuX2NhbkNvbnN1bWVOYW1lID0gdHJ1ZTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLl9jb25zdW1hYmxlcykgewogICAgICAgIGlmICh0eXBlIGluIGNvbnN1bWFibGVzKSB7CiAgICAgICAgICB0aGlzLl9hZGQodHlwZSwgY29uc3VtYWJsZXNbdHlwZV0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUZXN0cyBpZiBwYXJ0cyBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2RlfSBjYW4gYmUgY29uc3VtZWQuCiAgICAgKgogICAgICogRWxlbWVudCdzIG5hbWUgY2FuIGJlIHRlc3RlZDoKICAgICAqCiAgICAgKgkJY29uc3VtYWJsZXMudGVzdCggeyBuYW1lOiB0cnVlIH0gKTsKICAgICAqCiAgICAgKiBBdHRyaWJ1dGVzIGNsYXNzZXMgYW5kIHN0eWxlczoKICAgICAqCiAgICAgKgkJY29uc3VtYWJsZXMudGVzdCggeyBhdHRyaWJ1dGVzOiAndGl0bGUnLCBjbGFzc2VzOiAnZm9vJywgc3R5bGVzOiAnY29sb3InIH0gKTsKICAgICAqCQljb25zdW1hYmxlcy50ZXN0KCB7IGF0dHJpYnV0ZXM6IFsgJ3RpdGxlJywgJ25hbWUnIF0sIGNsYXNzZXM6IFsgJ2ZvbycsICdiYXInIF0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uc3VtYWJsZXMgT2JqZWN0IGRlc2NyaWJpbmcgd2hpY2ggcGFydHMgb2YgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIHRlc3RlZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gYHRydWVgIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgdGVzdGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIHRlc3QuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuY2xhc3NlcyBDbGFzcyBuYW1lIG9yIGFycmF5IG9mIGNsYXNzIG5hbWVzIHRvIHRlc3QuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuc3R5bGVzIFN0eWxlIG5hbWUgb3IgYXJyYXkgb2Ygc3R5bGUgbmFtZXMgdG8gdGVzdC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IGB0cnVlYCB3aGVuIGFsbCB0ZXN0ZWQgaXRlbXMgY2FuIGJlIGNvbnN1bWVkLCBgbnVsbGAgd2hlbiBldmVuIG9uZSBvZiB0aGUgaXRlbXMKICAgICAqIHdhcyBuZXZlciBtYXJrZWQgZm9yIGNvbnN1bXB0aW9uIGFuZCBgZmFsc2VgIHdoZW4gZXZlbiBvbmUgb2YgdGhlIGl0ZW1zIHdhcyBhbHJlYWR5IGNvbnN1bWVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRlc3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3QoY29uc3VtYWJsZXMpIHsKICAgICAgLy8gQ2hlY2sgaWYgbmFtZSBjYW4gYmUgY29uc3VtZWQuCiAgICAgIGlmIChjb25zdW1hYmxlcy5uYW1lICYmICF0aGlzLl9jYW5Db25zdW1lTmFtZSkgewogICAgICAgIHJldHVybiB0aGlzLl9jYW5Db25zdW1lTmFtZTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLl9jb25zdW1hYmxlcykgewogICAgICAgIGlmICh0eXBlIGluIGNvbnN1bWFibGVzKSB7CiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90ZXN0KHR5cGUsIGNvbnN1bWFibGVzW3R5cGVdKTsKCiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBSZXR1cm4gdHJ1ZSBvbmx5IGlmIGFsbCBjYW4gYmUgY29uc3VtZWQuCgoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIENvbnN1bWVzIHBhcnRzIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0uIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2sgaWYgY29uc3VtYWJsZSBpdGVtCiAgICAgKiBpcyBhbHJlYWR5IGNvbnN1bWVkIC0gaXQgY29uc3VtZXMgYWxsIGNvbnN1bWFibGUgaXRlbXMgcHJvdmlkZWQuCiAgICAgKiBFbGVtZW50J3MgbmFtZSBjYW4gYmUgY29uc3VtZWQ6CiAgICAgKgogICAgICoJCWNvbnN1bWFibGVzLmNvbnN1bWUoIHsgbmFtZTogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogQXR0cmlidXRlcyBjbGFzc2VzIGFuZCBzdHlsZXM6CiAgICAgKgogICAgICoJCWNvbnN1bWFibGVzLmNvbnN1bWUoIHsgYXR0cmlidXRlczogJ3RpdGxlJywgY2xhc3NlczogJ2ZvbycsIHN0eWxlczogJ2NvbG9yJyB9ICk7CiAgICAgKgkJY29uc3VtYWJsZXMuY29uc3VtZSggeyBhdHRyaWJ1dGVzOiBbICd0aXRsZScsICduYW1lJyBdLCBjbGFzc2VzOiBbICdmb28nLCAnYmFyJyBdICk7CiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnN1bWFibGVzIE9iamVjdCBkZXNjcmliaW5nIHdoaWNoIHBhcnRzIG9mIHRoZSBlbGVtZW50IHNob3VsZCBiZSBjb25zdW1lZC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uc3VtYWJsZXMubmFtZSBJZiBzZXQgdG8gYHRydWVgIGVsZW1lbnQncyBuYW1lIHdpbGwgYmUgY29uc3VtZWQuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gY29uc3VtYWJsZXMuYXR0cmlidXRlcyBBdHRyaWJ1dGUgbmFtZSBvciBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gY29uc3VtZS4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gY29uc3VtZS4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5zdHlsZXMgU3R5bGUgbmFtZSBvciBhcnJheSBvZiBzdHlsZSBuYW1lcyB0byBjb25zdW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNvbnN1bWUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUoY29uc3VtYWJsZXMpIHsKICAgICAgaWYgKGNvbnN1bWFibGVzLm5hbWUpIHsKICAgICAgICB0aGlzLl9jYW5Db25zdW1lTmFtZSA9IGZhbHNlOwogICAgICB9CgogICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuX2NvbnN1bWFibGVzKSB7CiAgICAgICAgaWYgKHR5cGUgaW4gY29uc3VtYWJsZXMpIHsKICAgICAgICAgIHRoaXMuX2NvbnN1bWUodHlwZSwgY29uc3VtYWJsZXNbdHlwZV0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXZlcnQgYWxyZWFkeSBjb25zdW1lZCBwYXJ0cyBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IEVsZW1lbnR9LCBzbyB0aGV5IGNhbiBiZSBjb25zdW1lZCBvbmNlIGFnYWluLgogICAgICogRWxlbWVudCdzIG5hbWUgY2FuIGJlIHJldmVydGVkOgogICAgICoKICAgICAqCQljb25zdW1hYmxlcy5yZXZlcnQoIHsgbmFtZTogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogQXR0cmlidXRlcyBjbGFzc2VzIGFuZCBzdHlsZXM6CiAgICAgKgogICAgICoJCWNvbnN1bWFibGVzLnJldmVydCggeyBhdHRyaWJ1dGVzOiAndGl0bGUnLCBjbGFzc2VzOiAnZm9vJywgc3R5bGVzOiAnY29sb3InIH0gKTsKICAgICAqCQljb25zdW1hYmxlcy5yZXZlcnQoIHsgYXR0cmlidXRlczogWyAndGl0bGUnLCAnbmFtZScgXSwgY2xhc3NlczogWyAnZm9vJywgJ2JhcicgXSApOwogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25zdW1hYmxlcyBPYmplY3QgZGVzY3JpYmluZyB3aGljaCBwYXJ0cyBvZiB0aGUgZWxlbWVudCBzaG91bGQgYmUgcmV2ZXJ0ZWQuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnN1bWFibGVzLm5hbWUgSWYgc2V0IHRvIGB0cnVlYCBlbGVtZW50J3MgbmFtZSB3aWxsIGJlIHJldmVydGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLmF0dHJpYnV0ZXMgQXR0cmlidXRlIG5hbWUgb3IgYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzIHRvIHJldmVydC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBjb25zdW1hYmxlcy5jbGFzc2VzIENsYXNzIG5hbWUgb3IgYXJyYXkgb2YgY2xhc3MgbmFtZXMgdG8gcmV2ZXJ0LgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNvbnN1bWFibGVzLnN0eWxlcyBTdHlsZSBuYW1lIG9yIGFycmF5IG9mIHN0eWxlIG5hbWVzIHRvIHJldmVydC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyZXZlcnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydChjb25zdW1hYmxlcykgewogICAgICBpZiAoY29uc3VtYWJsZXMubmFtZSkgewogICAgICAgIHRoaXMuX2NhbkNvbnN1bWVOYW1lID0gdHJ1ZTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLl9jb25zdW1hYmxlcykgewogICAgICAgIGlmICh0eXBlIGluIGNvbnN1bWFibGVzKSB7CiAgICAgICAgICB0aGlzLl9yZXZlcnQodHlwZSwgY29uc3VtYWJsZXNbdHlwZV0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgYWRkcyBjb25zdW1hYmxlcyBvZiBhIGdpdmVuIHR5cGU6IGF0dHJpYnV0ZSwgY2xhc3Mgb3Igc3R5bGUuCiAgICAgKgogICAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3Y29uc3VtYWJsZS1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBgY2xhc3NgIG9yIGBzdHlsZWAKICAgICAqIHR5cGUgaXMgcHJvdmlkZWQgLSBpdCBzaG91bGQgYmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGJ5IHByb3ZpZGluZyBhY3R1YWwgc3R5bGUvY2xhc3MgdHlwZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiB0aGUgY29uc3VtYWJsZSBpdGVtOiBgYXR0cmlidXRlc2AsIGBjbGFzc2VzYCBvciBgc3R5bGVzYC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5LjxTdHJpbmc+fSBpdGVtIENvbnN1bWFibGUgaXRlbSBvciBhcnJheSBvZiBpdGVtcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfYWRkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkKHR5cGUsIGl0ZW0pIHsKICAgICAgdmFyIGl0ZW1zID0gaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07CiAgICAgIHZhciBjb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzW3R5cGVdOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG5hbWUgPSBfc3RlcDUudmFsdWU7CgogICAgICAgICAgaWYgKHR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiAobmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lID09PSAnc3R5bGUnKSkgewogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogQ2xhc3MgYW5kIHN0eWxlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGhhbmRsZWQgc2VwYXJhdGVseSBpbgogICAgICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlI2FkZCBgVmlld0NvbnN1bWFibGUjYWRkKClgfS4KICAgICAgICAgICAgICoKICAgICAgICAgICAgICogV2hhdCB5b3UgaGF2ZSBkb25lIGlzIHRyeWluZyB0byB1c2U6CiAgICAgICAgICAgICAqCiAgICAgICAgICAgICAqCQljb25zdW1hYmxlcy5hZGQoIHsgYXR0cmlidXRlczogWyAnY2xhc3MnLCAnc3R5bGUnIF0gfSApOwogICAgICAgICAgICAgKgogICAgICAgICAgICAgKiBXaGlsZSBlYWNoIGNsYXNzIGFuZCBzdHlsZSBzaG91bGQgYmUgcmVnaXN0ZXJlZCBzZXBhcmF0ZWx5OgogICAgICAgICAgICAgKgogICAgICAgICAgICAgKgkJY29uc3VtYWJsZXMuYWRkKCB7IGNsYXNzZXM6ICdzb21lLWNsYXNzJywgc3R5bGVzOiAnZm9udC13ZWlnaHQnIH0gKTsKICAgICAgICAgICAgICoKICAgICAgICAgICAgICogQGVycm9yIHZpZXdjb25zdW1hYmxlLWludmFsaWQtYXR0cmlidXRlCiAgICAgICAgICAgICAqLwogICAgICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlld2NvbnN1bWFibGUtaW52YWxpZC1hdHRyaWJ1dGU6IENsYXNzZXMgYW5kIHN0eWxlcyBzaG91bGQgYmUgaGFuZGxlZCBzZXBhcmF0ZWx5LicsIHRoaXMpOwogICAgICAgICAgfQoKICAgICAgICAgIGNvbnN1bWFibGVzLnNldChuYW1lLCB0cnVlKTsKCiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0eWxlcycpIHsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTsKICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlOwogICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkOwoKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gdGhpcy5lbGVtZW50LmRvY3VtZW50LnN0eWxlc1Byb2Nlc3Nvci5nZXRSZWxhdGVkU3R5bGVzKG5hbWUpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7CiAgICAgICAgICAgICAgICB2YXIgYWxzb05hbWUgPSBfc3RlcDYudmFsdWU7CiAgICAgICAgICAgICAgICBjb25zdW1hYmxlcy5zZXQoYWxzb05hbWUsIHRydWUpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgICBfaXRlcmF0b3I2LnJldHVybigpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I2KSB7CiAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCB0ZXN0cyBjb25zdW1hYmxlcyBvZiBhIGdpdmVuIHR5cGU6IGF0dHJpYnV0ZSwgY2xhc3Mgb3Igc3R5bGUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgdGhlIGNvbnN1bWFibGUgaXRlbTogYGF0dHJpYnV0ZXNgLCBgY2xhc3Nlc2Agb3IgYHN0eWxlc2AuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaXRlbSBDb25zdW1hYmxlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxudWxsfSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgaXRlbXMgY2FuIGJlIGNvbnN1bWVkLCBgbnVsbGAgd2hlbiBvbmUgb2YgdGhlIGl0ZW1zIGNhbm5vdCBiZQogICAgICogY29uc3VtZWQgYW5kIGBmYWxzZWAgd2hlbiBvbmUgb2YgdGhlIGl0ZW1zIGlzIGFscmVhZHkgY29uc3VtZWQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3Rlc3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF90ZXN0KHR5cGUsIGl0ZW0pIHsKICAgICAgdmFyIGl0ZW1zID0gaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV07CiAgICAgIHZhciBjb25zdW1hYmxlcyA9IHRoaXMuX2NvbnN1bWFibGVzW3R5cGVdOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBpdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG5hbWUgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgaWYgKHR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiAobmFtZSA9PT0gJ2NsYXNzJyB8fCBuYW1lID09PSAnc3R5bGUnKSkgewogICAgICAgICAgICB2YXIgY29uc3VtYWJsZU5hbWUgPSBuYW1lID09ICdjbGFzcycgPyAnY2xhc3NlcycgOiAnc3R5bGVzJzsgLy8gQ2hlY2sgYWxsIGNsYXNzZXMvc3R5bGVzIGlmIGNsYXNzL3N0eWxlIGF0dHJpYnV0ZSBpcyB0ZXN0ZWQuCgogICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl90ZXN0KGNvbnN1bWFibGVOYW1lLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fY29uc3VtYWJsZXNbY29uc3VtYWJsZU5hbWVdLmtleXMoKSkpOwoKICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgX3ZhbHVlID0gY29uc3VtYWJsZXMuZ2V0KG5hbWUpOyAvLyBSZXR1cm4gbnVsbCBpZiBhdHRyaWJ1dGUgaXMgbm90IGZvdW5kLgoKCiAgICAgICAgICAgIGlmIChfdmFsdWUgPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIV92YWx1ZSkgewogICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgJiYgX2l0ZXJhdG9yNy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgY29uc3VtZXMgaXRlbXMgb2YgYSBnaXZlbiB0eXBlOiBhdHRyaWJ1dGUsIGNsYXNzIG9yIHN0eWxlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBjb25zdW1hYmxlIGl0ZW06IGBhdHRyaWJ1dGVzYCwgYGNsYXNzZXNgIG9yIGBzdHlsZXNgLgogICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGl0ZW0gQ29uc3VtYWJsZSBpdGVtIG9yIGFycmF5IG9mIGl0ZW1zLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jb25zdW1lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uc3VtZSh0eXBlLCBpdGVtKSB7CiAgICAgIHZhciBpdGVtcyA9IGlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dOwogICAgICB2YXIgY29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlc1t0eXBlXTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I4ID0gaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHsKICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXA4LnZhbHVlOwoKICAgICAgICAgIGlmICh0eXBlID09PSAnYXR0cmlidXRlcycgJiYgKG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZSA9PT0gJ3N0eWxlJykpIHsKICAgICAgICAgICAgdmFyIGNvbnN1bWFibGVOYW1lID0gbmFtZSA9PSAnY2xhc3MnID8gJ2NsYXNzZXMnIDogJ3N0eWxlcyc7IC8vIElmIGNsYXNzIG9yIHN0eWxlIGlzIHByb3ZpZGVkIGZvciBjb25zdW1wdGlvbiAtIGNvbnN1bWUgdGhlbSBhbGwuCgogICAgICAgICAgICB0aGlzLl9jb25zdW1lKGNvbnN1bWFibGVOYW1lLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fY29uc3VtYWJsZXNbY29uc3VtYWJsZU5hbWVdLmtleXMoKSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3VtYWJsZXMuc2V0KG5hbWUsIGZhbHNlKTsKCiAgICAgICAgICAgIGlmICh0eXBlID09ICdzdHlsZXMnKSB7CiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZTsKICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I5ID0gZmFsc2U7CiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yOSA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjkgPSB0aGlzLmVsZW1lbnQuZG9jdW1lbnQuc3R5bGVzUHJvY2Vzc29yLmdldFJlbGF0ZWRTdHlsZXMobmFtZSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDk7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSAoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWUpIHsKICAgICAgICAgICAgICAgICAgdmFyIHRvQ29uc3VtZSA9IF9zdGVwOS52YWx1ZTsKICAgICAgICAgICAgICAgICAgY29uc3VtYWJsZXMuc2V0KHRvQ29uc3VtZSwgZmFsc2UpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I5ID0gdHJ1ZTsKICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yOSA9IGVycjsKICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSAmJiBfaXRlcmF0b3I5LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yOS5yZXR1cm4oKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yOSkgewogICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I4LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yODsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHJldmVydHMgaXRlbXMgb2YgYSBnaXZlbiB0eXBlOiBhdHRyaWJ1dGUsIGNsYXNzIG9yIHN0eWxlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHRoZSBjb25zdW1hYmxlIGl0ZW06IGBhdHRyaWJ1dGVzYCwgYGNsYXNzZXNgIG9yICwgYHN0eWxlc2AuCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheS48U3RyaW5nPn0gaXRlbSBDb25zdW1hYmxlIGl0ZW0gb3IgYXJyYXkgb2YgaXRlbXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JldmVydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldmVydCh0eXBlLCBpdGVtKSB7CiAgICAgIHZhciBpdGVtcyA9IGlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dOwogICAgICB2YXIgY29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlc1t0eXBlXTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSAoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWUpIHsKICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXAxMC52YWx1ZTsKCiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpKSB7CiAgICAgICAgICAgIHZhciBjb25zdW1hYmxlTmFtZSA9IG5hbWUgPT0gJ2NsYXNzJyA/ICdjbGFzc2VzJyA6ICdzdHlsZXMnOyAvLyBJZiBjbGFzcyBvciBzdHlsZSBpcyBwcm92aWRlZCBmb3IgcmV2ZXJ0aW5nIC0gcmV2ZXJ0IHRoZW0gYWxsLgoKICAgICAgICAgICAgdGhpcy5fcmV2ZXJ0KGNvbnN1bWFibGVOYW1lLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fY29uc3VtYWJsZXNbY29uc3VtYWJsZU5hbWVdLmtleXMoKSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uc3VtYWJsZXMuZ2V0KG5hbWUpOwoKICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkgewogICAgICAgICAgICAgIGNvbnN1bWFibGVzLnNldChuYW1lLCB0cnVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IxMCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMTAucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEwKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfV0pOwoKICByZXR1cm4gVmlld0VsZW1lbnRDb25zdW1hYmxlczsKfSgpOw=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js"],"names":["isArray","CKEditorError","ViewConsumable","_consumables","Map","element","consumables","elementConsumables","is","set","has","ViewElementConsumables","get","add","undefined","test","consume","revert","name","attributes","classes","styles","getAttributeKeys","attribute","push","getClassNames","className","getStyleNames","style","from","instance","consumablesFromElement","getChildren","child","createFrom","_canConsumeName","type","_add","value","_test","_consume","_revert","item","items","document","stylesProcessor","getRelatedStyles","alsoName","consumableName","keys","toConsume"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/viewconsumable\n */\n\nimport { isArray } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Class used for handling consumption of view {@link module:engine/view/element~Element elements},\n * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.\n * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name\n * does not consume its attributes, classes and styles.\n * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.\n * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.\n * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.\n * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.\n *\n *\t\tviewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.\n *\t\tviewConsumable.add( textNode ); // Adds text node for consumption.\n *\t\tviewConsumable.add( docFragment ); // Adds document fragment for consumption.\n *\t\tviewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.\n *\t\tviewConsumable.test( textNode ); // Tests if text node can be consumed.\n *\t\tviewConsumable.test( docFragment ); // Tests if document fragment can be consumed.\n *\t\tviewConsumable.consume( element, { name: true }  ); // Consume element's name.\n *\t\tviewConsumable.consume( textNode ); // Consume text node.\n *\t\tviewConsumable.consume( docFragment ); // Consume document fragment.\n *\t\tviewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.\n *\t\tviewConsumable.revert( textNode ); // Revert already consumed text node.\n *\t\tviewConsumable.revert( docFragment ); // Revert already consumed document fragment.\n */\nexport default class ViewConsumable {\n\t/**\n\t * Creates new ViewConsumable.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,\n\t\t * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.\n\t\t * For {@link module:engine/view/text~Text text nodes} and\n\t\t * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}\n\t\t*/\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.\n\t *\n\t *\t\tviewConsumable.add( p, { name: true } ); // Adds element's name to consume.\n\t *\t\tviewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.\n\t *\t\tviewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // Adds element's style\n\t *\t\tviewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.\n\t *\t\tviewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.\n\t *\t\tviewConsumable.add( textNode ); // Adds text node to consume.\n\t *\t\tviewConsumable.add( docFragment ); // Adds document fragment to consume.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing actual style/class.\n\t *\n\t *\t\tviewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.\n\t *\t\tviewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\tadd( element, consumables ) {\n\t\tlet elementConsumables;\n\n\t\t// For text nodes and document fragments just mark them as consumable.\n\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\tthis._consumables.set( element, true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// For elements create new ViewElementConsumables or update already existing one.\n\t\tif ( !this._consumables.has( element ) ) {\n\t\t\telementConsumables = new ViewElementConsumables( element );\n\t\t\tthis._consumables.set( element, elementConsumables );\n\t\t} else {\n\t\t\telementConsumables = this._consumables.get( element );\n\t\t}\n\n\t\telementConsumables.add( consumables );\n\t}\n\n\t/**\n\t * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.\n\t * It returns `true` when all items included in method's call can be consumed. Returns `false` when\n\t * first already consumed item is found and `null` when first non-consumable item is found.\n\t *\n\t *\t\tviewConsumable.test( p, { name: true } ); // Tests element's name.\n\t *\t\tviewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.\n\t *\t\tviewConsumable.test( p, { classes: 'foobar' } ); // Tests class.\n\t *\t\tviewConsumable.test( p, { styles: 'color' } ); // Tests style.\n\t *\t\tviewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.\n\t *\t\tviewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.\n\t *\t\tviewConsumable.test( textNode ); // Tests text node.\n\t *\t\tviewConsumable.test( docFragment ); // Tests document fragment.\n\t *\n\t * Testing classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.\n\t *\t\tviewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`\n\t * when first already consumed item is found and `null` when first non-consumable item is found.\n\t */\n\ttest( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// For text nodes and document fragments return stored boolean value.\n\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\treturn elementConsumables;\n\t\t}\n\n\t\t// For elements test consumables object.\n\t\treturn elementConsumables.test( consumables );\n\t}\n\n\t/**\n\t * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.\n\t *\n\t *\t\tviewConsumable.consume( p, { name: true } ); // Consumes element's name.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.\n\t *\t\tviewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.\n\t *\t\tviewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.\n\t *\t\tviewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.\n\t *\t\tviewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.\n\t *\t\tviewConsumable.consume( textNode ); // Consumes text node.\n\t *\t\tviewConsumable.consume( docFragment ); // Consumes document fragment.\n\t *\n\t * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.\n\t *\n\t *\t\tviewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.\n\t *\t\tviewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,\n\t * otherwise returns `false`.\n\t */\n\tconsume( element, consumables ) {\n\t\tif ( this.test( element, consumables ) ) {\n\t\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments set value to false.\n\t\t\t\tthis._consumables.set( element, false );\n\t\t\t} else {\n\t\t\t\t// For elements - consume consumables object.\n\t\t\t\tthis._consumables.get( element ).consume( consumables );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.\n\t * Method does not revert items that were never previously added for consumption, even if they are included in\n\t * method's call.\n\t *\n\t *\t\tviewConsumable.revert( p, { name: true } ); // Reverts element's name.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.\n\t *\t\tviewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.\n\t *\t\tviewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.\n\t *\t\tviewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.\n\t *\t\tviewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.\n\t *\t\tviewConsumable.revert( textNode ); // Reverts text node.\n\t *\t\tviewConsumable.revert( docFragment ); // Reverts document fragment.\n\t *\n\t * Reverting classes and styles as attribute will revert all classes/styles that were previously added for\n\t * consumption.\n\t *\n\t *\t\tviewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.\n\t *\t\tviewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element\n\t * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.\n\t * @param {Boolean} consumables.name If set to true element's name will be included.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names.\n\t */\n\trevert( element, consumables ) {\n\t\tconst elementConsumables = this._consumables.get( element );\n\n\t\tif ( elementConsumables !== undefined ) {\n\t\t\tif ( element.is( 'text' ) || element.is( 'documentFragment' ) ) {\n\t\t\t\t// For text nodes and document fragments - set consumable to true.\n\t\t\t\tthis._consumables.set( element, true );\n\t\t\t} else {\n\t\t\t\t// For elements - revert items from consumables object.\n\t\t\t\telementConsumables.revert( consumables );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include\n\t * element's name and all its attributes, classes and styles.\n\t *\n\t * @static\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Object} consumables\n\t */\n\tstatic consumablesFromElement( element ) {\n\t\tconst consumables = {\n\t\t\telement,\n\t\t\tname: true,\n\t\t\tattributes: [],\n\t\t\tclasses: [],\n\t\t\tstyles: []\n\t\t};\n\n\t\tconst attributes = element.getAttributeKeys();\n\n\t\tfor ( const attribute of attributes ) {\n\t\t\t// Skip classes and styles - will be added separately.\n\t\t\tif ( attribute == 'style' || attribute == 'class' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconsumables.attributes.push( attribute );\n\t\t}\n\n\t\tconst classes = element.getClassNames();\n\n\t\tfor ( const className of classes ) {\n\t\t\tconsumables.classes.push( className );\n\t\t}\n\n\t\tconst styles = element.getStyleNames();\n\n\t\tfor ( const style of styles ) {\n\t\t\tconsumables.styles.push( style );\n\t\t}\n\n\t\treturn consumables;\n\t}\n\n\t/**\n\t * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from\n\t * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.\n\t * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.\n\t *\n\t * @static\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewConsumable` will be created.\n\t * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used\n\t * to add all consumables. It will be returned instead of a new instance.\n\t */\n\tstatic createFrom( from, instance ) {\n\t\tif ( !instance ) {\n\t\t\tinstance = new ViewConsumable( from );\n\t\t}\n\n\t\tif ( from.is( 'text' ) ) {\n\t\t\tinstance.add( from );\n\n\t\t\treturn instance;\n\t\t}\n\n\t\t// Add `from` itself, if it is an element.\n\t\tif ( from.is( 'element' ) ) {\n\t\t\tinstance.add( from, ViewConsumable.consumablesFromElement( from ) );\n\t\t}\n\n\t\tif ( from.is( 'documentFragment' ) ) {\n\t\t\tinstance.add( from );\n\t\t}\n\n\t\tfor ( const child of from.getChildren() ) {\n\t\t\tinstance = ViewConsumable.createFrom( child, instance );\n\t\t}\n\n\t\treturn instance;\n\t}\n}\n\n/**\n * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.\n * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.\n *\n * @private\n */\nclass ViewElementConsumables {\n\t/**\n\t * Creates ViewElementConsumables instance.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment\n\t * from which `ViewElementConsumables` is being created.\n\t */\n\tconstructor( from ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}\n\t\t */\n\t\tthis.element = from;\n\n\t\t/**\n\t\t * Flag indicating if name of the element can be consumed.\n\t\t *\n\t\t * @private\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis._canConsumeName = null;\n\n\t\t/**\n\t\t * Contains maps of element's consumables: attributes, classes and styles.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._consumables = {\n\t\t\tattributes: new Map(),\n\t\t\tstyles: new Map(),\n\t\t\tclasses: new Map()\n\t\t};\n\t}\n\n\t/**\n\t * Adds consumable parts of the {@link module:engine/view/element~Element view element}.\n\t * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and\n\t * styles still could be consumed):\n\t *\n\t *\t\tconsumables.add( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.\n\t *\n\t * @param {Object} consumables Object describing which parts of the element can be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.\n\t */\n\tadd( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._add( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.\n\t *\n\t * Element's name can be tested:\n\t *\n\t *\t\tconsumables.test( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be tested.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be tested.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.\n\t * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items\n\t * was never marked for consumption and `false` when even one of the items was already consumed.\n\t */\n\ttest( consumables ) {\n\t\t// Check if name can be consumed.\n\t\tif ( consumables.name && !this._canConsumeName ) {\n\t\t\treturn this._canConsumeName;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tconst value = this._test( type, consumables[ type ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return true only if all can be consumed.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item\n\t * is already consumed - it consumes all consumable items provided.\n\t * Element's name can be consumed:\n\t *\n\t *\t\tconsumables.consume( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be consumed.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be consumed.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.\n\t */\n\tconsume( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = false;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._consume( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.\n\t * Element's name can be reverted:\n\t *\n\t *\t\tconsumables.revert( { name: true } );\n\t *\n\t * Attributes classes and styles:\n\t *\n\t *\t\tconsumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );\n\t *\t\tconsumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );\n\t *\n\t * @param {Object} consumables Object describing which parts of the element should be reverted.\n\t * @param {Boolean} consumables.name If set to `true` element's name will be reverted.\n\t * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.\n\t * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.\n\t * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.\n\t */\n\trevert( consumables ) {\n\t\tif ( consumables.name ) {\n\t\t\tthis._canConsumeName = true;\n\t\t}\n\n\t\tfor ( const type in this._consumables ) {\n\t\t\tif ( type in consumables ) {\n\t\t\t\tthis._revert( type, consumables[ type ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that adds consumables of a given type: attribute, class or style.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`\n\t * type is provided - it should be handled separately by providing actual style/class type.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_add( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Class and style attributes should be handled separately in\n\t\t\t\t * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.\n\t\t\t\t *\n\t\t\t\t * What you have done is trying to use:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { attributes: [ 'class', 'style' ] } );\n\t\t\t\t *\n\t\t\t\t * While each class and style should be registered separately:\n\t\t\t\t *\n\t\t\t\t *\t\tconsumables.add( { classes: 'some-class', styles: 'font-weight' } );\n\t\t\t\t *\n\t\t\t\t * @error viewconsumable-invalid-attribute\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'viewconsumable-invalid-attribute: Classes and styles should be handled separately.', this );\n\t\t\t}\n\n\t\t\tconsumables.set( name, true );\n\n\t\t\tif ( type === 'styles' ) {\n\t\t\t\tfor ( const alsoName of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\tconsumables.set( alsoName, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that tests consumables of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be\n\t * consumed and `false` when one of the items is already consumed.\n\t */\n\t_test( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// Check all classes/styles if class/style attribute is tested.\n\t\t\t\tconst value = this._test( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\n\t\t\t\tif ( value !== true ) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\t\t\t\t// Return null if attribute is not found.\n\t\t\t\tif ( value === undefined ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif ( !value ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper method that consumes items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_consume( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for consumption - consume them all.\n\t\t\t\tthis._consume( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconsumables.set( name, false );\n\n\t\t\t\tif ( type == 'styles' ) {\n\t\t\t\t\tfor ( const toConsume of this.element.document.stylesProcessor.getRelatedStyles( name ) ) {\n\t\t\t\t\t\tconsumables.set( toConsume, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper method that reverts items of a given type: attribute, class or style.\n\t *\n\t * @private\n\t * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.\n\t * @param {String|Array.<String>} item Consumable item or array of items.\n\t */\n\t_revert( type, item ) {\n\t\tconst items = isArray( item ) ? item : [ item ];\n\t\tconst consumables = this._consumables[ type ];\n\n\t\tfor ( const name of items ) {\n\t\t\tif ( type === 'attributes' && ( name === 'class' || name === 'style' ) ) {\n\t\t\t\tconst consumableName = name == 'class' ? 'classes' : 'styles';\n\n\t\t\t\t// If class or style is provided for reverting - revert them all.\n\t\t\t\tthis._revert( consumableName, [ ...this._consumables[ consumableName ].keys() ] );\n\t\t\t} else {\n\t\t\t\tconst value = consumables.get( name );\n\n\t\t\t\tif ( value === false ) {\n\t\t\t\t\tconsumables.set( name, true );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}]}