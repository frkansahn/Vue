{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\conversion.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\conversion.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7Cgp2YXIgX21hcmtlZCA9Ci8qI19fUFVSRV9fKi8KcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoX2dldEFsbFVwY2FzdERlZmluaXRpb25zKSwKICAgIF9tYXJrZWQyID0KLyojX19QVVJFX18qLwpyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhfZ2V0VXBjYXN0RGVmaW5pdGlvbik7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbgogKi8KaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBVcGNhc3RIZWxwZXJzIGZyb20gJy4vdXBjYXN0aGVscGVycyc7CmltcG9ydCBEb3duY2FzdEhlbHBlcnMgZnJvbSAnLi9kb3duY2FzdGhlbHBlcnMnOwovKioKICogQSB1dGlsaXR5IGNsYXNzIHRoYXQgaGVscHMgYWRkIGNvbnZlcnRlcnMgdG8gdXBjYXN0IGFuZCBkb3duY2FzdCBkaXNwYXRjaGVycy4KICoKICogV2UgcmVjb21tZW5kIHJlYWRpbmcgdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUgRWRpdGluZyBlbmdpbmUgYXJjaGl0ZWN0dXJlfSBndWlkZSBmaXJzdCB0bwogKiB1bmRlcnN0YW5kIHRoZSBjb3JlIGNvbmNlcHRzIG9mIHRoZSBjb252ZXJzaW9uIG1lY2hhbmlzbXMuCiAqCiAqIEFuIGluc3RhbmNlIG9mIHRoZSBjb252ZXJzaW9uIG1hbmFnZXIgaXMgYXZhaWxhYmxlIGluIHRoZQogKiB7QGxpbmsgbW9kdWxlOmNvcmUvZWRpdG9yL2VkaXRvcn5FZGl0b3IjY29udmVyc2lvbiBgZWRpdG9yLmNvbnZlcnNpb25gfSBwcm9wZXJ0eQogKiBhbmQgYnkgZGVmYXVsdCBoYXMgdGhlIGZvbGxvd2luZyBncm91cHMgb2YgZGlzcGF0Y2hlcnMgKGkuZS4gZGlyZWN0aW9ucyBvZiBjb252ZXJzaW9uKToKICoKICogKiBgZG93bmNhc3RgIChlZGl0aW5nIGFuZCBkYXRhIGRvd25jYXN0cykKICogKiBgZWRpdGluZ0Rvd25jYXN0YAogKiAqIGBkYXRhRG93bmNhc3RgCiAqICogYHVwY2FzdGAKICoKICogIyBPbmUtd2F5IGNvbnZlcnRlcnMKICoKICogVG8gYWRkIGEgY29udmVydGVyIHRvIGEgc3BlY2lmaWMgZ3JvdXAsIHVzZSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBmb3IoKWB9CiAqIG1ldGhvZDoKICoKICoJCS8vIEFkZCBhIGNvbnZlcnRlciB0byBlZGl0aW5nIGRvd25jYXN0IGFuZCBkYXRhIGRvd25jYXN0LgogKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggY29uZmlnICkgKTsKICoKICoJCS8vIEFkZCBhIGNvbnZlcnRlciB0byB0aGUgZGF0YSBwaXBlcGxpbmUgb25seToKICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2RhdGFEb3duY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCBkYXRhQ29udmVyc2lvbkNvbmZpZyApICk7CiAqCiAqCQkvLyBBbmQgYSBzbGlnaHRseSBkaWZmZXJlbnQgb25lIGZvciB0aGUgZWRpdGluZyBwaXBlbGluZToKICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2VkaXRpbmdEb3duY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCBlZGl0aW5nQ29udmVyc2lvbkNvbmZpZyApICk7CiAqCiAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNmb3IgYGZvcigpYH0gbWV0aG9kIGRvY3VtZW50YXRpb24gdG8gbGVhcm4gbW9yZSBhYm91dAogKiBhdmFpbGFibGUgY29udmVyc2lvbiBoZWxwZXJzIGFuZCBob3cgdG8gdXNlIHlvdXIgY3VzdG9tIG9uZXMuCiAqCiAqICMgVHdvLXdheSBjb252ZXJ0ZXJzCiAqCiAqIEJlc2lkZXMgdXNpbmcgb25lLXdheSBjb252ZXJ0ZXJzIHZpYSB0aGUgYGZvcigpYCBtZXRob2QsIHlvdSBjYW4gYWxzbyB1c2Ugb3RoZXIgbWV0aG9kcyBhdmFpbGFibGUgaW4gdGhpcwogKiBjbGFzcyB0byBhZGQgdHdvLXdheSBjb252ZXJ0ZXJzICh1cGNhc3QgYW5kIGRvd25jYXN0KToKICoKICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNlbGVtZW50VG9FbGVtZW50IGBlbGVtZW50VG9FbGVtZW50KClgfSAmbmRhc2g7CiAqIE1vZGVsIGVsZW1lbnQgdG8gdmlldyBlbGVtZW50IGFuZCB2aWNlIHZlcnNhLgogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvRWxlbWVudCBgYXR0cmlidXRlVG9FbGVtZW50KClgfSAmbmRhc2g7CiAqIE1vZGVsIGF0dHJpYnV0ZSB0byB2aWV3IGVsZW1lbnQgYW5kIHZpY2UgdmVyc2EuCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jYXR0cmlidXRlVG9BdHRyaWJ1dGUgYGF0dHJpYnV0ZVRvQXR0cmlidXRlKClgfSAmbmRhc2g7CiAqIE1vZGVsIGF0dHJpYnV0ZSB0byB2aWV3IGVsZW1lbnQgYW5kIHZpY2UgdmVyc2EuCiAqLwoKdmFyIENvbnZlcnNpb24gPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IGNvbnZlcnNpb24gaW5zdGFuY2UuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfAogICAqIEFycmF5Ljxtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcj59IGRvd25jYXN0RGlzcGF0Y2hlcnMKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ8CiAgICogQXJyYXkuPG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXI+fSB1cGNhc3REaXNwYXRjaGVycwogICAqLwogIGZ1bmN0aW9uIENvbnZlcnNpb24oZG93bmNhc3REaXNwYXRjaGVycywgdXBjYXN0RGlzcGF0Y2hlcnMpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252ZXJzaW9uKTsKCiAgICAvKioKICAgICAqIE1hcHMgZGlzcGF0Y2hlcnMgZ3JvdXAgbmFtZSB0byBDb252ZXJzaW9uSGVscGVycyBpbnN0YW5jZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcC48U3RyaW5nLG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9uaGVscGVyc35Db252ZXJzaW9uSGVscGVycz59CiAgICAgKi8KICAgIHRoaXMuX2hlbHBlcnMgPSBuZXcgTWFwKCk7IC8vIERlZmluZSBkZWZhdWx0ICdkb3duY2FzdCcgJiAndXBjYXN0JyBkaXNwYXRjaGVycyBncm91cHMuIFRob3NlIGdyb3VwcyBhcmUgYWx3YXlzIGF2YWlsYWJsZSBhcyB0d28td2F5IGNvbnZlcnRlcnMgbmVlZHMgdGhlbS4KCiAgICB0aGlzLl9kb3duY2FzdCA9IEFycmF5LmlzQXJyYXkoZG93bmNhc3REaXNwYXRjaGVycykgPyBkb3duY2FzdERpc3BhdGNoZXJzIDogW2Rvd25jYXN0RGlzcGF0Y2hlcnNdOwoKICAgIHRoaXMuX2NyZWF0ZUNvbnZlcnNpb25IZWxwZXJzKHsKICAgICAgbmFtZTogJ2Rvd25jYXN0JywKICAgICAgZGlzcGF0Y2hlcnM6IHRoaXMuX2Rvd25jYXN0LAogICAgICBpc0Rvd25jYXN0OiB0cnVlCiAgICB9KTsKCiAgICB0aGlzLl91cGNhc3QgPSBBcnJheS5pc0FycmF5KHVwY2FzdERpc3BhdGNoZXJzKSA/IHVwY2FzdERpc3BhdGNoZXJzIDogW3VwY2FzdERpc3BhdGNoZXJzXTsKCiAgICB0aGlzLl9jcmVhdGVDb252ZXJzaW9uSGVscGVycyh7CiAgICAgIG5hbWU6ICd1cGNhc3QnLAogICAgICBkaXNwYXRjaGVyczogdGhpcy5fdXBjYXN0LAogICAgICBpc0Rvd25jYXN0OiBmYWxzZQogICAgfSk7CiAgfQogIC8qKgogICAqIERlZmluZSBhbiBhbGlhcyBmb3IgcmVnaXN0ZXJlZCBkaXNwYXRjaGVyLgogICAqCiAgICoJCWNvbnN0IGNvbnZlcnNpb24gPSBuZXcgQ29udmVyc2lvbigKICAgKgkJCVsgZGF0YURvd25jYXN0RGlzcGF0Y2hlciwgZWRpdGluZ0Rvd25jYXN0RGlzcGF0Y2hlciBdLAogICAqCQkJdXBjYXN0RGlzcGF0Y2hlcgogICAqCQkpOwogICAqCiAgICoJCWNvbnZlcnNpb24uYWRkQWxpYXMoICdkYXRhRG93bmNhc3QnLCBkYXRhRG93bmNhc3REaXNwYXRjaGVyICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gYWxpYXMgQW4gYWxpYXMgb2YgYSBkaXNwYXRjaGVyLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ8CiAgICogbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcn0gZGlzcGF0Y2hlciBEaXNwYXRjaGVyIHdoaWNoIHNob3VsZCBoYXZlIGFuIGFsaWFzLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKENvbnZlcnNpb24sIFt7CiAgICBrZXk6ICJhZGRBbGlhcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQWxpYXMoYWxpYXMsIGRpc3BhdGNoZXIpIHsKICAgICAgdmFyIGlzRG93bmNhc3QgPSB0aGlzLl9kb3duY2FzdC5pbmNsdWRlcyhkaXNwYXRjaGVyKTsKCiAgICAgIHZhciBpc1VwY2FzdCA9IHRoaXMuX3VwY2FzdC5pbmNsdWRlcyhkaXNwYXRjaGVyKTsKCiAgICAgIGlmICghaXNVcGNhc3QgJiYgIWlzRG93bmNhc3QpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUcnlpbmcgdG8gcmVnaXN0ZXIgYW5kIGFsaWFzIGZvciBhIGRpc3BhdGNoZXIgdGhhdCBuYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBjb252ZXJzaW9uLWFkZC1hbGlhcy1kaXNwYXRjaGVyLW5vdC1yZWdpc3RlcmVkCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2NvbnZlcnNpb24tYWRkLWFsaWFzLWRpc3BhdGNoZXItbm90LXJlZ2lzdGVyZWQ6ICcgKyAnVHJ5aW5nIHRvIHJlZ2lzdGVyIGFuZCBhbGlhcyBmb3IgYSBkaXNwYXRjaGVyIHRoYXQgbmFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHRoaXMuX2NyZWF0ZUNvbnZlcnNpb25IZWxwZXJzKHsKICAgICAgICBuYW1lOiBhbGlhcywKICAgICAgICBkaXNwYXRjaGVyczogW2Rpc3BhdGNoZXJdLAogICAgICAgIGlzRG93bmNhc3Q6IGlzRG93bmNhc3QKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIEFQSSB0byBhc3NpZ24gY29udmVydGVycyB0byBjb252ZXJzaW9uIGRpc3BhdGNoZXJzIGdyb3VwLgogICAgICoKICAgICAqIElmIHRoZSBnaXZlbiBncm91cCBuYW1lIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLCB0aGUKICAgICAqIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIGBjb252ZXJzaW9uLWZvci11bmtub3duLWdyb3VwYCBlcnJvcn0gaXMgdGhyb3duLgogICAgICoKICAgICAqIFlvdSBjYW4gdXNlIGNvbnZlcnNpb24gaGVscGVycyBhdmFpbGFibGUgZGlyZWN0bHkgaW4gdGhlIGBmb3IoKWAgY2hhaW4gb3IgeW91ciBjdXN0b20gb25lcyB2aWEKICAgICAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25oZWxwZXJzfkNvbnZlcnNpb25IZWxwZXJzI2FkZCBgYWRkKClgfSBtZXRob2QuCiAgICAgKgogICAgICogIyBVc2luZyBidWxpdC1pbiBjb252ZXJzaW9uIGhlbHBlcnMKICAgICAqCiAgICAgKiBUaGUgYGZvcigpYCBjaGFpbiBjb21lcyB3aXRoIGEgc2V0IG9mIGNvbnZlcnNpb24gaGVscGVycyB3aGljaCB5b3UgY2FuIHVzZSBsaWtlIHRoaXM6CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApCiAgICAgKgkJCS5lbGVtZW50VG9FbGVtZW50KCBjb25maWcxICkgICAgICAgIC8vIEFkZHMgYW4gZWxlbWVudC10by1lbGVtZW50IGRvd25jYXN0IGNvbnZlcnRlci4KICAgICAqCQkJLmF0dHJpYnV0ZVRvRWxlbWVudCggY29uZmlnMiApOyAgICAgLy8gQWRkcyBhbiBhdHRyaWJ1dGUtdG8tZWxlbWVudCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKQogICAgICoJCQkuZWxlbWVudFRvQXR0cmlidXRlKCBjb25maWczICk7ICAgICAvLyBBZGRzIGFuIGVsZW1lbnQtdG8tYXR0cmlidXRlIHVwY2FzdCBjb252ZXJ0ZXIuCiAgICAgKgogICAgICogUmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb2YgYnVpbHQtaW4gY29udmVyc2lvbiBoZWxwZXJzIHRvIGxlYXJuIGFib3V0IHRoZWlyIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4KICAgICAqCiAgICAgKiAqIGRvd25jYXN0IChtb2RlbC10by12aWV3KSBjb252ZXJzaW9uIGhlbHBlcnM6CiAgICAgKgogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjZWxlbWVudFRvRWxlbWVudCBgZWxlbWVudFRvRWxlbWVudCgpYH0sCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCgpYH0sCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNhdHRyaWJ1dGVUb0F0dHJpYnV0ZSBgYXR0cmlidXRlVG9BdHRyaWJ1dGUoKWB9LgogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjbWFya2VyVG9FbGVtZW50IGBtYXJrZXJUb0VsZW1lbnQoKWB9LgogICAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjbWFya2VyVG9IaWdobGlnaHQgYG1hcmtlclRvSGlnaGxpZ2h0KClgfS4KICAgICAqCiAgICAgKiAqIHVwY2FzdCAodmlldy10by1tb2RlbCkgY29udmVyc2lvbiBoZWxwZXJzOgogICAgICoKICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvRWxlbWVudCBgZWxlbWVudFRvRWxlbWVudCgpYH0sCiAgICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0F0dHJpYnV0ZSBgZWxlbWVudFRvQXR0cmlidXRlKClgfSwKICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYGF0dHJpYnV0ZVRvQXR0cmlidXRlKClgfS4KICAgICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvTWFya2VyIGBlbGVtZW50VG9NYXJrZXIoKWB9LgogICAgICoKICAgICAqICMgVXNpbmcgY3VzdG9tIGNvbnZlcnNpb24gaGVscGVycwogICAgICoKICAgICAqIElmIHlvdSBuZWVkIHRvIGltcGxlbWVudCBhIG5vbnR5cGljYWwgY29udmVydGVyLCB5b3UgY2FuIGRvIHNvIGJ5IGNhbGxpbmc6CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggZGlyZWN0aW9uICkuYWRkKCBjdXN0b21IZWxwZXIgKTsKICAgICAqCiAgICAgKiBUaGUgYC5hZGQoKWAgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIHBhcmFtZXRlciwgd2hpY2ggaXMgYSBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IG9uZSBwYXJhbWV0ZXIgdGhhdAogICAgICogaXMgYSBkaXNwYXRjaGVyIGluc3RhbmNlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIGFkZCBhbiBhY3R1YWwgY29udmVydGVyIHRvIHRoZSBwYXNzZWQgZGlzcGF0Y2hlciBpbnN0YW5jZS4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYWRkKCBkaXNwYXRjaGVyID0+IHsKICAgICAqCQkJZGlzcGF0Y2hlci5vbiggJ2VsZW1lbnQ6YScsICAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICAgICAqCQkJCS8vIERvIHNvbWV0aGluZyB3aXRoIGEgdmlldyA8YT4gZWxlbWVudC4KICAgICAqCQkJfSApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcn0KICAgICAqIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9IHRvIGxlYXJuIGhvdyB0byB3cml0ZQogICAgICogY3VzdG9tIGNvbnZlcnRlcnMuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSBUaGUgbmFtZSBvZiBkaXNwYXRjaGVycyBncm91cCB0byBhZGQgdGhlIGNvbnZlcnRlcnMgdG8uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN8bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVyc30KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmb3IiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9mb3IoZ3JvdXBOYW1lKSB7CiAgICAgIGlmICghdGhpcy5faGVscGVycy5oYXMoZ3JvdXBOYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIFRyeWluZyB0byBhZGQgYSBjb252ZXJ0ZXIgdG8gYW4gdW5rbm93biBkaXNwYXRjaGVycyBncm91cC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBjb252ZXJzaW9uLWZvci11bmtub3duLWdyb3VwCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2NvbnZlcnNpb24tZm9yLXVua25vd24tZ3JvdXA6IFRyeWluZyB0byBhZGQgYSBjb252ZXJ0ZXIgdG8gYW4gdW5rbm93biBkaXNwYXRjaGVycyBncm91cC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2hlbHBlcnMuZ2V0KGdyb3VwTmFtZSk7CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgZWxlbWVudCB0byBhIHZpZXcgZWxlbWVudCAoYW5kIHZpY2UgdmVyc2EpLgogICAgICogRm9yIGV4YW1wbGUsIHRoZSBtb2RlbCBgPHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD5gIGlzIGA8cD5Gb288L3A+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKgkJLy8gQSBzaW1wbGUgY29udmVyc2lvbiBmcm9tIHRoZSBgcGFyYWdyYXBoYCBtb2RlbCBlbGVtZW50IHRvIHRoZSBgPHA+YCB2aWV3IGVsZW1lbnQgKGFuZCB2aWNlIHZlcnNhKS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7IG1vZGVsOiAncGFyYWdyYXBoJywgdmlldzogJ3AnIH0gKTsKICAgICAqCiAgICAgKgkJLy8gT3ZlcnJpZGUgb3RoZXIgY29udmVydGVycyBieSBzcGVjaWZ5aW5nIGEgY29udmVydGVyIGRlZmluaXRpb24gd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7IG1vZGVsOiAncGFyYWdyYXBoJywgdmlldzogJ2RpdicsIGNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcgfSApOwogICAgICoKICAgICAqCQkvLyBWaWV3IHNwZWNpZmllZCBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZy4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnZmFuY3lQYXJhZ3JhcGgnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAncCcsCiAgICAgKgkJCQljbGFzc2VzOiAnZmFuY3knCiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFVzZSBgdXBjYXN0QWxzb2AgdG8gZGVmaW5lIG90aGVyIHZpZXcgZWxlbWVudHMgdGhhdCBzaG91bGQgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gYSBgcGFyYWdyYXBoYCBlbGVtZW50LgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdwYXJhZ3JhcGgnLAogICAgICoJCQl2aWV3OiAncCcsCiAgICAgKgkJCXVwY2FzdEFsc286IFsKICAgICAqCQkJCSdkaXYnLAogICAgICoJCQkJewogICAgICoJCQkJCS8vIEFueSBlbGVtZW50IHdpdGggdGhlIGBkaXNwbGF5OiBibG9ja2Agc3R5bGUuCiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCWRpc3BsYXk6ICdibG9jaycKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9CiAgICAgKgkJCV0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIGB1cGNhc3RBbHNvYCBzZXQgYXMgY2FsbGJhY2sgZW5hYmxlcyBhIGNvbnZlcnNpb24gb2YgYSB3aWRlIHJhbmdlIG9mIGRpZmZlcmVudCB2aWV3IGVsZW1lbnRzLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdoZWFkaW5nJywKICAgICAqCQkJdmlldzogJ2gyJywKICAgICAqCQkJLy8gQ29udmVydCAiaGVhZGxpbmctbGlrZSIgcGFyYWdyYXBocyB0byBoZWFkaW5ncy4KICAgICAqCQkJdXBjYXN0QWxzbzogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJY29uc3QgZm9udFNpemUgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICAgICAqCiAgICAgKgkJCQlpZiAoICFmb250U2l6ZSApIHsKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0KICAgICAqCiAgICAgKgkJCQljb25zdCBtYXRjaCA9IGZvbnRTaXplLm1hdGNoKCAvKFxkKylccypweC8gKTsKICAgICAqCiAgICAgKgkJCQlpZiAoICFtYXRjaCApIHsKICAgICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCX0KICAgICAqCiAgICAgKgkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICAgKgogICAgICoJCQkJaWYgKCBzaXplID4gMjYgKSB7CiAgICAgKgkJCQkJLy8gUmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBtYXRjaGVkIHByb3BlcnRpZXMuCiAgICAgKgkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCS8vIFNlZSBgZW5naW5lLnZpZXcuTWF0Y2hlcn5NYXRjaGVyUGF0dGVybmAgYW5kIGBlbmdpbmUudmlldy5NYXRjaGVyI21hdGNoYCBmb3IgbW9yZSBkZXRhaWxzLgogICAgICoKICAgICAqCQkJCQlyZXR1cm4geyBuYW1lOiB0cnVlLCBzdHlsZXM6IFsgJ2ZvbnQtc2l6ZScgXSB9OwogICAgICoJCQkJfQogICAgICoKICAgICAqCQkJCXJldHVybiBudWxsOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIGBkZWZpbml0aW9uLm1vZGVsYCBpcyBhIGBTdHJpbmdgIHdpdGggYSBtb2RlbCBlbGVtZW50IG5hbWUgdG8gY29udmVydCBmcm9tIG9yIHRvLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSB0byBsZWFybiBhYm91dCBvdGhlciBwYXJhbWV0ZXJzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbn0gZGVmaW5pdGlvbiBUaGUgY29udmVydGVyIGRlZmluaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZWxlbWVudFRvRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudFRvRWxlbWVudChkZWZpbml0aW9uKSB7CiAgICAgIC8vIFNldCB1cCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICAgIHRoaXMuZm9yKCdkb3duY2FzdCcpLmVsZW1lbnRUb0VsZW1lbnQoZGVmaW5pdGlvbik7IC8vIFNldCB1cCB1cGNhc3QgY29udmVydGVyLgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfZ2V0QWxsVXBjYXN0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbilbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSwKICAgICAgICAgICAgICBtb2RlbCA9IF9zdGVwJHZhbHVlLm1vZGVsLAogICAgICAgICAgICAgIHZpZXcgPSBfc3RlcCR2YWx1ZS52aWV3OwogICAgICAgICAgdGhpcy5mb3IoJ3VwY2FzdCcpLmVsZW1lbnRUb0VsZW1lbnQoewogICAgICAgICAgICBtb2RlbDogbW9kZWwsCiAgICAgICAgICAgIHZpZXc6IHZpZXcsCiAgICAgICAgICAgIGNvbnZlcnRlclByaW9yaXR5OiBkZWZpbml0aW9uLmNvbnZlcnRlclByaW9yaXR5CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogU2V0cyB1cCBjb252ZXJ0ZXJzIGJldHdlZW4gdGhlIG1vZGVsIGFuZCB0aGUgdmlldyB0aGF0IGNvbnZlcnQgYSBtb2RlbCBhdHRyaWJ1dGUgdG8gYSB2aWV3IGVsZW1lbnQgKGFuZCB2aWNlIHZlcnNhKS4KICAgICAqIEZvciBleGFtcGxlLCBhIG1vZGVsIHRleHQgbm9kZSB3aXRoIGAiRm9vImAgYXMgZGF0YSBhbmQgdGhlIGBib2xkYCBhdHRyaWJ1dGUgaXMgYDxzdHJvbmc+Rm9vPC9zdHJvbmc+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKgkJLy8gQSBzaW1wbGUgY29udmVyc2lvbiBmcm9tIHRoZSBgYm9sZD10cnVlYCBhdHRyaWJ1dGUgdG8gdGhlIGA8c3Ryb25nPmAgdmlldyBlbGVtZW50IChhbmQgdmljZSB2ZXJzYSkuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9FbGVtZW50KCB7IG1vZGVsOiAnYm9sZCcsIHZpZXc6ICdzdHJvbmcnIH0gKTsKICAgICAqCiAgICAgKgkJLy8gT3ZlcnJpZGUgb3RoZXIgY29udmVydGVycyBieSBzcGVjaWZ5aW5nIGEgY29udmVydGVyIGRlZmluaXRpb24gd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsgbW9kZWw6ICdib2xkJywgdmlldzogJ2InLCBjb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnIH0gKTsKICAgICAqCiAgICAgKgkJLy8gVmlldyBzcGVjaWZpZWQgYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCWNsYXNzZXM6ICdib2xkJwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBVc2UgYGNvbmZpZy5tb2RlbC5uYW1lYCB0byBkZWZpbmUgdGhlIGNvbnZlcnNpb24gb25seSBmcm9tIGEgZ2l2ZW4gbm9kZSB0eXBlLCBgJHRleHRgIGluIHRoaXMgY2FzZS4KICAgICAqCQkvLyBUaGUgc2FtZSBhdHRyaWJ1dGUgb24gZGlmZmVyZW50IGVsZW1lbnRzIG1heSB0aGVuIGJlIGhhbmRsZWQgYnkgYSBkaWZmZXJlbnQgY29udmVydGVyLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAndGV4dERlY29yYXRpb24nLAogICAgICoJCQkJdmFsdWVzOiBbICd1bmRlcmxpbmUnLCAnbGluZVRocm91Z2gnIF0sCiAgICAgKgkJCQluYW1lOiAnJHRleHQnCiAgICAgKgkJCX0sCiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCXVuZGVybGluZTogewogICAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQkJJ3RleHQtZGVjb3JhdGlvbic6ICd1bmRlcmxpbmUnCiAgICAgKgkJCQkJfQogICAgICoJCQkJfSwKICAgICAqCQkJCWxpbmVUaHJvdWdoOiB7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQkndGV4dC1kZWNvcmF0aW9uJzogJ2xpbmUtdGhyb3VnaCcKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIFVzZSBgdXBjYXN0QWxzb2AgdG8gZGVmaW5lIG90aGVyIHZpZXcgZWxlbWVudHMgdGhhdCBzaG91bGQgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gdGhlIGBib2xkYCBhdHRyaWJ1dGUuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6ICdzdHJvbmcnLAogICAgICoJCQl1cGNhc3RBbHNvOiBbCiAgICAgKgkJCQknYicsCiAgICAgKgkJCQl7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCWNsYXNzZXM6ICdib2xkJwogICAgICoJCQkJfSwKICAgICAqCQkJCXsKICAgICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCSdmb250LXdlaWdodCc6ICdib2xkJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0sCiAgICAgKgkJCQl2aWV3RWxlbWVudCA9PiB7CiAgICAgKgkJCQkJY29uc3QgZm9udFdlaWdodCA9IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnZm9udC13ZWlnaHQnICk7CiAgICAgKgogICAgICoJCQkJCWlmICggdmlld0VsZW1lbnQuaXMoICdzcGFuJyApICYmIGZvbnRXZWlnaHQgJiYgL1xkKy8udGVzdCgpICYmIE51bWJlciggZm9udFdlaWdodCApID4gNTAwICkgewogICAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgICAqCQkJCQkJLy8gVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlICJjb25zdW1lZCIgZHVyaW5nIHRoZSBjb252ZXJzaW9uLgogICAgICoJCQkJCQkvLyBTZWUgYGVuZ2luZS52aWV3Lk1hdGNoZXJ+TWF0Y2hlclBhdHRlcm5gIGFuZCBgZW5naW5lLnZpZXcuTWF0Y2hlciNtYXRjaGAgZm9yIG1vcmUgZGV0YWlscy4KICAgICAqCiAgICAgKgkJCQkJCXJldHVybiB7CiAgICAgKgkJCQkJCQluYW1lOiB0cnVlLAogICAgICoJCQkJCQkJc3R5bGVzOiBbICdmb250LXdlaWdodCcgXQogICAgICoJCQkJCQl9OwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJXQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gQ29udmVyc2lvbiBmcm9tIGFuZCB0byBhIG1vZGVsIGF0dHJpYnV0ZSBrZXkgd2hvc2UgdmFsdWUgaXMgYW4gZW51bSAoYGZvbnRTaXplPWJpZ3xzbWFsbGApLgogICAgICoJCS8vIGB1cGNhc3RBbHNvYCBzZXQgYXMgY2FsbGJhY2sgZW5hYmxlcyBhIGNvbnZlcnNpb24gb2YgYSB3aWRlIHJhbmdlIG9mIGRpZmZlcmVudCB2aWV3IGVsZW1lbnRzLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJa2V5OiAnZm9udFNpemUnLAogICAgICoJCQkJdmFsdWVzOiBbICdiaWcnLCAnc21hbGwnIF0KICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogewogICAgICoJCQkJYmlnOiB7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQknZm9udC1zaXplJzogJzEuMmVtJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0sCiAgICAgKgkJCQlzbWFsbDogewogICAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgICAqCQkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQkJJ2ZvbnQtc2l6ZSc6ICcwLjhlbScKICAgICAqCQkJCQl9CiAgICAgKgkJCQl9CiAgICAgKgkJCX0sCiAgICAgKgkJCXVwY2FzdEFsc286IHsKICAgICAqCQkJCWJpZzogdmlld0VsZW1lbnQgPT4gewogICAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICAgKgogICAgICoJCQkJCWlmICggIWZvbnRTaXplICkgewogICAgICoJCQkJCQlyZXR1cm4gbnVsbDsKICAgICAqCQkJCQl9CiAgICAgKgogICAgICoJCQkJCWNvbnN0IG1hdGNoID0gZm9udFNpemUubWF0Y2goIC8oXGQrKVxzKnB4LyApOwogICAgICoKICAgICAqCQkJCQlpZiAoICFtYXRjaCApIHsKICAgICAqCQkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICAgKgogICAgICoJCQkJCWlmICggdmlld0VsZW1lbnQuaXMoICdzcGFuJyApICYmIHNpemUgPiAxMCApIHsKICAgICAqCQkJCQkJLy8gUmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBtYXRjaGVkIHByb3BlcnRpZXMuCiAgICAgKgkJCQkJCS8vIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSAiY29uc3VtZWQiIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgICAqCQkJCQkJLy8gU2VlIGBlbmdpbmUudmlldy5NYXRjaGVyfk1hdGNoZXJQYXR0ZXJuYCBhbmQgYGVuZ2luZS52aWV3Lk1hdGNoZXIjbWF0Y2hgIGZvciBtb3JlIGRldGFpbHMuCiAgICAgKgogICAgICoJCQkJCQlyZXR1cm4geyBuYW1lOiB0cnVlLCBzdHlsZXM6IFsgJ2ZvbnQtc2l6ZScgXSB9OwogICAgICoJCQkJCX0KICAgICAqCiAgICAgKgkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQl9LAogICAgICoJCQkJc21hbGw6IHZpZXdFbGVtZW50ID0+IHsKICAgICAqCQkJCQljb25zdCBmb250U2l6ZSA9IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnZm9udC1zaXplJyApOwogICAgICoKICAgICAqCQkJCQlpZiAoICFmb250U2l6ZSApIHsKICAgICAqCQkJCQkJcmV0dXJuIG51bGw7CiAgICAgKgkJCQkJfQogICAgICoKICAgICAqCQkJCQljb25zdCBtYXRjaCA9IGZvbnRTaXplLm1hdGNoKCAvKFxkKylccypweC8gKTsKICAgICAqCiAgICAgKgkJCQkJaWYgKCAhbWF0Y2ggKSB7CiAgICAgKgkJCQkJCXJldHVybiBudWxsOwogICAgICoJCQkJCX0KICAgICAqCiAgICAgKgkJCQkJY29uc3Qgc2l6ZSA9IE51bWJlciggbWF0Y2hbIDEgXSApOwogICAgICoKICAgICAqCQkJCQlpZiAoIHZpZXdFbGVtZW50LmlzKCAnc3BhbicgKSAmJiBzaXplIDwgMTAgKSB7CiAgICAgKgkJCQkJCS8vIFJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgbWF0Y2hlZCBwcm9wZXJ0aWVzLgogICAgICoJCQkJCQkvLyBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgImNvbnN1bWVkIiBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICAgKgkJCQkJCS8vIFNlZSBgZW5naW5lLnZpZXcuTWF0Y2hlcn5NYXRjaGVyUGF0dGVybmAgYW5kIGBlbmdpbmUudmlldy5NYXRjaGVyI21hdGNoYCBmb3IgbW9yZSBkZXRhaWxzLgogICAgICoKICAgICAqCQkJCQkJcmV0dXJuIHsgbmFtZTogdHJ1ZSwgc3R5bGVzOiBbICdmb250LXNpemUnIF0gfTsKICAgICAqCQkJCQl9CiAgICAgKgogICAgICoJCQkJCXJldHVybiBudWxsOwogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFRoZSBgZGVmaW5pdGlvbi5tb2RlbGAgcGFyYW1ldGVyIHNwZWNpZmllcyB3aGljaCBtb2RlbCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZCBmcm9tIG9yIHRvLiBJdCBjYW4gYmUgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdAogICAgICogZGVzY3JpYmluZyB0aGUgYXR0cmlidXRlIGtleSBhbmQgdmFsdWUgdG8gY29udmVydCBvciBhIGBTdHJpbmdgIHNwZWNpZnlpbmcganVzdCB0aGUgYXR0cmlidXRlIGtleSAodGhlbiBgdmFsdWVgIGlzIHNldCB0byBgdHJ1ZWApLgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSB0byBsZWFybiBhYm91dCBvdGhlciBwYXJhbWV0ZXJzLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVydGVyRGVmaW5pdGlvbn0gZGVmaW5pdGlvbiBUaGUgY29udmVydGVyIGRlZmluaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXR0cmlidXRlVG9FbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVUb0VsZW1lbnQoZGVmaW5pdGlvbikgewogICAgICAvLyBTZXQgdXAgZG93bmNhc3QgY29udmVydGVyLgogICAgICB0aGlzLmZvcignZG93bmNhc3QnKS5hdHRyaWJ1dGVUb0VsZW1lbnQoZGVmaW5pdGlvbik7IC8vIFNldCB1cCB1cGNhc3QgY29udmVydGVyLgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2dldEFsbFVwY2FzdERlZmluaXRpb25zKGRlZmluaXRpb24pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX3N0ZXAyJHZhbHVlID0gX3N0ZXAyLnZhbHVlLAogICAgICAgICAgICAgIG1vZGVsID0gX3N0ZXAyJHZhbHVlLm1vZGVsLAogICAgICAgICAgICAgIHZpZXcgPSBfc3RlcDIkdmFsdWUudmlldzsKICAgICAgICAgIHRoaXMuZm9yKCd1cGNhc3QnKS5lbGVtZW50VG9BdHRyaWJ1dGUoewogICAgICAgICAgICB2aWV3OiB2aWV3LAogICAgICAgICAgICBtb2RlbDogbW9kZWwsCiAgICAgICAgICAgIGNvbnZlcnRlclByaW9yaXR5OiBkZWZpbml0aW9uLmNvbnZlcnRlclByaW9yaXR5CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgYXR0cmlidXRlIHRvIGEgdmlldyBhdHRyaWJ1dGUgKGFuZCB2aWNlIHZlcnNhKS4KICAgICAqIEZvciBleGFtcGxlLCBgPGltYWdlIHNyYz0nZm9vLmpwZyc+PC9pbWFnZT5gIGlzIGNvbnZlcnRlZCB0byBgPGltZyBzcmM9J2Zvby5qcGcnPjwvaW1nPmAgKHRoZSBzYW1lIGF0dHJpYnV0ZSBrZXkgYW5kIHZhbHVlKS4KICAgICAqIFRoaXMgdHlwZSBvZiBjb252ZXJ0ZXJzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgbW9kZWwgZWxlbWVudH0gbm9kZXMuCiAgICAgKiBUbyBjb252ZXJ0IHRleHQgYXR0cmlidXRlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCBjb252ZXJ0ZXJgfQogICAgICogc2hvdWxkIGJlIHNldCB1cC4KICAgICAqCiAgICAgKgkJLy8gQSBzaW1wbGUgY29udmVyc2lvbiBmcm9tIHRoZSBgc291cmNlYCBtb2RlbCBhdHRyaWJ1dGUgdG8gdGhlIGBzcmNgIHZpZXcgYXR0cmlidXRlIChhbmQgdmljZSB2ZXJzYSkuCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsgbW9kZWw6ICdzb3VyY2UnLCB2aWV3OiAnc3JjJyB9ICk7CiAgICAgKgogICAgICoJCS8vIEF0dHJpYnV0ZSB2YWx1ZXMgYXJlIHN0cmljdGx5IHNwZWNpZmllZC4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJbmFtZTogJ2ltYWdlJywKICAgICAqCQkJCWtleTogJ2FzaWRlJywKICAgICAqCQkJCXZhbHVlczogWyAnYXNpZGUnIF0KICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogewogICAgICoJCQkJYXNpZGU6IHsKICAgICAqCQkJCQluYW1lOiAnaW1nJywKICAgICAqCQkJCQlrZXk6ICdjbGFzcycsCiAgICAgKgkJCQkJdmFsdWU6IFsgJ2FzaWRlJywgJ2hhbGYtc2l6ZScgXQogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQkvLyBTZXQgdGhlIHN0eWxlIGF0dHJpYnV0ZS4KICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJbmFtZTogJ2ltYWdlJywKICAgICAqCQkJCWtleTogJ2FzaWRlJywKICAgICAqCQkJCXZhbHVlczogWyAnYXNpZGUnIF0KICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogewogICAgICoJCQkJYXNpZGU6IHsKICAgICAqCQkJCQluYW1lOiAnaW1nJywKICAgICAqCQkJCQlrZXk6ICdzdHlsZScsCiAgICAgKgkJCQkJdmFsdWU6IHsKICAgICAqCQkJCQkJZmxvYXQ6ICdyaWdodCcsCiAgICAgKgkJCQkJCXdpZHRoOiAnNTAlJywKICAgICAqCQkJCQkJbWFyZ2luOiAnNXB4JwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gQ29udmVyc2lvbiBmcm9tIGFuZCB0byBhIG1vZGVsIGF0dHJpYnV0ZSBrZXkgd2hvc2UgdmFsdWUgaXMgYW4gZW51bSAoYGFsaWduPXJpZ2h0fGNlbnRlcmApLgogICAgICoJCS8vIFVzZSBgdXBjYXN0QWxzb2AgdG8gZGVmaW5lIG90aGVyIHZpZXcgZWxlbWVudHMgdGhhdCBzaG91bGQgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gdGhlIGBhbGlnbj1yaWdodGAgYXR0cmlidXRlLgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdhbGlnbicsCiAgICAgKgkJCQl2YWx1ZXM6IFsgJ3JpZ2h0JywgJ2NlbnRlcicgXQogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQlyaWdodDogewogICAgICoJCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCQl2YWx1ZTogJ2FsaWduLXJpZ2h0JwogICAgICoJCQkJfSwKICAgICAqCQkJCWNlbnRlcjogewogICAgICoJCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCQl2YWx1ZTogJ2FsaWduLWNlbnRlcicKICAgICAqCQkJCX0KICAgICAqCQkJfSwKICAgICAqCQkJdXBjYXN0QWxzbzogewogICAgICoJCQkJcmlnaHQ6IHsKICAgICAqCQkJCQlzdHlsZXM6IHsKICAgICAqCQkJCQkJJ3RleHQtYWxpZ24nOiAncmlnaHQnCiAgICAgKgkJCQkJfQogICAgICoJCQkJfSwKICAgICAqCQkJCWNlbnRlcjogewogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQkndGV4dC1hbGlnbic6ICdjZW50ZXInCiAgICAgKgkJCQkJfQogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFRoZSBgZGVmaW5pdGlvbi5tb2RlbGAgcGFyYW1ldGVyIHNwZWNpZmllcyB3aGljaCBtb2RlbCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZCBmcm9tIGFuZCB0by4KICAgICAqIEl0IGNhbiBiZSBhIGB7IGtleSwgWyB2YWx1ZXMgXSwgWyBuYW1lIF0gfWAgb2JqZWN0IG9yIGEgYFN0cmluZ2AsIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBsaWtlIGB7IGtleTogZGVmaW5pdGlvbi5tb2RlbCB9YC4KICAgICAqIFRoZSBga2V5YCBwcm9wZXJ0eSBpcyB0aGUgbW9kZWwgYXR0cmlidXRlIGtleSB0byBjb252ZXJ0IGZyb20gYW5kIHRvLgogICAgICogVGhlIGB2YWx1ZXNgIGFyZSB0aGUgcG9zc2libGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlcy4gSWYgYHZhbHVlc2AgaXMgbm90IHNldCwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZQogICAgICogdmlldyBhdHRyaWJ1dGUgdmFsdWUuCiAgICAgKiBJZiBgbmFtZWAgaXMgc2V0LCB0aGUgY29udmVyc2lvbiB3aWxsIGJlIHNldCB1cCBvbmx5IGZvciBtb2RlbCBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLgogICAgICoKICAgICAqIFRoZSBgZGVmaW5pdGlvbi52aWV3YCBwYXJhbWV0ZXIgc3BlY2lmaWVzIHdoaWNoIHZpZXcgYXR0cmlidXRlIHNob3VsZCBiZSBjb252ZXJ0ZWQgZnJvbSBhbmQgdG8uCiAgICAgKiBJdCBjYW4gYmUgYSBgeyBrZXksIHZhbHVlLCBbIG5hbWUgXSB9YCBvYmplY3Qgb3IgYSBgU3RyaW5nYCwgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGxpa2UgYHsga2V5OiBkZWZpbml0aW9uLnZpZXcgfWAuCiAgICAgKiBUaGUgYGtleWAgcHJvcGVydHkgaXMgdGhlIHZpZXcgYXR0cmlidXRlIGtleSB0byBjb252ZXJ0IGZyb20gYW5kIHRvLgogICAgICogVGhlIGB2YWx1ZWAgaXMgdGhlIHZpZXcgYXR0cmlidXRlIHZhbHVlIHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uIElmIGBkZWZpbml0aW9uLnZhbHVlYCBpcyBub3Qgc2V0LCB0aGUgdmlldyBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZQogICAgICogdGhlIHNhbWUgYXMgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqIElmIGBrZXlgIGlzIGAnY2xhc3MnYCwgYHZhbHVlYCBjYW4gYmUgYSBgU3RyaW5nYCBvciBhbiBhcnJheSBvZiBgU3RyaW5nYHMuCiAgICAgKiBJZiBga2V5YCBpcyBgJ3N0eWxlJ2AsIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IHdpdGgga2V5LXZhbHVlIHBhaXJzLgogICAgICogSW4gb3RoZXIgY2FzZXMsIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC4KICAgICAqIElmIGBuYW1lYCBpcyBzZXQsIHRoZSBjb252ZXJzaW9uIHdpbGwgYmUgc2V0IHVwIG9ubHkgZm9yIG1vZGVsIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIG5hbWUuCiAgICAgKiBJZiBgZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXNgIGlzIHNldCwgYGRlZmluaXRpb24udmlld2AgaXMgYW4gb2JqZWN0IHRoYXQgYXNzaWducyB2YWx1ZXMgZnJvbSBgZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXNgCiAgICAgKiB0byBgeyBrZXksIHZhbHVlLCBbIG5hbWUgXSB9YCBvYmplY3RzLgogICAgICoKICAgICAqIGBkZWZpbml0aW9uLnVwY2FzdEFsc29gIHNwZWNpZmllcyB3aGljaCBvdGhlciBtYXRjaGluZyB2aWV3IGVsZW1lbnRzIHNob3VsZCBhbHNvIGJlIHVwY2FzdCB0byB0aGUgZ2l2ZW4gbW9kZWwgY29uZmlndXJhdGlvbi4KICAgICAqIElmIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AgaXMgc2V0LCBgZGVmaW5pdGlvbi51cGNhc3RBbHNvYCBzaG91bGQgYmUgYW4gb2JqZWN0IGFzc2lnbmluZyB2YWx1ZXMgZnJvbSBgZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXNgCiAgICAgKiB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59cyBvciBhcnJheXMgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufXMuCiAgICAgKgogICAgICogKipOb3RlOioqIGBkZWZpbml0aW9uLm1vZGVsYCBhbmQgYGRlZmluaXRpb24udmlld2AgZm9ybSBzaG91bGQgYmUgbWlycm9yZWQsIHNvIHRoZSBzYW1lIHR5cGVzIG9mIHBhcmFtZXRlcnMgc2hvdWxkCiAgICAgKiBiZSBnaXZlbiBpbiBib3RoIHBhcmFtZXRlcnMuCiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gVGhlIGNvbnZlcnRlciBkZWZpbml0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkZWZpbml0aW9uLm1vZGVsIFRoZSBtb2RlbCBhdHRyaWJ1dGUgdG8gY29udmVydCBmcm9tIGFuZCB0by4KICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGVmaW5pdGlvbi52aWV3IFRoZSB2aWV3IGF0dHJpYnV0ZSB0byBjb252ZXJ0IGZyb20gYW5kIHRvLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybnxBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm4+fSBbZGVmaW5pdGlvbi51cGNhc3RBbHNvXQogICAgICogQW55IHZpZXcgZWxlbWVudCBtYXRjaGluZyBgZGVmaW5pdGlvbi51cGNhc3RBbHNvYCB3aWxsIGFsc28gYmUgY29udmVydGVkIHRvIHRoZSBnaXZlbiBtb2RlbCBhdHRyaWJ1dGUuIGBkZWZpbml0aW9uLnVwY2FzdEFsc29gCiAgICAgKiBpcyB1c2VkIG9ubHkgaWYgYGNvbmZpZy5tb2RlbC52YWx1ZXNgIGlzIHNwZWNpZmllZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhdHRyaWJ1dGVUb0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlVG9BdHRyaWJ1dGUoZGVmaW5pdGlvbikgewogICAgICAvLyBTZXQgdXAgZG93bmNhc3QgY29udmVydGVyLgogICAgICB0aGlzLmZvcignZG93bmNhc3QnKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZShkZWZpbml0aW9uKTsgLy8gU2V0IHVwIHVwY2FzdCBjb252ZXJ0ZXIuCgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfZ2V0QWxsVXBjYXN0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbilbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHsKICAgICAgICAgIHZhciBfc3RlcDMkdmFsdWUgPSBfc3RlcDMudmFsdWUsCiAgICAgICAgICAgICAgbW9kZWwgPSBfc3RlcDMkdmFsdWUubW9kZWwsCiAgICAgICAgICAgICAgdmlldyA9IF9zdGVwMyR2YWx1ZS52aWV3OwogICAgICAgICAgdGhpcy5mb3IoJ3VwY2FzdCcpLmF0dHJpYnV0ZVRvQXR0cmlidXRlKHsKICAgICAgICAgICAgdmlldzogdmlldywKICAgICAgICAgICAgbW9kZWw6IG1vZGVsCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW5kIGNhY2hlcyBjb252ZXJzaW9uIGhlbHBlcnMgZm9yIGdpdmVuIGRpc3BhdGNoZXJzIGdyb3VwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubmFtZSBHcm91cCBuYW1lLgogICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ8CiAgICAgKiBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyPn0gb3B0aW9ucy5kaXNwYXRjaGVycwogICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmlzRG93bmNhc3QKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlQ29udmVyc2lvbkhlbHBlcnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb252ZXJzaW9uSGVscGVycyhfcmVmKSB7CiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLAogICAgICAgICAgZGlzcGF0Y2hlcnMgPSBfcmVmLmRpc3BhdGNoZXJzLAogICAgICAgICAgaXNEb3duY2FzdCA9IF9yZWYuaXNEb3duY2FzdDsKCiAgICAgIGlmICh0aGlzLl9oZWxwZXJzLmhhcyhuYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIFRyeWluZyB0byByZWdpc3RlciBhIGdyb3VwIG5hbWUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgY29udmVyc2lvbi1ncm91cC1leGlzdHMKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignY29udmVyc2lvbi1ncm91cC1leGlzdHM6IFRyeWluZyB0byByZWdpc3RlciBhIGdyb3VwIG5hbWUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuJywgdGhpcyk7CiAgICAgIH0KCiAgICAgIHZhciBoZWxwZXJzID0gaXNEb3duY2FzdCA/IG5ldyBEb3duY2FzdEhlbHBlcnMoZGlzcGF0Y2hlcnMpIDogbmV3IFVwY2FzdEhlbHBlcnMoZGlzcGF0Y2hlcnMpOwoKICAgICAgdGhpcy5faGVscGVycy5zZXQobmFtZSwgaGVscGVycyk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gQ29udmVyc2lvbjsKfSgpOwovKioKICogRGVmaW5lcyBob3cgdGhlIG1vZGVsIHNob3VsZCBiZSBjb252ZXJ0ZWQgZnJvbSBhbmQgdG8gdGhlIHZpZXcuCiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnRlckRlZmluaXRpb24KICoKICogQHByb3BlcnR5IHsqfSBbbW9kZWxdIFRoZSBtb2RlbCBjb252ZXJzaW9uIGRlZmluaXRpb24uIERlc2NyaWJlcyB0aGUgbW9kZWwgZWxlbWVudCBvciBtb2RlbCBhdHRyaWJ1dGUgdG8gY29udmVydC4gVGhpcyBwYXJhbWV0ZXIgZGlmZmVycwogKiBmb3IgZGlmZmVyZW50IGZ1bmN0aW9ucyB0aGF0IGFjY2VwdCBgQ29udmVydGVyRGVmaW5pdGlvbmAuIFNlZSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGZ1bmN0aW9uIHRvIGxlYXJuIGhvdyB0byBzZXQgaXQuCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnRkZWZpbml0aW9ufkVsZW1lbnREZWZpbml0aW9ufE9iamVjdH0gdmlldyBUaGUgZGVmaW5pdGlvbiBvZiB0aGUgdmlldyBlbGVtZW50IHRvIGNvbnZlcnQgZnJvbSBhbmQKICogdG8uIElmIGBtb2RlbGAgZGVzY3JpYmVzIG11bHRpcGxlIHZhbHVlcywgYHZpZXdgIGlzIGFuIG9iamVjdCB0aGF0IGFzc2lnbnMgdGhlc2UgdmFsdWVzIChgdmlld2Agb2JqZWN0IGtleXMpIHRvIHZpZXcgZWxlbWVudCBkZWZpbml0aW9ucwogKiAoYHZpZXdgIG9iamVjdCB2YWx1ZXMpLgogKiBAcHJvcGVydHkge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufEFycmF5Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybj59IFt1cGNhc3RBbHNvXQogKiBBbnkgdmlldyBlbGVtZW50IG1hdGNoaW5nIGB1cGNhc3RBbHNvYCB3aWxsIGFsc28gYmUgY29udmVydGVkIHRvIHRoZSBtb2RlbC4gSWYgYG1vZGVsYCBkZXNjcmliZXMgbXVsdGlwbGUgdmFsdWVzLCBgdXBjYXN0QWxzb2AKICogaXMgYW4gb2JqZWN0IHRoYXQgYXNzaWducyB0aGVzZSB2YWx1ZXMgKGB1cGNhc3RBbHNvYCBvYmplY3Qga2V5cykgdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufXMKICogKGB1cGNhc3RBbHNvYCBvYmplY3QgdmFsdWVzKS4KICogQHByb3BlcnR5IHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbnZlcnRlclByaW9yaXR5XSBUaGUgY29udmVydGVyIHByaW9yaXR5LgogKi8KLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGpvaW50IGFycmF5IG91dCBvZiBhbiBpdGVtIHBhc3NlZCBpbiBgZGVmaW5pdGlvbi52aWV3YCBhbmQgaXRlbXMgcGFzc2VkIGluCi8vIGBkZWZpbml0aW9uLnVwY2FzdEFsc29gLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnRlckRlZmluaXRpb259IGRlZmluaXRpb24KLy8gQHJldHVybnMge0FycmF5fSBBcnJheSBjb250YWluaW5nIHZpZXcgZGVmaW5pdGlvbnMuCgoKZXhwb3J0IHsgQ29udmVyc2lvbiBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBfZ2V0QWxsVXBjYXN0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbikgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCwgX2RpZEl0ZXJhdG9yRXJyb3I0LCBfaXRlcmF0b3JFcnJvcjQsIF9pdGVyYXRvcjQsIF9zdGVwNCwgdmFsdWUsIG1vZGVsLCB2aWV3LCB1cGNhc3RBbHNvOwoKICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2dldEFsbFVwY2FzdERlZmluaXRpb25zJChfY29udGV4dCkgewogICAgd2hpbGUgKDEpIHsKICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIGlmICghZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXMpIHsKICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDsKICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0OwogICAgICAgICAgX2l0ZXJhdG9yNCA9IGRlZmluaXRpb24ubW9kZWwudmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgY2FzZSA2OgogICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgdmFsdWUgPSBfc3RlcDQudmFsdWU7CiAgICAgICAgICBtb2RlbCA9IHsKICAgICAgICAgICAga2V5OiBkZWZpbml0aW9uLm1vZGVsLmtleSwKICAgICAgICAgICAgdmFsdWU6IHZhbHVlCiAgICAgICAgICB9OwogICAgICAgICAgdmlldyA9IGRlZmluaXRpb24udmlld1t2YWx1ZV07CiAgICAgICAgICB1cGNhc3RBbHNvID0gZGVmaW5pdGlvbi51cGNhc3RBbHNvID8gZGVmaW5pdGlvbi51cGNhc3RBbHNvW3ZhbHVlXSA6IHVuZGVmaW5lZDsKICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKF9nZXRVcGNhc3REZWZpbml0aW9uKG1vZGVsLCB2aWV3LCB1cGNhc3RBbHNvKSwgInQwIiwgMTIpOwoKICAgICAgICBjYXNlIDEyOgogICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxNToKICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlIDE3OgogICAgICAgICAgX2NvbnRleHQucHJldiA9IDE3OwogICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFsiY2F0Y2giXSg0KTsKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBfY29udGV4dC50MTsKCiAgICAgICAgY2FzZSAyMToKICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMTsKICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMjsKCiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSAyNDoKICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNDsKCiAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjc7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKCiAgICAgICAgY2FzZSAyNzoKICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjQpOwoKICAgICAgICBjYXNlIDI4OgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyMSk7CgogICAgICAgIGNhc2UgMjk6CiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzI7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAzMToKICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKF9nZXRVcGNhc3REZWZpbml0aW9uKGRlZmluaXRpb24ubW9kZWwsIGRlZmluaXRpb24udmlldywgZGVmaW5pdGlvbi51cGNhc3RBbHNvKSwgInQyIiwgMzIpOwoKICAgICAgICBjYXNlIDMyOgogICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpOwogICAgICB9CiAgICB9CiAgfSwgX21hcmtlZCwgbnVsbCwgW1s0LCAxNywgMjEsIDI5XSwgWzIyLCwgMjQsIDI4XV0pOwp9CgpmdW5jdGlvbiBfZ2V0VXBjYXN0RGVmaW5pdGlvbihtb2RlbCwgdmlldywgdXBjYXN0QWxzbykgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSwgX2RpZEl0ZXJhdG9yRXJyb3I1LCBfaXRlcmF0b3JFcnJvcjUsIF9pdGVyYXRvcjUsIF9zdGVwNSwgdXBjYXN0QWxzb0l0ZW07CgogIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfZ2V0VXBjYXN0RGVmaW5pdGlvbiQoX2NvbnRleHQyKSB7CiAgICB3aGlsZSAoMSkgewogICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICBjYXNlIDA6CiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBtb2RlbDogbW9kZWwsCiAgICAgICAgICAgIHZpZXc6IHZpZXcKICAgICAgICAgIH07CgogICAgICAgIGNhc2UgMjoKICAgICAgICAgIGlmICghdXBjYXN0QWxzbykgewogICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMwOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICB1cGNhc3RBbHNvID0gQXJyYXkuaXNBcnJheSh1cGNhc3RBbHNvKSA/IHVwY2FzdEFsc28gOiBbdXBjYXN0QWxzb107CiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNzsKICAgICAgICAgIF9pdGVyYXRvcjUgPSB1cGNhc3RBbHNvW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgY2FzZSA5OgogICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHVwY2FzdEFsc29JdGVtID0gX3N0ZXA1LnZhbHVlOwogICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMzsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIG1vZGVsOiBtb2RlbCwKICAgICAgICAgICAgdmlldzogdXBjYXN0QWxzb0l0ZW0KICAgICAgICAgIH07CgogICAgICAgIGNhc2UgMTM6CiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxNjoKICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAxODoKICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7CiAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbImNhdGNoIl0oNyk7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gX2NvbnRleHQyLnQwOwoKICAgICAgICBjYXNlIDIyOgogICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMjsKICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjM7CgogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgMjU6CiAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1OwoKICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3I1KSB7CiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjg7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNTsKCiAgICAgICAgY2FzZSAyODoKICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI1KTsKCiAgICAgICAgY2FzZSAyOToKICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDIyKTsKCiAgICAgICAgY2FzZSAzMDoKICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgIH0KICAgIH0KICB9LCBfbWFya2VkMiwgbnVsbCwgW1s3LCAxOCwgMjIsIDMwXSwgWzIzLCwgMjUsIDI5XV0pOwp9"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js"],"names":["_getAllUpcastDefinitions","_getUpcastDefinition","CKEditorError","UpcastHelpers","DowncastHelpers","Conversion","downcastDispatchers","upcastDispatchers","_helpers","Map","_downcast","Array","isArray","_createConversionHelpers","name","dispatchers","isDowncast","_upcast","alias","dispatcher","includes","isUpcast","groupName","has","get","definition","for","elementToElement","model","view","converterPriority","attributeToElement","elementToAttribute","attributeToAttribute","helpers","set","values","value","key","upcastAlso","undefined","upcastAlsoItem"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversion\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport UpcastHelpers from './upcasthelpers';\nimport DowncastHelpers from './downcasthelpers';\n\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * An instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * # One-way converters\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).elementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );\n *\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about\n * available conversion helpers and how to use your custom ones.\n *\n * # Two-way converters\n *\n * Besides using one-way converters via the `for()` method, you can also use other methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;\n * Model attribute to view element and vice versa.\n */\nexport default class Conversion {\n\t/**\n\t * Creates a new conversion instance.\n\t *\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|\n\t * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers\n\t */\n\tconstructor( downcastDispatchers, upcastDispatchers ) {\n\t\t/**\n\t\t * Maps dispatchers group name to ConversionHelpers instances.\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}\n\t\t */\n\t\tthis._helpers = new Map();\n\n\t\t// Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.\n\t\tthis._downcast = Array.isArray( downcastDispatchers ) ? downcastDispatchers : [ downcastDispatchers ];\n\t\tthis._createConversionHelpers( { name: 'downcast', dispatchers: this._downcast, isDowncast: true } );\n\n\t\tthis._upcast = Array.isArray( upcastDispatchers ) ? upcastDispatchers : [ upcastDispatchers ];\n\t\tthis._createConversionHelpers( { name: 'upcast', dispatchers: this._upcast, isDowncast: false } );\n\t}\n\n\t/**\n\t * Define an alias for registered dispatcher.\n\t *\n\t *\t\tconst conversion = new Conversion(\n\t *\t\t\t[ dataDowncastDispatcher, editingDowncastDispatcher ],\n\t *\t\t\tupcastDispatcher\n\t *\t\t);\n\t *\n\t *\t\tconversion.addAlias( 'dataDowncast', dataDowncastDispatcher );\n\t *\n\t * @param {String} alias An alias of a dispatcher.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.\n\t */\n\taddAlias( alias, dispatcher ) {\n\t\tconst isDowncast = this._downcast.includes( dispatcher );\n\t\tconst isUpcast = this._upcast.includes( dispatcher );\n\n\t\tif ( !isUpcast && !isDowncast ) {\n\t\t\t/**\n\t\t\t * Trying to register and alias for a dispatcher that nas not been registered.\n\t\t\t *\n\t\t\t * @error conversion-add-alias-dispatcher-not-registered\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-add-alias-dispatcher-not-registered: ' +\n\t\t\t\t'Trying to register and alias for a dispatcher that nas not been registered.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tthis._createConversionHelpers( { name: alias, dispatchers: [ dispatcher ], isDowncast } );\n\t}\n\n\t/**\n\t * Provides a chainable API to assign converters to conversion dispatchers group.\n\t *\n\t * If the given group name has not been registered, the\n\t * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n\t *\n\t * You can use conversion helpers available directly in the `for()` chain or your custom ones via\n\t * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.\n\t *\n\t * # Using bulit-in conversion helpers\n\t *\n\t * The `for()` chain comes with a set of conversion helpers which you can use like this:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' )\n\t *\t\t\t.elementToElement( config1 )        // Adds an element-to-element downcast converter.\n\t *\t\t\t.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' )\n\t *\t\t\t.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.\n\t *\n\t * Refer to the documentation of built-in conversion helpers to learn about their configuration options.\n\t *\n\t * * downcast (model-to-view) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.\n\t *\n\t * * upcast (view-to-model) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.\n\t *\n\t * # Using custom conversion helpers\n\t *\n\t * If you need to implement a nontypical converter, you can do so by calling:\n\t *\n\t *\t\teditor.conversion.for( direction ).add( customHelper );\n\t *\n\t * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n\t * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n\t *\n\t * Example:\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).add( dispatcher => {\n\t *\t\t\tdispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {\n\t *\t\t\t\t// Do something with a view <a> element.\n\t *\t\t\t} );\n\t *\t\t} );\n\t *\n\t * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write\n\t * custom converters.\n\t *\n\t * @param {String} groupName The name of dispatchers group to add the converters to.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tfor( groupName ) {\n\t\tif ( !this._helpers.has( groupName ) ) {\n\t\t\t/**\n\t\t\t * Trying to add a converter to an unknown dispatchers group.\n\t\t\t *\n\t\t\t * @error conversion-for-unknown-group\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.', this );\n\t\t}\n\n\t\treturn this._helpers.get( groupName );\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n\t * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'div',\n\t *\t\t\t\t{\n\t *\t\t\t\t\t// Any element with the `display: block` style.\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\tdisplay: 'block'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: 'h2',\n\t *\t\t\t// Convert \"headling-like\" paragraphs to headings.\n\t *\t\t\tupcastAlso: viewElement => {\n\t *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\tif ( size > 26 ) {\n\t *\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * `definition.model` is a `String` with a model element name to convert from or to.\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\telementToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).elementToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToElement( {\n\t\t\t\t\tmodel,\n\t\t\t\t\tview,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n\t * For example, a model text node with `\"Foo\"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n\t *\t\t// The same attribute on different elements may then be handled by a different converter.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'textDecoration',\n\t *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tunderline: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'underline'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tlineThrough: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'line-through'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'b',\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tclasses: 'bold'\n\t *\t\t\t\t},\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tviewElement => {\n\t *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn {\n\t *\t\t\t\t\t\t\tname: true,\n\t *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n\t *\t\t\t\t\t\t};\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tbig: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size > 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size < 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n\t * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\tattributeToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).\n\t * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n\t * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.\n\t * To convert text attributes {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}\n\t * should be set up.\n\t *\n\t *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n\t *\t\teditor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );\n\t *\n\t *\t\t// Attribute values are strictly specified.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Set the style attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'style',\n\t *\t\t\t\t\tvalue: {\n\t *\t\t\t\t\t\tfloat: 'right',\n\t *\t\t\t\t\t\twidth: '50%',\n\t *\t\t\t\t\t\tmargin: '5px'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'align',\n\t *\t\t\t\tvalues: [ 'right', 'center' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-right'\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-center'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'right'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'center'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from and to.\n\t * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n\t * The `key` property is the model attribute key to convert from and to.\n\t * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the\n\t * view attribute value.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t *\n\t * The `definition.view` parameter specifies which view attribute should be converted from and to.\n\t * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n\t * The `key` property is the view attribute key to convert from and to.\n\t * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n\t * the same as the model attribute value.\n\t * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n\t * If `key` is `'style'`, `value` is an object with key-value pairs.\n\t * In other cases, `value` is a `String`.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n\t * to `{ key, value, [ name ] }` objects.\n\t *\n\t * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n\t * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n\t * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n\t *\n\t * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n\t * be given in both parameters.\n\t *\n\t * @param {Object} definition The converter definition.\n\t * @param {String|Object} definition.model The model attribute to convert from and to.\n\t * @param {String|Object} definition.view The view attribute to convert from and to.\n\t * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n\t * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n\t * is used only if `config.model.values` is specified.\n\t */\n\tattributeToAttribute( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToAttribute( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.attributeToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and caches conversion helpers for given dispatchers group.\n\t *\n\t * @private\n\t * @param {Object} options\n\t * @param {String} options.name Group name.\n\t * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers\n\t * @param {Boolean} options.isDowncast\n\t */\n\t_createConversionHelpers( { name, dispatchers, isDowncast } ) {\n\t\tif ( this._helpers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to register a group name that has already been registered.\n\t\t\t *\n\t\t\t * @error conversion-group-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-group-exists: Trying to register a group name that has already been registered.', this );\n\t\t}\n\n\t\tconst helpers = isDowncast ? new DowncastHelpers( dispatchers ) : new UpcastHelpers( dispatchers );\n\n\t\tthis._helpers.set( name, helpers );\n\t}\n}\n\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\nfunction* _getAllUpcastDefinitions( definition ) {\n\tif ( definition.model.values ) {\n\t\tfor ( const value of definition.model.values ) {\n\t\t\tconst model = { key: definition.model.key, value };\n\t\t\tconst view = definition.view[ value ];\n\t\t\tconst upcastAlso = definition.upcastAlso ? definition.upcastAlso[ value ] : undefined;\n\n\t\t\tyield* _getUpcastDefinition( model, view, upcastAlso );\n\t\t}\n\t} else {\n\t\tyield* _getUpcastDefinition( definition.model, definition.view, definition.upcastAlso );\n\t}\n}\n\nfunction* _getUpcastDefinition( model, view, upcastAlso ) {\n\tyield { model, view };\n\n\tif ( upcastAlso ) {\n\t\tupcastAlso = Array.isArray( upcastAlso ) ? upcastAlso : [ upcastAlso ];\n\n\t\tfor ( const upcastAlsoItem of upcastAlso ) {\n\t\t\tyield { model, view: upcastAlsoItem };\n\t\t}\n\t}\n}\n"]}]}