{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\schema.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\schema.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zZXQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKdmFyIF9tYXJrZWQgPQovKiNfX1BVUkVfXyovCnJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGNvbWJpbmVXYWxrZXJzKSwKICAgIF9tYXJrZWQyID0KLyojX19QVVJFX18qLwpyZWdlbmVyYXRvclJ1bnRpbWUubWFyayhjb252ZXJ0VG9NaW5pbWFsRmxhdFJhbmdlcyk7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL3NjaGVtYQogKi8KaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBPYnNlcnZhYmxlTWl4aW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvb2JzZXJ2YWJsZW1peGluJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJzsKaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IFRyZWVXYWxrZXIgZnJvbSAnLi90cmVld2Fsa2VyJzsKLyoqCiAqIFRoZSBtb2RlbCdzIHNjaGVtYS4gSXQgZGVmaW5lcyBhbGxvd2VkIGFuZCBkaXNhbGxvd2VkIHN0cnVjdHVyZXMgb2Ygbm9kZXMgYXMgd2VsbCBhcyBub2RlcycgYXR0cmlidXRlcy4KICogVGhlIHNjaGVtYSBpcyB1c3VhbGx5IGRlZmluZWQgYnkgZmVhdHVyZXMgYW5kIGJhc2VkIG9uIHRoZW0gdGhlIGVkaXRpbmcgZnJhbWV3b3JrIGFuZCBmZWF0dXJlcwogKiBtYWtlIGRlY2lzaW9ucyBob3cgdG8gY2hhbmdlIGFuZCBwcm9jZXNzIHRoZSBtb2RlbC4KICoKICogVGhlIGluc3RhbmNlIG9mIHNjaGVtYSBpcyBhdmFpbGFibGUgaW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjc2NoZW1hIGBlZGl0b3IubW9kZWwuc2NoZW1hYH0uCiAqCiAqIFJlYWQgbW9yZSBhYm91dCB0aGUgc2NoZW1hIGluOgogKgogKiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjc2NoZW1hICJTY2hlbWEifSBzZWN0aW9uIG9mIHRoZQogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEludHJvZHVjdGlvbiB0byB0aGUgIkVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZSJ9LgogKiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hICJTY2hlbWEiIGRlZXAgZGl2ZX0gZ3VpZGUuCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbgogKi8KCnZhciBTY2hlbWEgPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIHNjaGVtYSBpbnN0YW5jZS4KICAgKi8KICBmdW5jdGlvbiBTY2hlbWEoKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpOwoKICAgIHRoaXMuX3NvdXJjZURlZmluaXRpb25zID0ge307CiAgICAvKioKICAgICAqIEEgZGljdGlvbmFyeSBjb250YWluaW5nIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtPYmplY3QuPFN0cmluZyxTdHJpbmc+fQogICAgICovCgogICAgdGhpcy5fYXR0cmlidXRlUHJvcGVydGllcyA9IHt9OwogICAgdGhpcy5kZWNvcmF0ZSgnY2hlY2tDaGlsZCcpOwogICAgdGhpcy5kZWNvcmF0ZSgnY2hlY2tBdHRyaWJ1dGUnKTsKICAgIHRoaXMub24oJ2NoZWNrQXR0cmlidXRlJywgZnVuY3Rpb24gKGV2dCwgYXJncykgewogICAgICBhcmdzWzBdID0gbmV3IFNjaGVtYUNvbnRleHQoYXJnc1swXSk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaGVzdCcKICAgIH0pOwogICAgdGhpcy5vbignY2hlY2tDaGlsZCcsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHsKICAgICAgYXJnc1swXSA9IG5ldyBTY2hlbWFDb250ZXh0KGFyZ3NbMF0pOwogICAgICBhcmdzWzFdID0gX3RoaXMuZ2V0RGVmaW5pdGlvbihhcmdzWzFdKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdoaWdoZXN0JwogICAgfSk7CiAgfQogIC8qKgogICAqIFJlZ2lzdGVycyBzY2hlbWEgaXRlbS4gQ2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IGl0ZW0gbmFtZS4KICAgKgogICAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAgICoJCQlpbmhlcml0QWxsRnJvbTogJyRibG9jaycKICAgKgkJfSApOwogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IGl0ZW1OYW1lCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gZGVmaW5pdGlvbgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFNjaGVtYSwgW3sKICAgIGtleTogInJlZ2lzdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlcihpdGVtTmFtZSwgZGVmaW5pdGlvbikgewogICAgICBpZiAodGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQSBzaW5nbGUgaXRlbSBjYW5ub3QgYmUgcmVnaXN0ZXJlZCB0d2ljZSBpbiB0aGUgc2NoZW1hLgogICAgICAgICAqCiAgICAgICAgICogVGhpcyBzaXR1YXRpb24gbWF5IGhhcHBlbiB3aGVuOgogICAgICAgICAqCiAgICAgICAgICogKiBUd28gb3IgbW9yZSBwbHVnaW5zIGNhbGxlZCB7QGxpbmsgI3JlZ2lzdGVyIGByZWdpc3RlcigpYH0gd2l0aCB0aGUgc2FtZSBuYW1lLiBUaGlzIHdpbGwgdXN1YWxseSBtZWFuIHRoYXQKICAgICAgICAgKiB0aGVyZSBpcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHBsdWdpbnMgd2hpY2ggdHJ5IHRvIHVzZSB0aGUgc2FtZSBlbGVtZW50IGluIHRoZSBtb2RlbC4gVW5mb3J0dW5hdGVseSwKICAgICAgICAgKiB0aGUgb25seSB3YXkgdG8gc29sdmUgdGhpcyBpcyBieSBtb2RpZnlpbmcgb25lIG9mIHRoZXNlIHBsdWdpbnMgdG8gdXNlIGEgdW5pcXVlIG1vZGVsIGVsZW1lbnQgbmFtZS4KICAgICAgICAgKiAqIEEgc2luZ2xlIHBsdWdpbiB3YXMgbG9hZGVkIHR3aWNlLiBUaGlzIGhhcHBlbnMgd2hlbiBpdCBpcyBpbnN0YWxsZWQgYnkgbnBtL3lhcm4gaW4gdHdvIHZlcnNpb25zCiAgICAgICAgICogYW5kIHVzdWFsbHkgbWVhbnMgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBpc3N1ZXM6CiAgICAgICAgICogICAgICogYSB2ZXJzaW9uIG1pc21hdGNoICh0d28gb2YgeW91ciBkZXBlbmRlbmNpZXMgcmVxdWlyZSB0d28gZGlmZmVyZW50IHZlcnNpb25zIG9mIHRoaXMgcGx1Z2luKSwKICAgICAgICAgKiAgICAgKiBpbmNvcnJlY3QgaW1wb3J0cyAodGhpcyBwbHVnaW4gaXMgc29tZWhvdyBpbXBvcnRlZCB0d2ljZSBpbiBhIHdheSB3aGljaCBjb25mdXNlcyB3ZWJwYWNrKSwKICAgICAgICAgKiAgICAgKiBtZXNzIGluIGBub2RlX21vZHVsZXMvYCAoYHJtIC1yZiBub2RlX21vZHVsZXMvYCBtYXkgaGVscCkuCiAgICAgICAgICoKICAgICAgICAgKiAqKk5vdGU6KiogQ2hlY2sgdGhlIGxvZ2dlZCBgaXRlbU5hbWVgIHRvIGJldHRlciB1bmRlcnN0YW5kIHdoaWNoIHBsdWdpbiB3YXMgZHVwbGljYXRlZC9jb25mbGljdGluZy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHJlZ2lzdGVyZWQgdHdpY2UuCiAgICAgICAgICogQGVycm9yIHNjaGVtYS1jYW5ub3QtcmVnaXN0ZXItaXRlbS10d2ljZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdzY2hlbWEtY2Fubm90LXJlZ2lzdGVyLWl0ZW0tdHdpY2U6IEEgc2luZ2xlIGl0ZW0gY2Fubm90IGJlIHJlZ2lzdGVyZWQgdHdpY2UgaW4gdGhlIHNjaGVtYS4nLCB0aGlzLCB7CiAgICAgICAgICBpdGVtTmFtZTogaXRlbU5hbWUKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgdGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdID0gW09iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pXTsKCiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTsKICAgIH0KICAgIC8qKgogICAgICogRXh0ZW5kcyBhIHtAbGluayAjcmVnaXN0ZXIgcmVnaXN0ZXJlZH0gaXRlbSdzIGRlZmluaXRpb24uCiAgICAgKgogICAgICogRXh0ZW5kaW5nIHByb3BlcnRpZXMgc3VjaCBhcyBgYWxsb3dJbmAgd2lsbCBhZGQgbW9yZSBpdGVtcyB0byB0aGUgZXhpc3RpbmcgcHJvcGVydGllcywKICAgICAqIHdoaWxlIHJlZGVmaW5pbmcgcHJvcGVydGllcyBzdWNoIGFzIGBpc0Jsb2NrYCB3aWxsIG92ZXJyaWRlIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgb25lcy4KICAgICAqCiAgICAgKgkJc2NoZW1hLnJlZ2lzdGVyKCAnZm9vJywgewogICAgICoJCQlhbGxvd0luOiAnJHJvb3QnLAogICAgICoJCQlpc0Jsb2NrOiB0cnVlOwogICAgICoJCX0gKTsKICAgICAqCQlzY2hlbWEuZXh0ZW5kKCAnZm9vJywgewogICAgICoJCQlhbGxvd0luOiAnYmxvY2tRdW90ZScsCiAgICAgKgkJCWlzQmxvY2s6IGZhbHNlCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQlzY2hlbWEuZ2V0RGVmaW5pdGlvbiggJ2ZvbycgKTsKICAgICAqCQkvLwl7CiAgICAgKgkJLy8JCWFsbG93SW46IFsgJyRyb290JywgJ2Jsb2NrUXVvdGUnIF0sCiAgICAgKgkJLy8gCQlpc0Jsb2NrOiBmYWxzZQogICAgICoJCS8vCX0KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaXRlbU5hbWUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGRlZmluaXRpb24KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJleHRlbmQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChpdGVtTmFtZSwgZGVmaW5pdGlvbikgewogICAgICBpZiAoIXRoaXMuX3NvdXJjZURlZmluaXRpb25zW2l0ZW1OYW1lXSkgewogICAgICAgIC8qKgogICAgICAgICAqIENhbm5vdCBleHRlbmQgYW4gaXRlbSB3aGljaCB3YXMgbm90IHJlZ2lzdGVyZWQgeWV0LgogICAgICAgICAqCiAgICAgICAgICogVGhpcyBlcnJvciBoYXBwZW5zIHdoZW4gYSBwbHVnaW4gdHJpZXMgdG8gZXh0ZW5kIHRoZSBzY2hlbWEgZGVmaW5pdGlvbiBvZiBhbiBpdGVtIHdoaWNoIHdhcyBub3QKICAgICAgICAgKiB7QGxpbmsgI3JlZ2lzdGVyIHJlZ2lzdGVyZWR9IHlldC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB3aGljaCBpcyBiZWluZyBleHRlbmRlZC4KICAgICAgICAgKiBAZXJyb3Igc2NoZW1hLWNhbm5vdC1leHRlbmQtbWlzc2luZy1pdGVtCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jYW5ub3QtZXh0ZW5kLW1pc3NpbmctaXRlbTogQ2Fubm90IGV4dGVuZCBhbiBpdGVtIHdoaWNoIHdhcyBub3QgcmVnaXN0ZXJlZCB5ZXQuJywgdGhpcywgewogICAgICAgICAgaXRlbU5hbWU6IGl0ZW1OYW1lCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHRoaXMuX3NvdXJjZURlZmluaXRpb25zW2l0ZW1OYW1lXS5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGRlZmluaXRpb24pKTsKCiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBpdGVtcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxTdHJpbmcsbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbj59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0RGVmaW5pdGlvbnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb25zKCkgewogICAgICBpZiAoIXRoaXMuX2NvbXBpbGVkRGVmaW5pdGlvbnMpIHsKICAgICAgICB0aGlzLl9jb21waWxlKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9jb21waWxlZERlZmluaXRpb25zOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgZGVmaW5pdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBvciBgdW5kZWZpbmVkYCBpZiBpdGVtIGlzIG5vdCByZWdpc3RlcmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXREZWZpbml0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0pIHsKICAgICAgdmFyIGl0ZW1OYW1lOwoKICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdzdHJpbmcnKSB7CiAgICAgICAgaXRlbU5hbWUgPSBpdGVtOwogICAgICB9IGVsc2UgaWYgKGl0ZW0uaXMgJiYgKGl0ZW0uaXMoJ3RleHQnKSB8fCBpdGVtLmlzKCd0ZXh0UHJveHknKSkpIHsKICAgICAgICBpdGVtTmFtZSA9ICckdGV4dCc7CiAgICAgIH0gLy8gRWxlbWVudCBvciBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbS4KICAgICAgZWxzZSB7CiAgICAgICAgICBpdGVtTmFtZSA9IGl0ZW0ubmFtZTsKICAgICAgICB9CgogICAgICByZXR1cm4gdGhpcy5nZXREZWZpbml0aW9ucygpW2l0ZW1OYW1lXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgcmVnaXN0ZXJlZCBpbiB0aGUgc2NoZW1hLgogICAgICoKICAgICAqCQlzY2hlbWEuaXNSZWdpc3RlcmVkKCAncGFyYWdyYXBoJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzUmVnaXN0ZXJlZCggZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzUmVnaXN0ZXJlZCggJ2ZvbycgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzUmVnaXN0ZXJlZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWdpc3RlcmVkKGl0ZW0pIHsKICAgICAgcmV0dXJuICEhdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBkZWZpbmVkIHRvIGJlCiAgICAgKiBhIGJsb2NrIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNCbG9ja2AgcHJvcGVydHkuCiAgICAgKgogICAgICoJCXNjaGVtYS5pc0Jsb2NrKCAncGFyYWdyYXBoJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzQmxvY2soICckcm9vdCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKgkJY29uc3QgcGFyYWdyYXBoRWxlbWVudCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAncGFyYWdyYXBoJyApOwogICAgICoJCXNjaGVtYS5pc0Jsb2NrKCBwYXJhZ3JhcGhFbGVtZW50ICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQmxvY2siLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzQmxvY2soaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc0Jsb2NrKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgZGVmaW5lZCB0byBiZQogICAgICogYSBsaW1pdCBlbGVtZW50IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNMaW1pdGAgb3IgYGlzT2JqZWN0YCBwcm9wZXJ0eQogICAgICogKGFsbCBvYmplY3RzIGFyZSBhbHNvIGxpbWl0cykuCiAgICAgKgogICAgICoJCXNjaGVtYS5pc0xpbWl0KCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNjaGVtYS5pc0xpbWl0KCAnJHJvb3QnICk7IC8vIC0+IHRydWUKICAgICAqCQlzY2hlbWEuaXNMaW1pdCggZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2NoZW1hLmlzTGltaXQoICdpbWFnZScgKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNMaW1pdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMaW1pdChpdGVtKSB7CiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oaXRlbSk7CgogICAgICBpZiAoIWRlZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuICEhKGRlZi5pc0xpbWl0IHx8IGRlZi5pc09iamVjdCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGRlZmluZWQgdG8gYmUKICAgICAqIGFuIG9iamVjdCBlbGVtZW50IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNPYmplY3RgIHByb3BlcnR5LgogICAgICoKICAgICAqCQlzY2hlbWEuaXNPYmplY3QoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJc2NoZW1hLmlzT2JqZWN0KCAnaW1hZ2UnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJY29uc3QgaW1hZ2VFbGVtZW50ID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdpbWFnZScgKTsKICAgICAqCQlzY2hlbWEuaXNPYmplY3QoIGltYWdlRWxlbWVudCApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc09iamVjdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc09iamVjdCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGRlZmluZWQgdG8gYmUKICAgICAqIGFuIGlubGluZSBlbGVtZW50IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNJbmxpbmVgIHByb3BlcnR5LgogICAgICoKICAgICAqCQlzY2hlbWEuaXNJbmxpbmUoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJc2NoZW1hLmlzSW5saW5lKCAnc29mdEJyZWFrJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICoJCWNvbnN0IHRleHQgPSB3cml0ZXIuY3JlYXRlVGV4dCgnZm9vJyApOwogICAgICoJCXNjaGVtYS5pc0lubGluZSggdGV4dCApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0lubGluZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbmxpbmUoaXRlbSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc0lubGluZSk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIChgY2hpbGRgKSBjYW4gYmUgYSBjaGlsZCBvZiB0aGUgZ2l2ZW4gY29udGV4dC4KICAgICAqCiAgICAgKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIG1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSwgcGFyYWdyYXBoICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoJCXNjaGVtYS5yZWdpc3RlciggJ3BhcmFncmFwaCcsIHsKICAgICAqCQkJYWxsb3dJbjogJyRyb290JwogICAgICoJCX0gKTsKICAgICAqCQlzY2hlbWEuY2hlY2tDaGlsZCggbW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpLCBwYXJhZ3JhcGggKTsgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqIE5vdGU6IFdoZW4gdmVyaWZ5aW5nIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgY2FuIGJlIGEgY2hpbGQgb2YgdGhlIGdpdmVuIGNvbnRleHQsIHRoZQogICAgICogc2NoZW1hIGFsc28gdmVyaWZpZXMgdGhlIGVudGlyZSBjb250ZXh0ICZtZGFzaDsgZnJvbSBpdHMgcm9vdCB0byBpdHMgbGFzdCBlbGVtZW50LiBUaGVyZWZvcmUsIGl0IGlzIHBvc3NpYmxlCiAgICAgKiBmb3IgYGNoZWNrQ2hpbGQoKWAgdG8gcmV0dXJuIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGhlIGNvbnRleHQncyBsYXN0IGVsZW1lbnQgY2FuIGNvbnRhaW4gdGhlIGNoZWNrZWQgY2hpbGQuCiAgICAgKiBJdCBoYXBwZW5zIGlmIG9uZSBvZiB0aGUgY29udGV4dCdzIGVsZW1lbnRzIGRvZXMgbm90IGFsbG93IGl0cyBjaGlsZC4KICAgICAqCiAgICAgKiBAZmlyZXMgY2hlY2tDaGlsZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2hpbGQgd2lsbCBiZSBjaGVja2VkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxTdHJpbmd9IGRlZiBUaGUgY2hpbGQgdG8gY2hlY2suCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2hlY2tDaGlsZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDaGlsZChjb250ZXh0LCBkZWYpIHsKICAgICAgLy8gTm90ZTogY29udGV4dCBhbmQgY2hpbGQgYXJlIGFscmVhZHkgbm9ybWFsaXplZCBoZXJlIHRvIGEgU2NoZW1hQ29udGV4dCBhbmQgU2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbi4KICAgICAgaWYgKCFkZWYpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLl9jaGVja0NvbnRleHRNYXRjaChkZWYsIGNvbnRleHQpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gYXR0cmlidXRlIGNhbiBiZSBhcHBsaWVkIGluIHRoZSBnaXZlbiBjb250ZXh0IChvbiB0aGUgbGFzdAogICAgICogaXRlbSBvZiB0aGUgY29udGV4dCkuCiAgICAgKgogICAgICoJCXNjaGVtYS5jaGVja0F0dHJpYnV0ZSggdGV4dE5vZGUsICdib2xkJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqCQlzY2hlbWEuZXh0ZW5kKCAnJHRleHQnLCB7CiAgICAgKgkJCWFsbG93QXR0cmlidXRlczogJ2JvbGQnCiAgICAgKgkJfSApOwogICAgICoJCXNjaGVtYS5jaGVja0F0dHJpYnV0ZSggdGV4dE5vZGUsICdib2xkJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICogQGZpcmVzIGNoZWNrQXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBjb250ZXh0IFRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBjaGVja2VkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjaGVja0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGUoY29udGV4dCwgYXR0cmlidXRlTmFtZSkgewogICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGNvbnRleHQubGFzdCk7CgogICAgICBpZiAoIWRlZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIGRlZi5hbGxvd0F0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IChgZWxlbWVudFRvTWVyZ2VgKSBjYW4gYmUgbWVyZ2VkIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGVsZW1lbnQgKGBwb3NpdGlvbk9yQmFzZUVsZW1lbnRgKS4KICAgICAqCiAgICAgKiBJbiBvdGhlciB3b3JkcyAmbWRhc2g7IHdoZXRoZXIgYGVsZW1lbnRUb01lcmdlYCdzIGNoaWxkcmVuIHtAbGluayAjY2hlY2tDaGlsZCBhcmUgYWxsb3dlZH0gaW4gdGhlIGBwb3NpdGlvbk9yQmFzZUVsZW1lbnRgLgogICAgICoKICAgICAqIFRoaXMgY2hlY2sgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIG1lcmdlZCB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjbWVyZ2UgYFdyaXRlciNtZXJnZSgpYH0KICAgICAqIHdpbGwgYmUgdmFsaWQuCiAgICAgKgogICAgICogSW5zdGVhZCBvZiBlbGVtZW50cywgeW91IGNhbiBwYXNzIHRoZSBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGNsYXNzIGFzIHRoZQogICAgICogYHBvc2l0aW9uT3JCYXNlRWxlbWVudGAuIEl0IG1lYW5zIHRoYXQgdGhlIGVsZW1lbnRzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCB3aGV0aGVyIHRoZXkgY2FuIGJlIG1lcmdlZC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBvc2l0aW9uT3JCYXNlRWxlbWVudCBUaGUgcG9zaXRpb24gb3IgYmFzZQogICAgICogZWxlbWVudCB0byB3aGljaCB0aGUgYGVsZW1lbnRUb01lcmdlYCB3aWxsIGJlIG1lcmdlZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnRUb01lcmdlIFRoZSBlbGVtZW50IHRvIG1lcmdlLiBSZXF1aXJlZCBpZiBgcG9zaXRpb25PckJhc2VFbGVtZW50YCBpcyBhbiBlbGVtZW50LgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2hlY2tNZXJnZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tNZXJnZShwb3NpdGlvbk9yQmFzZUVsZW1lbnQpIHsKICAgICAgdmFyIGVsZW1lbnRUb01lcmdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsOwoKICAgICAgaWYgKHBvc2l0aW9uT3JCYXNlRWxlbWVudCBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSBwb3NpdGlvbk9yQmFzZUVsZW1lbnQubm9kZUJlZm9yZTsKICAgICAgICB2YXIgbm9kZUFmdGVyID0gcG9zaXRpb25PckJhc2VFbGVtZW50Lm5vZGVBZnRlcjsKCiAgICAgICAgaWYgKCEobm9kZUJlZm9yZSBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7CiAgICAgICAgICAvKioKICAgICAgICAgICAqIFRoZSBub2RlIGJlZm9yZSB0aGUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAgICoKICAgICAgICAgICAqIEBlcnJvciBzY2hlbWEtY2hlY2stbWVyZ2Utbm8tZWxlbWVudC1iZWZvcmUKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jaGVjay1tZXJnZS1uby1lbGVtZW50LWJlZm9yZTogVGhlIG5vZGUgYmVmb3JlIHRoZSBtZXJnZSBwb3NpdGlvbiBtdXN0IGJlIGFuIGVsZW1lbnQuJywgdGhpcyk7CiAgICAgICAgfQoKICAgICAgICBpZiAoIShub2RlQWZ0ZXIgaW5zdGFuY2VvZiBFbGVtZW50KSkgewogICAgICAgICAgLyoqCiAgICAgICAgICAgKiBUaGUgbm9kZSBhZnRlciB0aGUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAgICoKICAgICAgICAgICAqIEBlcnJvciBzY2hlbWEtY2hlY2stbWVyZ2Utbm8tZWxlbWVudC1hZnRlcgogICAgICAgICAgICovCiAgICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignc2NoZW1hLWNoZWNrLW1lcmdlLW5vLWVsZW1lbnQtYWZ0ZXI6IFRoZSBub2RlIGFmdGVyIHRoZSBtZXJnZSBwb3NpdGlvbiBtdXN0IGJlIGFuIGVsZW1lbnQuJywgdGhpcyk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gdGhpcy5jaGVja01lcmdlKG5vZGVCZWZvcmUsIG5vZGVBZnRlcik7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZWxlbWVudFRvTWVyZ2UuZ2V0Q2hpbGRyZW4oKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlOwoKICAgICAgICAgIGlmICghdGhpcy5jaGVja0NoaWxkKHBvc2l0aW9uT3JCYXNlRWxlbWVudCwgY2hpbGQpKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogICAgLyoqCiAgICAgKiBBbGxvd3MgcmVnaXN0ZXJpbmcgYSBjYWxsYmFjayB0byB0aGUge0BsaW5rICNjaGVja0NoaWxkfSBtZXRob2QgY2FsbHMuCiAgICAgKgogICAgICogQ2FsbGJhY2tzIGFsbG93IHlvdSB0byBpbXBsZW1lbnQgcnVsZXMgd2hpY2ggYXJlIG5vdCBvdGhlcndpc2UgcG9zc2libGUgdG8gYWNoaWV2ZQogICAgICogYnkgdXNpbmcgdGhlIGRlY2xhcmF0aXZlIEFQSSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259LgogICAgICogRm9yIGV4YW1wbGUsIGJ5IHVzaW5nIHRoaXMgbWV0aG9kIHlvdSBjYW4gZGlzYWxsb3cgZWxlbWVudHMgaW4gc3BlY2lmaWMgY29udGV4dHMuCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgaXMgYSBzaG9ydGhhbmQgZm9yIHVzaW5nIHRoZSB7QGxpbmsgI2V2ZW50OmNoZWNrQ2hpbGR9IGV2ZW50LiBGb3IgZXZlbiBiZXR0ZXIgY29udHJvbCwKICAgICAqIHlvdSBjYW4gdXNlIHRoYXQgZXZlbnQgaW5zdGVhZC4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQkvLyBEaXNhbGxvdyBoZWFkaW5nMSBkaXJlY3RseSBpbnNpZGUgYSBibG9ja1F1b3RlLgogICAgICoJCXNjaGVtYS5hZGRDaGlsZENoZWNrKCAoIGNvbnRleHQsIGNoaWxkRGVmaW5pdGlvbiApID0+IHsKICAgICAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnYmxvY2tRdW90ZScgKSAmJiBjaGlsZERlZmluaXRpb24ubmFtZSA9PSAnaGVhZGluZzEnICkgewogICAgICoJCQkJcmV0dXJuIGZhbHNlOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFdoaWNoIHRyYW5zbGF0ZXMgdG86CiAgICAgKgogICAgICoJCXNjaGVtYS5vbiggJ2NoZWNrQ2hpbGQnLCAoIGV2dCwgYXJncyApID0+IHsKICAgICAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICAgICAqCQkJY29uc3QgY2hpbGREZWZpbml0aW9uID0gYXJnc1sgMSBdOwogICAgICoKICAgICAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnYmxvY2tRdW90ZScgKSAmJiBjaGlsZERlZmluaXRpb24gJiYgY2hpbGREZWZpbml0aW9uLm5hbWUgPT0gJ2hlYWRpbmcxJyApIHsKICAgICAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAgICAgKgkJCQlldnQuc3RvcCgpOwogICAgICoJCQkJLy8gU2V0IHRoZSBjaGVja0NoaWxkKCkncyByZXR1cm4gdmFsdWUuCiAgICAgKgkJCQlldnQucmV0dXJuID0gZmFsc2U7CiAgICAgKgkJCX0KICAgICAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQuIEl0IGlzIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IChjb250ZXh0KSBpbnN0YW5jZSBhbmQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9ufSAoY2hpbGQtdG8tY2hlY2sgZGVmaW5pdGlvbikuCiAgICAgKiBUaGUgY2FsbGJhY2sgbWF5IHJldHVybiBgdHJ1ZS9mYWxzZWAgdG8gb3ZlcnJpZGUgYGNoZWNrQ2hpbGQoKWAncyByZXR1cm4gdmFsdWUuIElmIGl0IGRvZXMgbm90IHJldHVybgogICAgICogYSBib29sZWFuIHZhbHVlLCB0aGUgZGVmYXVsdCBhbGdvcml0aG0gKG9yIG90aGVyIGNhbGxiYWNrcykgd2lsbCBkZWZpbmUgYGNoZWNrQ2hpbGQoKWAncyByZXR1cm4gdmFsdWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYWRkQ2hpbGRDaGVjayIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2hpbGRDaGVjayhjYWxsYmFjaykgewogICAgICB0aGlzLm9uKCdjaGVja0NoaWxkJywgZnVuY3Rpb24gKGV2dCwgX3JlZikgewogICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLAogICAgICAgICAgICBjdHggPSBfcmVmMlswXSwKICAgICAgICAgICAgY2hpbGREZWYgPSBfcmVmMlsxXTsKCiAgICAgICAgLy8gY2hlY2tDaGlsZCgpIHdhcyBjYWxsZWQgd2l0aCBhIG5vbi1yZWdpc3RlcmVkIGNoaWxkLgogICAgICAgIC8vIEluIDk5JSBjYXNlcyBzdWNoIGNoZWNrIHNob3VsZCByZXR1cm4gZmFsc2UsIHNvIG5vdCB0byBvdmVyY29tcGxpY2F0ZSBhbGwgY2FsbGJhY2tzCiAgICAgICAgLy8gZG9uJ3QgZXZlbiBleGVjdXRlIHRoZW0uCiAgICAgICAgaWYgKCFjaGlsZERlZikgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIHJldFZhbHVlID0gY2FsbGJhY2soY3R4LCBjaGlsZERlZik7CgogICAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICBldnQuc3RvcCgpOwogICAgICAgICAgZXZ0LnJldHVybiA9IHJldFZhbHVlOwogICAgICAgIH0KICAgICAgfSwgewogICAgICAgIHByaW9yaXR5OiAnaGlnaCcKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIEFsbG93cyByZWdpc3RlcmluZyBhIGNhbGxiYWNrIHRvIHRoZSB7QGxpbmsgI2NoZWNrQXR0cmlidXRlfSBtZXRob2QgY2FsbHMuCiAgICAgKgogICAgICogQ2FsbGJhY2tzIGFsbG93IHlvdSB0byBpbXBsZW1lbnQgcnVsZXMgd2hpY2ggYXJlIG5vdCBvdGhlcndpc2UgcG9zc2libGUgdG8gYWNoaWV2ZQogICAgICogYnkgdXNpbmcgdGhlIGRlY2xhcmF0aXZlIEFQSSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259LgogICAgICogRm9yIGV4YW1wbGUsIGJ5IHVzaW5nIHRoaXMgbWV0aG9kIHlvdSBjYW4gZGlzYWxsb3cgYXR0cmlidXRlIGlmIG5vZGUgdG8gd2hpY2ggaXQgaXMgYXBwbGllZAogICAgICogaXMgY29udGFpbmVkIHdpdGhpbiBzb21lIG90aGVyIGVsZW1lbnQgKGUuZy4geW91IHdhbnQgdG8gZGlzYWxsb3cgYGJvbGRgIG9uIGAkdGV4dGAgd2l0aGluIGBoZWFkaW5nMWApLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUge0BsaW5rICNldmVudDpjaGVja0F0dHJpYnV0ZX0gZXZlbnQuIEZvciBldmVuIGJldHRlciBjb250cm9sLAogICAgICogeW91IGNhbiB1c2UgdGhhdCBldmVudCBpbnN0ZWFkLgogICAgICoKICAgICAqIEV4YW1wbGU6CiAgICAgKgogICAgICoJCS8vIERpc2FsbG93IGJvbGQgb24gJHRleHQgaW5zaWRlIGhlYWRpbmcxLgogICAgICoJCXNjaGVtYS5hZGRBdHRyaWJ1dGVDaGVjayggKCBjb250ZXh0LCBhdHRyaWJ1dGVOYW1lICkgPT4gewogICAgICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdoZWFkaW5nMSAkdGV4dCcgKSAmJiBhdHRyaWJ1dGVOYW1lID09ICdib2xkJyApIHsKICAgICAqCQkJCXJldHVybiBmYWxzZTsKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBXaGljaCB0cmFuc2xhdGVzIHRvOgogICAgICoKICAgICAqCQlzY2hlbWEub24oICdjaGVja0F0dHJpYnV0ZScsICggZXZ0LCBhcmdzICkgPT4gewogICAgICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogICAgICoJCQljb25zdCBhdHRyaWJ1dGVOYW1lID0gYXJnc1sgMSBdOwogICAgICoKICAgICAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnaGVhZGluZzEgJHRleHQnICkgJiYgYXR0cmlidXRlTmFtZSA9PSAnYm9sZCcgKSB7CiAgICAgKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogICAgICoJCQkJZXZ0LnN0b3AoKTsKICAgICAqCQkJCS8vIFNldCB0aGUgY2hlY2tBdHRyaWJ1dGUoKSdzIHJldHVybiB2YWx1ZS4KICAgICAqCQkJCWV2dC5yZXR1cm4gPSBmYWxzZTsKICAgICAqCQkJfQogICAgICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6CiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gKGNvbnRleHQpIGluc3RhbmNlIGFuZCBhdHRyaWJ1dGUgbmFtZS4KICAgICAqIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuIGB0cnVlL2ZhbHNlYCB0byBvdmVycmlkZSBgY2hlY2tBdHRyaWJ1dGUoKWAncyByZXR1cm4gdmFsdWUuIElmIGl0IGRvZXMgbm90IHJldHVybgogICAgICogYSBib29sZWFuIHZhbHVlLCB0aGUgZGVmYXVsdCBhbGdvcml0aG0gKG9yIG90aGVyIGNhbGxiYWNrcykgd2lsbCBkZWZpbmUgYGNoZWNrQXR0cmlidXRlKClgJ3MgcmV0dXJuIHZhbHVlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImFkZEF0dHJpYnV0ZUNoZWNrIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBdHRyaWJ1dGVDaGVjayhjYWxsYmFjaykgewogICAgICB0aGlzLm9uKCdjaGVja0F0dHJpYnV0ZScsIGZ1bmN0aW9uIChldnQsIF9yZWYzKSB7CiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLAogICAgICAgICAgICBjdHggPSBfcmVmNFswXSwKICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWY0WzFdOwoKICAgICAgICB2YXIgcmV0VmFsdWUgPSBjYWxsYmFjayhjdHgsIGF0dHJpYnV0ZU5hbWUpOwoKICAgICAgICBpZiAodHlwZW9mIHJldFZhbHVlID09ICdib29sZWFuJykgewogICAgICAgICAgZXZ0LnN0b3AoKTsKICAgICAgICAgIGV2dC5yZXR1cm4gPSByZXRWYWx1ZTsKICAgICAgICB9CiAgICAgIH0sIHsKICAgICAgICBwcmlvcml0eTogJ2hpZ2gnCiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgYXNzaWduaW5nIGFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gdGhlIG1vZGVsIGF0dHJpYnV0ZXMuIEZvciBleGFtcGxlLAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hfkF0dHJpYnV0ZVByb3BlcnRpZXMgYEF0dHJpYnV0ZVByb3BlcnRpZXMjaXNGb3JtYXR0aW5nYCBwcm9wZXJ0eX0gaXMKICAgICAqIHVzZWQgdG8gbWFyayBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgKGxpa2UgYGJvbGRgIG9yIGBpdGFsaWNgKS4KICAgICAqCiAgICAgKgkJLy8gTWFyayBib2xkIGFzIGEgZm9ybWF0dGluZyBhdHRyaWJ1dGUuCiAgICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdib2xkJywgewogICAgICoJCQlpc0Zvcm1hdHRpbmc6IHRydWUKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIE92ZXJyaWRlIGNvZGUgbm90IHRvIGJlIGNvbnNpZGVyZWQgYSBmb3JtYXR0aW5nIG1hcmt1cC4KICAgICAqCQlzY2hlbWEuc2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2NvZGUnLCB7CiAgICAgKgkJCWlzRm9ybWF0dGluZzogZmFsc2UKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogUHJvcGVydGllcyBhcmUgbm90IGxpbWl0ZWQgdG8gbWVtYmVycyBkZWZpbmVkIGluIHRoZQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hfkF0dHJpYnV0ZVByb3BlcnRpZXMgYEF0dHJpYnV0ZVByb3BlcnRpZXNgIHR5cGV9IGFuZCB5b3UgY2FuIGFsc28gdXNlIGN1c3RvbSBwcm9wZXJ0aWVzOgogICAgICoKICAgICAqCQlzY2hlbWEuc2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2Jsb2NrUXVvdGUnLCB7CiAgICAgKgkJCWN1c3RvbVByb3BlcnR5OiAndmFsdWUnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFN1YnNlcXVlbnQgY2FsbHMgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGUgd2lsbCBleHRlbmQgaXRzIGN1c3RvbSBwcm9wZXJ0aWVzOgogICAgICoKICAgICAqCQlzY2hlbWEuc2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2Jsb2NrUXVvdGUnLCB7CiAgICAgKgkJCW9uZTogMQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdibG9ja1F1b3RlJywgewogICAgICoJCQl0d286IDIKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWNvbnNvbGUubG9nKCBzY2hlbWEuZ2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2Jsb2NrUXVvdGUnICkgKTsKICAgICAqCQkvLyBMb2dzOiB7IG9uZTogMSwgdHdvOiAyIH0KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBBIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byByZWNlaXZlIHRoZSBwcm9wZXJ0aWVzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzIEEgZGljdGlvbmFyeSBvZiBwcm9wZXJ0aWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldEF0dHJpYnV0ZVByb3BlcnRpZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZVByb3BlcnRpZXMoYXR0cmlidXRlTmFtZSwgcHJvcGVydGllcykgewogICAgICB0aGlzLl9hdHRyaWJ1dGVQcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gT2JqZWN0LmFzc2lnbih0aGlzLmdldEF0dHJpYnV0ZVByb3BlcnRpZXMoYXR0cmlidXRlTmFtZSksIHByb3BlcnRpZXMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYXR0cmlidXRlLiBTZWUge0BsaW5rICNzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzIGBzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBBIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEF0dHJpYnV0ZVByb3BlcnRpZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVByb3BlcnRpZXMoYXR0cmlidXRlTmFtZSkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlUHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSB8fCB7fTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0aGUgbG93ZXN0IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNMaW1pdCBsaW1pdCBlbGVtZW50fSBjb250YWluaW5nIHRoZSBlbnRpcmUKICAgICAqIHNlbGVjdGlvbi9yYW5nZS9wb3NpdGlvbiBvciB0aGUgcm9vdCBvdGhlcndpc2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbnwKICAgICAqIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24KICAgICAqIFRoZSBzZWxlY3Rpb24vcmFuZ2UvcG9zaXRpb24gdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IFRoZSBsb3dlc3QgbGltaXQgZWxlbWVudCBjb250YWluaW5nCiAgICAgKiB0aGUgZW50aXJlIGBzZWxlY3Rpb25PclJhbmdlT3JQb3NpdGlvbmAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TGltaXRFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW1pdEVsZW1lbnQoc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24pIHsKICAgICAgdmFyIGVsZW1lbnQ7CgogICAgICBpZiAoc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24gaW5zdGFuY2VvZiBQb3NpdGlvbikgewogICAgICAgIGVsZW1lbnQgPSBzZWxlY3Rpb25PclJhbmdlT3JQb3NpdGlvbi5wYXJlbnQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uIGluc3RhbmNlb2YgUmFuZ2UgPyBbc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb25dIDogQXJyYXkuZnJvbShzZWxlY3Rpb25PclJhbmdlT3JQb3NpdGlvbi5nZXRSYW5nZXMoKSk7IC8vIEZpbmQgdGhlIGNvbW1vbiBhbmNlc3RvciBmb3IgYWxsIHNlbGVjdGlvbidzIHJhbmdlcy4KCiAgICAgICAgZWxlbWVudCA9IHJhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKGVsZW1lbnQsIHJhbmdlKSB7CiAgICAgICAgICB2YXIgcmFuZ2VDb21tb25BbmNlc3RvciA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7CgogICAgICAgICAgaWYgKCFlbGVtZW50KSB7CiAgICAgICAgICAgIHJldHVybiByYW5nZUNvbW1vbkFuY2VzdG9yOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldENvbW1vbkFuY2VzdG9yKHJhbmdlQ29tbW9uQW5jZXN0b3IsIHsKICAgICAgICAgICAgaW5jbHVkZVNlbGY6IHRydWUKICAgICAgICAgIH0pOwogICAgICAgIH0sIG51bGwpOwogICAgICB9CgogICAgICB3aGlsZSAoIXRoaXMuaXNMaW1pdChlbGVtZW50KSkgewogICAgICAgIGlmIChlbGVtZW50LnBhcmVudCkgewogICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBlbGVtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQgaW4gc2VsZWN0aW9uOgogICAgICoKICAgICAqICogaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkLCB0aGVuIGNoZWNrcyBpZiB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQgb24gYW55IG9mIG5vZGVzIGluIHRoYXQgcmFuZ2UsCiAgICAgKiAqIGlmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLCB0aGVuIGNoZWNrcyBpZiBvbiB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uIHRoZXJlJ3MgYSB0ZXh0IHdpdGggdGhlCiAgICAgKiBzcGVjaWZpZWQgYXR0cmlidXRlIGFsbG93ZWQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gc2VsZWN0aW9uCiAgICAgKiBTZWxlY3Rpb24gd2hpY2ggd2lsbCBiZSBjaGVja2VkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2hlY2tBdHRyaWJ1dGVJblNlbGVjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBdHRyaWJ1dGVJblNlbGVjdGlvbihzZWxlY3Rpb24sIGF0dHJpYnV0ZSkgewogICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgdmFyIGZpcnN0UG9zaXRpb24gPSBzZWxlY3Rpb24uZ2V0Rmlyc3RQb3NpdGlvbigpOwoKICAgICAgICB2YXIgX2NvbnRleHQgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGZpcnN0UG9zaXRpb24uZ2V0QW5jZXN0b3JzKCkpLCBbbmV3IFRleHQoJycsIHNlbGVjdGlvbi5nZXRBdHRyaWJ1dGVzKCkpXSk7IC8vIENoZWNrIHdoZXRoZXIgc2NoZW1hIGFsbG93cyBmb3IgYSB0ZXh0IHdpdGggdGhlIGF0dHJpYnV0ZSBpbiB0aGUgc2VsZWN0aW9uLgoKCiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBdHRyaWJ1dGUoX2NvbnRleHQsIGF0dHJpYnV0ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKTsgLy8gRm9yIGFsbCByYW5nZXMsIGNoZWNrIG5vZGVzIGluIHRoZW0gdW50aWwgeW91IGZpbmQgYSBub2RlIHRoYXQgaXMgYWxsb3dlZCB0byBoYXZlIHRoZSBhdHRyaWJ1dGUuCgogICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcmFuZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciByYW5nZSA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlOwogICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gcmFuZ2VbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0F0dHJpYnV0ZSh2YWx1ZS5pdGVtLCBhdHRyaWJ1dGUpKSB7CiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbm9kZSB0aGF0IGlzIGFsbG93ZWQgdG8gaGF2ZSB0aGUgYXR0cmlidXRlLCByZXR1cm4gdHJ1ZS4KICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjsKICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBJZiB3ZSBoYXZlbid0IGZvdW5kIHN1Y2ggbm9kZSwgcmV0dXJuIGZhbHNlLgoKCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcyBpbnRvIGEgc2V0IG9mIHJhbmdlcyB3aGVyZSB0aGUgZ2l2ZW4gYXR0cmlidXRlIGlzIGFsbG93ZWQgKGFuZCBjYW4gYmUgYXBwbGllZCkuCiAgICAgKgogICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcyBSYW5nZXMgdG8gYmUgdmFsaWRhdGVkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gUmFuZ2VzIGluIHdoaWNoIHRoZSBhdHRyaWJ1dGUgaXMgYWxsb3dlZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRWYWxpZFJhbmdlcyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldFZhbGlkUmFuZ2VzKHJhbmdlcywgYXR0cmlidXRlKSB7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCwgX2RpZEl0ZXJhdG9yRXJyb3I0LCBfaXRlcmF0b3JFcnJvcjQsIF9pdGVyYXRvcjQsIF9zdGVwNCwgcmFuZ2U7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0VmFsaWRSYW5nZXMkKF9jb250ZXh0MikgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHJhbmdlcyA9IGNvbnZlcnRUb01pbmltYWxGbGF0UmFuZ2VzKHJhbmdlcyk7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDQ7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yNCA9IHJhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByYW5nZSA9IF9zdGVwNC52YWx1ZTsKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmRlbGVnYXRlWWllbGQodGhpcy5fZ2V0VmFsaWRSYW5nZXNGb3JSYW5nZShyYW5nZSwgYXR0cmlidXRlKSwgInQwIiwgOSk7CgogICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNDsKICAgICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDJbImNhdGNoIl0oNCk7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBfY29udGV4dDIudDE7CgogICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxOTsKCiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgMjE6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMTsKCiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjQ7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKCiAgICAgICAgICAgIGNhc2UgMjQ6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjEpOwoKICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgxOCk7CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0VmFsaWRSYW5nZXMsIHRoaXMsIFtbNCwgMTQsIDE4LCAyNl0sIFsxOSwsIDIxLCAyNV1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIEJhc2luZyBvbiBnaXZlbiBgcG9zaXRpb25gLCBmaW5kcyBhbmQgcmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSB3aGljaCBpcwogICAgICogbmVhcmVzdCB0byB0aGF0IGBwb3NpdGlvbmAgYW5kIGlzIGEgY29ycmVjdCByYW5nZSBmb3Igc2VsZWN0aW9uLgogICAgICoKICAgICAqIFRoZSBjb3JyZWN0IHNlbGVjdGlvbiByYW5nZSBtaWdodCBiZSBjb2xsYXBzZWQgd2hlbiBpdCBpcyBsb2NhdGVkIGluIGEgcG9zaXRpb24gd2hlcmUgdGhlIHRleHQgbm9kZSBjYW4gYmUgcGxhY2VkLgogICAgICogTm9uLWNvbGxhcHNlZCByYW5nZSBpcyByZXR1cm5lZCB3aGVuIHNlbGVjdGlvbiBjYW4gYmUgcGxhY2VkIGFyb3VuZCBlbGVtZW50IG1hcmtlZCBhcyBhbiAib2JqZWN0IiBpbgogICAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfS4KICAgICAqCiAgICAgKiBEaXJlY3Rpb24gb2Ygc2VhcmNoaW5nIGZvciB0aGUgbmVhcmVzdCBjb3JyZWN0IHNlbGVjdGlvbiByYW5nZSBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYGJvdGhgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIGluIGJvdGggd2F5cywKICAgICAqICogYGZvcndhcmRgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIG9ubHkgZm9yd2FyZCwKICAgICAqICogYGJhY2t3YXJkYCAtIHNlYXJjaGluZyB3aWxsIGJlIHBlcmZvcm1lZCBvbmx5IGJhY2t3YXJkLgogICAgICoKICAgICAqIFdoZW4gdmFsaWQgc2VsZWN0aW9uIHJhbmdlIGNhbm5vdCBiZSBmb3VuZCwgYG51bGxgIGlzIHJldHVybmVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUmVmZXJlbmNlIHBvc2l0aW9uIHdoZXJlIG5ldyBzZWxlY3Rpb24gcmFuZ2Ugc2hvdWxkIGJlIGxvb2tlZCBmb3IuCiAgICAgKiBAcGFyYW0geydib3RoJ3wnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW2RpcmVjdGlvbj0nYm90aCddIFNlYXJjaCBkaXJlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBOZWFyZXN0IHNlbGVjdGlvbiByYW5nZSBvciBgbnVsbGAgaWYgb25lIGNhbm5vdCBiZSBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROZWFyZXN0U2VsZWN0aW9uUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5lYXJlc3RTZWxlY3Rpb25SYW5nZShwb3NpdGlvbikgewogICAgICB2YXIgX3RoaXMyID0gdGhpczsKCiAgICAgIHZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdib3RoJzsKCiAgICAgIC8vIFJldHVybiBjb2xsYXBzZWQgcmFuZ2UgaWYgcHJvdmlkZWQgcG9zaXRpb24gaXMgdmFsaWQuCiAgICAgIGlmICh0aGlzLmNoZWNrQ2hpbGQocG9zaXRpb24sICckdGV4dCcpKSB7CiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHZhciBiYWNrd2FyZFdhbGtlciwgZm9yd2FyZFdhbGtlcjsgLy8gTmV2ZXIgbGVhdmUgYSBsaW1pdCBlbGVtZW50LgoKICAgICAgdmFyIGxpbWl0RWxlbWVudCA9IHBvc2l0aW9uLmdldEFuY2VzdG9ycygpLnJldmVyc2UoKS5maW5kKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgcmV0dXJuIF90aGlzMi5pc0xpbWl0KGl0ZW0pOwogICAgICB9KSB8fCBwb3NpdGlvbi5yb290OwoKICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYm90aCcgfHwgZGlyZWN0aW9uID09ICdiYWNrd2FyZCcpIHsKICAgICAgICBiYWNrd2FyZFdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICAgIGJvdW5kYXJpZXM6IFJhbmdlLl9jcmVhdGVJbihsaW1pdEVsZW1lbnQpLAogICAgICAgICAgc3RhcnRQb3NpdGlvbjogcG9zaXRpb24sCiAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCcKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgaWYgKGRpcmVjdGlvbiA9PSAnYm90aCcgfHwgZGlyZWN0aW9uID09ICdmb3J3YXJkJykgewogICAgICAgIGZvcndhcmRXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcih7CiAgICAgICAgICBib3VuZGFyaWVzOiBSYW5nZS5fY3JlYXRlSW4obGltaXRFbGVtZW50KSwKICAgICAgICAgIHN0YXJ0UG9zaXRpb246IHBvc2l0aW9uCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGNvbWJpbmVXYWxrZXJzKGJhY2t3YXJkV2Fsa2VyLCBmb3J3YXJkV2Fsa2VyKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IChfc3RlcDUgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGRhdGEgPSBfc3RlcDUudmFsdWU7CiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEud2Fsa2VyID09IGJhY2t3YXJkV2Fsa2VyID8gJ2VsZW1lbnRFbmQnIDogJ2VsZW1lbnRTdGFydCc7CiAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlOwoKICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IHR5cGUgJiYgdGhpcy5pc09iamVjdCh2YWx1ZS5pdGVtKSkgewogICAgICAgICAgICByZXR1cm4gUmFuZ2UuX2NyZWF0ZU9uKHZhbHVlLml0ZW0pOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2hpbGQodmFsdWUubmV4dFBvc2l0aW9uLCAnJHRleHQnKSkgewogICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHZhbHVlLm5leHRQb3NpdGlvbik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFRyaWVzIHRvIGZpbmQgcG9zaXRpb24gYW5jZXN0b3JzIHRoYXQgYWxsb3dzIHRvIGluc2VydCBnaXZlbiBub2RlLgogICAgICogSXQgc3RhcnRzIHNlYXJjaGluZyBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgZ29lcyBub2RlIGJ5IG5vZGUgdG8gdGhlIHRvcCBvZiB0aGUgbW9kZWwgdHJlZQogICAgICogYXMgbG9uZyBhcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgbGltaXQgZWxlbWVudH0sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzT2JqZWN0IG9iamVjdCBlbGVtZW50fSBvciB0b3AtbW9zdCBhbmNlc3RvciB3b24ndCBiZSByZWFjaGVkLgogICAgICoKICAgICAqIEBwYXJhbXMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIGZyb20gc2VhcmNoaW5nIHdpbGwgc3RhcnQuCiAgICAgKiBAcGFyYW1zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxTdHJpbmd9IG5vZGUgTm9kZSBmb3Igd2hpY2ggYWxsb3dlZCBwYXJlbnQgc2hvdWxkIGJlIGZvdW5kIG9yIGl0cyBuYW1lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG51bGx9IGVsZW1lbnQgQWxsb3dlZCBwYXJlbnQgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmaW5kQWxsb3dlZFBhcmVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEFsbG93ZWRQYXJlbnQocG9zaXRpb24sIG5vZGUpIHsKICAgICAgdmFyIHBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsKCiAgICAgIHdoaWxlIChwYXJlbnQpIHsKICAgICAgICBpZiAodGhpcy5jaGVja0NoaWxkKHBhcmVudCwgbm9kZSkpIHsKICAgICAgICAgIHJldHVybiBwYXJlbnQ7CiAgICAgICAgfSAvLyBEbyBub3Qgc3BsaXQgbGltaXQgZWxlbWVudHMuCgoKICAgICAgICBpZiAodGhpcy5pc0xpbWl0KHBhcmVudCkpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYXR0cmlidXRlcyBkaXNhbGxvd2VkIGJ5IHRoZSBzY2hlbWEuCiAgICAgKgogICAgICogQHBhcmFtIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBub2RlcyBOb2RlcyB0aGF0IHdpbGwgYmUgZmlsdGVyZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZURpc2FsbG93ZWRBdHRyaWJ1dGVzKG5vZGVzLCB3cml0ZXIpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gbm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHsKICAgICAgICAgIHZhciBub2RlID0gX3N0ZXA2LnZhbHVlOwoKICAgICAgICAgIC8vIFdoZW4gbm9kZSBpcyBhIGBUZXh0YCBpdCBoYXMgbm8gY2hpbGRyZW4sIHNvIGp1c3QgZmlsdGVyIGl0IG91dC4KICAgICAgICAgIGlmIChub2RlLmlzKCd0ZXh0JykpIHsKICAgICAgICAgICAgcmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZUZyb21Ob2RlKHRoaXMsIG5vZGUsIHdyaXRlcik7CiAgICAgICAgICB9IC8vIEluIGEgY2FzZSBvZiBgRWxlbWVudGAgaXRlcmF0ZXMgdGhyb3VnaCBwb3NpdGlvbnMgYmV0d2VlbiBub2RlcyBpbnNpZGUgdGhpcyBlbGVtZW50CiAgICAgICAgICAvLyBhbmQgZmlsdGVyIG91dCBub2RlIGJlZm9yZSB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgcG9zaXRpb24gcGFyZW50IHdoZW4gcG9zaXRpb24KICAgICAgICAgIC8vIGlzIGF0IHN0YXJ0IG9mIGFuIGVsZW1lbnQuIFVzaW5nIHBvc2l0aW9ucyBwcmV2ZW50IGZyb20gb21pdHRpbmcgbWVyZ2VkIG5vZGVzCiAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzE3ODkuCiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgcmFuZ2VJbk5vZGUgPSBSYW5nZS5fY3JlYXRlSW4obm9kZSk7CgogICAgICAgICAgICAgIHZhciBwb3NpdGlvbnNJblJhbmdlID0gcmFuZ2VJbk5vZGUuZ2V0UG9zaXRpb25zKCk7CiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTsKICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7CiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBwb3NpdGlvbnNJblJhbmdlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF9zdGVwNy52YWx1ZTsKICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBwb3NpdGlvbi5ub2RlQmVmb3JlIHx8IHBvc2l0aW9uLnBhcmVudDsKICAgICAgICAgICAgICAgICAgcmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZUZyb21Ob2RlKHRoaXMsIGl0ZW0sIHdyaXRlcik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlOwogICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I3ID0gZXJyOwogICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I3OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBzY2hlbWEgY29udGV4dC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBjb250ZXh0CiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVDb250ZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGNvbnRleHQpIHsKICAgICAgcmV0dXJuIG5ldyBTY2hlbWFDb250ZXh0KGNvbnRleHQpOwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jbGVhckNhY2hlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYXJDYWNoZSgpIHsKICAgICAgdGhpcy5fY29tcGlsZWREZWZpbml0aW9ucyA9IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NvbXBpbGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jb21waWxlKCkgewogICAgICB2YXIgY29tcGlsZWREZWZpbml0aW9ucyA9IHt9OwogICAgICB2YXIgc291cmNlUnVsZXMgPSB0aGlzLl9zb3VyY2VEZWZpbml0aW9uczsKICAgICAgdmFyIGl0ZW1OYW1lcyA9IE9iamVjdC5rZXlzKHNvdXJjZVJ1bGVzKTsKCiAgICAgIGZvciAodmFyIF9pID0gMCwgX2l0ZW1OYW1lcyA9IGl0ZW1OYW1lczsgX2kgPCBfaXRlbU5hbWVzLmxlbmd0aDsgX2krKykgewogICAgICAgIHZhciBpdGVtTmFtZSA9IF9pdGVtTmFtZXNbX2ldOwogICAgICAgIGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdID0gY29tcGlsZUJhc2VJdGVtUnVsZShzb3VyY2VSdWxlc1tpdGVtTmFtZV0sIGl0ZW1OYW1lKTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2l0ZW1OYW1lczIgPSBpdGVtTmFtZXM7IF9pMiA8IF9pdGVtTmFtZXMyLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICB2YXIgX2l0ZW1OYW1lID0gX2l0ZW1OYW1lczJbX2kyXTsKICAgICAgICBjb21waWxlQWxsb3dDb250ZW50T2YoY29tcGlsZWREZWZpbml0aW9ucywgX2l0ZW1OYW1lKTsKICAgICAgfQoKICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2l0ZW1OYW1lczMgPSBpdGVtTmFtZXM7IF9pMyA8IF9pdGVtTmFtZXMzLmxlbmd0aDsgX2kzKyspIHsKICAgICAgICB2YXIgX2l0ZW1OYW1lMiA9IF9pdGVtTmFtZXMzW19pM107CiAgICAgICAgY29tcGlsZUFsbG93V2hlcmUoY29tcGlsZWREZWZpbml0aW9ucywgX2l0ZW1OYW1lMik7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9pdGVtTmFtZXM0ID0gaXRlbU5hbWVzOyBfaTQgPCBfaXRlbU5hbWVzNC5sZW5ndGg7IF9pNCsrKSB7CiAgICAgICAgdmFyIF9pdGVtTmFtZTMgPSBfaXRlbU5hbWVzNFtfaTRdOwogICAgICAgIGNvbXBpbGVBbGxvd0F0dHJpYnV0ZXNPZihjb21waWxlZERlZmluaXRpb25zLCBfaXRlbU5hbWUzKTsKICAgICAgICBjb21waWxlSW5oZXJpdFByb3BlcnRpZXNGcm9tKGNvbXBpbGVkRGVmaW5pdGlvbnMsIF9pdGVtTmFtZTMpOwogICAgICB9CgogICAgICBmb3IgKHZhciBfaTUgPSAwLCBfaXRlbU5hbWVzNSA9IGl0ZW1OYW1lczsgX2k1IDwgX2l0ZW1OYW1lczUubGVuZ3RoOyBfaTUrKykgewogICAgICAgIHZhciBfaXRlbU5hbWU0ID0gX2l0ZW1OYW1lczVbX2k1XTsKICAgICAgICBjbGVhblVwQWxsb3dJbihjb21waWxlZERlZmluaXRpb25zLCBfaXRlbU5hbWU0KTsKICAgICAgICBjbGVhblVwQWxsb3dBdHRyaWJ1dGVzKGNvbXBpbGVkRGVmaW5pdGlvbnMsIF9pdGVtTmFtZTQpOwogICAgICB9CgogICAgICB0aGlzLl9jb21waWxlZERlZmluaXRpb25zID0gY29tcGlsZWREZWZpbml0aW9uczsKICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbn0gZGVmCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IGNvbnRleHQKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb250ZXh0SXRlbUluZGV4CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NoZWNrQ29udGV4dE1hdGNoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tDb250ZXh0TWF0Y2goZGVmLCBjb250ZXh0KSB7CiAgICAgIHZhciBjb250ZXh0SXRlbUluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBjb250ZXh0Lmxlbmd0aCAtIDE7CiAgICAgIHZhciBjb250ZXh0SXRlbSA9IGNvbnRleHQuZ2V0SXRlbShjb250ZXh0SXRlbUluZGV4KTsKCiAgICAgIGlmIChkZWYuYWxsb3dJbi5pbmNsdWRlcyhjb250ZXh0SXRlbS5uYW1lKSkgewogICAgICAgIGlmIChjb250ZXh0SXRlbUluZGV4ID09IDApIHsKICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgcGFyZW50UnVsZSA9IHRoaXMuZ2V0RGVmaW5pdGlvbihjb250ZXh0SXRlbSk7CiAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tDb250ZXh0TWF0Y2gocGFyZW50UnVsZSwgY29udGV4dCwgY29udGV4dEl0ZW1JbmRleCAtIDEpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogVGFrZXMgYSBmbGF0IHJhbmdlIGFuZCBhbiBhdHRyaWJ1dGUgbmFtZS4gVHJhdmVyc2VzIHRoZSByYW5nZSByZWN1cnNpdmVseSBhbmQgZGVlcGx5IHRvIGZpbmQgYW5kIHJldHVybiBhbGwgcmFuZ2VzCiAgICAgKiBpbnNpZGUgdGhlIGdpdmVuIHJhbmdlIG9uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgY2FuIGJlIGFwcGxpZWQuCiAgICAgKgogICAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3Ige0BsaW5rIH5TY2hlbWEjZ2V0VmFsaWRSYW5nZXN9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIHByb2Nlc3MuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY2hlY2suCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSYW5nZXMgaW4gd2hpY2ggdGhlIGF0dHJpYnV0ZSBpcyBhbGxvd2VkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRWYWxpZFJhbmdlc0ZvclJhbmdlIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgICB2YXIgc3RhcnQsIGVuZCwgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjgsIF9kaWRJdGVyYXRvckVycm9yOCwgX2l0ZXJhdG9yRXJyb3I4LCBfaXRlcmF0b3I4LCBfc3RlcDgsIGl0ZW07CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UkKF9jb250ZXh0MykgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7CiAgICAgICAgICAgICAgZW5kID0gcmFuZ2Uuc3RhcnQ7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yOCA9IHJhbmdlLmdldEl0ZW1zKHsKICAgICAgICAgICAgICAgIHNoYWxsb3c6IHRydWUKICAgICAgICAgICAgICB9KVtTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIwOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBpdGVtID0gX3N0ZXA4LnZhbHVlOwoKICAgICAgICAgICAgICBpZiAoIWl0ZW0uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5kZWxlZ2F0ZVlpZWxkKHRoaXMuX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UoUmFuZ2UuX2NyZWF0ZUluKGl0ZW0pLCBhdHRyaWJ1dGUpLCAidDAiLCAxMSk7CgogICAgICAgICAgICBjYXNlIDExOgogICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQXR0cmlidXRlKGl0ZW0sIGF0dHJpYnV0ZSkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGlmIChzdGFydC5pc0VxdWFsKGVuZCkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTU7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKCiAgICAgICAgICAgIGNhc2UgMTU6CiAgICAgICAgICAgICAgc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoaXRlbSk7CgogICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgIGVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBZnRlcihpdGVtKTsKCiAgICAgICAgICAgIGNhc2UgMTc6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNzsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMjA6CiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNjsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyMjsKICAgICAgICAgICAgICBfY29udGV4dDMudDEgPSBfY29udGV4dDNbImNhdGNoIl0oNSk7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBfY29udGV4dDMudDE7CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjY7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyNzsKCiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCAmJiBfaXRlcmF0b3I4LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3I4LnJldHVybigpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgMjk6CiAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyOTsKCiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjgpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzI7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yODsKCiAgICAgICAgICAgIGNhc2UgMzI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjkpOwoKICAgICAgICAgICAgY2FzZSAzMzoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgyNik7CgogICAgICAgICAgICBjYXNlIDM0OgogICAgICAgICAgICAgIGlmIChzdGFydC5pc0VxdWFsKGVuZCkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzc7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzc7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKCiAgICAgICAgICAgIGNhc2UgMzc6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBfZ2V0VmFsaWRSYW5nZXNGb3JSYW5nZSwgdGhpcywgW1s1LCAyMiwgMjYsIDM0XSwgWzI3LCwgMjksIDMzXV0pOwogICAgfSkKICB9XSk7CgogIHJldHVybiBTY2hlbWE7Cn0oKTsKCmV4cG9ydCB7IFNjaGVtYSBhcyBkZWZhdWx0IH07Cm1peChTY2hlbWEsIE9ic2VydmFibGVNaXhpbik7Ci8qKgogKiBFdmVudCBmaXJlZCB3aGVuIHRoZSB7QGxpbmsgI2NoZWNrQ2hpbGR9IG1ldGhvZCBpcyBjYWxsZWQuIEl0IGFsbG93cyBwbHVnZ2luZyBpbgogKiBhZGRpdGlvbmFsIGJlaGF2aW9yIOKAkyBlLmcuIGltcGxlbWVudGluZyBydWxlcyB3aGljaCBjYW5ub3QgYmUgZGVmaW5lZCB1c2luZyB0aGUgZGVjbGFyYXRpdmUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSBpbnRlcmZhY2UuCiAqCiAqICoqTm90ZToqKiBUaGUge0BsaW5rICNhZGRDaGlsZENoZWNrfSBtZXRob2QgaXMgYSBtb3JlIGhhbmR5IHdheSB0byByZWdpc3RlciBjYWxsYmFja3MuIEludGVybmFsbHksCiAqIGl0IHJlZ2lzdGVycyBhIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgYnV0IGNvbWVzIHdpdGggYSBzaW1wbGVyIEFQSSBhbmQgaXQgaXMgdGhlIHJlY29tbWVuZGVkIGNob2ljZQogKiBpbiBtb3N0IG9mIHRoZSBjYXNlcy4KICoKICogVGhlIHtAbGluayAjY2hlY2tDaGlsZH0gbWV0aG9kIGZpcmVzIGFuIGV2ZW50IGJlY2F1c2UgaXQgaXMKICoge0BsaW5rIG1vZHVsZTp1dGlscy9vYnNlcnZhYmxlbWl4aW5+T2JzZXJ2YWJsZU1peGluI2RlY29yYXRlIGRlY29yYXRlZH0gd2l0aCBpdC4gVGhhbmtzIHRvIHRoYXQgeW91IGNhbgogKiB1c2UgdGhpcyBldmVudCBpbiBhIHZhcmlvdXMgd2F5LCBidXQgdGhlIG1vc3QgaW1wb3J0YW50IHVzZSBjYXNlIGlzIG92ZXJyaWRpbmcgc3RhbmRhcmQgYmVoYXZpb3VyIG9mIHRoZQogKiBgY2hlY2tDaGlsZCgpYCBtZXRob2QuIExldCdzIHNlZSBhIHR5cGljYWwgbGlzdGVuZXIgdGVtcGxhdGU6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBjaGlsZERlZmluaXRpb24gPSBhcmdzWyAxIF07CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCBhIGBoaWdoYCBwcmlvcml0eSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGRlZmF1bHQgbWV0aG9kIGlzIHJlYWxseSBjYWxsZWQuIFRoZSBgYXJnc2AgY2FsbGJhY2sKICogcGFyYW1ldGVyIGNvbnRhaW5zIGFyZ3VtZW50cyBwYXNzZWQgdG8gYGNoZWNrQ2hpbGQoIGNvbnRleHQsIGNoaWxkIClgLiBIb3dldmVyLCB0aGUgYGNvbnRleHRgIHBhcmFtZXRlciBpcyBhbHJlYWR5CiAqIG5vcm1hbGl6ZWQgdG8gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gaW5zdGFuY2UgYW5kIGBjaGlsZGAgdG8gYQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbn0gaW5zdGFuY2UsIHNvIHlvdSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0CiAqIHRoZSB2YXJpb3VzIHdheXMgaG93IGBjb250ZXh0YCBhbmQgYGNoaWxkYCBtYXkgYmUgcGFzc2VkIHRvIGBjaGVja0NoaWxkKClgLgogKgogKiAqKk5vdGU6KiogYGNoaWxkRGVmaW5pdGlvbmAgbWF5IGJlIGB1bmRlZmluZWRgIGlmIGBjaGVja0NoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBhIG5vbi1yZWdpc3RlcmVkIGVsZW1lbnQuCiAqCiAqIFNvLCBpbiBvcmRlciB0byBpbXBsZW1lbnQgYSBydWxlICJkaXNhbGxvdyBgaGVhZGluZzFgIGluIGBibG9ja1F1b3RlYCIgeW91IGNhbiBhZGQgc3VjaCBhIGxpc3RlbmVyOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgY2hpbGREZWZpbml0aW9uID0gYXJnc1sgMSBdOwogKgogKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2Jsb2NrUXVvdGUnICkgJiYgY2hpbGREZWZpbml0aW9uICYmIGNoaWxkRGVmaW5pdGlvbi5uYW1lID09ICdoZWFkaW5nMScgKSB7CiAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAqCQkJCWV2dC5zdG9wKCk7CiAqCQkJCS8vIFNldCB0aGUgY2hlY2tDaGlsZCgpJ3MgcmV0dXJuIHZhbHVlLgogKgkJCQlldnQucmV0dXJuID0gZmFsc2U7CiAqCQkJfQogKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICoKICogQWxsb3dpbmcgZWxlbWVudHMgaW4gc3BlY2lmaWMgY29udGV4dHMgd2lsbCBiZSBhIGZhciBsZXNzIGNvbW1vbiB1c2UgY2FzZSwgYmVjYXVzZSBpdCdzIG5vcm1hbGx5IGhhbmRsZWQgYnkKICogYGFsbG93SW5gIHJ1bGUgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGJ1dCBpZiB5b3UgaGF2ZSBhIGNvbXBsZXggc2NlbmFyaW8KICogd2hlcmUgYGxpc3RJdGVtYCBzaG91bGQgYmUgYWxsb3dlZCBvbmx5IGluIGVsZW1lbnQgYGZvb2Agd2hpY2ggbXVzdCBiZSBpbiBlbGVtZW50IGBiYXJgLCB0aGVuIHRoaXMgd291bGQgYmUgdGhlIHdheToKICoKICoJCXNjaGVtYS5vbiggJ2NoZWNrQ2hpbGQnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGNoaWxkRGVmaW5pdGlvbiA9IGFyZ3NbIDEgXTsKICoKICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdiYXIgZm9vJyApICYmIGNoaWxkRGVmaW5pdGlvbi5uYW1lID09ICdsaXN0SXRlbScgKSB7CiAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAqCQkJCWV2dC5zdG9wKCk7CiAqCQkJCS8vIFNldCB0aGUgY2hlY2tDaGlsZCgpJ3MgcmV0dXJuIHZhbHVlLgogKgkJCQlldnQucmV0dXJuID0gdHJ1ZTsKICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBAZXZlbnQgY2hlY2tDaGlsZAogKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBgY2hlY2tDaGlsZCgpYCdzIGFyZ3VtZW50cy4KICovCgovKioKICogRXZlbnQgZmlyZWQgd2hlbiB0aGUge0BsaW5rICNjaGVja0F0dHJpYnV0ZX0gbWV0aG9kIGlzIGNhbGxlZC4gSXQgYWxsb3dzIHBsdWdnaW5nIGluCiAqIGFkZGl0aW9uYWwgYmVoYXZpb3Ig4oCTIGUuZy4gaW1wbGVtZW50aW5nIHJ1bGVzIHdoaWNoIGNhbm5vdCBiZSBkZWZpbmVkIHVzaW5nIHRoZSBkZWNsYXJhdGl2ZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGludGVyZmFjZS4KICoKICogKipOb3RlOioqIFRoZSB7QGxpbmsgI2FkZEF0dHJpYnV0ZUNoZWNrfSBtZXRob2QgaXMgYSBtb3JlIGhhbmR5IHdheSB0byByZWdpc3RlciBjYWxsYmFja3MuIEludGVybmFsbHksCiAqIGl0IHJlZ2lzdGVycyBhIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgYnV0IGNvbWVzIHdpdGggYSBzaW1wbGVyIEFQSSBhbmQgaXQgaXMgdGhlIHJlY29tbWVuZGVkIGNob2ljZQogKiBpbiBtb3N0IG9mIHRoZSBjYXNlcy4KICoKICogVGhlIHtAbGluayAjY2hlY2tBdHRyaWJ1dGV9IG1ldGhvZCBmaXJlcyBhbiBldmVudCBiZWNhdXNlIGl0J3MKICoge0BsaW5rIG1vZHVsZTp1dGlscy9vYnNlcnZhYmxlbWl4aW5+T2JzZXJ2YWJsZU1peGluI2RlY29yYXRlIGRlY29yYXRlZH0gd2l0aCBpdC4gVGhhbmtzIHRvIHRoYXQgeW91IGNhbgogKiB1c2UgdGhpcyBldmVudCBpbiBhIHZhcmlvdXMgd2F5LCBidXQgdGhlIG1vc3QgaW1wb3J0YW50IHVzZSBjYXNlIGlzIG92ZXJyaWRpbmcgc3RhbmRhcmQgYmVoYXZpb3VyIG9mIHRoZQogKiBgY2hlY2tBdHRyaWJ1dGUoKWAgbWV0aG9kLiBMZXQncyBzZWUgYSB0eXBpY2FsIGxpc3RlbmVyIHRlbXBsYXRlOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tBdHRyaWJ1dGUnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhcmdzWyAxIF07CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCBhIGBoaWdoYCBwcmlvcml0eSB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGRlZmF1bHQgbWV0aG9kIGlzIHJlYWxseSBjYWxsZWQuIFRoZSBgYXJnc2AgY2FsbGJhY2sKICogcGFyYW1ldGVyIGNvbnRhaW5zIGFyZ3VtZW50cyBwYXNzZWQgdG8gYGNoZWNrQXR0cmlidXRlKCBjb250ZXh0LCBhdHRyaWJ1dGVOYW1lIClgLiBIb3dldmVyLCB0aGUgYGNvbnRleHRgIHBhcmFtZXRlciBpcyBhbHJlYWR5CiAqIG5vcm1hbGl6ZWQgdG8gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gaW5zdGFuY2UsIHNvIHlvdSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0CiAqIHRoZSB2YXJpb3VzIHdheXMgaG93IGBjb250ZXh0YCBtYXkgYmUgcGFzc2VkIHRvIGBjaGVja0F0dHJpYnV0ZSgpYC4KICoKICogU28sIGluIG9yZGVyIHRvIGltcGxlbWVudCBhIHJ1bGUgImRpc2FsbG93IGBib2xkYCBpbiBhIHRleHQgd2hpY2ggaXMgaW4gYSBgaGVhZGluZzFgIHlvdSBjYW4gYWRkIHN1Y2ggYSBsaXN0ZW5lcjoKICoKICoJCXNjaGVtYS5vbiggJ2NoZWNrQXR0cmlidXRlJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBhdHJpYnV0ZU5hbWUgPSBhcmdzWyAxIF07CiAqCiAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnaGVhZGluZzEgJHRleHQnICkgJiYgYXR0cmlidXRlTmFtZSA9PSAnYm9sZCcgKSB7CiAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAqCQkJCWV2dC5zdG9wKCk7CiAqCQkJCS8vIFNldCB0aGUgY2hlY2tBdHRyaWJ1dGUoKSdzIHJldHVybiB2YWx1ZS4KICoJCQkJZXZ0LnJldHVybiA9IGZhbHNlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEFsbG93aW5nIGF0dHJpYnV0ZXMgaW4gc3BlY2lmaWMgY29udGV4dHMgd2lsbCBiZSBhIGZhciBsZXNzIGNvbW1vbiB1c2UgY2FzZSwgYmVjYXVzZSBpdCdzIG5vcm1hbGx5IGhhbmRsZWQgYnkKICogYGFsbG93QXR0cmlidXRlc2AgcnVsZSBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gYnV0IGlmIHlvdSBoYXZlIGEgY29tcGxleCBzY2VuYXJpbwogKiB3aGVyZSBgYm9sZGAgc2hvdWxkIGJlIGFsbG93ZWQgb25seSBpbiBlbGVtZW50IGBmb29gIHdoaWNoIG11c3QgYmUgaW4gZWxlbWVudCBgYmFyYCwgdGhlbiB0aGlzIHdvdWxkIGJlIHRoZSB3YXk6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0F0dHJpYnV0ZScsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgYXRyaWJ1dGVOYW1lID0gYXJnc1sgMSBdOwogKgogKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2JhciBmb28gJHRleHQnICkgJiYgYXR0cmlidXRlTmFtZSA9PSAnYm9sZCcgKSB7CiAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAqCQkJCWV2dC5zdG9wKCk7CiAqCQkJCS8vIFNldCB0aGUgY2hlY2tBdHRyaWJ1dGUoKSdzIHJldHVybiB2YWx1ZS4KICoJCQkJZXZ0LnJldHVybiA9IHRydWU7CiAqCQkJfQogKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICoKICogQGV2ZW50IGNoZWNrQXR0cmlidXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGBjaGVja0F0dHJpYnV0ZSgpYCdzIGFyZ3VtZW50cy4KICovCgovKioKICogQSBkZWZpbml0aW9uIG9mIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IGl0ZW0uCiAqCiAqIFlvdSBjYW4gZGVmaW5lIHRoZSBmb2xsb3dpbmcgcnVsZXM6CiAqCiAqICogYGFsbG93SW5gICZuZGFzaDsgQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gRGVmaW5lcyBpbiB3aGljaCBvdGhlciBpdGVtcyB0aGlzIGl0ZW0gd2lsbCBiZSBhbGxvd2VkLgogKiAqIGBhbGxvd0F0dHJpYnV0ZXNgICZuZGFzaDsgQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gRGVmaW5lcyBhbGxvd2VkIGF0dHJpYnV0ZXMgb2YgdGhlIGdpdmVuIGl0ZW0uCiAqICogYGFsbG93Q29udGVudE9mYCAmbmRhc2g7IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIEluaGVyaXRzICJhbGxvd2VkIGNoaWxkcmVuIiBmcm9tIG90aGVyIGl0ZW1zLgogKiAqIGBhbGxvd1doZXJlYCAmbmRhc2g7IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIEluaGVyaXRzICJhbGxvd2VkIGluIiBmcm9tIG90aGVyIGl0ZW1zLgogKiAqIGBhbGxvd0F0dHJpYnV0ZXNPZmAgJm5kYXNoOyBBIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLiBJbmhlcml0cyBhdHRyaWJ1dGVzIGZyb20gb3RoZXIgaXRlbXMuCiAqICogYGluaGVyaXRUeXBlc0Zyb21gICZuZGFzaDsgQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gSW5oZXJpdHMgYGlzKmAgcHJvcGVydGllcyBvZiBvdGhlciBpdGVtcy4KICogKiBgaW5oZXJpdEFsbEZyb21gICZuZGFzaDsgQSBzdHJpbmcuIEEgc2hvcnRoYW5kIGZvciBgYWxsb3dDb250ZW50T2ZgLCBgYWxsb3dXaGVyZWAsIGBhbGxvd0F0dHJpYnV0ZXNPZmAsIGBpbmhlcml0VHlwZXNGcm9tYC4KICogKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gZGVmaW5lIHRoZSBmb2xsb3dpbmcgYGlzKmAgcHJvcGVydGllczogYGlzQmxvY2tgLCBgaXNMaW1pdGAsIGBpc09iamVjdGAsIGBpc0lubGluZWAuIFJlYWQgYWJvdXQgdGhlbSBiZWxvdy4KICoKICogIyBUaGUgaXMqIHByb3BlcnRpZXMKICoKICogVGhlcmUgYXJlIDMgY29tbW9ubHkgdXNlZCBgaXMqYCBwcm9wZXJ0aWVzLiBUaGVpciByb2xlIGlzIHRvIGFzc2lnbiBhZGRpdGlvbmFsIHNlbWFudGljcyB0byBzY2hlbWEgaXRlbXMuCiAqIFlvdSBjYW4gZGVmaW5lIG1vcmUgcHJvcGVydGllcyBidXQgeW91IHdpbGwgYWxzbyBuZWVkIHRvIGltcGxlbWVudCBzdXBwb3J0IGZvciB0aGVtIGluIHRoZSBleGlzdGluZyBlZGl0b3IgZmVhdHVyZXMuCiAqCiAqICogYGlzQmxvY2tgICZuZGFzaDsgV2hldGhlciB0aGlzIGl0ZW0gaXMgcGFyYWdyYXBoLWxpa2UuIEdlbmVyYWxseSBzcGVha2luZywgY29udGVudCBpcyB1c3VhbGx5IG1hZGUgb3V0IG9mIGJsb2NrcwogKiBsaWtlIHBhcmFncmFwaHMsIGxpc3QgaXRlbXMsIGltYWdlcywgaGVhZGluZ3MsIGV0Yy4gQWxsIHRoZXNlIGVsZW1lbnRzIGFyZSBtYXJrZWQgYXMgYmxvY2tzLiBBIGJsb2NrCiAqIHNob3VsZCBub3QgYWxsb3cgYW5vdGhlciBibG9jayBpbnNpZGUuIE5vdGU6IFRoZXJlIGlzIGFsc28gdGhlIGAkYmxvY2tgIGdlbmVyaWMgaXRlbSB3aGljaCBoYXMgYGlzQmxvY2tgIHNldCB0byBgdHJ1ZWAuCiAqIE1vc3QgYmxvY2sgdHlwZSBpdGVtcyB3aWxsIGluaGVyaXQgZnJvbSBgJGJsb2NrYCAodGhyb3VnaCBgaW5oZXJpdEFsbEZyb21gKS4KICogKiBgaXNMaW1pdGAgJm5kYXNoOyBJdCBjYW4gYmUgdW5kZXJzdG9vZCBhcyB3aGV0aGVyIHRoaXMgZWxlbWVudCBzaG91bGQgbm90IGJlIHNwbGl0IGJ5IDxrYmQ+RW50ZXI8L2tiZD4uCiAqIEV4YW1wbGVzIG9mIGxpbWl0IGVsZW1lbnRzOiBgJHJvb3RgLCB0YWJsZSBjZWxsLCBpbWFnZSBjYXB0aW9uLCBldGMuIEluIG90aGVyIHdvcmRzLCBhbGwgYWN0aW9ucyB0aGF0IGhhcHBlbiBpbnNpZGUKICogYSBsaW1pdCBlbGVtZW50IGFyZSBsaW1pdGVkIHRvIGl0cyBjb250ZW50LiAqKk5vdGU6KiogQWxsIG9iamVjdHMgKGBpc09iamVjdGApIGFyZSB0cmVhdGVkIGFzIGxpbWl0IGVsZW1lbnRzLCB0b28uCiAqICogYGlzT2JqZWN0YCAmbmRhc2g7IFdoZXRoZXIgYW4gaXRlbSBpcyAic2VsZi1jb250YWluZWQiIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHdob2xlLiBFeGFtcGxlcyBvZiBvYmplY3QgZWxlbWVudHM6CiAqIGBpbWFnZWAsIGB0YWJsZWAsIGB2aWRlb2AsIGV0Yy4gKipOb3RlOioqIEFuIG9iamVjdCBpcyBhbHNvIGEgbGltaXQsIHNvCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNMaW1pdCBgaXNMaW1pdCgpYH0gcmV0dXJucyBgdHJ1ZWAgZm9yIG9iamVjdCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5LgogKiAqIGBpc0lubGluZWAgJm5kYXNoOyBXaGV0aGVyIGFuIGl0ZW0gaXMgInRleHQtbGlrZSIgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFuIGlubGluZSBub2RlLiBFeGFtcGxlcyBvZiBpbmxpbmUgZWxlbWVudHM6CiAqIGAkdGV4dGAsIGBzb2Z0QnJlYWtgIChgPGJyPmApLCBldGMuCiAqCiAqICMgR2VuZXJpYyBpdGVtcwogKgogKiBUaGVyZSBhcmUgdGhyZWUgYmFzaWMgZ2VuZXJpYyBpdGVtczogYCRyb290YCwgYCRibG9ja2AgYW5kIGAkdGV4dGAuCiAqIFRoZXkgYXJlIGRlZmluZWQgYXMgZm9sbG93czoKICoKICoJCXRoaXMuc2NoZW1hLnJlZ2lzdGVyKCAnJHJvb3QnLCB7CiAqCQkJaXNMaW1pdDogdHJ1ZQogKgkJfSApOwogKgkJdGhpcy5zY2hlbWEucmVnaXN0ZXIoICckYmxvY2snLCB7CiAqCQkJYWxsb3dJbjogJyRyb290JywKICoJCQlpc0Jsb2NrOiB0cnVlCiAqCQl9ICk7CiAqCQl0aGlzLnNjaGVtYS5yZWdpc3RlciggJyR0ZXh0JywgewogKgkJCWFsbG93SW46ICckYmxvY2snLAogKgkJCWlzSW5saW5lOiB0cnVlCiAqCQl9ICk7CiAqCiAqIFRoZXkgcmVmbGVjdCB0eXBpY2FsIGVkaXRvciBjb250ZW50IHRoYXQgaXMgY29udGFpbmVkIHdpdGhpbiBvbmUgcm9vdCwgY29uc2lzdHMgb2Ygc2V2ZXJhbCBibG9ja3MKICogKHBhcmFncmFwaHMsIGxpc3RzIGl0ZW1zLCBoZWFkaW5ncywgaW1hZ2VzKSB3aGljaCwgaW4gdHVybiwgbWF5IGNvbnRhaW4gdGV4dCBpbnNpZGUuCiAqCiAqIEJ5IGluaGVyaXRpbmcgZnJvbSB0aGUgZ2VuZXJpYyBpdGVtcyB5b3UgY2FuIGRlZmluZSBuZXcgaXRlbXMgd2hpY2ggd2lsbCBnZXQgZXh0ZW5kZWQgYnkgb3RoZXIgZWRpdG9yIGZlYXR1cmVzLgogKiBSZWFkIG1vcmUgYWJvdXQgZ2VuZXJpYyB0eXBlcyBpbiB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2RlZXAtZGl2ZS9zY2hlbWEgRGVmaW5pbmcgc2NoZW1hfSBndWlkZS4KICoKICogIyBFeGFtcGxlIGRlZmluaXRpb25zCiAqCiAqIEFsbG93IGBwYXJhZ3JhcGhgIGluIHJvb3RzIGFuZCBibG9jayBxdW90ZXM6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAqCQkJYWxsb3dJbjogWyAnJHJvb3QnLCAnYmxvY2tRdW90ZScgXSwKICoJCQlpc0Jsb2NrOiB0cnVlCiAqCQl9ICk7CiAqCiAqIEFsbG93IGBwYXJhZ3JhcGhgIGV2ZXJ5d2hlcmUgd2hlcmUgYCRibG9ja2AgaXMgYWxsb3dlZCAoaS5lLiBpbiBgJHJvb3RgKToKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ3BhcmFncmFwaCcsIHsKICoJCQlhbGxvd1doZXJlOiAnJGJsb2NrJywKICoJCQlpc0Jsb2NrOiB0cnVlCiAqCQl9ICk7CiAqCiAqIE1ha2UgYGltYWdlYCBhIGJsb2NrIG9iamVjdCwgd2hpY2ggaXMgYWxsb3dlZCBldmVyeXdoZXJlIHdoZXJlIGAkYmxvY2tgIGlzLgogKiBBbHNvLCBhbGxvdyBgc3JjYCBhbmQgYGFsdGAgYXR0cmlidXRlcyBpbiBpdDoKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ2ltYWdlJywgewogKgkJCWFsbG93V2hlcmU6ICckYmxvY2snLAogKgkJCWFsbG93QXR0cmlidXRlczogWyAnc3JjJywgJ2FsdCcgXSwKICoJCQlpc0Jsb2NrOiB0cnVlLAogKgkJCWlzT2JqZWN0OiB0cnVlCiAqCQl9ICk7CiAqCiAqIE1ha2UgYGNhcHRpb25gIGFsbG93ZWQgaW4gYGltYWdlYCBhbmQgbWFrZSBpdCBhbGxvdyBhbGwgdGhlIGNvbnRlbnQgb2YgYCRibG9ja2BzICh1c3VhbGx5LCBgJHRleHRgKS4KICogQWxzbywgbWFyayBpdCBhcyBhIGxpbWl0IGVsZW1lbnQgc28gaXQgY2Fubm90IGJlIHNwbGl0OgogKgogKgkJc2NoZW1hLnJlZ2lzdGVyKCAnY2FwdGlvbicsIHsKICoJCQlhbGxvd0luOiAnaW1hZ2UnLAogKgkJCWFsbG93Q29udGVudE9mOiAnJGJsb2NrJywKICoJCQlpc0xpbWl0OiB0cnVlCiAqCQl9ICk7CiAqCiAqIE1ha2UgYGxpc3RJdGVtYCBpbmhlcml0IGFsbCBmcm9tIGAkYmxvY2tgIGJ1dCBhbHNvIGFsbG93IGFkZGl0aW9uYWwgYXR0cmlidXRlczoKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ2xpc3RJdGVtJywgewogKgkJCWluaGVyaXRBbGxGcm9tOiAnJGJsb2NrJywKICoJCQlhbGxvd0F0dHJpYnV0ZXM6IFsgJ2xpc3RUeXBlJywgJ2xpc3RJbmRlbnQnIF0KICoJCX0gKTsKICoKICogV2hpY2ggdHJhbnNsYXRlcyB0bzoKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ2xpc3RJdGVtJywgewogKgkJCWFsbG93V2hlcmU6ICckYmxvY2snLAogKgkJCWFsbG93Q29udGVudE9mOiAnJGJsb2NrJywKICoJCQlhbGxvd0F0dHJpYnV0ZXNPZjogJyRibG9jaycsCiAqCQkJaW5oZXJpdFR5cGVzRnJvbTogJyRibG9jaycsCiAqCQkJYWxsb3dBdHRyaWJ1dGVzOiBbICdsaXN0VHlwZScsICdsaXN0SW5kZW50JyBdCiAqCQl9ICk7CiAqCiAqICMgVGlwcwogKgogKiAqIENoZWNrIHNjaGVtYSBkZWZpbml0aW9ucyBvZiBleGlzdGluZyBmZWF0dXJlcyB0byBzZWUgaG93IHRoZXkgYXJlIGRlZmluZWQuCiAqICogSWYgeW91IHdhbnQgdG8gcHVibGlzaCB5b3VyIGZlYXR1cmUgc28gb3RoZXIgZGV2ZWxvcGVycyBjYW4gdXNlIGl0LCB0cnkgdG8gdXNlCiAqIGdlbmVyaWMgaXRlbXMgYXMgbXVjaCBhcyBwb3NzaWJsZS4KICogKiBLZWVwIHlvdXIgbW9kZWwgY2xlYW4uIExpbWl0IGl0IHRvIHRoZSBhY3R1YWwgZGF0YSBhbmQgc3RvcmUgaW5mb3JtYXRpb24gaW4gYSBub3JtYWxpemVkIHdheS4KICogKiBSZW1lbWJlciBhYm91dCBkZWZpbmluaW5nIHRoZSBgaXMqYCBwcm9wZXJ0aWVzLiBUaGV5IGRvIG5vdCBhZmZlY3QgdGhlIGFsbG93ZWQgc3RydWN0dXJlcywgYnV0IHRoZXkgY2FuCiAqIGFmZmVjdCBob3cgdGhlIGVkaXRvciBmZWF0dXJlcyB0cmVhdCB5b3VyIGVsZW1lbnRzLgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbgogKi8KCi8qKgogKiBBIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGFmdGVyCiAqIGNvbXBpbGF0aW9uIGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0uCiAqIFJ1bGVzIGZlZCB0byB0aGUgc2NoZW1hIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjcmVnaXN0ZXJ9CiAqIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2V4dGVuZH0gbWV0aG9kcyBhcmUgZGVmaW5lZCBpbiB0aGUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSBmb3JtYXQuCiAqIExhdGVyIG9uLCB0aGV5IGFyZSBjb21waWxlZCB0byBgU2NoZW1hQ29tcGlsZWRJdGVtRGVmaXRpb25gIHNvIHdoZW4geW91IHVzZSBlLmcuCiAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2dldERlZmluaXRpb259IG1ldGhvZCB5b3UgZ2V0IHRoZSBjb21waWxlZCB2ZXJzaW9uLgogKgogKiBUaGUgY29tcGlsZWQgdmVyc2lvbiBjb250YWlucyBvbmx5IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoKICoKICogKiBUaGUgYG5hbWVgIHByb3BlcnR5LAogKiAqIFRoZSBgaXMqYCBwcm9wZXJ0aWVzLAogKiAqIFRoZSBgYWxsb3dJbmAgYXJyYXksCiAqICogVGhlIGBhbGxvd0F0dHJpYnV0ZXNgIGFycmF5LgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9uCiAqLwoKLyoqCiAqIEEgc2NoZW1hIGNvbnRleHQgJm1kYXNoOyBhIGxpc3Qgb2YgYW5jZXN0b3JzIG9mIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LgogKgogKiBDb25zaWRlcmluZyBzdWNoIHBvc2l0aW9uOgogKgogKgkJPCRyb290PgogKgkJCTxibG9ja1F1b3RlPgogKgkJCQk8cGFyYWdyYXBoPgogKgkJCQkJXgogKgkJCQk8L3BhcmFncmFwaD4KICoJCQk8L2Jsb2NrUXVvdGU+CiAqCQk8LyRyb290PgogKgogKiBUaGUgY29udGV4dCBvZiB0aGlzIHBvc2l0aW9uIGlzIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNnZXRBbmNlc3RvcnMgbGlzdHMgb2YgYW5jZXN0b3JzfToKICoKICoJCVsgcm9vdEVsZW1lbnQsIGJsb2NrUXVvdGVFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50IF0KICoKICogQ29udGV4dHMgYXJlIHVzZWQgaW4gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjZXZlbnQ6Y2hlY2tDaGlsZCBgU2NoZW1hI2NoZWNrQ2hpbGRgfSBhbmQKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNldmVudDpjaGVja0F0dHJpYnV0ZSBgU2NoZW1hI2NoZWNrQXR0cmlidXRlYH0gZXZlbnRzIGFzIGEgZGVmaW5pdGlvbgogKiBvZiBhIHBsYWNlIGluIHRoZSBkb2N1bWVudCB3aGVyZSB0aGUgY2hlY2sgb2NjdXJzLiBUaGUgY29udGV4dCBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYmFzZWQgb24gdGhlIGZpcnN0IGFyZ3VtZW50cwogKiBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNjaGVja0NoaWxkIGBTY2hlbWEjY2hlY2tDaGlsZCgpYH0gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tBdHRyaWJ1dGUgYFNjaGVtYSNjaGVja0F0dHJpYnV0ZSgpYH0gbWV0aG9kcyBzbyB3aGVuCiAqIHVzaW5nIHRoZXNlIG1ldGhvZHMgeW91IG5lZWQgdG8gdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn1zLgogKi8KCmV4cG9ydCB2YXIgU2NoZW1hQ29udGV4dCA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGNvbnRleHQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBjb250ZXh0CiAgICovCiAgZnVuY3Rpb24gU2NoZW1hQ29udGV4dChjb250ZXh0KSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NoZW1hQ29udGV4dCk7CgogICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBTY2hlbWFDb250ZXh0KSB7CiAgICAgIHJldHVybiBjb250ZXh0OwogICAgfQoKICAgIGlmICh0eXBlb2YgY29udGV4dCA9PSAnc3RyaW5nJykgewogICAgICBjb250ZXh0ID0gW2NvbnRleHRdOwogICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShjb250ZXh0KSkgewogICAgICAvLyBgY29udGV4dGAgaXMgaXRlbSBvciBwb3NpdGlvbi4KICAgICAgLy8gUG9zaXRpb24jZ2V0QW5jZXN0b3JzKCkgZG9lc24ndCBhY2NlcHQgYW55IHBhcmFtZXRlcnMgYnV0IGl0IHdvcmtzIGp1c3QgZmluZSBoZXJlLgogICAgICBjb250ZXh0ID0gY29udGV4dC5nZXRBbmNlc3RvcnMoewogICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgIH0pOwogICAgfQoKICAgIGlmIChjb250ZXh0WzBdICYmIHR5cGVvZiBjb250ZXh0WzBdICE9ICdzdHJpbmcnICYmIGNvbnRleHRbMF0uaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICBjb250ZXh0LnNoaWZ0KCk7CiAgICB9CgogICAgdGhpcy5faXRlbXMgPSBjb250ZXh0Lm1hcChtYXBDb250ZXh0SXRlbSk7CiAgfQogIC8qKgogICAqIFRoZSBudW1iZXIgb2YgaXRlbXMuCiAgICoKICAgKiBAdHlwZSB7TnVtYmVyfQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFNjaGVtYUNvbnRleHQsIFt7CiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvciwKCiAgICAvKioKICAgICAqIEl0ZXJhYmxlIGludGVyZmFjZS4KICAgICAqCiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb250ZXh0IGl0ZW1zLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW0+fQogICAgICovCiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBuZXcgc2NoZW1hIGNvbnRleHQgaW5zdGFuY2Ugd2l0aCBhbiBhZGRpdGlvbmFsIGl0ZW0uCiAgICAgKgogICAgICogSXRlbSBjYW4gYmUgYWRkZWQgYXM6CiAgICAgKgogICAgICogCQljb25zdCBjb250ZXh0ID0gbmV3IFNjaGVtYUNvbnRleHQoIFsgJyRyb290JyBdICk7CiAgICAgKgogICAgICogCQkvLyBBbiBlbGVtZW50LgogICAgICogCQljb25zdCBmb29FbGVtZW50ID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdmb29FbGVtZW50JyApOwogICAgICogCQljb25zdCBuZXdDb250ZXh0ID0gY29udGV4dC5wdXNoKCBmb29FbGVtZW50ICk7IC8vIFsgJyRyb290JywgJ2Zvb0VsZW1lbnQnIF0KICAgICAqCiAgICAgKiAJCS8vIEEgdGV4dCBub2RlLgogICAgICogCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoICdmb29iYXInICk7CiAgICAgKiAJCWNvbnN0IG5ld0NvbnRleHQgPSBjb250ZXh0LnB1c2goIHRleHQgKTsgLy8gWyAnJHJvb3QnLCAnJHRleHQnIF0KICAgICAqCiAgICAgKiAJCS8vIEEgc3RyaW5nIChlbGVtZW50IG5hbWUpLgogICAgICogCQljb25zdCBuZXdDb250ZXh0ID0gY29udGV4dC5wdXNoKCAnYmFyRWxlbWVudCcgKTsgLy8gWyAnJHJvb3QnLCAnYmFyRWxlbWVudCcgXQogICAgICoKICAgICAqICoqTm90ZSoqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gdGhhdCBpcyBhbHJlYWR5IGluIHRoZSBtb2RlbCB0cmVlIHdpbGwgYmUgYWRkZWQgYXMgdGhlIG9ubHkgaXRlbQogICAgICogKHdpdGhvdXQgYW5jZXN0b3JzKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxBcnJheTxTdHJpbmd8bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGU+fSBpdGVtIEFuIGl0ZW0gdGhhdCB3aWxsIGJlIGFkZGVkCiAgICAgKiB0byB0aGUgY3VycmVudCBjb250ZXh0LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IEEgbmV3IHNjaGVtYSBjb250ZXh0IGluc3RhbmNlIHdpdGggYW4gYWRkaXRpb25hbCBpdGVtLgogICAgICovCgogIH0sIHsKICAgIGtleTogInB1c2giLAogICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2goaXRlbSkgewogICAgICB2YXIgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoW2l0ZW1dKTsKICAgICAgY3R4Ll9pdGVtcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5faXRlbXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoY3R4Ll9pdGVtcykpOwogICAgICByZXR1cm4gY3R4OwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIGFuIGl0ZW0gb24gdGhlIGdpdmVuIGluZGV4LgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJdGVtIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtKGluZGV4KSB7CiAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF07CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGl0ZW1zLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROYW1lcyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldE5hbWVzKCkgewogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0TmFtZXMkKF9jb250ZXh0NCkgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuZGVsZWdhdGVZaWVsZCh0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWU7CiAgICAgICAgICAgICAgfSksICJ0MCIsIDEpOwoKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0TmFtZXMsIHRoaXMpOwogICAgfSkKICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNvbnRleHQgZW5kcyB3aXRoIHRoZSBnaXZlbiBub2Rlcy4KICAgICAqCiAgICAgKgkJY29uc3QgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoIFsgcm9vdEVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQsIHRleHROb2RlIF0gKTsKICAgICAqCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAnJHRleHQnICk7IC8vIC0+IHRydWUKICAgICAqCQljdHguZW5kc1dpdGgoICdwYXJhZ3JhcGggJHRleHQnICk7IC8vIC0+IHRydWUKICAgICAqCQljdHguZW5kc1dpdGgoICckcm9vdCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCQljdHguZW5kc1dpdGgoICdwYXJhZ3JhcGgnICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5CiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJlbmRzV2l0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kc1dpdGgocXVlcnkpIHsKICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5nZXROYW1lcygpKS5qb2luKCcgJykuZW5kc1dpdGgocXVlcnkpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgY29udGV4dCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gbm9kZXMuCiAgICAgKgogICAgICoJCWNvbnN0IGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KCBbIHJvb3RFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50LCB0ZXh0Tm9kZSBdICk7CiAgICAgKgogICAgICoJCWN0eC5lbmRzV2l0aCggJyRyb290JyApOyAvLyAtPiB0cnVlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAnJHJvb3QgcGFyYWdyYXBoJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAnJHRleHQnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJY3R4LmVuZHNXaXRoKCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic3RhcnRzV2l0aCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRzV2l0aChxdWVyeSkgewogICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmdldE5hbWVzKCkpLmpvaW4oJyAnKS5zdGFydHNXaXRoKHF1ZXJ5KTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJsZW5ndGgiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7CiAgICB9CiAgICAvKioKICAgICAqIFRoZSBsYXN0IGl0ZW0gKHRoZSBsb3dlc3Qgbm9kZSkuCiAgICAgKgogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfQogICAgICovCgogIH0sIHsKICAgIGtleTogImxhc3QiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXTsKICAgIH0KICB9XSk7CgogIHJldHVybiBTY2hlbWFDb250ZXh0Owp9KCk7Ci8qKgogKiBUaGUgZGVmaW5pdGlvbiBvZiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0IHNjaGVtYSBjb250ZXh0fS4KICoKICogQ29udGV4dHMgY2FuIGJlIGNyZWF0ZWQgaW4gbXVsdGlwbGUgd2F5czoKICoKICogKiBCeSBkZWZpbmluZyBhICoqbm9kZSoqIOKAkyBpbiB0aGlzIGNhc2VzIHRoaXMgbm9kZSBhbmQgYWxsIGl0cyBhbmNlc3RvcnMgd2lsbCBiZSB1c2VkLgogKiAqIEJ5IGRlZmluaW5nIGEgKipwb3NpdGlvbioqIGluIHRoZSBkb2N1bWVudCDigJMgaW4gdGhpcyBjYXNlIGFsbCBpdHMgYW5jZXN0b3JzIHdpbGwgYmUgdXNlZC4KICogKiBCeSBkZWZpbmluZyBhbiAqKmFycmF5IG9mIG5vZGVzKiog4oCTIGluIHRoaXMgY2FzZSB0aGlzIGFycmF5IGRlZmluZXMgdGhlIGVudGlyZSBjb250ZXh0LgogKiAqIEJ5IGRlZmluaW5nIGEgKipuYW1lIG9mIG5vZGUqKiAtIGluIHRoaXMgY2FzZSBub2RlIHdpbGwgYmUgIm1vY2tlZCIuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCBiZWNhdXNlIGNvbnRleHQKICogd2lsbCBiZSB1bnJlYWxpc3RpYyAoZS5nLiBhdHRyaWJ1dGVzIG9mIHRoZXNlIG5vZGVzIGFyZSBub3Qgc3BlY2lmaWVkKS4gSG93ZXZlciwgYXQgdGltZXMgdGhpcyBtYXkgYmUgdGhlIG9ubHkKICogd2F5IHRvIGRlZmluZSB0aGUgY29udGV4dCAoZS5nLiB3aGVuIGNoZWNraW5nIHNvbWUgaHlwb3RoZXRpY2FsIHNpdHVhdGlvbikuCiAqICogQnkgZGVmaW5pbmcgYW4gKiphcnJheSBvZiBub2RlIG5hbWVzKiogKHBvdGVudGlhbGx5LCBtaXhlZCB3aXRoIHJlYWwgbm9kZXMpIOKAkyBUaGUgc2FtZSBhcyAqKm5hbWUgb2Ygbm9kZSoqCiAqIGJ1dCBpdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgYSBwYXRoLgogKiAqIEJ5IGRlZmluaW5nIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IGluc3RhbmNlIC0gaW4gdGhpcyBjYXNlIHRoZSBzYW1lIGluc3RhbmNlIGFzIHByb3ZpZGVkCiAqIHdpbGwgYmUgcmV0dXJuLgogKgogKiBFeGFtcGxlcyBvZiBjb250ZXh0IGRlZmluaXRpb25zIHBhc3NlZCB0byB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNjaGVja0NoaWxkIGBTY2hlbWEjY2hlY2tDaGlsZCgpYH0KICogbWV0aG9kOgogKgogKgkJLy8gQXNzdW1pbmcgdGhhdCB3ZSBoYXZlIGEgJHJvb3QgPiBibG9ja1F1b3RlID4gcGFyYWdyYXBoIHN0cnVjdHVyZSwgdGhlIGZvbGxvd2luZyBjb2RlCiAqCQkvLyB3aWxsIGNoZWNrIG5vZGUgJ2ZvbycgaW4gdGhlIGZvbGxvd2luZyBjb250ZXh0OgogKgkJLy8gWyByb290RWxlbWVudCwgYmxvY2tRdW90ZUVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXQogKgkJY29uc3QgY29udGV4dERlZmluaXRpb24gPSBwYXJhZ3JhcGhFbGVtZW50OwogKiAJCWNvbnN0IGNoaWxkVG9DaGVjayA9ICdmb28nOwogKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIGNvbnRleHREZWZpbml0aW9uLCBjaGlsZFRvQ2hlY2sgKTsKICoKICoJCS8vIEFsc28gY2hlY2sgaW4gWyByb290RWxlbWVudCwgYmxvY2tRdW90ZUVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXS4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkF0KCBwYXJhZ3JhcGhFbGVtZW50LCAwICksICdmb28nICk7CiAqCiAqCQkvLyBDaGVjayBpbiBbIHJvb3RFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50IF0uCiAqCQlzY2hlbWEuY2hlY2tDaGlsZCggWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdLCAnZm9vJyApOwogKgogKgkJLy8gQ2hlY2sgb25seSBmYWtlUGFyYWdyYXBoRWxlbWVudC4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCAncGFyYWdyYXBoJywgJ2ZvbycgKTsKICoKICoJCS8vIENoZWNrIGluIFsgZmFrZVJvb3RFbGVtZW50LCBmYWtlQmFyRWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdLgogKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIFsgJyRyb290JywgJ2JhcicsIHBhcmFncmFwaEVsZW1lbnQgXSwgJ2ZvbycgKTsKICoKICogQWxsIHRoZXNlIGBjaGVja0NoaWxkKClgIGNhbGxzIHdpbGwgZmlyZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2V2ZW50OmNoZWNrQ2hpbGQgYFNjaGVtYSNjaGVja0NoaWxkYH0KICogZXZlbnRzIGluIHdoaWNoIGBhcmdzWyAwIF1gIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjb250ZXh0LiBUaGVyZWZvcmUsIHlvdSBjYW4gd3JpdGUgYSBsaXN0ZW5lciBsaWtlIHRoaXM6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY3R4ID0gYXJnc1sgMCBdOwogKgogKgkJCWNvbnNvbGUubG9nKCBBcnJheS5mcm9tKCBjdHguZ2V0TmFtZXMoKSApICk7CiAqCQl9ICk7CiAqCiAqIFdoaWNoIHdpbGwgbG9nIHRoZSBmb2xsb3dpbmc6CiAqCiAqCQlbICckcm9vdCcsICdibG9ja1F1b3RlJywgJ3BhcmFncmFwaCcgXQogKgkJWyAnJHJvb3QnLCAncGFyYWdyYXBoJyBdCiAqCQlbICckcm9vdCcsICdiYXInLCAncGFyYWdyYXBoJyBdCiAqCiAqIE5vdGU6IFdoZW4gdXNpbmcgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tBdHRyaWJ1dGUgYFNjaGVtYSNjaGVja0F0dHJpYnV0ZSgpYH0gbWV0aG9kCiAqIHlvdSBtYXkgd2FudCB0byBjaGVjayB3aGV0aGVyIGEgdGV4dCBub2RlIG1heSBoYXZlIGFuIGF0dHJpYnV0ZS4gQSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR9IGlzIGEKICogY29ycmVjdCB3YXkgdG8gZGVmaW5lIGEgY29udGV4dCBzbyB5b3UgY2FuIGRvIHRoaXM6CiAqCiAqCQlzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIHRleHROb2RlLCAnYm9sZCcgKTsKICoKICogQnV0IHNvbWV0aW1lcyB5b3Ugd2FudCB0byBjaGVjayB3aGV0aGVyIGEgdGV4dCBhdCBhIGdpdmVuIHBvc2l0aW9uIG1pZ2h0J3ZlIGhhZCBzb21lIGF0dHJpYnV0ZSwKICogaW4gd2hpY2ggY2FzZSB5b3UgY2FuIGNyZWF0ZSBhIGNvbnRleHQgYnkgbWlzaW5nIGFuIGFycmF5IG9mIGVsZW1lbnRzIHdpdGggYSBgJyR0ZXh0J2Agc3RyaW5nOgogKgogKgkJLy8gQ2hlY2sgaW4gWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCwgdGV4dE5vZGUgXS4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCBbIC4uLnBvc2l0aW9uSW5QYXJhZ3JhcGguZ2V0QW5jZXN0b3JzKCksICckdGV4dCcgXSwgJ2JvbGQnICk7CiAqCiAqIEB0eXBlZGVmIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR8CiAqIFN0cmluZ3xBcnJheS48U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb24KICovCgovKioKICogQW4gaXRlbSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHQgc2NoZW1hIGNvbnRleHR9LgogKgogKiBJdCBjb250YWlucyAzIHByb3BlcnRpZXM6CiAqCiAqICogYG5hbWVgIOKAkyB0aGUgbmFtZSBvZiB0aGlzIGl0ZW0sCiAqICogYCogZ2V0QXR0cmlidXRlS2V5cygpYCDigJMgYSBnZW5lcmF0b3Igb2Yga2V5cyBvZiBpdGVtIGF0dHJpYnV0ZXMsCiAqICogYGdldEF0dHJpYnV0ZSgga2V5TmFtZSApYCDigJMgYSBtZXRob2QgdG8gZ2V0IGF0dHJpYnV0ZSB2YWx1ZXMuCiAqCiAqIFRoZSBjb250ZXh0IGl0ZW0gaW50ZXJmYWNlIGlzIGEgaGlnaGx5IHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IGFuZCBpdHMgcm9sZQogKiBpcyB0byBleHBvc2Ugb25seSB0aGUgaW5mb3JtYXRpb24gd2hpY2ggc2NoZW1hIGNoZWNrcyBhcmUgYWJsZSB0byBwcm92aWRlICh3aGljaCBpcyB0aGUgbmFtZSBvZiB0aGUgbm9kZSBhbmQKICogbm9kZSdzIGF0dHJpYnV0ZXMpLgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGN0eCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBmaXJzdEl0ZW0gPSBjdHguZ2V0SXRlbSggMCApOwogKgogKgkJCWNvbnNvbGUubG9nKCBmaXJzdEl0ZW0ubmFtZSApOyAvLyAtPiAnJHJvb3QnCiAqCQkJY29uc29sZS5sb2coIGZpcnN0SXRlbS5nZXRBdHRyaWJ1dGUoICdmb28nICkgKTsgLy8gLT4gJ2JhcicKICoJCQljb25zb2xlLmxvZyggQXJyYXkuZnJvbSggZmlyc3RJdGVtLmdldEF0dHJpYnV0ZUtleXMoKSApICk7IC8vIC0+IFsgJ2ZvbycsICdmYWEnIF0KICoJCX0gKTsKICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW0KICovCgovKioKICogQSBzdHJ1Y3R1cmUgY29udGFpbmluZyBhZGRpdGlvbmFsIG1ldGFkYXRhIGRlc2NyaWJpbmcgdGhlIGF0dHJpYnV0ZS4KICoKICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjc2V0QXR0cmlidXRlUHJvcGVydGllcyBgU2NoZW1hI3NldEF0dHJpYnV0ZVByb3BlcnRpZXMoKWB9IGZvciB1c2FnZSBleGFtcGxlcy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+QXR0cmlidXRlUHJvcGVydGllcwogKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpc0Zvcm1hdHRpbmddIEluZGljYXRlcyB0aGF0IHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgYSB2aXN1YWwgZm9ybWF0dGluZywgbGlrZSBgYm9sZGAsIGBpdGFsaWNgIG9yCiAqIGBmb250U2l6ZWAgcmF0aGVyIHRoYW4gc2VtYW50aWMgYXR0cmlidXRlIChzdWNoIGFzIGBzcmNgLCBgbGlzdFR5cGVgLCBldGMuKS4gRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgdGhlICJSZW1vdmUgZm9ybWF0IiBmZWF0dXJlLgogKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb3B5T25FbnRlcl0gSW5kaWNhdGVzIHRoYXQgZ2l2ZW4gdGV4dCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgbmV4dCBibG9jayB3aGVuIGVudGVyIGlzIHByZXNzZWQuCiAqLwoKZnVuY3Rpb24gY29tcGlsZUJhc2VJdGVtUnVsZShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1OYW1lKSB7CiAgdmFyIGl0ZW1SdWxlID0gewogICAgbmFtZTogaXRlbU5hbWUsCiAgICBhbGxvd0luOiBbXSwKICAgIGFsbG93Q29udGVudE9mOiBbXSwKICAgIGFsbG93V2hlcmU6IFtdLAogICAgYWxsb3dBdHRyaWJ1dGVzOiBbXSwKICAgIGFsbG93QXR0cmlidXRlc09mOiBbXSwKICAgIGluaGVyaXRUeXBlc0Zyb206IFtdCiAgfTsKICBjb3B5VHlwZXMoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdhbGxvd0luJyk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdhbGxvd0NvbnRlbnRPZicpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnYWxsb3dXaGVyZScpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnYWxsb3dBdHRyaWJ1dGVzJyk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdhbGxvd0F0dHJpYnV0ZXNPZicpOwogIGNvcHlQcm9wZXJ0eShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlLCAnaW5oZXJpdFR5cGVzRnJvbScpOwogIG1ha2VJbmhlcml0QWxsV29yayhzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlKTsKICByZXR1cm4gaXRlbVJ1bGU7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVBbGxvd0NvbnRlbnRPZihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjkgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dDb250ZW50T2ZbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDk7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSAoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWUpIHsKICAgICAgdmFyIGFsbG93Q29udGVudE9mSXRlbU5hbWUgPSBfc3RlcDkudmFsdWU7CgogICAgICAvLyBUaGUgYWxsb3dDb250ZW50T2YgcHJvcGVydHkgbWF5IHBvaW50IHRvIGFuIHVucmVnaXN0ZXJlZCBlbGVtZW50LgogICAgICBpZiAoY29tcGlsZWREZWZpbml0aW9uc1thbGxvd0NvbnRlbnRPZkl0ZW1OYW1lXSkgewogICAgICAgIHZhciBhbGxvd2VkQ2hpbGRyZW4gPSBnZXRBbGxvd2VkQ2hpbGRyZW4oY29tcGlsZWREZWZpbml0aW9ucywgYWxsb3dDb250ZW50T2ZJdGVtTmFtZSk7CiAgICAgICAgYWxsb3dlZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFsbG93ZWRJdGVtKSB7CiAgICAgICAgICBhbGxvd2VkSXRlbS5hbGxvd0luLnB1c2goaXRlbU5hbWUpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjkgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I5OwogICAgICB9CiAgICB9CiAgfQoKICBkZWxldGUgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dDb250ZW50T2Y7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVBbGxvd1doZXJlKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTAgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IxMCA9IHVuZGVmaW5lZDsKCiAgdHJ5IHsKICAgIGZvciAodmFyIF9pdGVyYXRvcjEwID0gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dXaGVyZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7CiAgICAgIHZhciBhbGxvd1doZXJlSXRlbU5hbWUgPSBfc3RlcDEwLnZhbHVlOwogICAgICB2YXIgaW5oZXJpdEZyb20gPSBjb21waWxlZERlZmluaXRpb25zW2FsbG93V2hlcmVJdGVtTmFtZV07IC8vIFRoZSBhbGxvd1doZXJlIHByb3BlcnR5IG1heSBwb2ludCB0byBhbiB1bnJlZ2lzdGVyZWQgZWxlbWVudC4KCiAgICAgIGlmIChpbmhlcml0RnJvbSkgewogICAgICAgIHZhciBfY29tcGlsZWREZWZpbml0aW9ucyQ7CgogICAgICAgIHZhciBhbGxvd2VkSW4gPSBpbmhlcml0RnJvbS5hbGxvd0luOwoKICAgICAgICAoX2NvbXBpbGVkRGVmaW5pdGlvbnMkID0gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dJbikucHVzaC5hcHBseShfY29tcGlsZWREZWZpbml0aW9ucyQsIF90b0NvbnN1bWFibGVBcnJheShhbGxvd2VkSW4pKTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjEwID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCAmJiBfaXRlcmF0b3IxMC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjEwLnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMCkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTA7CiAgICAgIH0KICAgIH0KICB9CgogIGRlbGV0ZSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd1doZXJlOwp9CgpmdW5jdGlvbiBjb21waWxlQWxsb3dBdHRyaWJ1dGVzT2YoY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjExID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMTEgPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd0F0dHJpYnV0ZXNPZltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlKSB7CiAgICAgIHZhciBhbGxvd0F0dHJpYnV0ZU9mSXRlbSA9IF9zdGVwMTEudmFsdWU7CiAgICAgIHZhciBpbmhlcml0RnJvbSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbYWxsb3dBdHRyaWJ1dGVPZkl0ZW1dOwoKICAgICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgICAgdmFyIF9jb21waWxlZERlZmluaXRpb25zJDI7CgogICAgICAgIHZhciBpbmhlcml0QXR0cmlidXRlcyA9IGluaGVyaXRGcm9tLmFsbG93QXR0cmlidXRlczsKCiAgICAgICAgKF9jb21waWxlZERlZmluaXRpb25zJDIgPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd0F0dHJpYnV0ZXMpLnB1c2guYXBwbHkoX2NvbXBpbGVkRGVmaW5pdGlvbnMkMiwgX3RvQ29uc3VtYWJsZUFycmF5KGluaGVyaXRBdHRyaWJ1dGVzKSk7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yMTEgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IxMSA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgJiYgX2l0ZXJhdG9yMTEucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IxMS5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTEpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjExOwogICAgICB9CiAgICB9CiAgfQoKICBkZWxldGUgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dBdHRyaWJ1dGVzT2Y7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVJbmhlcml0UHJvcGVydGllc0Zyb20oY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICB2YXIgaXRlbSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEyID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yMTIgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3IxMiA9IGl0ZW0uaW5oZXJpdFR5cGVzRnJvbVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSB0cnVlKSB7CiAgICAgIHZhciBpbmhlcml0UHJvcGVydGllc09mSXRlbSA9IF9zdGVwMTIudmFsdWU7CiAgICAgIHZhciBpbmhlcml0RnJvbSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaW5oZXJpdFByb3BlcnRpZXNPZkl0ZW1dOwoKICAgICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgICAgdmFyIHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKGluaGVyaXRGcm9tKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsKICAgICAgICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoJ2lzJyk7CiAgICAgICAgfSk7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTMgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMyA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEzID0gdHlwZU5hbWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSAoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIG5hbWUgPSBfc3RlcDEzLnZhbHVlOwoKICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBpdGVtKSkgewogICAgICAgICAgICAgIGl0ZW1bbmFtZV0gPSBpbmhlcml0RnJvbVtuYW1lXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxMyA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjEzID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyAmJiBfaXRlcmF0b3IxMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgIF9pdGVyYXRvcjEzLnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMykgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTM7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yMTIgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IxMiA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgJiYgX2l0ZXJhdG9yMTIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IxMi5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTIpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjEyOwogICAgICB9CiAgICB9CiAgfQoKICBkZWxldGUgaXRlbS5pbmhlcml0VHlwZXNGcm9tOwp9IC8vIFJlbW92ZSBpdGVtcyB3aGljaCB3ZXJlbid0IHJlZ2lzdGVyZWQgKGJlY2F1c2UgaXQgbWF5IGJyZWFrIHNvbWUgY2hlY2tzIG9yIHdlJ2QgbmVlZCB0byBjb21wbGljYXRlIHRoZW0pLgovLyBNYWtlIHN1cmUgYWxsb3dJbiBkb2Vzbid0IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzLgoKCmZ1bmN0aW9uIGNsZWFuVXBBbGxvd0luKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgdmFyIGl0ZW1SdWxlID0gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV07CiAgdmFyIGV4aXN0aW5nSXRlbXMgPSBpdGVtUnVsZS5hbGxvd0luLmZpbHRlcihmdW5jdGlvbiAoaXRlbVRvQ2hlY2spIHsKICAgIHJldHVybiBjb21waWxlZERlZmluaXRpb25zW2l0ZW1Ub0NoZWNrXTsKICB9KTsKICBpdGVtUnVsZS5hbGxvd0luID0gQXJyYXkuZnJvbShuZXcgU2V0KGV4aXN0aW5nSXRlbXMpKTsKfQoKZnVuY3Rpb24gY2xlYW5VcEFsbG93QXR0cmlidXRlcyhjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIGl0ZW1SdWxlLmFsbG93QXR0cmlidXRlcyA9IEFycmF5LmZyb20obmV3IFNldChpdGVtUnVsZS5hbGxvd0F0dHJpYnV0ZXMpKTsKfQoKZnVuY3Rpb24gY29weVR5cGVzKHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUpIHsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE0ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxNCA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjE0ID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMTQgPSBzb3VyY2VJdGVtUnVsZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDE0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNCA9IChfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE0ID0gdHJ1ZSkgewogICAgICB2YXIgc291cmNlSXRlbVJ1bGUgPSBfc3RlcDE0LnZhbHVlOwogICAgICB2YXIgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoc291cmNlSXRlbVJ1bGUpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkgewogICAgICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoJ2lzJyk7CiAgICAgIH0pOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE1ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTUgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMTUgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjE1ID0gdHlwZU5hbWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTUgPSAoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNSA9IHRydWUpIHsKICAgICAgICAgIHZhciBuYW1lID0gX3N0ZXAxNS52YWx1ZTsKICAgICAgICAgIGl0ZW1SdWxlW25hbWVdID0gc291cmNlSXRlbVJ1bGVbbmFtZV07CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjE1ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjE1ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNSAmJiBfaXRlcmF0b3IxNS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IxNS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTUpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxNTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yMTQgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IxNCA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgJiYgX2l0ZXJhdG9yMTQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IxNC5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTQpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjE0OwogICAgICB9CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgcHJvcGVydHlOYW1lKSB7CiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNiA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTYgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IxNiA9IHVuZGVmaW5lZDsKCiAgdHJ5IHsKICAgIGZvciAodmFyIF9pdGVyYXRvcjE2ID0gc291cmNlSXRlbVJ1bGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTYgPSAoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNiA9IHRydWUpIHsKICAgICAgdmFyIHNvdXJjZUl0ZW1SdWxlID0gX3N0ZXAxNi52YWx1ZTsKCiAgICAgIGlmICh0eXBlb2Ygc291cmNlSXRlbVJ1bGVbcHJvcGVydHlOYW1lXSA9PSAnc3RyaW5nJykgewogICAgICAgIGl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0ucHVzaChzb3VyY2VJdGVtUnVsZVtwcm9wZXJ0eU5hbWVdKTsKICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZUl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pKSB7CiAgICAgICAgdmFyIF9pdGVtUnVsZSRwcm9wZXJ0eU5hbTsKCiAgICAgICAgKF9pdGVtUnVsZSRwcm9wZXJ0eU5hbSA9IGl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pLnB1c2guYXBwbHkoX2l0ZW1SdWxlJHByb3BlcnR5TmFtLCBfdG9Db25zdW1hYmxlQXJyYXkoc291cmNlSXRlbVJ1bGVbcHJvcGVydHlOYW1lXSkpOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjE2ID0gdHJ1ZTsKICAgIF9pdGVyYXRvckVycm9yMTYgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE2ICYmIF9pdGVyYXRvcjE2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgX2l0ZXJhdG9yMTYucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjE2KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxNjsKICAgICAgfQogICAgfQogIH0KfQoKZnVuY3Rpb24gbWFrZUluaGVyaXRBbGxXb3JrKHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUpIHsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE3ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxNyA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjE3ID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMTcgPSBzb3VyY2VJdGVtUnVsZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDE3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNyA9IChfc3RlcDE3ID0gX2l0ZXJhdG9yMTcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE3ID0gdHJ1ZSkgewogICAgICB2YXIgc291cmNlSXRlbVJ1bGUgPSBfc3RlcDE3LnZhbHVlOwogICAgICB2YXIgaW5oZXJpdEZyb20gPSBzb3VyY2VJdGVtUnVsZS5pbmhlcml0QWxsRnJvbTsKCiAgICAgIGlmIChpbmhlcml0RnJvbSkgewogICAgICAgIGl0ZW1SdWxlLmFsbG93Q29udGVudE9mLnB1c2goaW5oZXJpdEZyb20pOwogICAgICAgIGl0ZW1SdWxlLmFsbG93V2hlcmUucHVzaChpbmhlcml0RnJvbSk7CiAgICAgICAgaXRlbVJ1bGUuYWxsb3dBdHRyaWJ1dGVzT2YucHVzaChpbmhlcml0RnJvbSk7CiAgICAgICAgaXRlbVJ1bGUuaW5oZXJpdFR5cGVzRnJvbS5wdXNoKGluaGVyaXRGcm9tKTsKICAgICAgfQogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxNyA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjE3ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNyAmJiBfaXRlcmF0b3IxNy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjE3LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxNykgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTc7CiAgICAgIH0KICAgIH0KICB9Cn0KCmZ1bmN0aW9uIGdldEFsbG93ZWRDaGlsZHJlbihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIHZhciBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIHJldHVybiBnZXRWYWx1ZXMoY29tcGlsZWREZWZpbml0aW9ucykuZmlsdGVyKGZ1bmN0aW9uIChkZWYpIHsKICAgIHJldHVybiBkZWYuYWxsb3dJbi5pbmNsdWRlcyhpdGVtUnVsZS5uYW1lKTsKICB9KTsKfQoKZnVuY3Rpb24gZ2V0VmFsdWVzKG9iaikgewogIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7CiAgICByZXR1cm4gb2JqW2tleV07CiAgfSk7Cn0KCmZ1bmN0aW9uIG1hcENvbnRleHRJdGVtKGN0eEl0ZW0pIHsKICBpZiAodHlwZW9mIGN0eEl0ZW0gPT0gJ3N0cmluZycpIHsKICAgIHJldHVybiB7CiAgICAgIG5hbWU6IGN0eEl0ZW0sCiAgICAgIGdldEF0dHJpYnV0ZUtleXM6CiAgICAgIC8qI19fUFVSRV9fKi8KICAgICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gZ2V0QXR0cmlidXRlS2V5cygpIHsKICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0QXR0cmlidXRlS2V5cyQoX2NvbnRleHQ1KSB7CiAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHsKICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwgZ2V0QXR0cmlidXRlS2V5cyk7CiAgICAgIH0pLAogICAgICBnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSgpIHt9CiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gewogICAgICAvLyAnJHRleHQnIG1lYW5zIHRleHQgbm9kZXMgYW5kIHRleHQgcHJveGllcy4KICAgICAgbmFtZTogY3R4SXRlbS5pcygnZWxlbWVudCcpID8gY3R4SXRlbS5uYW1lIDogJyR0ZXh0JywKICAgICAgZ2V0QXR0cmlidXRlS2V5czoKICAgICAgLyojX19QVVJFX18qLwogICAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRBdHRyaWJ1dGVLZXlzKCkgewogICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRBdHRyaWJ1dGVLZXlzJChfY29udGV4dDYpIHsKICAgICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkgewogICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuZGVsZWdhdGVZaWVsZChjdHhJdGVtLmdldEF0dHJpYnV0ZUtleXMoKSwgInQwIiwgMSk7CgogICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9LCBnZXRBdHRyaWJ1dGVLZXlzKTsKICAgICAgfSksCiAgICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGtleSkgewogICAgICAgIHJldHVybiBjdHhJdGVtLmdldEF0dHJpYnV0ZShrZXkpOwogICAgICB9CiAgICB9OwogIH0KfSAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gcmV0dXJuaW5nIHZhbHVlcyBmcm9tIHByb3ZpZGVkIHdhbGtlcnMsIHN3aXRjaGluZyBiZXR3ZWVuIHRoZW0gYXQgZWFjaCBpdGVyYXRpb24uIElmIG9ubHkgb25lIHdhbGtlcgovLyBpcyBwcm92aWRlZCBpdCB3aWxsIHJldHVybiBkYXRhIG9ubHkgZnJvbSB0aGF0IHdhbGtlci4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZHVsZS90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IFtiYWNrd2FyZF0gV2Fsa2VyIGl0ZXJhdGluZyBpbiBiYWNrd2FyZCBkaXJlY3Rpb24uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2R1bGUvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSBbZm9yd2FyZF0gV2Fsa2VyIGl0ZXJhdGluZyBpbiBmb3J3YXJkIGRpcmVjdGlvbi4KLy8gQHJldHVybnMge0l0ZXJhYmxlLjxPYmplY3Q+fSBPYmplY3QgcmV0dXJuZWQgYXQgZWFjaCBpdGVyYXRpb24gY29udGFpbnMgYHZhbHVlYCBhbmQgYHdhbGtlcmAgKGluZm9ybWluZyB3aGljaCB3YWxrZXIgcmV0dXJuZWQKLy8gZ2l2ZW4gdmFsdWUpIGZpZWxkcy4KCgpmdW5jdGlvbiBjb21iaW5lV2Fsa2VycyhiYWNrd2FyZCwgZm9yd2FyZCkgewogIHZhciBkb25lLCBzdGVwLCBfc3RlcDE4OwoKICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gY29tYmluZVdhbGtlcnMkKF9jb250ZXh0NykgewogICAgd2hpbGUgKDEpIHsKICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7CiAgICAgICAgY2FzZSAwOgogICAgICAgICAgZG9uZSA9IGZhbHNlOwoKICAgICAgICBjYXNlIDE6CiAgICAgICAgICBpZiAoZG9uZSkgewogICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE3OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBkb25lID0gdHJ1ZTsKCiAgICAgICAgICBpZiAoIWJhY2t3YXJkKSB7CiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gOTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgc3RlcCA9IGJhY2t3YXJkLm5leHQoKTsKCiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7CiAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gOTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgZG9uZSA9IGZhbHNlOwogICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5OwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgd2Fsa2VyOiBiYWNrd2FyZCwKICAgICAgICAgICAgdmFsdWU6IHN0ZXAudmFsdWUKICAgICAgICAgIH07CgogICAgICAgIGNhc2UgOToKICAgICAgICAgIGlmICghZm9yd2FyZCkgewogICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE1OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBfc3RlcDE4ID0gZm9yd2FyZC5uZXh0KCk7CgogICAgICAgICAgaWYgKF9zdGVwMTguZG9uZSkgewogICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE1OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBkb25lID0gZmFsc2U7CiAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDE1OwogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgd2Fsa2VyOiBmb3J3YXJkLAogICAgICAgICAgICB2YWx1ZTogX3N0ZXAxOC52YWx1ZQogICAgICAgICAgfTsKCiAgICAgICAgY2FzZSAxNToKICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlIDE3OgogICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTsKICAgICAgfQogICAgfQogIH0sIF9tYXJrZWQpOwp9IC8vIFRha2VzIGFuIGFycmF5IG9mIG5vbi1pbnRlcnNlY3RpbmcgcmFuZ2VzLiBGb3IgZWFjaCBvZiB0aGVtIGdldHMgbWluaW1hbCBmbGF0IHJhbmdlcyBjb3ZlcmluZyB0aGF0IHJhbmdlIGFuZCByZXR1cm5zCi8vIGFsbCB0aG9zZSBtaW5pbWFsIGZsYXQgcmFuZ2VzLgovLwovLyBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gcmFuZ2VzIFJhbmdlcyB0byBwcm9jZXNzLgovLyBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBNaW5pbWFsIGZsYXQgcmFuZ2VzIG9mIGdpdmVuIGByYW5nZXNgLgoKCmZ1bmN0aW9uIGNvbnZlcnRUb01pbmltYWxGbGF0UmFuZ2VzKHJhbmdlcykgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTgsIF9kaWRJdGVyYXRvckVycm9yMTgsIF9pdGVyYXRvckVycm9yMTgsIF9pdGVyYXRvcjE4LCBfc3RlcDE5LCByYW5nZTsKCiAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIGNvbnZlcnRUb01pbmltYWxGbGF0UmFuZ2VzJChfY29udGV4dDgpIHsKICAgIHdoaWxlICgxKSB7CiAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xOCA9IHRydWU7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjE4ID0gZmFsc2U7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjE4ID0gdW5kZWZpbmVkOwogICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAzOwogICAgICAgICAgX2l0ZXJhdG9yMTggPSByYW5nZXNbU3ltYm9sLml0ZXJhdG9yXSgpOwoKICAgICAgICBjYXNlIDU6CiAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE4ID0gKF9zdGVwMTkgPSBfaXRlcmF0b3IxOC5uZXh0KCkpLmRvbmUpIHsKICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgcmFuZ2UgPSBfc3RlcDE5LnZhbHVlOwogICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5kZWxlZ2F0ZVlpZWxkKHJhbmdlLmdldE1pbmltYWxGbGF0UmFuZ2VzKCksICJ0MCIsIDgpOwoKICAgICAgICBjYXNlIDg6CiAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTggPSB0cnVlOwogICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA1OwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgMTE6CiAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE3OwogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgMTM6CiAgICAgICAgICBfY29udGV4dDgucHJldiA9IDEzOwogICAgICAgICAgX2NvbnRleHQ4LnQxID0gX2NvbnRleHQ4WyJjYXRjaCJdKDMpOwogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxOCA9IHRydWU7CiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjE4ID0gX2NvbnRleHQ4LnQxOwoKICAgICAgICBjYXNlIDE3OgogICAgICAgICAgX2NvbnRleHQ4LnByZXYgPSAxNzsKICAgICAgICAgIF9jb250ZXh0OC5wcmV2ID0gMTg7CgogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTggJiYgX2l0ZXJhdG9yMTgucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMTgucmV0dXJuKCk7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgMjA6CiAgICAgICAgICBfY29udGV4dDgucHJldiA9IDIwOwoKICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IxOCkgewogICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDIzOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjE4OwoKICAgICAgICBjYXNlIDIzOgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5maW5pc2goMjApOwoKICAgICAgICBjYXNlIDI0OgogICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5maW5pc2goMTcpOwoKICAgICAgICBjYXNlIDI1OgogICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTsKICAgICAgfQogICAgfQogIH0sIF9tYXJrZWQyLCBudWxsLCBbWzMsIDEzLCAxNywgMjVdLCBbMTgsLCAyMCwgMjRdXSk7Cn0KCmZ1bmN0aW9uIHJlbW92ZURpc2FsbG93ZWRBdHRyaWJ1dGVGcm9tTm9kZShzY2hlbWEsIG5vZGUsIHdyaXRlcikgewogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTkgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjE5ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yMTkgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3IxOSA9IG5vZGUuZ2V0QXR0cmlidXRlS2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyMDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTkgPSAoX3N0ZXAyMCA9IF9pdGVyYXRvcjE5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xOSA9IHRydWUpIHsKICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9zdGVwMjAudmFsdWU7CgogICAgICBpZiAoIXNjaGVtYS5jaGVja0F0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUpKSB7CiAgICAgICAgd3JpdGVyLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIG5vZGUpOwogICAgICB9CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjE5ID0gdHJ1ZTsKICAgIF9pdGVyYXRvckVycm9yMTkgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE5ICYmIF9pdGVyYXRvcjE5LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgX2l0ZXJhdG9yMTkucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjE5KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxOTsKICAgICAgfQogICAgfQogIH0KfQ=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"names":["combineWalkers","convertToMinimalFlatRanges","CKEditorError","ObservableMixin","mix","Range","Position","Element","Text","TreeWalker","Schema","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","itemName","definition","Object","assign","_clearCache","push","_compiledDefinitions","_compile","item","is","name","getDefinitions","def","isBlock","isLimit","isObject","isInline","context","_checkContextMatch","attributeName","last","allowAttributes","includes","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","checkMerge","getChildren","child","checkChild","callback","ctx","childDef","retValue","stop","return","properties","getAttributeProperties","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","checkAttribute","value","_getValidRangesForRange","position","direction","backwardWalker","forwardWalker","limitElement","reverse","find","root","boundaries","_createIn","startPosition","data","type","walker","_createOn","nextPosition","node","nodes","writer","removeDisallowedAttributeFromNode","rangeInNode","positionsInRange","getPositions","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","isArray","shift","_items","map","mapContextItem","Symbol","iterator","index","query","getNames","join","endsWith","startsWith","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowContentOfItemName","allowedChildren","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","existingItems","itemToCheck","Set","sourceItemRule","propertyName","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","schema","removeAttribute"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by features and based on them the editing framework and features\n * make decisions how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * {@glink framework/guides/architecture/editing-engine#schema \"Schema\"} section of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the \"Editing engine architecture\"}.\n * * {@glink framework/guides/deep-dive/schema \"Schema\" deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\t/**\n\t\t * A dictionary containing attribute properties.\n\t\t *\n\t\t * @private\n\t\t * @member {Object.<String,String>}\n\t\t */\n\t\tthis._attributeProperties = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * A single item cannot be registered twice in the schema.\n\t\t\t *\n\t\t\t * This situation may happen when:\n\t\t\t *\n\t\t\t * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n\t\t\t * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n\t\t\t * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n\t\t\t * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n\t\t\t * and usually means one or more of the following issues:\n\t\t\t *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n\t\t\t *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n\t\t\t *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n\t\t\t *\n\t\t\t * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element that is being registered twice.\n\t\t\t * @error schema-cannot-register-item-twice\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.',\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\titemName\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * Cannot extend an item which was not registered yet.\n\t\t\t *\n\t\t\t * This error happens when a plugin tries to extend the schema definition of an item which was not\n\t\t\t * {@link #register registered} yet.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element which is being extended.\n\t\t\t * @error schema-cannot-extend-missing-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.', this, {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns all registered items.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if item is not registered.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( 'text' ) || item.is( 'textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a limit element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isLimit` or `isObject` property\n\t * (all objects are also limits).\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'image' ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an object element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isObject` property.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'image' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'image' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an inline element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n\t *\n\t *\t\tschema.isInline( 'paragraph' ); // -> false\n\t *\t\tschema.isInline( 'softBreak' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText('foo' );\n\t *\t\tschema.isInline( text ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisInline( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isInline );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-before: The node before the merge position must be an element.',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-after: The node after the merge position must be an element.',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * This method allows assigning additional metadata to the model attributes. For example,\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n\t * used to mark formatting attributes (like `bold` or `italic`).\n\t *\n\t *\t\t// Mark bold as a formatting attribute.\n\t *\t\tschema.setAttributeProperties( 'bold', {\n\t *\t\t\tisFormatting: true\n\t *\t\t} );\n\t *\n\t *\t\t// Override code not to be considered a formatting markup.\n\t *\t\tschema.setAttributeProperties( 'code', {\n\t *\t\t\tisFormatting: false\n\t *\t\t} );\n\t *\n\t * Properties are not limited to members defined in the\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tcustomProperty: 'value'\n\t *\t\t} );\n\t *\n\t * Subsequent calls with the same attribute will extend its custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tone: 1\n\t *\t\t} );\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\ttwo: 2\n\t *\t\t} );\n\t *\n\t *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n\t *\t\t// Logs: { one: 1, two: 2 }\n\t *\n\t * @param {String} attributeName A name of the attribute to receive the properties.\n\t * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n\t */\n\tsetAttributeProperties( attributeName, properties ) {\n\t\tthis._attributeProperties[ attributeName ] = Object.assign( this.getAttributeProperties( attributeName ), properties );\n\t}\n\n\t/**\n\t * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n\t *\n\t * @param {String} attributeName A name of the attribute.\n\t * @returns {module:engine/model/schema~AttributeProperties}\n\t */\n\tgetAttributeProperties( attributeName ) {\n\t\treturn this._attributeProperties[ attributeName ] || {};\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst context = [\n\t\t\t\t...firstPosition.getAncestors(),\n\t\t\t\tnew Text( '', selection.getAttributes() )\n\t\t\t];\n\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( context, attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* getValidRanges( ranges, attribute ) {\n\t\tranges = convertToMinimalFlatRanges( ranges );\n\n\t\tfor ( const range of ranges ) {\n\t\t\tyield* this._getValidRangesForRange( range, attribute );\n\t\t}\n\t}\n\n\t/**\n\t * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\t// Never leave a limit element.\n\t\tconst limitElement = position.getAncestors().reverse().find( item => this.isLimit( item ) ) || position.root;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position,\n\t\t\t\tdirection: 'backward'\n\t\t\t} );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( {\n\t\t\t\tboundaries: Range._createIn( limitElement ),\n\t\t\t\tstartPosition: position\n\t\t\t} );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range._createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allows to insert given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as {@link module:engine/model/schema~Schema#isLimit limit element},\n\t * {@link module:engine/model/schema~Schema#isObject object element} or top-most ancestor won't be reached.\n\t *\n\t * @params {module:engine/model/position~Position} position Position from searching will start.\n\t * @params {module:engine/model/node~Node|String} node Node for which allowed parent should be found or its name.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( position, node ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\t// When node is a `Text` it has no children, so just filter it out.\n\t\t\tif ( node.is( 'text' ) ) {\n\t\t\t\tremoveDisallowedAttributeFromNode( this, node, writer );\n\t\t\t}\n\t\t\t// In a case of `Element` iterates through positions between nodes inside this element\n\t\t\t// and filter out node before the current position, or position parent when position\n\t\t\t// is at start of an element. Using positions prevent from omitting merged nodes\n\t\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n\t\t\telse {\n\t\t\t\tconst rangeInNode = Range._createIn( node );\n\t\t\t\tconst positionsInRange = rangeInNode.getPositions();\n\n\t\t\t\tfor ( const position of positionsInRange ) {\n\t\t\t\t\tconst item = position.nodeBefore || position.parent;\n\n\t\t\t\t\tremoveDisallowedAttributeFromNode( this, item, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an instance of the schema context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t * @returns {module:engine/model/schema~SchemaContext}\n\t */\n\tcreateContext( context ) {\n\t\treturn new SchemaContext( context );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n\t * inside the given range on which the attribute can be applied.\n\t *\n\t * This is a helper function for {@link ~Schema#getValidRanges}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Range to process.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* _getValidRangesForRange( range, attribute ) {\n\t\tlet start = range.start;\n\t\tlet end = range.start;\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tyield* this._getValidRangesForRange( Range._createIn( item ), attribute );\n\t\t\t}\n\n\t\t\tif ( !this.checkAttribute( item, attribute ) ) {\n\t\t\t\tif ( !start.isEqual( end ) ) {\n\t\t\t\t\tyield new Range( start, end );\n\t\t\t\t}\n\n\t\t\t\tstart = Position._createAfter( item );\n\t\t\t}\n\n\t\t\tend = Position._createAfter( item );\n\t\t}\n\n\t\tif ( !start.isEqual( end ) ) {\n\t\t\tyield new Range( start, end );\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you don't have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\" you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it's normally handled by\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it's\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you don't have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1` you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it's normally handled by\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * `allowIn` &ndash; A string or an array of strings. Defines in which other items this item will be allowed.\n * * `allowAttributes` &ndash; A string or an array of strings. Defines allowed attributes of the given item.\n * * `allowContentOf` &ndash; A string or an array of strings. Inherits \"allowed children\" from other items.\n * * `allowWhere` &ndash; A string or an array of strings. Inherits \"allowed in\" from other items.\n * * `allowAttributesOf` &ndash; A string or an array of strings. Inherits attributes from other items.\n * * `inheritTypesFrom` &ndash; A string or an array of strings. Inherits `is*` properties of other items.\n * * `inheritAllFrom` &ndash; A string. A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n * * Additionally, you can define the following `is*` properties: `isBlock`, `isLimit`, `isObject`, `isInline`. Read about them below.\n *\n * # The is* properties\n *\n * There are 3 commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * `isBlock` &ndash; Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n * * `isLimit` &ndash; It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content. **Note:** All objects (`isObject`) are treated as limit elements, too.\n * * `isObject` &ndash; Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `image`, `table`, `video`, etc. **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n * * `isInline` &ndash; Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Defining schema} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `image` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'image', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'image',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about definining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tif ( context[ 0 ] && typeof context[ 0 ] != 'string' && context[ 0 ].is( 'documentFragment' ) ) {\n\t\t\tcontext.shift();\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n\t * (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n\n\t/**\n\t * Checks whether the context starts with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$root' ); // -> true\n\t *\t\tctx.endsWith( '$root paragraph' ); // -> true\n\t *\t\tctx.endsWith( '$text' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tstartsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).startsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node**  in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document  in this case all its ancestors will be used.\n * * By defining an **array of nodes**  in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes)  The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mising an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name`  the name of this item,\n * * `* getAttributeKeys()`  a generator of keys of item attributes,\n * * `getAttribute( keyName )`  a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' ) {\n\t\treturn {\n\t\t\tname: ctxItem,\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges( ranges ) {\n\tfor ( const range of ranges ) {\n\t\tyield* range.getMinimalFlatRanges();\n\t}\n}\n\nfunction removeDisallowedAttributeFromNode( schema, node, writer ) {\n\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\tif ( !schema.checkAttribute( node, attribute ) ) {\n\t\t\twriter.removeAttribute( attribute, node );\n\t\t}\n\t}\n}\n"]}]}