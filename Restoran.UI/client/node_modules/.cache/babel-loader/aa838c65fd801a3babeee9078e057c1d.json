{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\downcasthelpers.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\downcasthelpers.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX3R5cGVvZiBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZiI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iOwppbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YiOwppbXBvcnQgX2luaGVyaXRzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBDb250YWlucyBkb3duY2FzdCAobW9kZWwtdG8tdmlldykgY29udmVydGVycyBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfS4KICoKICogQG1vZHVsZSBlbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnMKICovCmltcG9ydCBNb2RlbFJhbmdlIGZyb20gJy4uL21vZGVsL3JhbmdlJzsKaW1wb3J0IE1vZGVsU2VsZWN0aW9uIGZyb20gJy4uL21vZGVsL3NlbGVjdGlvbic7CmltcG9ydCBNb2RlbEVsZW1lbnQgZnJvbSAnLi4vbW9kZWwvZWxlbWVudCc7CmltcG9ydCBWaWV3QXR0cmlidXRlRWxlbWVudCBmcm9tICcuLi92aWV3L2F0dHJpYnV0ZWVsZW1lbnQnOwppbXBvcnQgRG9jdW1lbnRTZWxlY3Rpb24gZnJvbSAnLi4vbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb24nOwppbXBvcnQgQ29udmVyc2lvbkhlbHBlcnMgZnJvbSAnLi9jb252ZXJzaW9uaGVscGVycyc7CmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwovKioKICogRG93bmNhc3QgY29udmVyc2lvbiBoZWxwZXIgZnVuY3Rpb25zLgogKgogKiBAZXh0ZW5kcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbmhlbHBlcnN+Q29udmVyc2lvbkhlbHBlcnMKICovCgp2YXIgRG93bmNhc3RIZWxwZXJzID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoX0NvbnZlcnNpb25IZWxwZXJzKSB7CiAgX2luaGVyaXRzKERvd25jYXN0SGVscGVycywgX0NvbnZlcnNpb25IZWxwZXJzKTsKCiAgZnVuY3Rpb24gRG93bmNhc3RIZWxwZXJzKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvd25jYXN0SGVscGVycyk7CgogICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEb3duY2FzdEhlbHBlcnMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpOwogIH0KCiAgX2NyZWF0ZUNsYXNzKERvd25jYXN0SGVscGVycywgW3sKICAgIGtleTogImVsZW1lbnRUb0VsZW1lbnQiLAoKICAgIC8qKgogICAgICogTW9kZWwgZWxlbWVudCB0byB2aWV3IGVsZW1lbnQgY29udmVyc2lvbiBoZWxwZXIuCiAgICAgKgogICAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gY3JlYXRpbmcgYSB2aWV3IGVsZW1lbnQuIEZvciBleGFtcGxlLCBtb2RlbCBgPHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD5gIGJlY29tZXMgYDxwPkZvbzwvcD5gIGluIHRoZSB2aWV3LgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAncGFyYWdyYXBoJywKICAgICAqCQkJdmlldzogJ3AnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5lbGVtZW50VG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAncGFyYWdyYXBoJywKICAgICAqCQkJdmlldzogJ2RpdicsCiAgICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdmYW5jeVBhcmFncmFwaCcsCiAgICAgKgkJCXZpZXc6IHsKICAgICAqCQkJCW5hbWU6ICdwJywKICAgICAqCQkJCWNsYXNzZXM6ICdmYW5jeScKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ2hlYWRpbmcnLAogICAgICoJCQl2aWV3OiAoIG1vZGVsRWxlbWVudCwgdmlld1dyaXRlciApID0+IHsKICAgICAqCQkJCXJldHVybiB2aWV3V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdoJyArIG1vZGVsRWxlbWVudC5nZXRBdHRyaWJ1dGUoICdsZXZlbCcgKSApCiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjZWxlbWVudFRvRWxlbWVudAogICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLm1vZGVsIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBlbGVtZW50IHRvIGNvbnZlcnQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbiBvciBhIGZ1bmN0aW9uCiAgICAgKiB0aGF0IHRha2VzIHRoZSBtb2RlbCBlbGVtZW50IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyIHZpZXcgZG93bmNhc3Qgd3JpdGVyfQogICAgICogYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIHZpZXcgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN9CiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50VG9FbGVtZW50KGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RFbGVtZW50VG9FbGVtZW50KGNvbmZpZykpOwogICAgfQogICAgLyoqCiAgICAgKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIHdyYXBwaW5nIHZpZXcgbm9kZXMgd2l0aCBhIHZpZXcgYXR0cmlidXRlIGVsZW1lbnQuIEZvciBleGFtcGxlLCBhIG1vZGVsIHRleHQgbm9kZSB3aXRoCiAgICAgKiBgIkZvbyJgIGFzIGRhdGEgYW5kIHRoZSBgYm9sZGAgYXR0cmlidXRlIGJlY29tZXMgYDxzdHJvbmc+Rm9vPC9zdHJvbmc+YCBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6ICdzdHJvbmcnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdib2xkJywKICAgICAqCQkJdmlldzogJ2InLAogICAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdpbnZlcnQnLAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQljbGFzc2VzOiBbICdmb250LWxpZ2h0JywgJ2JnLWRhcmsnIF0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdmb250U2l6ZScsCiAgICAgKgkJCQl2YWx1ZXM6IFsgJ2JpZycsICdzbWFsbCcgXQogICAgICoJCQl9LAogICAgICoJCQl2aWV3OiB7CiAgICAgKgkJCQliaWc6IHsKICAgICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICAgKgkJCQkJc3R5bGVzOiB7CiAgICAgKgkJCQkJCSdmb250LXNpemUnOiAnMS4yZW0nCiAgICAgKgkJCQkJfQogICAgICoJCQkJfSwKICAgICAqCQkJCXNtYWxsOiB7CiAgICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJCXN0eWxlczogewogICAgICoJCQkJCQknZm9udC1zaXplJzogJzAuOGVtJwogICAgICoJCQkJCX0KICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICAgKgkJCXZpZXc6ICggbW9kZWxBdHRyaWJ1dGVWYWx1ZSwgdmlld1dyaXRlciApID0+IHsKICAgICAqCQkJCXJldHVybiB2aWV3V3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzcGFuJywgewogICAgICoJCQkJCXN0eWxlOiAnZm9udC13ZWlnaHQ6JyArIG1vZGVsQXR0cmlidXRlVmFsdWUKICAgICAqCQkJCX0gKTsKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiB7CiAgICAgKgkJCQlrZXk6ICdjb2xvcicsCiAgICAgKgkJCQluYW1lOiAnJHRleHQnCiAgICAgKgkJCX0sCiAgICAgKgkJCXZpZXc6ICggbW9kZWxBdHRyaWJ1dGVWYWx1ZSwgdmlld1dyaXRlciApID0+IHsKICAgICAqCQkJCXJldHVybiB2aWV3V3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzcGFuJywgewogICAgICoJCQkJCXN0eWxlOiAnY29sb3I6JyArIG1vZGVsQXR0cmlidXRlVmFsdWUKICAgICAqCQkJCX0gKTsKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAbWV0aG9kICNhdHRyaWJ1dGVUb0VsZW1lbnQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgVGhlIGtleSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBvciBhIGB7IGtleSwgdmFsdWVzIH1gIG9iamVjdC4gYHZhbHVlc2AgaXMgYW4gYXJyYXkKICAgICAqIG9mIGBTdHJpbmdgcyB3aXRoIHBvc3NpYmxlIHZhbHVlcyBpZiB0aGUgbW9kZWwgYXR0cmlidXRlIGlzIGFuIGVudW1lcmFibGUuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbnxPYmplY3R9IGNvbmZpZy52aWV3IEEgdmlldyBlbGVtZW50IGRlZmluaXRpb24gb3IgYSBmdW5jdGlvbgogICAgICogdGhhdCB0YWtlcyB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyIHZpZXcgZG93bmNhc3Qgd3JpdGVyfQogICAgICogYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIHZpZXcgYXR0cmlidXRlIGVsZW1lbnQuIElmIGBjb25maWcubW9kZWwudmFsdWVzYCBpcwogICAgICogZ2l2ZW4sIGBjb25maWcudmlld2Agc2hvdWxkIGJlIGFuIG9iamVjdCBhc3NpZ25pbmcgdmFsdWVzIGZyb20gYGNvbmZpZy5tb2RlbC52YWx1ZXNgIHRvIHZpZXcgZWxlbWVudCBkZWZpbml0aW9ucyBvciBmdW5jdGlvbnMuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXR0cmlidXRlVG9FbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVUb0VsZW1lbnQoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZChkb3duY2FzdEF0dHJpYnV0ZVRvRWxlbWVudChjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogTW9kZWwgYXR0cmlidXRlIHRvIHZpZXcgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgogICAgICoKICAgICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIGFkZGluZyBhbiBhdHRyaWJ1dGUgdG8gYSB2aWV3IG5vZGUsIGJhc2luZyBvbiBhbiBhdHRyaWJ1dGUgZnJvbSBhIG1vZGVsIG5vZGUuIEZvciBleGFtcGxlLAogICAgICogYDxpbWFnZSBzcmM9J2Zvby5qcGcnPjwvaW1hZ2U+YCBpcyBjb252ZXJ0ZWQgdG8gYDxpbWcgc3JjPSdmb28uanBnJz48L2ltZz5gLgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQltb2RlbDogJ3NvdXJjZScsCiAgICAgKgkJCXZpZXc6ICdzcmMnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQltb2RlbDogJ3NvdXJjZScsCiAgICAgKgkJCXZpZXc6ICdocmVmJywKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6IHsKICAgICAqCQkJCW5hbWU6ICdpbWFnZScsCiAgICAgKgkJCQlrZXk6ICdzb3VyY2UnCiAgICAgKgkJCX0sCiAgICAgKgkJCXZpZXc6ICdzcmMnCiAgICAgKgkJfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICoJCQltb2RlbDogewogICAgICoJCQkJbmFtZTogJ3N0eWxlZCcsCiAgICAgKgkJCQl2YWx1ZXM6IFsgJ2RhcmsnLCAnbGlnaHQnIF0KICAgICAqCQkJfSwKICAgICAqCQkJdmlldzogewogICAgICoJCQkJZGFyazogewogICAgICoJCQkJCWtleTogJ2NsYXNzJywKICAgICAqCQkJCQl2YWx1ZTogWyAnc3R5bGVkJywgJ3N0eWxlZC1kYXJrJyBdCiAgICAgKgkJCQl9LAogICAgICoJCQkJbGlnaHQ6IHsKICAgICAqCQkJCQlrZXk6ICdjbGFzcycsCiAgICAgKgkJCQkJdmFsdWU6IFsgJ3N0eWxlZCcsICdzdHlsZWQtbGlnaHQnIF0KICAgICAqCQkJCX0KICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgICAqCQkJbW9kZWw6ICdzdHlsZWQnLAogICAgICoJCQl2aWV3OiBtb2RlbEF0dHJpYnV0ZVZhbHVlID0+ICggeyBrZXk6ICdjbGFzcycsIHZhbHVlOiAnc3R5bGVkLScgKyBtb2RlbEF0dHJpYnV0ZVZhbHVlIH0gKQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiAqKk5vdGUqKjogRG93bmNhc3RpbmcgdG8gYSBzdHlsZSBwcm9wZXJ0eSByZXF1aXJlcyBwcm92aWRpbmcgYHZhbHVlYCBhcyBhbiBvYmplY3Q6CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICAgKgkJCW1vZGVsOiAnbGluZUhlaWdodCcsCiAgICAgKgkJCXZpZXc6IG1vZGVsQXR0cmlidXRlVmFsdWUgPT4gKCB7CiAgICAgKgkJCQlrZXk6ICdzdHlsZScsCiAgICAgKgkJCQl2YWx1ZTogewogICAgICoJCQkJCSdsaW5lLWhlaWdodCc6IG1vZGVsQXR0cmlidXRlVmFsdWUsCiAgICAgKgkJCQkJJ2JvcmRlci1ib3R0b20nOiAnMXB4IGRvdHRlZCAjYmEyJwogICAgICoJCQkJfQogICAgICoJCQl9ICkKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjYXR0cmlidXRlVG9BdHRyaWJ1dGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcubW9kZWwgVGhlIGtleSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBvciBhIGB7IGtleSwgdmFsdWVzLCBbIG5hbWUgXSB9YCBvYmplY3QgZGVzY3JpYmluZwogICAgICogdGhlIGF0dHJpYnV0ZSBrZXksIHBvc3NpYmxlIHZhbHVlcyBhbmQsIG9wdGlvbmFsbHksIGFuIGVsZW1lbnQgbmFtZSB0byBjb252ZXJ0IGZyb20uCiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBhdHRyaWJ1dGUga2V5LCBvciBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcwogICAgICogdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSBhbmQgcmV0dXJucyBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0LiBJZiBga2V5YCBpcyBgJ2NsYXNzJ2AsIGB2YWx1ZWAgY2FuIGJlIGEgYFN0cmluZ2Agb3IgYW4KICAgICAqIGFycmF5IG9mIGBTdHJpbmdgcy4gSWYgYGtleWAgaXMgYCdzdHlsZSdgLCBgdmFsdWVgIGlzIGFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy4gSW4gb3RoZXIgY2FzZXMsIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC4KICAgICAqIElmIGBjb25maWcubW9kZWwudmFsdWVzYCBpcyBzZXQsIGBjb25maWcudmlld2Agc2hvdWxkIGJlIGFuIG9iamVjdCBhc3NpZ25pbmcgdmFsdWVzIGZyb20gYGNvbmZpZy5tb2RlbC52YWx1ZXNgIHRvCiAgICAgKiBgeyBrZXksIHZhbHVlIH1gIG9iamVjdHMgb3IgYSBmdW5jdGlvbnMuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYXR0cmlidXRlVG9BdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZVRvQXR0cmlidXRlKGNvbmZpZykgewogICAgICByZXR1cm4gdGhpcy5hZGQoZG93bmNhc3RBdHRyaWJ1dGVUb0F0dHJpYnV0ZShjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogTW9kZWwgbWFya2VyIHRvIHZpZXcgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiBUaGlzIGNvbnZlcnNpb24gcmVzdWx0cyBpbiBjcmVhdGluZyBhIHZpZXcgZWxlbWVudCBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgY29udmVydGVkIG1hcmtlci4gSWYgdGhlIGNvbnZlcnRlZCBtYXJrZXIKICAgICAqIGlzIGNvbGxhcHNlZCwgb25seSBvbmUgZWxlbWVudCBpcyBjcmVhdGVkLiBGb3IgZXhhbXBsZSwgbW9kZWwgbWFya2VyIHNldCBsaWtlIHRoaXM6IGA8cGFyYWdyYXBoPkZbb28gYl1hcjwvcGFyYWdyYXBoPmAKICAgICAqIGJlY29tZXMgYDxwPkY8c3BhbiBkYXRhLW1hcmtlcj0ic2VhcmNoIj48L3NwYW4+b28gYjxzcGFuIGRhdGEtbWFya2VyPSJzZWFyY2giPjwvc3Bhbj5hcjwvcD5gIGluIHRoZSB2aWV3LgogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5tYXJrZXJUb0VsZW1lbnQoIHsKICAgICAqCQkJbW9kZWw6ICdzZWFyY2gnLAogICAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLm1hcmtlclRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ3NlYXJjaCcsCiAgICAgKgkJCXZpZXc6ICdzZWFyY2gtcmVzdWx0JywKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkubWFya2VyVG9FbGVtZW50KCB7CiAgICAgKgkJCW1vZGVsOiAnc2VhcmNoJywKICAgICAqCQkJdmlldzogewogICAgICoJCQkJbmFtZTogJ3NwYW4nLAogICAgICoJCQkJYXR0cmlidXRlczogewogICAgICoJCQkJCSdkYXRhLW1hcmtlcic6ICdzZWFyY2gnCiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLm1hcmtlclRvRWxlbWVudCggewogICAgICoJCQltb2RlbDogJ3NlYXJjaCcsCiAgICAgKgkJCXZpZXc6ICggbWFya2VyRGF0YSwgdmlld1dyaXRlciApID0+IHsKICAgICAqCQkJCXJldHVybiB2aWV3V3JpdGVyLmNyZWF0ZVVJRWxlbWVudCggJ3NwYW4nLCB7CiAgICAgKgkJCQkJJ2RhdGEtbWFya2VyJzogJ3NlYXJjaCcsCiAgICAgKgkJCQkJJ2RhdGEtc3RhcnQnOiBtYXJrZXJEYXRhLmlzT3BlbmluZwogICAgICoJCQkJfSApOwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIGFzIHRoZSBgY29uZmlnLnZpZXdgIHBhcmFtZXRlciwgaXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIGJvdGggYm91bmRhcnkgZWxlbWVudHMuIFRoZSBmdW5jdGlvbgogICAgICogcmVjZWl2ZXMgdGhlIGBkYXRhYCBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHNob3VsZCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgdmlldyBVSSBlbGVtZW50fS4gVGhlIGBkYXRhYCBvYmplY3QgYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdENvbnZlcnNpb25BcGkgYGNvbnZlcnNpb25BcGlgfSBhcmUgcGFzc2VkIGZyb20KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDphZGRNYXJrZXJ9LiBBZGRpdGlvbmFsbHksCiAgICAgKiB0aGUgYGRhdGEuaXNPcGVuaW5nYCBwYXJhbWV0ZXIgaXMgcGFzc2VkLCB3aGljaCBpcyBzZXQgdG8gYHRydWVgIGZvciB0aGUgbWFya2VyIHN0YXJ0IGJvdW5kYXJ5IGVsZW1lbnQsIGFuZCBgZmFsc2VgIHRvCiAgICAgKiB0aGUgbWFya2VyIGVuZCBib3VuZGFyeSBlbGVtZW50LgogICAgICoKICAgICAqIFRoaXMga2luZCBvZiBjb252ZXJzaW9uIGlzIHVzZWZ1bCBmb3Igc2F2aW5nIGRhdGEgaW50byB0aGUgZGF0YWJhc2UsIHNvIGl0IHNob3VsZCBiZSB1c2VkIGluIHRoZSBkYXRhIGNvbnZlcnNpb24gcGlwZWxpbmUuCiAgICAgKgogICAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICAgKgogICAgICogQG1ldGhvZCAjbWFya2VyVG9FbGVtZW50CiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubW9kZWwgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciAob3IgbW9kZWwgbWFya2VyIGdyb3VwKSB0byBjb252ZXJ0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBlbGVtZW50IGRlZmluaXRpb24gb3IgYSBmdW5jdGlvbgogICAgICogdGhhdCB0YWtlcyB0aGUgbW9kZWwgbWFya2VyIGRhdGEgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSB2aWV3IFVJIGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnN9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWFya2VyVG9FbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrZXJUb0VsZW1lbnQoY29uZmlnKSB7CiAgICAgIHJldHVybiB0aGlzLmFkZChkb3duY2FzdE1hcmtlclRvRWxlbWVudChjb25maWcpKTsKICAgIH0KICAgIC8qKgogICAgICogTW9kZWwgbWFya2VyIHRvIGhpZ2hsaWdodCBjb252ZXJzaW9uIGhlbHBlci4KICAgICAqCiAgICAgKiBUaGlzIGNvbnZlcnNpb24gcmVzdWx0cyBpbiBjcmVhdGluZyBhIGhpZ2hsaWdodCBvbiB2aWV3IG5vZGVzLiBGb3IgdGhpcyBraW5kIG9mIGNvbnZlcnNpb24sCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfSBzaG91bGQgYmUgcHJvdmlkZWQuCiAgICAgKgogICAgICogRm9yIHRleHQgbm9kZXMsIGEgYDxzcGFuPmAge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGlzIGNyZWF0ZWQgYW5kIGl0IHdyYXBzIGFsbCB0ZXh0IG5vZGVzCiAgICAgKiBpbiB0aGUgY29udmVydGVkIG1hcmtlciByYW5nZS4gRm9yIGV4YW1wbGUsIGEgbW9kZWwgbWFya2VyIHNldCBsaWtlIHRoaXM6IGA8cGFyYWdyYXBoPkZbb28gYl1hcjwvcGFyYWdyYXBoPmAgYmVjb21lcwogICAgICogYDxwPkY8c3BhbiBjbGFzcz0iY29tbWVudCI+b28gYjwvc3Bhbj5hcjwvcD5gIGluIHRoZSB2aWV3LgogICAgICoKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fSBtYXkgcHJvdmlkZSBhIGN1c3RvbSB3YXkgb2YgaGFuZGxpbmcgaGlnaGxpZ2h0LiBNb3N0IG9mdGVuLAogICAgICogdGhlIGVsZW1lbnQgaXRzZWxmIGlzIGdpdmVuIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZXMgZGVzY3JpYmVkIGluIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciAoaW5zdGVhZCBvZiBiZWluZyB3cmFwcGVkIGluIGA8c3Bhbj5gKS4KICAgICAqIEZvciBleGFtcGxlLCBhIG1vZGVsIG1hcmtlciBzZXQgbGlrZSB0aGlzOiBgWzxpbWFnZSBzcmM9ImZvby5qcGciPjwvaW1hZ2U+XWAgYmVjb21lcyBgPGltZyBzcmM9ImZvby5qcGciIGNsYXNzPSJjb21tZW50Ij48L2ltZz5gCiAgICAgKiBpbiB0aGUgdmlldy4KICAgICAqCiAgICAgKiBGb3IgY29udGFpbmVyIGVsZW1lbnRzLCB0aGUgY29udmVyc2lvbiBpcyB0d28tc3RlcC4gV2hpbGUgdGhlIGNvbnZlcnRlciBwcm9jZXNzZXMgdGhlIGhpZ2hsaWdodCBkZXNjcmlwdG9yIGFuZCBwYXNzZXMgaXQKICAgICAqIHRvIGEgY29udGFpbmVyIGVsZW1lbnQsIGl0IGlzIHRoZSBjb250YWluZXIgZWxlbWVudCBpbnN0YW5jZSBpdHNlbGYgdGhhdCBhcHBsaWVzIHZhbHVlcyBmcm9tIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvci4KICAgICAqIFNvLCBpbiBhIHNlbnNlLCB0aGUgY29udmVydGVyIHRha2VzIGNhcmUgb2Ygc3RhdGluZyB3aGF0IHNob3VsZCBiZSBhcHBsaWVkIG9uIHdoYXQsIHdoaWxlIHRoZSBlbGVtZW50IGRlY2lkZXMgaG93IHRvIGFwcGx5IHRoYXQuCiAgICAgKgogICAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLm1hcmtlclRvSGlnaGxpZ2h0KCB7IG1vZGVsOiAnY29tbWVudCcsIHZpZXc6IHsgY2xhc3NlczogJ2NvbW1lbnQnIH0gfSApOwogICAgICoKICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5tYXJrZXJUb0hpZ2hsaWdodCggewogICAgICoJCQltb2RlbDogJ2NvbW1lbnQnLAogICAgICoJCQl2aWV3OiB7IGNsYXNzZXM6ICduZXctY29tbWVudCcgfSwKICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAnZG93bmNhc3QnICkubWFya2VyVG9IaWdobGlnaHQoIHsKICAgICAqCQkJbW9kZWw6ICdjb21tZW50JywKICAgICAqCQkJdmlldzogZGF0YSA9PiB7CiAgICAgKgkJCQkvLyBBc3N1bWluZyB0aGF0IHRoZSBtYXJrZXIgbmFtZSBpcyBpbiBhIGZvcm0gb2YgY29tbWVudDpjb21tZW50VHlwZS4KICAgICAqCQkJCWNvbnN0IGNvbW1lbnRUeXBlID0gZGF0YS5tYXJrZXJOYW1lLnNwbGl0KCAnOicgKVsgMSBdOwogICAgICoKICAgICAqCQkJCXJldHVybiB7CiAgICAgKgkJCQkJY2xhc3NlczogWyAnY29tbWVudCcsICdjb21tZW50LScgKyBjb21tZW50VHlwZSBdCiAgICAgKgkJCQl9OwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIElmIGEgZnVuY3Rpb24gaXMgcGFzc2VkIGFzIHRoZSBgY29uZmlnLnZpZXdgIHBhcmFtZXRlciwgaXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvci4gVGhlIGZ1bmN0aW9uCiAgICAgKiByZWNlaXZlcyB0aGUgYGRhdGFgIG9iamVjdCBhcyBhIHBhcmFtZXRlciBhbmQgc2hvdWxkIHJldHVybiBhCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yIGhpZ2hsaWdodCBkZXNjcmlwdG9yfS4KICAgICAqIFRoZSBgZGF0YWAgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHBhc3NlZCBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDphZGRNYXJrZXJ9LgogICAgICoKICAgICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNmb3IgYGNvbnZlcnNpb24uZm9yKClgfSB0byBsZWFybiBob3cgdG8gYWRkIGEgY29udmVydGVyCiAgICAgKiB0byB0aGUgY29udmVyc2lvbiBwcm9jZXNzLgogICAgICoKICAgICAqIEBtZXRob2QgI21hcmtlclRvSGlnaGxpZ2h0CiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcubW9kZWwgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciAob3IgbW9kZWwgbWFya2VyIGdyb3VwKSB0byBjb252ZXJ0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkhpZ2hsaWdodERlc2NyaXB0b3J8RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgaGlnaGxpZ2h0IGRlc2NyaXB0b3IKICAgICAqIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBoaWdobGlnaHRpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBtb2RlbCBtYXJrZXIgZGF0YSBhcyBhIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIGhpZ2hsaWdodCBkZXNjcmlwdG9yLgogICAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm1hcmtlclRvSGlnaGxpZ2h0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrZXJUb0hpZ2hsaWdodChjb25maWcpIHsKICAgICAgcmV0dXJuIHRoaXMuYWRkKGRvd25jYXN0TWFya2VyVG9IaWdobGlnaHQoY29uZmlnKSk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gRG93bmNhc3RIZWxwZXJzOwp9KENvbnZlcnNpb25IZWxwZXJzKTsKLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgZGVmYXVsdCBkb3duY2FzdCBjb252ZXJ0ZXIgZm9yIHRleHQgaW5zZXJ0aW9uIGNoYW5nZXMuCiAqCiAqIFRoZSBjb252ZXJ0ZXIgYXV0b21hdGljYWxseSBjb25zdW1lcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSBjb25zdW1hYmxlcyBsaXN0IGFuZCBzdG9wcyB0aGUgZXZlbnQgKHNlZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9KS4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ2luc2VydDokdGV4dCcsIGluc2VydFRleHQoKSApOwogKgogKiBAcmV0dXJucyB7RnVuY3Rpb259IEluc2VydCB0ZXh0IGV2ZW50IGNvbnZlcnRlci4KICovCgoKZXhwb3J0IHsgRG93bmNhc3RIZWxwZXJzIGFzIGRlZmF1bHQgfTsKZXhwb3J0IGZ1bmN0aW9uIGluc2VydFRleHQoKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCAnaW5zZXJ0JykpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7CiAgICB2YXIgdmlld1Bvc2l0aW9uID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24oZGF0YS5yYW5nZS5zdGFydCk7CiAgICB2YXIgdmlld1RleHQgPSB2aWV3V3JpdGVyLmNyZWF0ZVRleHQoZGF0YS5pdGVtLmRhdGEpOwogICAgdmlld1dyaXRlci5pbnNlcnQodmlld1Bvc2l0aW9uLCB2aWV3VGV4dCk7CiAgfTsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBkZWZhdWx0IGRvd25jYXN0IGNvbnZlcnRlciBmb3Igbm9kZSByZW1vdmUgY2hhbmdlcy4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ3JlbW92ZScsIHJlbW92ZSgpICk7CiAqCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmVtb3ZlIGV2ZW50IGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gcmVtb3ZlKCkgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICAvLyBGaW5kIHZpZXcgcmFuZ2Ugc3RhcnQgcG9zaXRpb24gYnkgbWFwcGluZyBtb2RlbCBwb3NpdGlvbiBhdCB3aGljaCB0aGUgcmVtb3ZlIGhhcHBlbmVkLgogICAgdmFyIHZpZXdTdGFydCA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKGRhdGEucG9zaXRpb24pOwogICAgdmFyIG1vZGVsRW5kID0gZGF0YS5wb3NpdGlvbi5nZXRTaGlmdGVkQnkoZGF0YS5sZW5ndGgpOwogICAgdmFyIHZpZXdFbmQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdQb3NpdGlvbihtb2RlbEVuZCwgewogICAgICBpc1BoYW50b206IHRydWUKICAgIH0pOwogICAgdmFyIHZpZXdSYW5nZSA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVJhbmdlKHZpZXdTdGFydCwgdmlld0VuZCk7IC8vIFRyaW0gdGhlIHJhbmdlIHRvIHJlbW92ZSBpbiBjYXNlIHNvbWUgVUkgZWxlbWVudHMgYXJlIG9uIHRoZSB2aWV3IHJhbmdlIGJvdW5kYXJpZXMuCgogICAgdmFyIHJlbW92ZWQgPSBjb252ZXJzaW9uQXBpLndyaXRlci5yZW1vdmUodmlld1JhbmdlLmdldFRyaW1tZWQoKSk7IC8vIEFmdGVyIHRoZSByYW5nZSBpcyByZW1vdmVkLCB1bmJpbmQgYWxsIHZpZXcgZWxlbWVudHMgZnJvbSB0aGUgbW9kZWwuCiAgICAvLyBSYW5nZSBpbnNpZGUgdmlldyBkb2N1bWVudCBmcmFnbWVudCBpcyB1c2VkIHRvIHVuYmluZCBkZWVwbHkuCgogICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgdHJ5IHsKICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUmFuZ2VJbihyZW1vdmVkKS5nZXRJdGVtcygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkgewogICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlOwogICAgICAgIGNvbnZlcnNpb25BcGkubWFwcGVyLnVuYmluZFZpZXdFbGVtZW50KGNoaWxkKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICB9IGZpbmFsbHkgewogICAgICB0cnkgewogICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICB9CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9Owp9Ci8qKgogKiBDcmVhdGVzIGEgYDxzcGFuPmAge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgdmlldyBhdHRyaWJ1dGUgZWxlbWVudH0gZnJvbSB0aGUgaW5mb3JtYXRpb24KICogcHJvdmlkZWQgYnkgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkhpZ2hsaWdodERlc2NyaXB0b3IgaGlnaGxpZ2h0IGRlc2NyaXB0b3J9IG9iamVjdC4gSWYgYSBwcmlvcml0eQogKiBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIGRlc2NyaXB0b3IsIHRoZSBkZWZhdWx0IHByaW9yaXR5IHdpbGwgYmUgdXNlZC4KICoKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9IHdyaXRlcgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcn0gZGVzY3JpcHRvcgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0KICovCgpleHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlld0VsZW1lbnRGcm9tSGlnaGxpZ2h0RGVzY3JpcHRvcih3cml0ZXIsIGRlc2NyaXB0b3IpIHsKICB2YXIgdmlld0VsZW1lbnQgPSB3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCgnc3BhbicsIGRlc2NyaXB0b3IuYXR0cmlidXRlcyk7CgogIGlmIChkZXNjcmlwdG9yLmNsYXNzZXMpIHsKICAgIHZpZXdFbGVtZW50Ll9hZGRDbGFzcyhkZXNjcmlwdG9yLmNsYXNzZXMpOwogIH0KCiAgaWYgKGRlc2NyaXB0b3IucHJpb3JpdHkpIHsKICAgIHZpZXdFbGVtZW50Ll9wcmlvcml0eSA9IGRlc2NyaXB0b3IucHJpb3JpdHk7CiAgfQoKICB2aWV3RWxlbWVudC5faWQgPSBkZXNjcmlwdG9yLmlkOwogIHJldHVybiB2aWV3RWxlbWVudDsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgYSBub24tY29sbGFwc2VkIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24gbW9kZWwgc2VsZWN0aW9ufQogKiB0byBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24gdmlldyBzZWxlY3Rpb259LiBUaGUgY29udmVydGVyIGNvbnN1bWVzIGFwcHJvcHJpYXRlCiAqIHZhbHVlIGZyb20gdGhlIGBjb25zdW1hYmxlYCBvYmplY3QgYW5kIG1hcHMgbW9kZWwgcG9zaXRpb25zIGZyb20gdGhlIHNlbGVjdGlvbiB0byB2aWV3IHBvc2l0aW9ucy4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ3NlbGVjdGlvbicsIGNvbnZlcnRSYW5nZVNlbGVjdGlvbigpICk7CiAqCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2VsZWN0aW9uIGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gY29udmVydFJhbmdlU2VsZWN0aW9uKCkgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgc2VsZWN0aW9uID0gZGF0YS5zZWxlY3Rpb247CgogICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShzZWxlY3Rpb24sICdzZWxlY3Rpb24nKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIHZpZXdSYW5nZXMgPSBbXTsKICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7CiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgIHRyeSB7CiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICB2YXIgcmFuZ2UgPSBfc3RlcDIudmFsdWU7CiAgICAgICAgdmFyIHZpZXdSYW5nZSA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1JhbmdlKHJhbmdlKTsKICAgICAgICB2aWV3UmFuZ2VzLnB1c2godmlld1JhbmdlKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjsKICAgIH0gZmluYWxseSB7CiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgIH0KICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgY29udmVyc2lvbkFwaS53cml0ZXIuc2V0U2VsZWN0aW9uKHZpZXdSYW5nZXMsIHsKICAgICAgYmFja3dhcmQ6IHNlbGVjdGlvbi5pc0JhY2t3YXJkCiAgICB9KTsKICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBhIGNvbGxhcHNlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uIG1vZGVsIHNlbGVjdGlvbn0gdG8KICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uIHZpZXcgc2VsZWN0aW9ufS4gVGhlIGNvbnZlcnRlciBjb25zdW1lcyBhcHByb3ByaWF0ZQogKiB2YWx1ZSBmcm9tIHRoZSBgY29uc3VtYWJsZWAgb2JqZWN0LCBtYXBzIHRoZSBtb2RlbCBzZWxlY3Rpb24gcG9zaXRpb24gdG8gdGhlIHZpZXcgcG9zaXRpb24gYW5kIGJyZWFrcwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IGF0IHRoZSBzZWxlY3Rpb24gcG9zaXRpb24uCiAqCiAqCQltb2RlbERpc3BhdGNoZXIub24oICdzZWxlY3Rpb24nLCBjb252ZXJ0Q29sbGFwc2VkU2VsZWN0aW9uKCkgKTsKICoKICogQW4gZXhhbXBsZSBvZiB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgYW5kIGFmdGVyIGNvbnZlcnRpbmcgdGhlIGNvbGxhcHNlZCBzZWxlY3Rpb246CiAqCiAqCQkgICA8cD48c3Ryb25nPmZeb288c3Ryb25nPmJhcjwvcD4KICoJCS0+IDxwPjxzdHJvbmc+Zjwvc3Ryb25nPl48c3Ryb25nPm9vPC9zdHJvbmc+YmFyPC9wPgogKgogKiBCeSBicmVha2luZyBhdHRyaWJ1dGUgZWxlbWVudHMgbGlrZSBgPHN0cm9uZz5gLCB0aGUgc2VsZWN0aW9uIGlzIGluIGEgY29ycmVjdCBlbGVtZW50LiBUaGVuLCB3aGVuIHRoZSBzZWxlY3Rpb24gYXR0cmlidXRlIGlzCiAqIGNvbnZlcnRlZCwgYnJva2VuIGF0dHJpYnV0ZXMgbWlnaHQgYmUgbWVyZ2VkIGFnYWluLCBvciB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHNlbGVjdGlvbiBpcyBtYXkgYmUgd3JhcHBlZAogKiB3aXRoIGRpZmZlcmVudCwgYXBwcm9wcmlhdGUgYXR0cmlidXRlIGVsZW1lbnRzLgogKgogKiBTZWUgYWxzbyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35jbGVhckF0dHJpYnV0ZXN9IHdoaWNoIGRvZXMgYSBjbGVhbi11cAogKiBieSBtZXJnaW5nIGF0dHJpYnV0ZXMuCiAqCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2VsZWN0aW9uIGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gY29udmVydENvbGxhcHNlZFNlbGVjdGlvbigpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHNlbGVjdGlvbiA9IGRhdGEuc2VsZWN0aW9uOwoKICAgIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKHNlbGVjdGlvbiwgJ3NlbGVjdGlvbicpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogICAgdmFyIG1vZGVsUG9zaXRpb24gPSBzZWxlY3Rpb24uZ2V0Rmlyc3RQb3NpdGlvbigpOwogICAgdmFyIHZpZXdQb3NpdGlvbiA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKG1vZGVsUG9zaXRpb24pOwogICAgdmFyIGJyb2tlblBvc2l0aW9uID0gdmlld1dyaXRlci5icmVha0F0dHJpYnV0ZXModmlld1Bvc2l0aW9uKTsKICAgIHZpZXdXcml0ZXIuc2V0U2VsZWN0aW9uKGJyb2tlblBvc2l0aW9uKTsKICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjbGVhcnMgYXJ0aWZhY3RzIGFmdGVyIHRoZSBwcmV2aW91cwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uIG1vZGVsIHNlbGVjdGlvbn0gY29udmVyc2lvbi4gSXQgcmVtb3ZlcyBhbGwgZW1wdHkKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgdmlldyBhdHRyaWJ1dGUgZWxlbWVudHN9IGFuZCBtZXJnZXMgc2libGluZyBhdHRyaWJ1dGVzIGF0IGFsbCBzdGFydCBhbmQgZW5kCiAqIHBvc2l0aW9ucyBvZiBhbGwgcmFuZ2VzLgogKgogKgkJICAgPHA+PHN0cm9uZz5ePC9zdHJvbmc+PC9wPgogKgkJLT4gPHA+XjwvcD4KICoKICoJCSAgIDxwPjxzdHJvbmc+Zm9vPC9zdHJvbmc+XjxzdHJvbmc+YmFyPC9zdHJvbmc+YmFyPC9wPgogKgkJLT4gPHA+PHN0cm9uZz5mb29eYmFyPHN0cm9uZz5iYXI8L3A+CiAqCiAqCQkgICA8cD48c3Ryb25nPmZvbzwvc3Ryb25nPjxlbT5ePC9lbT48c3Ryb25nPmJhcjwvc3Ryb25nPmJhcjwvcD4KICoJCS0+IDxwPjxzdHJvbmc+Zm9vXmJhcjxzdHJvbmc+YmFyPC9wPgogKgogKiBUaGlzIGxpc3RlbmVyIHNob3VsZCBiZSBhc3NpZ25lZCBiZWZvcmUgYW55IGNvbnZlcnRlciBmb3IgdGhlIG5ldyBzZWxlY3Rpb246CiAqCiAqCQltb2RlbERpc3BhdGNoZXIub24oICdzZWxlY3Rpb24nLCBjbGVhckF0dHJpYnV0ZXMoKSApOwogKgogKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+Y29udmVydENvbGxhcHNlZFNlbGVjdGlvbn0KICogd2hpY2ggZG9lcyB0aGUgb3Bwb3NpdGUgYnkgYnJlYWtpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uLgogKgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFNlbGVjdGlvbiBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcygpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsKICAgIHZhciB2aWV3U2VsZWN0aW9uID0gdmlld1dyaXRlci5kb2N1bWVudC5zZWxlY3Rpb247CiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDsKCiAgICB0cnkgewogICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gdmlld1NlbGVjdGlvbi5nZXRSYW5nZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgIHZhciByYW5nZSA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgLy8gTm90IGNvbGxhcHNlZCBzZWxlY3Rpb24gc2hvdWxkIG5vdCBoYXZlIGFydGlmYWN0cy4KICAgICAgICBpZiAocmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICAgIC8vIFBvc2l0aW9uIG1pZ2h0IGJlIGluIHRoZSBub2RlIHJlbW92ZWQgYnkgdGhlIHZpZXcgd3JpdGVyLgogICAgICAgICAgaWYgKHJhbmdlLmVuZC5wYXJlbnQuaXNBdHRhY2hlZCgpKSB7CiAgICAgICAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLm1lcmdlQXR0cmlidXRlcyhyYW5nZS5zdGFydCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgfSBmaW5hbGx5IHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgfQogICAgICB9IGZpbmFsbHkgewogICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMzsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB2aWV3V3JpdGVyLnNldFNlbGVjdGlvbihudWxsKTsKICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBzZXQvY2hhbmdlL3JlbW92ZSBhdHRyaWJ1dGUgY2hhbmdlcyBmcm9tIHRoZSBtb2RlbCB0byB0aGUgdmlldy4KICogSXQgY2FuIGFsc28gYmUgdXNlZCB0byBjb252ZXJ0IHNlbGVjdGlvbiBhdHRyaWJ1dGVzLiBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IGF0dHJpYnV0ZSBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlCiAqIHNlbGVjdGlvbiB3aWxsIGJlIHB1dCBpbnNpZGUgaXQuCiAqCiAqIEF0dHJpYnV0ZXMgZnJvbSB0aGUgbW9kZWwgYXJlIGNvbnZlcnRlZCB0byBhIHZpZXcgZWxlbWVudCB0aGF0IHdpbGwgYmUgd3JhcHBpbmcgdGhlc2UgdmlldyBub2RlcyB0aGF0IGFyZSBib3VuZCB0bwogKiBtb2RlbCBlbGVtZW50cyBoYXZpbmcgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGF0dHJpYnV0ZXMgbGlrZSBgYm9sZGAgdGhhdCBtYXkgYmUgc2V0IG9uIHRleHQgbm9kZXMgaW4gdGhlIG1vZGVsCiAqIGJ1dCBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gZWxlbWVudCBpbiB0aGUgdmlldzoKICoKICoJCVtwYXJhZ3JhcGhdICAgICAgICAgICAgICBNT0RFTCA9PT09PiBWSUVXICAgICAgICA8cD4KICoJCQl8LSBhIHtib2xkOiB0cnVlfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0gPGI+CiAqCQkJfC0gYiB7Ym9sZDogdHJ1ZX0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICB8LSBhYgogKgkJCXwtIGMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8LSBjCiAqCiAqIFBhc3NlZCBgRnVuY3Rpb25gIHdpbGwgYmUgcHJvdmlkZWQgd2l0aCB0aGUgYXR0cmlidXRlIHZhbHVlIGFuZCB0aGVuIGFsbCB0aGUgcGFyYW1ldGVycyBvZiB0aGUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyI2V2ZW50OmF0dHJpYnV0ZSBgYXR0cmlidXRlYCBldmVudH0uCiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGZ1bmN0aW9uIHJldHVybnMgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9LgogKiBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHRoZSB3cmFwcGluZyBlbGVtZW50LgogKiBXaGVuIHRoZSBwcm92aWRlZCBgRnVuY3Rpb25gIGRvZXMgbm90IHJldHVybiBhbnkgZWxlbWVudCwgbm8gY29udmVyc2lvbiB3aWxsIHRha2UgcGxhY2UuCiAqCiAqIFRoZSBjb252ZXJ0ZXIgYXV0b21hdGljYWxseSBjb25zdW1lcyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSBjb25zdW1hYmxlcyBsaXN0IGFuZCBzdG9wcyB0aGUgZXZlbnQgKHNlZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9KS4KICoKICoJCW1vZGVsRGlzcGF0Y2hlci5vbiggJ2F0dHJpYnV0ZTpib2xkJywgd3JhcCggKCBtb2RlbEF0dHJpYnV0ZVZhbHVlLCB2aWV3V3JpdGVyICkgPT4gewogKgkJCXJldHVybiB2aWV3V3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzdHJvbmcnICk7CiAqCQl9ICk7CiAqCiAqIEBwcm90ZWN0ZWQKICogQHBhcmFtIHtGdW5jdGlvbn0gZWxlbWVudENyZWF0b3IgRnVuY3Rpb24gcmV0dXJuaW5nIGEgdmlldyBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGZvciB3cmFwcGluZy4KICogQHJldHVybnMge0Z1bmN0aW9ufSBTZXQvY2hhbmdlIGF0dHJpYnV0ZSBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZWxlbWVudENyZWF0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgLy8gUmVjcmVhdGUgY3VycmVudCB3cmFwcGluZyBub2RlLiBJdCB3aWxsIGJlIHVzZWQgdG8gdW53cmFwIHZpZXcgcmFuZ2UgaWYgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBoYXMgY2hhbmdlZAogICAgLy8gb3IgdGhlIGF0dHJpYnV0ZSB3YXMgcmVtb3ZlZC4KICAgIHZhciBvbGRWaWV3RWxlbWVudCA9IGVsZW1lbnRDcmVhdG9yKGRhdGEuYXR0cmlidXRlT2xkVmFsdWUsIGNvbnZlcnNpb25BcGkud3JpdGVyKTsgLy8gQ3JlYXRlIG5vZGUgdG8gd3JhcCB3aXRoLgoKICAgIHZhciBuZXdWaWV3RWxlbWVudCA9IGVsZW1lbnRDcmVhdG9yKGRhdGEuYXR0cmlidXRlTmV3VmFsdWUsIGNvbnZlcnNpb25BcGkud3JpdGVyKTsKCiAgICBpZiAoIW9sZFZpZXdFbGVtZW50ICYmICFuZXdWaWV3RWxlbWVudCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLml0ZW0sIGV2dC5uYW1lKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsKICAgIHZhciB2aWV3U2VsZWN0aW9uID0gdmlld1dyaXRlci5kb2N1bWVudC5zZWxlY3Rpb247CgogICAgaWYgKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsU2VsZWN0aW9uIHx8IGRhdGEuaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50U2VsZWN0aW9uKSB7CiAgICAgIC8vIFNlbGVjdGlvbiBhdHRyaWJ1dGUgY29udmVyc2lvbi4KICAgICAgdmlld1dyaXRlci53cmFwKHZpZXdTZWxlY3Rpb24uZ2V0Rmlyc3RSYW5nZSgpLCBuZXdWaWV3RWxlbWVudCk7CiAgICB9IGVsc2UgewogICAgICAvLyBOb2RlIGF0dHJpYnV0ZSBjb252ZXJzaW9uLgogICAgICB2YXIgdmlld1JhbmdlID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UmFuZ2UoZGF0YS5yYW5nZSk7IC8vIEZpcnN0LCB1bndyYXAgdGhlIHJhbmdlIGZyb20gY3VycmVudCB3cmFwcGVyLgoKICAgICAgaWYgKGRhdGEuYXR0cmlidXRlT2xkVmFsdWUgIT09IG51bGwgJiYgb2xkVmlld0VsZW1lbnQpIHsKICAgICAgICB2aWV3UmFuZ2UgPSB2aWV3V3JpdGVyLnVud3JhcCh2aWV3UmFuZ2UsIG9sZFZpZXdFbGVtZW50KTsKICAgICAgfQoKICAgICAgaWYgKGRhdGEuYXR0cmlidXRlTmV3VmFsdWUgIT09IG51bGwgJiYgbmV3Vmlld0VsZW1lbnQpIHsKICAgICAgICB2aWV3V3JpdGVyLndyYXAodmlld1JhbmdlLCBuZXdWaWV3RWxlbWVudCk7CiAgICAgIH0KICAgIH0KICB9Owp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgY3JlYXRlcyBhIGNvbnZlcnRlciB3aGljaCBjb252ZXJ0cyBub2RlIGluc2VydGlvbiBjaGFuZ2VzIGZyb20gdGhlIG1vZGVsIHRvIHRoZSB2aWV3LgogKiBUaGUgZnVuY3Rpb24gcGFzc2VkIHdpbGwgYmUgcHJvdmlkZWQgd2l0aCBhbGwgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGRpc3BhdGNoZXIncwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6aW5zZXJ0IGBpbnNlcnRgIGV2ZW50fS4KICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgZnVuY3Rpb24gcmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0uCiAqIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGUgdmlldy4KICoKICogVGhlIGNvbnZlcnRlciBhdXRvbWF0aWNhbGx5IGNvbnN1bWVzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIGNvbnN1bWFibGVzIGxpc3QsIHN0b3BzIHRoZSBldmVudCAoc2VlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0pIGFuZCBiaW5kcyB0aGUgbW9kZWwgYW5kIHZpZXcgZWxlbWVudHMuCiAqCiAqCQlkb3duY2FzdERpc3BhdGNoZXIub24oCiAqCQkJJ2luc2VydDpteUVsZW0nLAogKgkJCWluc2VydEVsZW1lbnQoICggbW9kZWxJdGVtLCB2aWV3V3JpdGVyICkgPT4gewogKgkJCQljb25zdCB0ZXh0ID0gdmlld1dyaXRlci5jcmVhdGVUZXh0KCAnbXlUZXh0JyApOwogKgkJCQljb25zdCBteUVsZW0gPSB2aWV3V3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdteUVsZW0nLCB7IG15QXR0cjogJ215LScgKyBtb2RlbEl0ZW0uZ2V0QXR0cmlidXRlKCAnbXlBdHRyJyApIH0sIHRleHQgKTsKICoKICoJCQkJLy8gRG8gc29tZXRoaW5nIGZhbmN5IHdpdGggYG15RWxlbWAgdXNpbmcgYG1vZGVsSXRlbWAgb3Igb3RoZXIgcGFyYW1ldGVycy4KICoKICoJCQkJcmV0dXJuIG15RWxlbTsKICoJCQl9CiAqCQkpICk7CiAqCiAqIEBwcm90ZWN0ZWQKICogQHBhcmFtIHtGdW5jdGlvbn0gZWxlbWVudENyZWF0b3IgRnVuY3Rpb24gcmV0dXJuaW5nIGEgdmlldyBlbGVtZW50LCB3aGljaCB3aWxsIGJlIGluc2VydGVkLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IEluc2VydCBlbGVtZW50IGV2ZW50IGNvbnZlcnRlci4KICovCgpleHBvcnQgZnVuY3Rpb24gaW5zZXJ0RWxlbWVudChlbGVtZW50Q3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICB2YXIgdmlld0VsZW1lbnQgPSBlbGVtZW50Q3JlYXRvcihkYXRhLml0ZW0sIGNvbnZlcnNpb25BcGkud3JpdGVyKTsKCiAgICBpZiAoIXZpZXdFbGVtZW50KSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgJ2luc2VydCcpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1Bvc2l0aW9uID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24oZGF0YS5yYW5nZS5zdGFydCk7CiAgICBjb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudHMoZGF0YS5pdGVtLCB2aWV3RWxlbWVudCk7CiAgICBjb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQodmlld1Bvc2l0aW9uLCB2aWV3RWxlbWVudCk7CiAgfTsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgbWFya2VyIGFkZGluZyBjaGFuZ2UgdG8gdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCB2aWV3IFVJIGVsZW1lbnR9LgogKgogKiBUaGUgdmlldyBVSSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdmlldyBkZXBlbmRzIG9uIHRoZSBwYXNzZWQgcGFyYW1ldGVyLiBTZWUge0BsaW5rIH5pbnNlcnRFbGVtZW50fS4KICogSW4gY2FzZSBvZiBhIG5vbi1jb2xsYXBzZWQgcmFuZ2UsIHRoZSBVSSBlbGVtZW50IHdpbGwgbm90IHdyYXAgbm9kZXMgYnV0IHNlcGFyYXRlIGVsZW1lbnRzIHdpbGwgYmUgcGxhY2VkIGF0IHRoZSBiZWdpbm5pbmcKICogYW5kIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLgogKgogKiBUaGlzIGNvbnZlcnRlciBiaW5kcyBjcmVhdGVkIFVJIGVsZW1lbnRzIHdpdGggdGhlIG1hcmtlciBuYW1lIHVzaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNiaW5kRWxlbWVudFRvTWFya2VyfS4KICoKICogQHByb3RlY3RlZAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fEZ1bmN0aW9ufSBlbGVtZW50Q3JlYXRvciBBIHZpZXcgVUkgZWxlbWVudCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgdmlldyBlbGVtZW50CiAqIHRoYXQgd2lsbCBiZSBpbnNlcnRlZC4KICogQHJldHVybnMge0Z1bmN0aW9ufSBJbnNlcnQgZWxlbWVudCBldmVudCBjb252ZXJ0ZXIuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGluc2VydFVJRWxlbWVudChlbGVtZW50Q3JlYXRvcikgewogIHJldHVybiBmdW5jdGlvbiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgICAvLyBDcmVhdGUgdHdvIHZpZXcgZWxlbWVudHMuIE9uZSB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgbWFya2VyLCBvbmUgYXQgdGhlIGVuZC4KICAgIC8vIElmIG1hcmtlciBpcyBjb2xsYXBzZWQsIG9ubHkgIm9wZW5pbmciIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZC4KICAgIGRhdGEuaXNPcGVuaW5nID0gdHJ1ZTsKICAgIHZhciB2aWV3U3RhcnRFbGVtZW50ID0gZWxlbWVudENyZWF0b3IoZGF0YSwgY29udmVyc2lvbkFwaS53cml0ZXIpOwogICAgZGF0YS5pc09wZW5pbmcgPSBmYWxzZTsKICAgIHZhciB2aWV3RW5kRWxlbWVudCA9IGVsZW1lbnRDcmVhdG9yKGRhdGEsIGNvbnZlcnNpb25BcGkud3JpdGVyKTsKCiAgICBpZiAoIXZpZXdTdGFydEVsZW1lbnQgfHwgIXZpZXdFbmRFbGVtZW50KSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgbWFya2VyUmFuZ2UgPSBkYXRhLm1hcmtlclJhbmdlOyAvLyBNYXJrZXIgdGhhdCBpcyBjb2xsYXBzZWQgaGFzIGNvbnN1bWFibGUgYnVpbGQgZGlmZmVyZW50bHkgdGhhdCBub24tY29sbGFwc2VkIG9uZS4KICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBgYWRkTWFya2VyYCBldmVudCBkZXNjcmlwdGlvbi4KICAgIC8vIElmIG1hcmtlcidzIHJhbmdlIGlzIGNvbGxhcHNlZCAtIGNoZWNrIGlmIGl0IGNhbiBiZSBjb25zdW1lZC4KCiAgICBpZiAobWFya2VyUmFuZ2UuaXNDb2xsYXBzZWQgJiYgIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKG1hcmtlclJhbmdlLCBldnQubmFtZSkpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBJZiBtYXJrZXIncyByYW5nZSBpcyBub3QgY29sbGFwc2VkIC0gY29uc3VtZSBhbGwgaXRlbXMgaW5zaWRlLgoKCiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDsKCiAgICB0cnkgewogICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gbWFya2VyUmFuZ2VbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDQudmFsdWU7CgogICAgICAgIGlmICghY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUodmFsdWUuaXRlbSwgZXZ0Lm5hbWUpKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyOwogICAgfSBmaW5hbGx5IHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7CiAgICAgICAgfQogICAgICB9IGZpbmFsbHkgewogICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICB2YXIgbWFwcGVyID0gY29udmVyc2lvbkFwaS5tYXBwZXI7CiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOyAvLyBBZGQgIm9wZW5pbmciIGVsZW1lbnQuCgogICAgdmlld1dyaXRlci5pbnNlcnQobWFwcGVyLnRvVmlld1Bvc2l0aW9uKG1hcmtlclJhbmdlLnN0YXJ0KSwgdmlld1N0YXJ0RWxlbWVudCk7CiAgICBjb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudFRvTWFya2VyKHZpZXdTdGFydEVsZW1lbnQsIGRhdGEubWFya2VyTmFtZSk7IC8vIEFkZCAiY2xvc2luZyIgZWxlbWVudCBvbmx5IGlmIHJhbmdlIGlzIG5vdCBjb2xsYXBzZWQuCgogICAgaWYgKCFtYXJrZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICB2aWV3V3JpdGVyLmluc2VydChtYXBwZXIudG9WaWV3UG9zaXRpb24obWFya2VyUmFuZ2UuZW5kKSwgdmlld0VuZEVsZW1lbnQpOwogICAgICBjb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudFRvTWFya2VyKHZpZXdFbmRFbGVtZW50LCBkYXRhLm1hcmtlck5hbWUpOwogICAgfQoKICAgIGV2dC5zdG9wKCk7CiAgfTsKfSAvLyBGdW5jdGlvbiBmYWN0b3J5IHRoYXQgcmV0dXJucyBhIGRlZmF1bHQgZG93bmNhc3QgY29udmVydGVyIGZvciByZW1vdmluZyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSSBlbGVtZW50fQovLyBiYXNpbmcgb24gbWFya2VyIHJlbW92ZSBjaGFuZ2UuCi8vCi8vIFRoaXMgY29udmVydGVyIHVuYmluZHMgZWxlbWVudHMgZnJvbSB0aGUgbWFya2VyIG5hbWUuCi8vCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gUmVtb3ZlZCBVSSBlbGVtZW50IGNvbnZlcnRlci4KCmZ1bmN0aW9uIHJlbW92ZVVJRWxlbWVudCgpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIGVsZW1lbnRzID0gY29udmVyc2lvbkFwaS5tYXBwZXIubWFya2VyTmFtZVRvRWxlbWVudHMoZGF0YS5tYXJrZXJOYW1lKTsKCiAgICBpZiAoIWVsZW1lbnRzKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlOwogICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKCiAgICB0cnkgewogICAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gZWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHsKICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwNS52YWx1ZTsKICAgICAgICBjb252ZXJzaW9uQXBpLm1hcHBlci51bmJpbmRFbGVtZW50RnJvbU1hcmtlck5hbWUoZWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsKICAgICAgICBjb252ZXJzaW9uQXBpLndyaXRlci5jbGVhcihjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZU9uKGVsZW1lbnQpLCBlbGVtZW50KTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICAgIF9pdGVyYXRvckVycm9yNSA9IGVycjsKICAgIH0gZmluYWxseSB7CiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSAmJiBfaXRlcmF0b3I1LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpOwogICAgICAgIH0KICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgY29udmVyc2lvbkFwaS53cml0ZXIuY2xlYXJDbG9uZWRFbGVtZW50c0dyb3VwKGRhdGEubWFya2VyTmFtZSk7CiAgICBldnQuc3RvcCgpOwogIH07Cn0gLy8gRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgc2V0L2NoYW5nZS9yZW1vdmUgYXR0cmlidXRlIGNoYW5nZXMgZnJvbSB0aGUgbW9kZWwgdG8gdGhlIHZpZXcuCi8vCi8vIEF0dHJpYnV0ZXMgZnJvbSB0aGUgbW9kZWwgYXJlIGNvbnZlcnRlZCB0byB0aGUgdmlldyBlbGVtZW50IGF0dHJpYnV0ZXMgaW4gdGhlIHZpZXcuIFlvdSBtYXkgcHJvdmlkZSBhIGN1c3RvbSBmdW5jdGlvbiB0byBnZW5lcmF0ZQovLyBhIGtleS12YWx1ZSBhdHRyaWJ1dGUgcGFpciB0byBhZGQvY2hhbmdlL3JlbW92ZS4gSWYgbm90IHByb3ZpZGVkLCBtb2RlbCBhdHRyaWJ1dGVzIHdpbGwgYmUgY29udmVydGVkIHRvIHZpZXcgZWxlbWVudAovLyBhdHRyaWJ1dGVzIG9uIGEgb25lLXRvLW9uZSBiYXNpcy4KLy8KLy8gKk5vdGU6KiogVGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSBjcmVhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGBrZXlgIGZvciBhIGdpdmVuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbC4KLy8KLy8gVGhlIGNvbnZlcnRlciBhdXRvbWF0aWNhbGx5IGNvbnN1bWVzIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIGNvbnN1bWFibGVzIGxpc3QgYW5kIHN0b3BzIHRoZSBldmVudCAoc2VlCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0pLgovLwovLwkJbW9kZWxEaXNwYXRjaGVyLm9uKCAnYXR0cmlidXRlOmN1c3RvbUF0dHI6bXlFbGVtJywgY2hhbmdlQXR0cmlidXRlKCAoIHZhbHVlLCBkYXRhICkgPT4gewovLwkJCS8vIENoYW5nZSBhdHRyaWJ1dGUga2V5IGZyb20gYGN1c3RvbUF0dHJgIHRvIGBjbGFzc2AgaW4gdGhlIHZpZXcuCi8vCQkJY29uc3Qga2V5ID0gJ2NsYXNzJzsKLy8JCQlsZXQgdmFsdWUgPSBkYXRhLmF0dHJpYnV0ZU5ld1ZhbHVlOwovLwovLwkJCS8vIEZvcmNlIGF0dHJpYnV0ZSB2YWx1ZSB0byAnZW1wdHknIGlmIHRoZSBtb2RlbCBlbGVtZW50IGlzIGVtcHR5LgovLwkJCWlmICggZGF0YS5pdGVtLmNoaWxkQ291bnQgPT09IDAgKSB7Ci8vCQkJCXZhbHVlID0gJ2VtcHR5JzsKLy8JCQl9Ci8vCi8vCQkJLy8gUmV0dXJuIHRoZSBrZXktdmFsdWUgcGFpci4KLy8JCQlyZXR1cm4geyBrZXksIHZhbHVlIH07Ci8vCQl9ICkgKTsKLy8KLy8gQHBhcmFtIHtGdW5jdGlvbn0gW2F0dHJpYnV0ZUNyZWF0b3JdIEZ1bmN0aW9uIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczogYGtleWAgYW5kIGB2YWx1ZWAsIHdoaWNoCi8vIHJlcHJlc2VudCB0aGUgYXR0cmlidXRlIGtleSBhbmQgYXR0cmlidXRlIHZhbHVlIHRvIGJlIHNldCBvbiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0uCi8vIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGFuZCBhZGRpdGlvbmFsIGRhdGEgYWJvdXQgdGhlIGNoYW5nZSBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBTZXQvY2hhbmdlIGF0dHJpYnV0ZSBjb252ZXJ0ZXIuCgoKZnVuY3Rpb24gY2hhbmdlQXR0cmlidXRlKGF0dHJpYnV0ZUNyZWF0b3IpIHsKICByZXR1cm4gZnVuY3Rpb24gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogICAgdmFyIG9sZEF0dHJpYnV0ZSA9IGF0dHJpYnV0ZUNyZWF0b3IoZGF0YS5hdHRyaWJ1dGVPbGRWYWx1ZSwgZGF0YSk7CiAgICB2YXIgbmV3QXR0cmlidXRlID0gYXR0cmlidXRlQ3JlYXRvcihkYXRhLmF0dHJpYnV0ZU5ld1ZhbHVlLCBkYXRhKTsKCiAgICBpZiAoIW9sZEF0dHJpYnV0ZSAmJiAhbmV3QXR0cmlidXRlKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgZXZ0Lm5hbWUpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld0VsZW1lbnQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdFbGVtZW50KGRhdGEuaXRlbSk7CiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOyAvLyBJZiBtb2RlbCBpdGVtIGNhbm5vdCBiZSBtYXBwZWQgdG8gYSB2aWV3IGVsZW1lbnQsIGl0IG1lYW5zIGl0ZW0gaXMgbm90IGFuIGBFbGVtZW50YCBpbnN0YW5jZSBidXQgYSBgVGV4dFByb3h5YCBub2RlLgogICAgLy8gT25seSBlbGVtZW50cyBjYW4gaGF2ZSBhdHRyaWJ1dGVzIGluIGEgdmlldyBzbyBkbyBub3QgcHJvY2VlZCBmb3IgYW55dGhpbmcgZWxzZSAoIzE1ODcpLgoKICAgIGlmICghdmlld0VsZW1lbnQpIHsKICAgICAgLyoqCiAgICAgICAqIFRoaXMgZXJyb3Igb2NjdXJzIHdoZW4gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5IHRleHQgbm9kZSdzfSBhdHRyaWJ1dGUgaXMgdG8gYmUgZG93bmNhc3RlZAogICAgICAgKiBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0F0dHJpYnV0ZSBgQXR0cmlidXRlIHRvIEF0dHJpYnV0ZSBjb252ZXJ0ZXJgfS4KICAgICAgICogSW4gbW9zdCBjYXNlcyBpdCBpcyBjYXVzZWQgYnkgY29udmVydGVycyBtaXNjb25maWd1cmF0aW9uIHdoZW4gb25seSAiZ2VuZXJpYyIgY29udmVydGVyIGlzIGRlZmluZWQ6CiAgICAgICAqCiAgICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAgICAgKgkJCW1vZGVsOiAnYXR0cmlidXRlLW5hbWUnLAogICAgICAgKgkJCXZpZXc6ICdhdHRyaWJ1dGUtbmFtZScKICAgICAgICoJCX0gKSApOwogICAgICAgKgogICAgICAgKiBhbmQgZ2l2ZW4gYXR0cmlidXRlIGlzIHVzZWQgb24gdGV4dCBub2RlLCBmb3IgZXhhbXBsZToKICAgICAgICoKICAgICAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ0ZvbycsIHsgJ2F0dHJpYnV0ZS1uYW1lJzogJ2JhcicgfSwgcGFyZW50LCAwICk7CiAgICAgICAqCQl9ICk7CiAgICAgICAqCiAgICAgICAqIEluIHN1Y2ggY2FzZXMsIHRvIGNvbnZlcnQgdGhlIHNhbWUgYXR0cmlidXRlIGZvciBib3RoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0KICAgICAgICogYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHkgYFRleHRgfSBub2RlcywgdGV4dCBzcGVjaWZpYwogICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0VsZW1lbnQgYEF0dHJpYnV0ZSB0byBFbGVtZW50IGNvbnZlcnRlcmB9CiAgICAgICAqIHdpdGggaGlnaGVyIHtAbGluayBtb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZyBwcmlvcml0eX0gbXVzdCBhbHNvIGJlIGRlZmluZWQ6CiAgICAgICAqCiAgICAgICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkb3duY2FzdCcgKS5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgICAgICoJCQltb2RlbDogewogICAgICAgKgkJCQlrZXk6ICdhdHRyaWJ1dGUtbmFtZScsCiAgICAgICAqCQkJCW5hbWU6ICckdGV4dCcKICAgICAgICoJCQl9LAogICAgICAgKgkJCXZpZXc6ICggdmFsdWUsIHdyaXRlciApID0+IHsKICAgICAgICoJCQkJcmV0dXJuIHdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnc3BhbicsIHsgJ2F0dHJpYnV0ZS1uYW1lJzogdmFsdWUgfSApOwogICAgICAgKgkJCX0sCiAgICAgICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAgICAgKgkJfSApICk7CiAgICAgICAqCiAgICAgICAqIEBlcnJvciBjb252ZXJzaW9uLWF0dHJpYnV0ZS10by1hdHRyaWJ1dGUtb24tdGV4dAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2NvbnZlcnNpb24tYXR0cmlidXRlLXRvLWF0dHJpYnV0ZS1vbi10ZXh0OiAnICsgJ1RyeWluZyB0byBjb252ZXJ0IHRleHQgbm9kZVwncyBhdHRyaWJ1dGUgd2l0aCBhdHRyaWJ1dGUtdG8tYXR0cmlidXRlIGNvbnZlcnRlci4nLCBbZGF0YSwgY29udmVyc2lvbkFwaV0pOwogICAgfSAvLyBGaXJzdCByZW1vdmUgdGhlIG9sZCBhdHRyaWJ1dGUgaWYgdGhlcmUgd2FzIG9uZS4KCgogICAgaWYgKGRhdGEuYXR0cmlidXRlT2xkVmFsdWUgIT09IG51bGwgJiYgb2xkQXR0cmlidXRlKSB7CiAgICAgIGlmIChvbGRBdHRyaWJ1dGUua2V5ID09ICdjbGFzcycpIHsKICAgICAgICB2YXIgY2xhc3NlcyA9IEFycmF5LmlzQXJyYXkob2xkQXR0cmlidXRlLnZhbHVlKSA/IG9sZEF0dHJpYnV0ZS52YWx1ZSA6IFtvbGRBdHRyaWJ1dGUudmFsdWVdOwogICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gY2xhc3Nlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkgewogICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX3N0ZXA2LnZhbHVlOwogICAgICAgICAgICB2aWV3V3JpdGVyLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSwgdmlld0VsZW1lbnQpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChvbGRBdHRyaWJ1dGUua2V5ID09ICdzdHlsZScpIHsKICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9sZEF0dHJpYnV0ZS52YWx1ZSk7CgogICAgICAgIGZvciAodmFyIF9pID0gMCwgX2tleXMgPSBrZXlzOyBfaSA8IF9rZXlzLmxlbmd0aDsgX2krKykgewogICAgICAgICAgdmFyIGtleSA9IF9rZXlzW19pXTsKICAgICAgICAgIHZpZXdXcml0ZXIucmVtb3ZlU3R5bGUoa2V5LCB2aWV3RWxlbWVudCk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHZpZXdXcml0ZXIucmVtb3ZlQXR0cmlidXRlKG9sZEF0dHJpYnV0ZS5rZXksIHZpZXdFbGVtZW50KTsKICAgICAgfQogICAgfSAvLyBUaGVuIHNldCB0aGUgbmV3IGF0dHJpYnV0ZS4KCgogICAgaWYgKGRhdGEuYXR0cmlidXRlTmV3VmFsdWUgIT09IG51bGwgJiYgbmV3QXR0cmlidXRlKSB7CiAgICAgIGlmIChuZXdBdHRyaWJ1dGUua2V5ID09ICdjbGFzcycpIHsKICAgICAgICB2YXIgX2NsYXNzZXMgPSBBcnJheS5pc0FycmF5KG5ld0F0dHJpYnV0ZS52YWx1ZSkgPyBuZXdBdHRyaWJ1dGUudmFsdWUgOiBbbmV3QXR0cmlidXRlLnZhbHVlXTsKCiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTsKICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7CiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNyA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBfY2xhc3Nlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkgewogICAgICAgICAgICB2YXIgX2NsYXNzTmFtZSA9IF9zdGVwNy52YWx1ZTsKICAgICAgICAgICAgdmlld1dyaXRlci5hZGRDbGFzcyhfY2xhc3NOYW1lLCB2aWV3RWxlbWVudCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3I3ID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I3OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKG5ld0F0dHJpYnV0ZS5rZXkgPT0gJ3N0eWxlJykgewogICAgICAgIHZhciBfa2V5czIgPSBPYmplY3Qua2V5cyhuZXdBdHRyaWJ1dGUudmFsdWUpOwoKICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfa2V5czMgPSBfa2V5czI7IF9pMiA8IF9rZXlzMy5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzM1tfaTJdOwogICAgICAgICAgdmlld1dyaXRlci5zZXRTdHlsZShfa2V5LCBuZXdBdHRyaWJ1dGUudmFsdWVbX2tleV0sIHZpZXdFbGVtZW50KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmlld1dyaXRlci5zZXRBdHRyaWJ1dGUobmV3QXR0cmlidXRlLmtleSwgbmV3QXR0cmlidXRlLnZhbHVlLCB2aWV3RWxlbWVudCk7CiAgICAgIH0KICAgIH0KICB9Owp9IC8vIEZ1bmN0aW9uIGZhY3RvcnkgdGhhdCBjcmVhdGVzIGEgY29udmVydGVyIHdoaWNoIGNvbnZlcnRzIHRoZSB0ZXh0IGluc2lkZSBtYXJrZXIncyByYW5nZS4gVGhlIGNvbnZlcnRlciB3cmFwcyB0aGUgdGV4dCB3aXRoCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBjcmVhdGVkIGZyb20gdGhlIHByb3ZpZGVkIGRlc2NyaXB0b3IuCi8vIFNlZSB7bGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfmNyZWF0ZVZpZXdFbGVtZW50RnJvbUhpZ2hsaWdodERlc2NyaXB0b3J9LgovLwovLyBJdCBjYW4gYWxzbyBiZSB1c2VkIHRvIGNvbnZlcnQgdGhlIHNlbGVjdGlvbiB0aGF0IGlzIGluc2lkZSBhIG1hcmtlci4gSW4gdGhhdCBjYXNlLCBhbiBlbXB0eSBhdHRyaWJ1dGUgZWxlbWVudCB3aWxsIGJlCi8vIGNyZWF0ZWQgYW5kIHRoZSBzZWxlY3Rpb24gd2lsbCBiZSBwdXQgaW5zaWRlIGl0LgovLwovLyBJZiB0aGUgaGlnaGxpZ2h0IGRlc2NyaXB0b3IgZG9lcyBub3QgcHJvdmlkZSB0aGUgYHByaW9yaXR5YCBwcm9wZXJ0eSwgYDEwYCB3aWxsIGJlIHVzZWQuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgaWRgIHByb3BlcnR5LCB0aGUgbmFtZSBvZiB0aGUgbWFya2VyIHdpbGwgYmUgdXNlZC4KLy8KLy8gVGhpcyBjb252ZXJ0ZXIgYmluZHMgdGhlIGNyZWF0ZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnN9IHdpdGggdGhlIG1hcmtlciBuYW1lCi8vIHVzaW5nIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjYmluZEVsZW1lbnRUb01hcmtlcn0gbWV0aG9kLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcnxGdW5jdGlvbn0gaGlnaGxpZ2h0RGVzY3JpcHRvcgovLyBAcmV0dXJucyB7RnVuY3Rpb259CgoKZnVuY3Rpb24gaGlnaGxpZ2h0VGV4dChoaWdobGlnaHREZXNjcmlwdG9yKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIGlmICghZGF0YS5pdGVtKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIShkYXRhLml0ZW0gaW5zdGFuY2VvZiBNb2RlbFNlbGVjdGlvbiB8fCBkYXRhLml0ZW0gaW5zdGFuY2VvZiBEb2N1bWVudFNlbGVjdGlvbikgJiYgIWRhdGEuaXRlbS5pcygndGV4dFByb3h5JykpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBkZXNjcmlwdG9yID0gcHJlcGFyZURlc2NyaXB0b3IoaGlnaGxpZ2h0RGVzY3JpcHRvciwgZGF0YSwgY29udmVyc2lvbkFwaSk7CgogICAgaWYgKCFkZXNjcmlwdG9yKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIWNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEuaXRlbSwgZXZ0Lm5hbWUpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOwogICAgdmFyIHZpZXdFbGVtZW50ID0gY3JlYXRlVmlld0VsZW1lbnRGcm9tSGlnaGxpZ2h0RGVzY3JpcHRvcih2aWV3V3JpdGVyLCBkZXNjcmlwdG9yKTsKICAgIHZhciB2aWV3U2VsZWN0aW9uID0gdmlld1dyaXRlci5kb2N1bWVudC5zZWxlY3Rpb247CgogICAgaWYgKGRhdGEuaXRlbSBpbnN0YW5jZW9mIE1vZGVsU2VsZWN0aW9uIHx8IGRhdGEuaXRlbSBpbnN0YW5jZW9mIERvY3VtZW50U2VsZWN0aW9uKSB7CiAgICAgIHZpZXdXcml0ZXIud3JhcCh2aWV3U2VsZWN0aW9uLmdldEZpcnN0UmFuZ2UoKSwgdmlld0VsZW1lbnQsIHZpZXdTZWxlY3Rpb24pOwogICAgfSBlbHNlIHsKICAgICAgdmFyIHZpZXdSYW5nZSA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1JhbmdlKGRhdGEucmFuZ2UpOwogICAgICB2YXIgcmFuZ2VBZnRlcldyYXAgPSB2aWV3V3JpdGVyLndyYXAodmlld1JhbmdlLCB2aWV3RWxlbWVudCk7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjggPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IHJhbmdlQWZ0ZXJXcmFwLmdldEl0ZW1zKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHsKICAgICAgICAgIHZhciBlbGVtZW50ID0gX3N0ZXA4LnZhbHVlOwoKICAgICAgICAgIGlmIChlbGVtZW50LmlzKCdhdHRyaWJ1dGVFbGVtZW50JykgJiYgZWxlbWVudC5pc1NpbWlsYXIodmlld0VsZW1lbnQpKSB7CiAgICAgICAgICAgIGNvbnZlcnNpb25BcGkubWFwcGVyLmJpbmRFbGVtZW50VG9NYXJrZXIoZWxlbWVudCwgZGF0YS5tYXJrZXJOYW1lKTsgLy8gT25lIGF0dHJpYnV0ZSBlbGVtZW50IGlzIGVub3VnaCwgYmVjYXVzZSBhbGwgb2YgdGhlbSBhcmUgYm91bmQgdG9nZXRoZXIgYnkgdGhlIHZpZXcgd3JpdGVyLgogICAgICAgICAgICAvLyBNYXBwZXIgdXNlcyB0aGlzIGJpbmRpbmcgdG8gZ2V0IGFsbCB0aGUgZWxlbWVudHMgbm8gbWF0dGVyIGhvdyBtYW55IG9mIHRoZW0gYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG1hcHBlci4KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I4LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I4KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yODsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9Owp9IC8vIENvbnZlcnRlciBmdW5jdGlvbiBmYWN0b3J5LiBJdCBjcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyB0aGUgbWFya2VyJ3MgaGlnaGxpZ2h0IHRvIGFuIGVsZW1lbnQgaW5zaWRlIHRoZSBtYXJrZXIncyByYW5nZS4KLy8KLy8gVGhlIGNvbnZlcnRlciBjaGVja3MgaWYgYW4gZWxlbWVudCBoYXMgdGhlIGBhZGRIaWdobGlnaHRgIGZ1bmN0aW9uIHN0b3JlZCBhcyBhCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50I19zZXRDdXN0b21Qcm9wZXJ0eSBjdXN0b20gcHJvcGVydHl9IGFuZCwgaWYgc28sIHVzZXMgaXQgdG8gYXBwbHkgdGhlIGhpZ2hsaWdodC4KLy8gSW4gc3VjaCBjYXNlIHRoZSBjb252ZXJ0ZXIgd2lsbCBjb25zdW1lIGFsbCBlbGVtZW50J3MgY2hpbGRyZW4sIGFzc3VtaW5nIHRoYXQgdGhleSB3ZXJlIGhhbmRsZWQgYnkgdGhlIGVsZW1lbnQgaXRzZWxmLgovLwovLyBXaGVuIHRoZSBgYWRkSGlnaGxpZ2h0YCBjdXN0b20gcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHRoZSBlbGVtZW50IGlzIG5vdCBjb252ZXJ0ZWQgaW4gYW55IHNwZWNpYWwgd2F5LgovLyBUaGlzIG1lYW5zIHRoYXQgY29udmVydGVycyB3aWxsIHByb2NlZWQgdG8gY29udmVydCB0aGUgZWxlbWVudCdzIGNoaWxkIG5vZGVzLgovLwovLyBJZiB0aGUgaGlnaGxpZ2h0IGRlc2NyaXB0b3IgZG9lcyBub3QgcHJvdmlkZSB0aGUgYHByaW9yaXR5YCBwcm9wZXJ0eSwgYDEwYCB3aWxsIGJlIHVzZWQuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgaWRgIHByb3BlcnR5LCB0aGUgbmFtZSBvZiB0aGUgbWFya2VyIHdpbGwgYmUgdXNlZC4KLy8KLy8gVGhpcyBjb252ZXJ0ZXIgYmluZHMgYWx0ZXJlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudHN9IHdpdGggdGhlIG1hcmtlciBuYW1lIHVzaW5nCi8vIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjYmluZEVsZW1lbnRUb01hcmtlcn0gbWV0aG9kLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcnxGdW5jdGlvbn0gaGlnaGxpZ2h0RGVzY3JpcHRvcgovLyBAcmV0dXJucyB7RnVuY3Rpb259CgoKZnVuY3Rpb24gaGlnaGxpZ2h0RWxlbWVudChoaWdobGlnaHREZXNjcmlwdG9yKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIGlmICghZGF0YS5pdGVtKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBpZiAoIShkYXRhLml0ZW0gaW5zdGFuY2VvZiBNb2RlbEVsZW1lbnQpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICB2YXIgZGVzY3JpcHRvciA9IHByZXBhcmVEZXNjcmlwdG9yKGhpZ2hsaWdodERlc2NyaXB0b3IsIGRhdGEsIGNvbnZlcnNpb25BcGkpOwoKICAgIGlmICghZGVzY3JpcHRvcikgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLml0ZW0sIGV2dC5uYW1lKSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIHZpZXdFbGVtZW50ID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3RWxlbWVudChkYXRhLml0ZW0pOwoKICAgIGlmICh2aWV3RWxlbWVudCAmJiB2aWV3RWxlbWVudC5nZXRDdXN0b21Qcm9wZXJ0eSgnYWRkSGlnaGxpZ2h0JykpIHsKICAgICAgLy8gQ29uc3VtZSBlbGVtZW50IGl0c2VsZi4KICAgICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCBldnQubmFtZSk7IC8vIENvbnN1bWUgYWxsIGNoaWxkcmVuIG5vZGVzLgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yOSA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I5ID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4oZGF0YS5pdGVtKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXA5LnZhbHVlOwogICAgICAgICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUodmFsdWUuaXRlbSwgZXZ0Lm5hbWUpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I5ID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjkgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgJiYgX2l0ZXJhdG9yOS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZpZXdFbGVtZW50LmdldEN1c3RvbVByb3BlcnR5KCdhZGRIaWdobGlnaHQnKSh2aWV3RWxlbWVudCwgZGVzY3JpcHRvciwgY29udmVyc2lvbkFwaS53cml0ZXIpOwogICAgICBjb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudFRvTWFya2VyKHZpZXdFbGVtZW50LCBkYXRhLm1hcmtlck5hbWUpOwogICAgfQogIH07Cn0gLy8gRnVuY3Rpb24gZmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBjb252ZXJ0ZXIgd2hpY2ggY29udmVydHMgdGhlIHJlbW92aW5nIG1vZGVsIG1hcmtlciB0byB0aGUgdmlldy4KLy8KLy8gQm90aCB0ZXh0IG5vZGVzIGFuZCBlbGVtZW50cyBhcmUgaGFuZGxlZCBieSB0aGlzIGNvbnZlcnRlciBidXQgdGhleSBhcmUgaGFuZGxlZCBhIGJpdCBkaWZmZXJlbnRseS4KLy8KLy8gVGV4dCBub2RlcyBhcmUgdW53cmFwcGVkIHVzaW5nIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudH0gY3JlYXRlZCBmcm9tIHRoZQovLyBwcm92aWRlZCBoaWdobGlnaHQgZGVzY3JpcHRvci4gU2VlIHtsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+SGlnaGxpZ2h0RGVzY3JpcHRvcn0uCi8vCi8vIEZvciBlbGVtZW50cywgdGhlIGNvbnZlcnRlciBjaGVja3MgaWYgYW4gZWxlbWVudCBoYXMgdGhlIGByZW1vdmVIaWdobGlnaHRgIGZ1bmN0aW9uIHN0b3JlZCBhcyBhCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50I19zZXRDdXN0b21Qcm9wZXJ0eSBjdXN0b20gcHJvcGVydHl9LiBJZiBzbywgaXQgdXNlcyBpdCB0byByZW1vdmUgdGhlIGhpZ2hsaWdodC4KLy8gSW4gc3VjaCBjYXNlLCB0aGUgY2hpbGRyZW4gb2YgdGhhdCBlbGVtZW50IHdpbGwgbm90IGJlIGNvbnZlcnRlZC4KLy8KLy8gV2hlbiBgcmVtb3ZlSGlnaGxpZ2h0YCBpcyBub3QgcHJlc2VudCwgdGhlIGVsZW1lbnQgaXMgbm90IGNvbnZlcnRlZCBpbiBhbnkgc3BlY2lhbCB3YXkuCi8vIFRoZSBjb252ZXJ0ZXIgd2lsbCBwcm9jZWVkIHRvIGNvbnZlcnQgdGhlIGVsZW1lbnQncyBjaGlsZCBub2RlcyBpbnN0ZWFkLgovLwovLyBJZiB0aGUgaGlnaGxpZ2h0IGRlc2NyaXB0b3IgZG9lcyBub3QgcHJvdmlkZSB0aGUgYHByaW9yaXR5YCBwcm9wZXJ0eSwgYDEwYCB3aWxsIGJlIHVzZWQuCi8vCi8vIElmIHRoZSBoaWdobGlnaHQgZGVzY3JpcHRvciBkb2VzIG5vdCBwcm92aWRlIHRoZSBgaWRgIHByb3BlcnR5LCB0aGUgbmFtZSBvZiB0aGUgbWFya2VyIHdpbGwgYmUgdXNlZC4KLy8KLy8gVGhpcyBjb252ZXJ0ZXIgdW5iaW5kcyBlbGVtZW50cyBmcm9tIHRoZSBtYXJrZXIgbmFtZS4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkhpZ2hsaWdodERlc2NyaXB0b3J8RnVuY3Rpb259IGhpZ2hsaWdodERlc2NyaXB0b3IKLy8gQHJldHVybnMge0Z1bmN0aW9ufQoKCmZ1bmN0aW9uIHJlbW92ZUhpZ2hsaWdodChoaWdobGlnaHREZXNjcmlwdG9yKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICAgIC8vIFRoaXMgY29udmVyc2lvbiBtYWtlcyBzZW5zZSBvbmx5IGZvciBub24tY29sbGFwc2VkIHJhbmdlLgogICAgaWYgKGRhdGEubWFya2VyUmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHZhciBkZXNjcmlwdG9yID0gcHJlcGFyZURlc2NyaXB0b3IoaGlnaGxpZ2h0RGVzY3JpcHRvciwgZGF0YSwgY29udmVyc2lvbkFwaSk7CgogICAgaWYgKCFkZXNjcmlwdG9yKSB7CiAgICAgIHJldHVybjsKICAgIH0gLy8gVmlldyBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHVud3JhcCBgQXR0cmlidXRlRWxlbWVudGBzLgoKCiAgICB2YXIgdmlld0hpZ2hsaWdodEVsZW1lbnQgPSBjcmVhdGVWaWV3RWxlbWVudEZyb21IaWdobGlnaHREZXNjcmlwdG9yKGNvbnZlcnNpb25BcGkud3JpdGVyLCBkZXNjcmlwdG9yKTsgLy8gR2V0IGFsbCBlbGVtZW50cyBib3VuZCB3aXRoIGdpdmVuIG1hcmtlciBuYW1lLgoKICAgIHZhciBlbGVtZW50cyA9IGNvbnZlcnNpb25BcGkubWFwcGVyLm1hcmtlck5hbWVUb0VsZW1lbnRzKGRhdGEubWFya2VyTmFtZSk7CgogICAgaWYgKCFlbGVtZW50cykgewogICAgICByZXR1cm47CiAgICB9CgogICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yMTAgPSB1bmRlZmluZWQ7CgogICAgdHJ5IHsKICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTAgPSBlbGVtZW50c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgPSB0cnVlKSB7CiAgICAgICAgdmFyIGVsZW1lbnQgPSBfc3RlcDEwLnZhbHVlOwogICAgICAgIGNvbnZlcnNpb25BcGkubWFwcGVyLnVuYmluZEVsZW1lbnRGcm9tTWFya2VyTmFtZShlbGVtZW50LCBkYXRhLm1hcmtlck5hbWUpOwoKICAgICAgICBpZiAoZWxlbWVudC5pcygnYXR0cmlidXRlRWxlbWVudCcpKSB7CiAgICAgICAgICBjb252ZXJzaW9uQXBpLndyaXRlci51bndyYXAoY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUmFuZ2VPbihlbGVtZW50KSwgdmlld0hpZ2hsaWdodEVsZW1lbnQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBpZiBlbGVtZW50LmlzKCAnY29udGFpbmVyRWxlbWVudCcgKS4KICAgICAgICAgIGVsZW1lbnQuZ2V0Q3VzdG9tUHJvcGVydHkoJ3JlbW92ZUhpZ2hsaWdodCcpKGVsZW1lbnQsIGRlc2NyaXB0b3IuaWQsIGNvbnZlcnNpb25BcGkud3JpdGVyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gY2F0Y2ggKGVycikgewogICAgICBfZGlkSXRlcmF0b3JFcnJvcjEwID0gdHJ1ZTsKICAgICAgX2l0ZXJhdG9yRXJyb3IxMCA9IGVycjsKICAgIH0gZmluYWxseSB7CiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgIF9pdGVyYXRvcjEwLnJldHVybigpOwogICAgICAgIH0KICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxMCkgewogICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBjb252ZXJzaW9uQXBpLndyaXRlci5jbGVhckNsb25lZEVsZW1lbnRzR3JvdXAoZGF0YS5tYXJrZXJOYW1lKTsKICAgIGV2dC5zdG9wKCk7CiAgfTsKfSAvLyBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+RG93bmNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYC5lbGVtZW50VG9FbGVtZW50KClgIGRvd25jYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5tb2RlbCBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCB0byBjb252ZXJ0LgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxGdW5jdGlvbn0gY29uZmlnLnZpZXcgQSB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbiBvciBhIGZ1bmN0aW9uCi8vIHRoYXQgdGFrZXMgdGhlIG1vZGVsIGVsZW1lbnQgYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIgdmlldyBkb3duY2FzdCB3cml0ZXJ9Ci8vIGFzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgYSB2aWV3IGNvbnRhaW5lciBlbGVtZW50LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBjb25maWcudmlldyA9IG5vcm1hbGl6ZVRvRWxlbWVudENvbmZpZyhjb25maWcudmlldywgJ2NvbnRhaW5lcicpOwogIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikgewogICAgZGlzcGF0Y2hlci5vbignaW5zZXJ0OicgKyBjb25maWcubW9kZWwsIGluc2VydEVsZW1lbnQoY29uZmlnLnZpZXcpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gTW9kZWwgYXR0cmlidXRlIHRvIHZpZXcgZWxlbWVudCBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+RG93bmNhc3RIZWxwZXJzI2F0dHJpYnV0ZVRvRWxlbWVudCBgLmF0dHJpYnV0ZVRvRWxlbWVudCgpYCBkb3duY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIFRoZSBrZXkgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0IGZyb20gb3IgYSBgeyBrZXksIHZhbHVlcyB9YCBvYmplY3QuIGB2YWx1ZXNgIGlzIGFuIGFycmF5Ci8vIG9mIGBTdHJpbmdgcyB3aXRoIHBvc3NpYmxlIHZhbHVlcyBpZiB0aGUgbW9kZWwgYXR0cmlidXRlIGlzIGFuIGVudW1lcmFibGUuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnRkZWZpbml0aW9ufkVsZW1lbnREZWZpbml0aW9ufEZ1bmN0aW9ufE9iamVjdH0gY29uZmlnLnZpZXcgQSB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbiBvciBhIGZ1bmN0aW9uCi8vIHRoYXQgdGFrZXMgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciB2aWV3IGRvd25jYXN0IHdyaXRlcn0KLy8gYXMgcGFyYW1ldGVycyBhbmQgcmV0dXJucyBhIHZpZXcgYXR0cmlidXRlIGVsZW1lbnQuIElmIGBjb25maWcubW9kZWwudmFsdWVzYCBpcwovLyBnaXZlbiwgYGNvbmZpZy52aWV3YCBzaG91bGQgYmUgYW4gb2JqZWN0IGFzc2lnbmluZyB2YWx1ZXMgZnJvbSBgY29uZmlnLm1vZGVsLnZhbHVlc2AgdG8gdmlldyBlbGVtZW50IGRlZmluaXRpb25zIG9yIGZ1bmN0aW9ucy4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0QXR0cmlidXRlVG9FbGVtZW50KGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOwogIHZhciBtb2RlbEtleSA9IGNvbmZpZy5tb2RlbC5rZXkgPyBjb25maWcubW9kZWwua2V5IDogY29uZmlnLm1vZGVsOwogIHZhciBldmVudE5hbWUgPSAnYXR0cmlidXRlOicgKyBtb2RlbEtleTsKCiAgaWYgKGNvbmZpZy5tb2RlbC5uYW1lKSB7CiAgICBldmVudE5hbWUgKz0gJzonICsgY29uZmlnLm1vZGVsLm5hbWU7CiAgfQoKICBpZiAoY29uZmlnLm1vZGVsLnZhbHVlcykgewogICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWU7CiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMSA9IGZhbHNlOwogICAgdmFyIF9pdGVyYXRvckVycm9yMTEgPSB1bmRlZmluZWQ7CgogICAgdHJ5IHsKICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTEgPSBjb25maWcubW9kZWwudmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSAoX3N0ZXAxMSA9IF9pdGVyYXRvcjExLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSA9IHRydWUpIHsKICAgICAgICB2YXIgbW9kZWxWYWx1ZSA9IF9zdGVwMTEudmFsdWU7CiAgICAgICAgY29uZmlnLnZpZXdbbW9kZWxWYWx1ZV0gPSBub3JtYWxpemVUb0VsZW1lbnRDb25maWcoY29uZmlnLnZpZXdbbW9kZWxWYWx1ZV0sICdhdHRyaWJ1dGUnKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yMTEgPSB0cnVlOwogICAgICBfaXRlcmF0b3JFcnJvcjExID0gZXJyOwogICAgfSBmaW5hbGx5IHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgX2l0ZXJhdG9yMTEucmV0dXJuKCk7CiAgICAgICAgfQogICAgICB9IGZpbmFsbHkgewogICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjExKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjExOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0gZWxzZSB7CiAgICBjb25maWcudmlldyA9IG5vcm1hbGl6ZVRvRWxlbWVudENvbmZpZyhjb25maWcudmlldywgJ2F0dHJpYnV0ZScpOwogIH0KCiAgdmFyIGVsZW1lbnRDcmVhdG9yID0gZ2V0RnJvbUF0dHJpYnV0ZUNyZWF0b3IoY29uZmlnKTsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oZXZlbnROYW1lLCB3cmFwKGVsZW1lbnRDcmVhdG9yKSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICB9Owp9IC8vIE1vZGVsIGF0dHJpYnV0ZSB0byB2aWV3IGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+RG93bmNhc3RIZWxwZXJzI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGAuYXR0cmlidXRlVG9BdHRyaWJ1dGUoKWAgZG93bmNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBUaGUga2V5IG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29udmVydCBmcm9tIG9yIGEgYHsga2V5LCB2YWx1ZXMsIFsgbmFtZSBdIH1gIG9iamVjdCBkZXNjcmliaW5nCi8vIHRoZSBhdHRyaWJ1dGUga2V5LCBwb3NzaWJsZSB2YWx1ZXMgYW5kLCBvcHRpb25hbGx5LCBhbiBlbGVtZW50IG5hbWUgdG8gY29udmVydCBmcm9tLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBhdHRyaWJ1dGUga2V5LCBvciBhIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcwovLyB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIGFuZCByZXR1cm5zIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QuIElmIGBrZXlgIGlzIGAnY2xhc3MnYCwgYHZhbHVlYCBjYW4gYmUgYSBgU3RyaW5nYCBvciBhbgovLyBhcnJheSBvZiBgU3RyaW5nYHMuIElmIGBrZXlgIGlzIGAnc3R5bGUnYCwgYHZhbHVlYCBpcyBhbiBvYmplY3Qgd2l0aCBrZXktdmFsdWUgcGFpcnMuIEluIG90aGVyIGNhc2VzLCBgdmFsdWVgIGlzIGEgYFN0cmluZ2AuCi8vIElmIGBjb25maWcubW9kZWwudmFsdWVzYCBpcyBzZXQsIGBjb25maWcudmlld2Agc2hvdWxkIGJlIGFuIG9iamVjdCBhc3NpZ25pbmcgdmFsdWVzIGZyb20gYGNvbmZpZy5tb2RlbC52YWx1ZXNgIHRvCi8vIGB7IGtleSwgdmFsdWUgfWAgb2JqZWN0cyBvciBhIGZ1bmN0aW9ucy4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0QXR0cmlidXRlVG9BdHRyaWJ1dGUoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgdmFyIG1vZGVsS2V5ID0gY29uZmlnLm1vZGVsLmtleSA/IGNvbmZpZy5tb2RlbC5rZXkgOiBjb25maWcubW9kZWw7CiAgdmFyIGV2ZW50TmFtZSA9ICdhdHRyaWJ1dGU6JyArIG1vZGVsS2V5OwoKICBpZiAoY29uZmlnLm1vZGVsLm5hbWUpIHsKICAgIGV2ZW50TmFtZSArPSAnOicgKyBjb25maWcubW9kZWwubmFtZTsKICB9CgogIGlmIChjb25maWcubW9kZWwudmFsdWVzKSB7CiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gdHJ1ZTsKICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEyID0gZmFsc2U7CiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMiA9IHVuZGVmaW5lZDsKCiAgICB0cnkgewogICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMiA9IGNvbmZpZy5tb2RlbC52YWx1ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IChfc3RlcDEyID0gX2l0ZXJhdG9yMTIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gdHJ1ZSkgewogICAgICAgIHZhciBtb2RlbFZhbHVlID0gX3N0ZXAxMi52YWx1ZTsKICAgICAgICBjb25maWcudmlld1ttb2RlbFZhbHVlXSA9IG5vcm1hbGl6ZVRvQXR0cmlidXRlQ29uZmlnKGNvbmZpZy52aWV3W21vZGVsVmFsdWVdKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yMTIgPSB0cnVlOwogICAgICBfaXRlcmF0b3JFcnJvcjEyID0gZXJyOwogICAgfSBmaW5hbGx5IHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiAmJiBfaXRlcmF0b3IxMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgX2l0ZXJhdG9yMTIucmV0dXJuKCk7CiAgICAgICAgfQogICAgICB9IGZpbmFsbHkgewogICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEyKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjEyOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0gZWxzZSB7CiAgICBjb25maWcudmlldyA9IG5vcm1hbGl6ZVRvQXR0cmlidXRlQ29uZmlnKGNvbmZpZy52aWV3KTsKICB9CgogIHZhciBlbGVtZW50Q3JlYXRvciA9IGdldEZyb21BdHRyaWJ1dGVDcmVhdG9yKGNvbmZpZyk7CiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaGVyKSB7CiAgICBkaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgY2hhbmdlQXR0cmlidXRlKGVsZW1lbnRDcmVhdG9yKSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICB9Owp9IC8vIE1vZGVsIG1hcmtlciB0byB2aWV3IGVsZW1lbnQgY29udmVyc2lvbiBoZWxwZXIuCi8vCi8vIFNlZSB7QGxpbmsgfkRvd25jYXN0SGVscGVycyNtYXJrZXJUb0VsZW1lbnQgYC5tYXJrZXJUb0VsZW1lbnQoKWAgZG93bmNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge1N0cmluZ30gY29uZmlnLm1vZGVsIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBtYXJrZXIgKG9yIG1vZGVsIG1hcmtlciBncm91cCkgdG8gY29udmVydC4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb258RnVuY3Rpb259IGNvbmZpZy52aWV3IEEgdmlldyBlbGVtZW50IGRlZmluaXRpb24gb3IgYSBmdW5jdGlvbgovLyB0aGF0IHRha2VzIHRoZSBtb2RlbCBtYXJrZXIgZGF0YSBhcyBhIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIHZpZXcgVUkgZWxlbWVudC4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIGRvd25jYXN0TWFya2VyVG9FbGVtZW50KGNvbmZpZykgewogIGNvbmZpZyA9IGNsb25lRGVlcChjb25maWcpOwogIGNvbmZpZy52aWV3ID0gbm9ybWFsaXplVG9FbGVtZW50Q29uZmlnKGNvbmZpZy52aWV3LCAndWknKTsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oJ2FkZE1hcmtlcjonICsgY29uZmlnLm1vZGVsLCBpbnNlcnRVSUVsZW1lbnQoY29uZmlnLnZpZXcpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogICAgZGlzcGF0Y2hlci5vbigncmVtb3ZlTWFya2VyOicgKyBjb25maWcubW9kZWwsIHJlbW92ZVVJRWxlbWVudChjb25maWcudmlldyksIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbm9ybWFsJwogICAgfSk7CiAgfTsKfSAvLyBNb2RlbCBtYXJrZXIgdG8gaGlnaGxpZ2h0IGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5Eb3duY2FzdEhlbHBlcnMjbWFya2VyVG9FbGVtZW50IGAubWFya2VyVG9FbGVtZW50KClgIGRvd25jYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5tb2RlbCBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgbWFya2VyIChvciBtb2RlbCBtYXJrZXIgZ3JvdXApIHRvIGNvbnZlcnQuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35IaWdobGlnaHREZXNjcmlwdG9yfEZ1bmN0aW9ufSBjb25maWcudmlldyBBIGhpZ2hsaWdodCBkZXNjcmlwdG9yCi8vIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBoaWdobGlnaHRpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBtb2RlbCBtYXJrZXIgZGF0YSBhcyBhIHBhcmFtZXRlciBhbmQgcmV0dXJucyBhIGhpZ2hsaWdodCBkZXNjcmlwdG9yLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdub3JtYWwnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gZG93bmNhc3RNYXJrZXJUb0hpZ2hsaWdodChjb25maWcpIHsKICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHsKICAgIGRpc3BhdGNoZXIub24oJ2FkZE1hcmtlcjonICsgY29uZmlnLm1vZGVsLCBoaWdobGlnaHRUZXh0KGNvbmZpZy52aWV3KSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICAgIGRpc3BhdGNoZXIub24oJ2FkZE1hcmtlcjonICsgY29uZmlnLm1vZGVsLCBoaWdobGlnaHRFbGVtZW50KGNvbmZpZy52aWV3KSwgewogICAgICBwcmlvcml0eTogY29uZmlnLmNvbnZlcnRlclByaW9yaXR5IHx8ICdub3JtYWwnCiAgICB9KTsKICAgIGRpc3BhdGNoZXIub24oJ3JlbW92ZU1hcmtlcjonICsgY29uZmlnLm1vZGVsLCByZW1vdmVIaWdobGlnaHQoY29uZmlnLnZpZXcpLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gVGFrZXMgYGNvbmZpZy52aWV3YCwgYW5kIGlmIGl0IGlzIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudGRlZmluaXRpb25+RWxlbWVudERlZmluaXRpb259LCBjb252ZXJ0cyBpdAovLyB0byBhIGZ1bmN0aW9uIChiZWNhdXNlIGxvd2VyIGxldmVsIGNvbnZlcnRlcnMgYWNjZXB0IG9ubHkgZWxlbWVudCBjcmVhdG9yIGZ1bmN0aW9ucykuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnRkZWZpbml0aW9ufkVsZW1lbnREZWZpbml0aW9ufEZ1bmN0aW9ufSB2aWV3IFZpZXcgY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHsnY29udGFpbmVyJ3wnYXR0cmlidXRlJ3wndWknfSB2aWV3RWxlbWVudFR5cGUgVmlldyBlbGVtZW50IHR5cGUgdG8gY3JlYXRlLgovLyBAcmV0dXJucyB7RnVuY3Rpb259IEVsZW1lbnQgY3JlYXRvciBmdW5jdGlvbiB0byB1c2UgaW4gbG93ZXIgbGV2ZWwgY29udmVydGVycy4KCgpmdW5jdGlvbiBub3JtYWxpemVUb0VsZW1lbnRDb25maWcodmlldywgdmlld0VsZW1lbnRUeXBlKSB7CiAgaWYgKHR5cGVvZiB2aWV3ID09ICdmdW5jdGlvbicpIHsKICAgIC8vIElmIGB2aWV3YCBpcyBhbHJlYWR5IGEgZnVuY3Rpb24sIGRvbid0IGRvIGFueXRoaW5nLgogICAgcmV0dXJuIHZpZXc7CiAgfQoKICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsRGF0YSwgdmlld1dyaXRlcikgewogICAgcmV0dXJuIGNyZWF0ZVZpZXdFbGVtZW50RnJvbURlZmluaXRpb24odmlldywgdmlld1dyaXRlciwgdmlld0VsZW1lbnRUeXBlKTsKICB9Owp9IC8vIENyZWF0ZXMgYSB2aWV3IGVsZW1lbnQgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbn0gYW5kIGNsYXNzLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbn0gdmlld0VsZW1lbnREZWZpbml0aW9uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyfSB2aWV3V3JpdGVyCi8vIEBwYXJhbSB7J2NvbnRhaW5lcid8J2F0dHJpYnV0ZSd8J3VpJ30gdmlld0VsZW1lbnRUeXBlCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fQoKCmZ1bmN0aW9uIGNyZWF0ZVZpZXdFbGVtZW50RnJvbURlZmluaXRpb24odmlld0VsZW1lbnREZWZpbml0aW9uLCB2aWV3V3JpdGVyLCB2aWV3RWxlbWVudFR5cGUpIHsKICBpZiAodHlwZW9mIHZpZXdFbGVtZW50RGVmaW5pdGlvbiA9PSAnc3RyaW5nJykgewogICAgLy8gSWYgYHZpZXdFbGVtZW50RGVmaW5pdGlvbmAgaXMgZ2l2ZW4gYXMgYSBgU3RyaW5nYCwgbm9ybWFsaXplIGl0IHRvIGFuIG9iamVjdCB3aXRoIGBuYW1lYCBwcm9wZXJ0eS4KICAgIHZpZXdFbGVtZW50RGVmaW5pdGlvbiA9IHsKICAgICAgbmFtZTogdmlld0VsZW1lbnREZWZpbml0aW9uCiAgICB9OwogIH0KCiAgdmFyIGVsZW1lbnQ7CiAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2aWV3RWxlbWVudERlZmluaXRpb24uYXR0cmlidXRlcyk7CgogIGlmICh2aWV3RWxlbWVudFR5cGUgPT0gJ2NvbnRhaW5lcicpIHsKICAgIGVsZW1lbnQgPSB2aWV3V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQodmlld0VsZW1lbnREZWZpbml0aW9uLm5hbWUsIGF0dHJpYnV0ZXMpOwogIH0gZWxzZSBpZiAodmlld0VsZW1lbnRUeXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICB2YXIgb3B0aW9ucyA9IHsKICAgICAgcHJpb3JpdHk6IHZpZXdFbGVtZW50RGVmaW5pdGlvbi5wcmlvcml0eSB8fCBWaWV3QXR0cmlidXRlRWxlbWVudC5ERUZBVUxUX1BSSU9SSVRZCiAgICB9OwogICAgZWxlbWVudCA9IHZpZXdXcml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCh2aWV3RWxlbWVudERlZmluaXRpb24ubmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyk7CiAgfSBlbHNlIHsKICAgIC8vICd1aScuCiAgICBlbGVtZW50ID0gdmlld1dyaXRlci5jcmVhdGVVSUVsZW1lbnQodmlld0VsZW1lbnREZWZpbml0aW9uLm5hbWUsIGF0dHJpYnV0ZXMpOwogIH0KCiAgaWYgKHZpZXdFbGVtZW50RGVmaW5pdGlvbi5zdHlsZXMpIHsKICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmlld0VsZW1lbnREZWZpbml0aW9uLnN0eWxlcyk7CgogICAgZm9yICh2YXIgX2kzID0gMCwgX2tleXM0ID0ga2V5czsgX2kzIDwgX2tleXM0Lmxlbmd0aDsgX2kzKyspIHsKICAgICAgdmFyIGtleSA9IF9rZXlzNFtfaTNdOwogICAgICB2aWV3V3JpdGVyLnNldFN0eWxlKGtleSwgdmlld0VsZW1lbnREZWZpbml0aW9uLnN0eWxlc1trZXldLCBlbGVtZW50KTsKICAgIH0KICB9CgogIGlmICh2aWV3RWxlbWVudERlZmluaXRpb24uY2xhc3NlcykgewogICAgdmFyIGNsYXNzZXMgPSB2aWV3RWxlbWVudERlZmluaXRpb24uY2xhc3NlczsKCiAgICBpZiAodHlwZW9mIGNsYXNzZXMgPT0gJ3N0cmluZycpIHsKICAgICAgdmlld1dyaXRlci5hZGRDbGFzcyhjbGFzc2VzLCBlbGVtZW50KTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxMyA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMyA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMTMgPSBjbGFzc2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSAoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWUpIHsKICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBfc3RlcDEzLnZhbHVlOwogICAgICAgICAgdmlld1dyaXRlci5hZGRDbGFzcyhjbGFzc05hbWUsIGVsZW1lbnQpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxMyA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IxMyA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgJiYgX2l0ZXJhdG9yMTMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMTMucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEzKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gZWxlbWVudDsKfQoKZnVuY3Rpb24gZ2V0RnJvbUF0dHJpYnV0ZUNyZWF0b3IoY29uZmlnKSB7CiAgaWYgKGNvbmZpZy5tb2RlbC52YWx1ZXMpIHsKICAgIHJldHVybiBmdW5jdGlvbiAobW9kZWxBdHRyaWJ1dGVWYWx1ZSwgdmlld1dyaXRlcikgewogICAgICB2YXIgdmlldyA9IGNvbmZpZy52aWV3W21vZGVsQXR0cmlidXRlVmFsdWVdOwoKICAgICAgaWYgKHZpZXcpIHsKICAgICAgICByZXR1cm4gdmlldyhtb2RlbEF0dHJpYnV0ZVZhbHVlLCB2aWV3V3JpdGVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gY29uZmlnLnZpZXc7CiAgfQp9IC8vIFRha2VzIHRoZSBjb25maWd1cmF0aW9uLCBhZGRzIGRlZmF1bHQgcGFyYW1ldGVycyBpZiB0aGV5IGRvIG5vdCBleGlzdCBhbmQgbm9ybWFsaXplcyBvdGhlciBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgaW4gZG93bmNhc3QgY29udmVydGVycwovLyBmb3IgZ2VuZXJhdGluZyBhIHZpZXcgYXR0cmlidXRlLgovLwovLyBAcGFyYW0ge09iamVjdH0gdmlldyBWaWV3IGNvbmZpZ3VyYXRpb24uCgoKZnVuY3Rpb24gbm9ybWFsaXplVG9BdHRyaWJ1dGVDb25maWcodmlldykgewogIGlmICh0eXBlb2YgdmlldyA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlbEF0dHJpYnV0ZVZhbHVlKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAga2V5OiB2aWV3LAogICAgICAgIHZhbHVlOiBtb2RlbEF0dHJpYnV0ZVZhbHVlCiAgICAgIH07CiAgICB9OwogIH0gZWxzZSBpZiAoX3R5cGVvZih2aWV3KSA9PSAnb2JqZWN0JykgewogICAgLy8geyBrZXksIHZhbHVlLCAuLi4gfQogICAgaWYgKHZpZXcudmFsdWUpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gdmlldzsKICAgICAgfTsKICAgIH0gLy8geyBrZXksIC4uLiB9CiAgICBlbHNlIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGVsQXR0cmlidXRlVmFsdWUpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGtleTogdmlldy5rZXksCiAgICAgICAgICAgIHZhbHVlOiBtb2RlbEF0dHJpYnV0ZVZhbHVlCiAgICAgICAgICB9OwogICAgICAgIH07CiAgICAgIH0KICB9IGVsc2UgewogICAgLy8gZnVuY3Rpb24uCiAgICByZXR1cm4gdmlldzsKICB9Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgaGlnaGxpZ2h0YC4gUHJlcGFyZXMgdGhlIGFjdHVhbCBkZXNjcmlwdG9yIG9iamVjdCB1c2luZyB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnZlcnRlci4KCgpmdW5jdGlvbiBwcmVwYXJlRGVzY3JpcHRvcihoaWdobGlnaHREZXNjcmlwdG9yLCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgLy8gSWYgcGFzc2VkIGRlc2NyaXB0b3IgaXMgYSBjcmVhdG9yIGZ1bmN0aW9uLCBjYWxsIGl0LiBJZiBub3QsIGp1c3QgdXNlIHBhc3NlZCB2YWx1ZS4KICB2YXIgZGVzY3JpcHRvciA9IHR5cGVvZiBoaWdobGlnaHREZXNjcmlwdG9yID09ICdmdW5jdGlvbicgPyBoaWdobGlnaHREZXNjcmlwdG9yKGRhdGEsIGNvbnZlcnNpb25BcGkpIDogaGlnaGxpZ2h0RGVzY3JpcHRvcjsKCiAgaWYgKCFkZXNjcmlwdG9yKSB7CiAgICByZXR1cm4gbnVsbDsKICB9IC8vIEFwcGx5IGRlZmF1bHQgZGVzY3JpcHRvciBwcmlvcml0eS4KCgogIGlmICghZGVzY3JpcHRvci5wcmlvcml0eSkgewogICAgZGVzY3JpcHRvci5wcmlvcml0eSA9IDEwOwogIH0gLy8gRGVmYXVsdCBkZXNjcmlwdG9yIGlkIGlzIG1hcmtlciBuYW1lLgoKCiAgaWYgKCFkZXNjcmlwdG9yLmlkKSB7CiAgICBkZXNjcmlwdG9yLmlkID0gZGF0YS5tYXJrZXJOYW1lOwogIH0KCiAgcmV0dXJuIGRlc2NyaXB0b3I7Cn0KLyoqCiAqIEFuIG9iamVjdCBkZXNjcmliaW5nIGhvdyB0aGUgbWFya2VyIGhpZ2hsaWdodCBzaG91bGQgYmUgcmVwcmVzZW50ZWQgaW4gdGhlIHZpZXcuCiAqCiAqIEVhY2ggdGV4dCBub2RlIGNvbnRhaW5lZCBpbiBhIGhpZ2hsaWdodGVkIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbiBhIGA8c3Bhbj5gCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IHZpZXcgYXR0cmlidXRlIGVsZW1lbnR9IHdpdGggQ1NTIGNsYXNzKGVzKSwgYXR0cmlidXRlcyBhbmQgYSBwcmlvcml0eQogKiBkZXNjcmliZWQgYnkgdGhpcyBvYmplY3QuCiAqCiAqIEFkZGl0aW9uYWxseSwgZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0gY2FuIGhhbmRsZSBkaXNwbGF5aW5nIHRoZSBoaWdobGlnaHQKICogc2VwYXJhdGVseSBieSBwcm92aWRpbmcgdGhlIGBhZGRIaWdobGlnaHRgIGFuZCBgcmVtb3ZlSGlnaGxpZ2h0YCBjdXN0b20gcHJvcGVydGllcy4gSW4gdGhpcyBjYXNlOgogKgogKiAgKiBUaGUgYEhpZ2hsaWdodERlc2NyaXB0b3JgIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIGBhZGRIaWdobGlnaHRgIGZ1bmN0aW9uIHVwb24gY29udmVyc2lvbiBhbmQgc2hvdWxkIGJlIHVzZWQgdG8gYXBwbHkgdGhlIGhpZ2hsaWdodCB0bwogKiAgdGhlIGVsZW1lbnQuCiAqICAqIFRoZSBkZXNjcmlwdG9yIGBpZGAgaXMgcGFzc2VkIHRvIHRoZSBgcmVtb3ZlSGlnaGxpZ2h0YCBmdW5jdGlvbiB1cG9uIGNvbnZlcnNpb24gYW5kIHNob3VsZCBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgaGlnaGxpZ2h0IHdpdGggdGhlCiAqICBnaXZlbiBJRCBmcm9tIHRoZSBlbGVtZW50LgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkhpZ2hsaWdodERlc2NyaXB0b3IKICoKICogQHByb3BlcnR5IHtTdHJpbmd8QXJyYXkuPFN0cmluZz59IGNsYXNzZXMgQSBDU1MgY2xhc3Mgb3IgYW4gYXJyYXkgb2YgY2xhc3NlcyB0byBzZXQuIElmIHRoZSBkZXNjcmlwdG9yIGlzIHVzZWQgdG8KICogY3JlYXRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fSBvdmVyIHRleHQgbm9kZXMsIHRoZXNlIGNsYXNzZXMgd2lsbCBiZSBzZXQKICogb24gdGhhdCBhdHRyaWJ1dGUgZWxlbWVudC4gSWYgdGhlIGRlc2NyaXB0b3IgaXMgYXBwbGllZCB0byBhbiBlbGVtZW50LCB1c3VhbGx5IHRoZXNlIGNsYXNzZXMgd2lsbCBiZSBzZXQgb24gdGhhdCBlbGVtZW50LCBob3dldmVyLAogKiB0aGlzIGRlcGVuZHMgb24gaG93IHRoZSBlbGVtZW50IGNvbnZlcnRzIHRoZSBkZXNjcmlwdG9yLgogKgogKiBAcHJvcGVydHkge1N0cmluZ30gW2lkXSBEZXNjcmlwdG9yIGlkZW50aWZpZXIuIElmIG5vdCBwcm92aWRlZCwgaXQgZGVmYXVsdHMgdG8gdGhlIGNvbnZlcnRlZCBtYXJrZXIncyBuYW1lLgogKgogKiBAcHJvcGVydHkge051bWJlcn0gW3ByaW9yaXR5XSBEZXNjcmlwdG9yIHByaW9yaXR5LiBJZiBub3QgcHJvdmlkZWQsIGl0IGRlZmF1bHRzIHRvIGAxMGAuIElmIHRoZSBkZXNjcmlwdG9yIGlzIHVzZWQgdG8gY3JlYXRlCiAqIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fSwgaXQgd2lsbCBiZSB0aGF0IGVsZW1lbnQncwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNwcmlvcml0eSBwcmlvcml0eX0uIElmIHRoZSBkZXNjcmlwdG9yIGlzIGFwcGxpZWQgdG8gYW4gZWxlbWVudCwKICogdGhlIHByaW9yaXR5IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZGVzY3JpcHRvciBpcyBtb3JlIGltcG9ydGFudC4KICoKICogQHByb3BlcnR5IHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldC4gSWYgdGhlIGRlc2NyaXB0b3IgaXMgdXNlZCB0byBjcmVhdGUKICogYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnR9IG92ZXIgdGV4dCBub2RlcywgdGhlc2UgYXR0cmlidXRlcyB3aWxsIGJlIHNldCBvbiB0aGF0CiAqIGF0dHJpYnV0ZSBlbGVtZW50LiBJZiB0aGUgZGVzY3JpcHRvciBpcyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQsIHVzdWFsbHkgdGhlc2UgYXR0cmlidXRlcyB3aWxsIGJlIHNldCBvbiB0aGF0IGVsZW1lbnQsIGhvd2V2ZXIsCiAqIHRoaXMgZGVwZW5kcyBvbiBob3cgdGhlIGVsZW1lbnQgY29udmVydHMgdGhlIGRlc2NyaXB0b3IuCiAqLw=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js"],"names":["ModelRange","ModelSelection","ModelElement","ViewAttributeElement","DocumentSelection","ConversionHelpers","cloneDeep","CKEditorError","DowncastHelpers","config","add","downcastElementToElement","downcastAttributeToElement","downcastAttributeToAttribute","downcastMarkerToElement","downcastMarkerToHighlight","insertText","evt","data","conversionApi","consumable","consume","item","viewWriter","writer","viewPosition","mapper","toViewPosition","range","start","viewText","createText","insert","remove","viewStart","position","modelEnd","getShiftedBy","length","viewEnd","isPhantom","viewRange","createRange","removed","getTrimmed","createRangeIn","getItems","child","unbindViewElement","createViewElementFromHighlightDescriptor","descriptor","viewElement","createAttributeElement","attributes","classes","_addClass","priority","_priority","_id","id","convertRangeSelection","selection","isCollapsed","viewRanges","getRanges","toViewRange","push","setSelection","backward","isBackward","convertCollapsedSelection","modelPosition","getFirstPosition","brokenPosition","breakAttributes","clearAttributes","viewSelection","document","end","parent","isAttached","mergeAttributes","wrap","elementCreator","oldViewElement","attributeOldValue","newViewElement","attributeNewValue","name","getFirstRange","unwrap","insertElement","bindElements","insertUIElement","isOpening","viewStartElement","viewEndElement","markerRange","value","bindElementToMarker","markerName","stop","removeUIElement","elements","markerNameToElements","element","unbindElementFromMarkerName","clear","createRangeOn","clearClonedElementsGroup","changeAttribute","attributeCreator","oldAttribute","newAttribute","toViewElement","key","Array","isArray","className","removeClass","keys","Object","removeStyle","removeAttribute","addClass","setStyle","setAttribute","highlightText","highlightDescriptor","is","prepareDescriptor","rangeAfterWrap","isSimilar","highlightElement","test","getCustomProperty","_createIn","removeHighlight","viewHighlightElement","view","normalizeToElementConfig","dispatcher","on","model","converterPriority","modelKey","eventName","values","modelValue","getFromAttributeCreator","normalizeToAttributeConfig","viewElementType","modelData","createViewElementFromDefinition","viewElementDefinition","assign","createContainerElement","options","DEFAULT_PRIORITY","createUIElement","styles","modelAttributeValue"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.\n *\n * @module engine/conversion/downcasthelpers\n */\n\nimport ModelRange from '../model/range';\nimport ModelSelection from '../model/selection';\nimport ModelElement from '../model/element';\n\nimport ViewAttributeElement from '../view/attributeelement';\nimport DocumentSelection from '../model/documentselection';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Downcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class DowncastHelpers extends ConversionHelpers {\n\t/**\n\t * Model element to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'div',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: ( modelElement, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model element to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n\t * that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n\t * as parameters and returns a view container element.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( downcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view element conversion helper.\n\t *\n\t * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with\n\t * `\"Foo\"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'b',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'invert',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'font-light', 'bg-dark' ]\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'font-weight:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'color',\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: ( modelAttributeValue, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createAttributeElement( 'span', {\n\t *\t\t\t\t\tstyle: 'color:' + modelAttributeValue\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n\t * of `String`s with possible values if the model attribute is an enumerable.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n\t * that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n\t * as parameters and returns a view attribute element. If `config.model.values` is\n\t * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToElement( config ) {\n\t\treturn this.add( downcastAttributeToElement( config ) );\n\t}\n\n\t/**\n\t * Model attribute to view attribute conversion helper.\n\t *\n\t * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,\n\t * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tview: 'href',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'source'\n\t *\t\t\t},\n\t *\t\t\tview: 'src'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'styled',\n\t *\t\t\t\tvalues: [ 'dark', 'light' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tdark: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-dark' ]\n\t *\t\t\t\t},\n\t *\t\t\t\tlight: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'styled', 'styled-light' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'styled',\n\t *\t\t\tview: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )\n\t *\t\t} );\n\t *\n\t * **Note**: Downcasting to a style property requires providing `value` as an object:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t *\t\t\tmodel: 'lineHeight',\n\t *\t\t\tview: modelAttributeValue => ( {\n\t *\t\t\t\tkey: 'style',\n\t *\t\t\t\tvalue: {\n\t *\t\t\t\t\t'line-height': modelAttributeValue,\n\t *\t\t\t\t\t'border-bottom': '1px dotted #ba2'\n\t *\t\t\t\t}\n\t *\t\t\t} )\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n\t * the attribute key, possible values and, optionally, an element name to convert from.\n\t * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n\t * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n\t * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n\t * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n\t * `{ key, value }` objects or a functions.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( downcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * Model marker to view element conversion helper.\n\t *\n\t * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker\n\t * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`\n\t * becomes `<p>F<span data-marker=\"search\"></span>oo b<span data-marker=\"search\"></span>ar</p>` in the view.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'marker-search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: 'search-result',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToElement( {\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tview: ( markerData, viewWriter ) => {\n\t *\t\t\t\treturn viewWriter.createUIElement( 'span', {\n\t *\t\t\t\t\t'data-marker': 'search',\n\t *\t\t\t\t\t'data-start': markerData.isOpening\n\t *\t\t\t\t} );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function\n\t * receives the `data` object as a parameter and should return an instance of the\n\t * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from\n\t * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,\n\t * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to\n\t * the marker end boundary element.\n\t *\n\t * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n\t * that takes the model marker data as a parameter and returns a view UI element.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToElement( config ) {\n\t\treturn this.add( downcastMarkerToElement( config ) );\n\t}\n\n\t/**\n\t * Model marker to highlight conversion helper.\n\t *\n\t * This conversion results in creating a highlight on view nodes. For this kind of conversion,\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.\n\t *\n\t * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes\n\t * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes\n\t * `<p>F<span class=\"comment\">oo b</span>ar</p>` in the view.\n\t *\n\t * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,\n\t * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).\n\t * For example, a model marker set like this: `[<image src=\"foo.jpg\"></image>]` becomes `<img src=\"foo.jpg\" class=\"comment\"></img>`\n\t * in the view.\n\t *\n\t * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it\n\t * to a container element, it is the container element instance itself that applies values from the highlight descriptor.\n\t * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: { classes: 'new-comment' },\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'downcast' ).markerToHighlight( {\n\t *\t\t\tmodel: 'comment',\n\t *\t\t\tview: data => {\n\t *\t\t\t\t// Assuming that the marker name is in a form of comment:commentType.\n\t *\t\t\t\tconst commentType = data.markerName.split( ':' )[ 1 ];\n\t *\n\t *\t\t\t\treturn {\n\t *\t\t\t\t\tclasses: [ 'comment', 'comment-' + commentType ]\n\t *\t\t\t\t};\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function\n\t * receives the `data` object as a parameter and should return a\n\t * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.\n\t * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #markerToHighlight\n\t * @param {Object} config Conversion configuration.\n\t * @param {String} config.model The name of the model marker (or model marker group) to convert.\n\t * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n\t * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}\n\t */\n\tmarkerToHighlight( config ) {\n\t\treturn this.add( downcastMarkerToHighlight( config ) );\n\t}\n}\n\n/**\n * Function factory that creates a default downcast converter for text insertion changes.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'insert:$text', insertText() );\n *\n * @returns {Function} Insert text event converter.\n */\nexport function insertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\t\tconst viewText = viewWriter.createText( data.item.data );\n\n\t\tviewWriter.insert( viewPosition, viewText );\n\t};\n}\n\n/**\n * Function factory that creates a default downcast converter for node remove changes.\n *\n *\t\tmodelDispatcher.on( 'remove', remove() );\n *\n * @returns {Function} Remove event converter.\n */\nexport function remove() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Find view range start position by mapping model position at which the remove happened.\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position );\n\n\t\tconst modelEnd = data.position.getShiftedBy( data.length );\n\t\tconst viewEnd = conversionApi.mapper.toViewPosition( modelEnd, { isPhantom: true } );\n\n\t\tconst viewRange = conversionApi.writer.createRange( viewStart, viewEnd );\n\n\t\t// Trim the range to remove in case some UI elements are on the view range boundaries.\n\t\tconst removed = conversionApi.writer.remove( viewRange.getTrimmed() );\n\n\t\t// After the range is removed, unbind all view elements from the model.\n\t\t// Range inside view document fragment is used to unbind deeply.\n\t\tfor ( const child of conversionApi.writer.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\t};\n}\n\n/**\n * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information\n * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority\n * is not provided in the descriptor, the default priority will be used.\n *\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor\n * @returns {module:engine/view/attributeelement~AttributeElement}\n */\nexport function createViewElementFromHighlightDescriptor( writer, descriptor ) {\n\tconst viewElement = writer.createAttributeElement( 'span', descriptor.attributes );\n\n\tif ( descriptor.classes ) {\n\t\tviewElement._addClass( descriptor.classes );\n\t}\n\n\tif ( descriptor.priority ) {\n\t\tviewElement._priority = descriptor.priority;\n\t}\n\n\tviewElement._id = descriptor.id;\n\n\treturn viewElement;\n}\n\n/**\n * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}\n * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object and maps model positions from the selection to view positions.\n *\n *\t\tmodelDispatcher.on( 'selection', convertRangeSelection() );\n *\n * @returns {Function} Selection converter.\n */\nexport function convertRangeSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( const range of selection.getRanges() ) {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( range );\n\t\t\tviewRanges.push( viewRange );\n\t\t}\n\n\t\tconversionApi.writer.setSelection( viewRanges, { backward: selection.isBackward } );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to\n * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate\n * value from the `consumable` object, maps the model selection position to the view position and breaks\n * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.\n *\n *\t\tmodelDispatcher.on( 'selection', convertCollapsedSelection() );\n *\n * An example of the view state before and after converting the collapsed selection:\n *\n *\t\t   <p><strong>f^oo<strong>bar</p>\n *\t\t-> <p><strong>f</strong>^<strong>oo</strong>bar</p>\n *\n * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is\n * converted, broken attributes might be merged again, or the position where the selection is may be wrapped\n * with different, appropriate attribute elements.\n *\n * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up\n * by merging attributes.\n *\n * @returns {Function} Selection converter.\n */\nexport function convertCollapsedSelection() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst selection = data.selection;\n\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( selection, 'selection' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst modelPosition = selection.getFirstPosition();\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( modelPosition );\n\t\tconst brokenPosition = viewWriter.breakAttributes( viewPosition );\n\n\t\tviewWriter.setSelection( brokenPosition );\n\t};\n}\n\n/**\n * Function factory that creates a converter which clears artifacts after the previous\n * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty\n * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end\n * positions of all ranges.\n *\n *\t\t   <p><strong>^</strong></p>\n *\t\t-> <p>^</p>\n *\n *\t\t   <p><strong>foo</strong>^<strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n *\t\t   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>\n *\t\t-> <p><strong>foo^bar<strong>bar</p>\n *\n * This listener should be assigned before any converter for the new selection:\n *\n *\t\tmodelDispatcher.on( 'selection', clearAttributes() );\n *\n * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}\n * which does the opposite by breaking attributes in the selection position.\n *\n * @returns {Function} Selection converter.\n */\nexport function clearAttributes() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t// Not collapsed selection should not have artifacts.\n\t\t\tif ( range.isCollapsed ) {\n\t\t\t\t// Position might be in the node removed by the view writer.\n\t\t\t\tif ( range.end.parent.isAttached() ) {\n\t\t\t\t\tconversionApi.writer.mergeAttributes( range.start );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tviewWriter.setSelection( null );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the\n * selection will be put inside it.\n *\n * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to\n * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model\n * but are represented as an element in the view:\n *\n *\t\t[paragraph]              MODEL ====> VIEW        <p>\n *\t\t\t|- a {bold: true}                             |- <b>\n *\t\t\t|- b {bold: true}                             |   |- ab\n *\t\t\t|- c                                          |- c\n *\n * Passed `Function` will be provided with the attribute value and then all the parameters of the\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be the wrapping element.\n * When the provided `Function` does not return any element, no conversion will take place.\n *\n * The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n *\n *\t\tmodelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, viewWriter ) => {\n *\t\t\treturn viewWriter.createAttributeElement( 'strong' );\n *\t\t} );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element that will be used for wrapping.\n * @returns {Function} Set/change attribute converter.\n */\nexport function wrap( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed\n\t\t// or the attribute was removed.\n\t\tconst oldViewElement = elementCreator( data.attributeOldValue, conversionApi.writer );\n\n\t\t// Create node to wrap with.\n\t\tconst newViewElement = elementCreator( data.attributeNewValue, conversionApi.writer );\n\n\t\tif ( !oldViewElement && !newViewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\t// Selection attribute conversion.\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), newViewElement );\n\t\t} else {\n\t\t\t// Node attribute conversion.\n\t\t\tlet viewRange = conversionApi.mapper.toViewRange( data.range );\n\n\t\t\t// First, unwrap the range from current wrapper.\n\t\t\tif ( data.attributeOldValue !== null && oldViewElement ) {\n\t\t\t\tviewRange = viewWriter.unwrap( viewRange, oldViewElement );\n\t\t\t}\n\n\t\t\tif ( data.attributeNewValue !== null && newViewElement ) {\n\t\t\t\tviewWriter.wrap( viewRange, newViewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts node insertion changes from the model to the view.\n * The function passed will be provided with all the parameters of the dispatcher's\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.\n * It is expected that the function returns an {@link module:engine/view/element~Element}.\n * The result of the function will be inserted into the view.\n *\n * The converter automatically consumes the corresponding value from the consumables list, stops the event (see\n * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.\n *\n *\t\tdowncastDispatcher.on(\n *\t\t\t'insert:myElem',\n *\t\t\tinsertElement( ( modelItem, viewWriter ) => {\n *\t\t\t\tconst text = viewWriter.createText( 'myText' );\n *\t\t\t\tconst myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );\n *\n *\t\t\t\t// Do something fancy with `myElem` using `modelItem` or other parameters.\n *\n *\t\t\t\treturn myElem;\n *\t\t\t}\n *\t\t) );\n *\n * @protected\n * @param {Function} elementCreator Function returning a view element, which will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewElement = elementCreator( data.item, conversionApi.writer );\n\n\t\tif ( !viewElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( data.item, viewElement );\n\t\tconversionApi.writer.insert( viewPosition, viewElement );\n\t};\n}\n\n/**\n * Function factory that creates a converter which converts marker adding change to the\n * {@link module:engine/view/uielement~UIElement view UI element}.\n *\n * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.\n * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning\n * and at the end of the range.\n *\n * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.\n *\n * @protected\n * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element\n * that will be inserted.\n * @returns {Function} Insert element event converter.\n */\nexport function insertUIElement( elementCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Create two view elements. One will be inserted at the beginning of marker, one at the end.\n\t\t// If marker is collapsed, only \"opening\" element will be inserted.\n\t\tdata.isOpening = true;\n\t\tconst viewStartElement = elementCreator( data, conversionApi.writer );\n\n\t\tdata.isOpening = false;\n\t\tconst viewEndElement = elementCreator( data, conversionApi.writer );\n\n\t\tif ( !viewStartElement || !viewEndElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst markerRange = data.markerRange;\n\n\t\t// Marker that is collapsed has consumable build differently that non-collapsed one.\n\t\t// For more information see `addMarker` event description.\n\t\t// If marker's range is collapsed - check if it can be consumed.\n\t\tif ( markerRange.isCollapsed && !conversionApi.consumable.consume( markerRange, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If marker's range is not collapsed - consume all items inside.\n\t\tfor ( const value of markerRange ) {\n\t\t\tif ( !conversionApi.consumable.consume( value.item, evt.name ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst mapper = conversionApi.mapper;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// Add \"opening\" element.\n\t\tviewWriter.insert( mapper.toViewPosition( markerRange.start ), viewStartElement );\n\t\tconversionApi.mapper.bindElementToMarker( viewStartElement, data.markerName );\n\n\t\t// Add \"closing\" element only if range is not collapsed.\n\t\tif ( !markerRange.isCollapsed ) {\n\t\t\tviewWriter.insert( mapper.toViewPosition( markerRange.end ), viewEndElement );\n\t\t\tconversionApi.mapper.bindElementToMarker( viewEndElement, data.markerName );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}\n// basing on marker remove change.\n//\n// This converter unbinds elements from the marker name.\n//\n// @returns {Function} Removed UI element converter.\nfunction removeUIElement() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\t\t\tconversionApi.writer.clear( conversionApi.writer.createRangeOn( element ), element );\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.\n//\n// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate\n// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element\n// attributes on a one-to-one basis.\n//\n// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.\n//\n// The converter automatically consumes the corresponding value from the consumables list and stops the event (see\n// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).\n//\n//\t\tmodelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {\n//\t\t\t// Change attribute key from `customAttr` to `class` in the view.\n//\t\t\tconst key = 'class';\n//\t\t\tlet value = data.attributeNewValue;\n//\n//\t\t\t// Force attribute value to 'empty' if the model element is empty.\n//\t\t\tif ( data.item.childCount === 0 ) {\n//\t\t\t\tvalue = 'empty';\n//\t\t\t}\n//\n//\t\t\t// Return the key-value pair.\n//\t\t\treturn { key, value };\n//\t\t} ) );\n//\n// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which\n// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.\n// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.\n// @returns {Function} Set/change attribute converter.\nfunction changeAttribute( attributeCreator ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst oldAttribute = attributeCreator( data.attributeOldValue, data );\n\t\tconst newAttribute = attributeCreator( data.attributeNewValue, data );\n\n\t\tif ( !oldAttribute && !newAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.\n\t\t// Only elements can have attributes in a view so do not proceed for anything else (#1587).\n\t\tif ( !viewElement ) {\n\t\t\t/**\n\t\t\t * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted\n\t\t\t * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.\n\t\t\t * In most cases it is caused by converters misconfiguration when only \"generic\" converter is defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToAttribute( {\n\t\t\t *\t\t\tmodel: 'attribute-name',\n\t\t\t *\t\t\tview: 'attribute-name'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * and given attribute is used on text node, for example:\n\t\t\t *\n\t\t\t *\t\tmodel.change( writer => {\n\t\t\t *\t\t\twriter.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}\n\t\t\t * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific\n\t\t\t * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}\n\t\t\t * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:\n\t\t\t *\n\t\t\t *\t\teditor.conversion.for( 'downcast' ).attributeToElement( {\n\t\t\t *\t\t\tmodel: {\n\t\t\t *\t\t\t\tkey: 'attribute-name',\n\t\t\t *\t\t\t\tname: '$text'\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tview: ( value, writer ) => {\n\t\t\t *\t\t\t\treturn writer.createAttributeElement( 'span', { 'attribute-name': value } );\n\t\t\t *\t\t\t},\n\t\t\t *\t\t\tconverterPriority: 'high'\n\t\t\t *\t\t} ) );\n\t\t\t *\n\t\t\t * @error conversion-attribute-to-attribute-on-text\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-attribute-to-attribute-on-text: ' +\n\t\t\t\t'Trying to convert text node\\'s attribute with attribute-to-attribute converter.',\n\t\t\t\t[ data, conversionApi ]\n\t\t\t);\n\t\t}\n\n\t\t// First remove the old attribute if there was one.\n\t\tif ( data.attributeOldValue !== null && oldAttribute ) {\n\t\t\tif ( oldAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( oldAttribute.value ) ? oldAttribute.value : [ oldAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.removeClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( oldAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( oldAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.removeStyle( key, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.removeAttribute( oldAttribute.key, viewElement );\n\t\t\t}\n\t\t}\n\n\t\t// Then set the new attribute.\n\t\tif ( data.attributeNewValue !== null && newAttribute ) {\n\t\t\tif ( newAttribute.key == 'class' ) {\n\t\t\t\tconst classes = Array.isArray( newAttribute.value ) ? newAttribute.value : [ newAttribute.value ];\n\n\t\t\t\tfor ( const className of classes ) {\n\t\t\t\t\tviewWriter.addClass( className, viewElement );\n\t\t\t\t}\n\t\t\t} else if ( newAttribute.key == 'style' ) {\n\t\t\t\tconst keys = Object.keys( newAttribute.value );\n\n\t\t\t\tfor ( const key of keys ) {\n\t\t\t\t\tviewWriter.setStyle( key, newAttribute.value[ key ], viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tviewWriter.setAttribute( newAttribute.key, newAttribute.value, viewElement );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with\n// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.\n// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.\n//\n// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be\n// created and the selection will be put inside it.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name\n// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightText( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) && !data.item.is( 'textProxy' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst viewElement = createViewElementFromHighlightDescriptor( viewWriter, descriptor );\n\t\tconst viewSelection = viewWriter.document.selection;\n\n\t\tif ( data.item instanceof ModelSelection || data.item instanceof DocumentSelection ) {\n\t\t\tviewWriter.wrap( viewSelection.getFirstRange(), viewElement, viewSelection );\n\t\t} else {\n\t\t\tconst viewRange = conversionApi.mapper.toViewRange( data.range );\n\t\t\tconst rangeAfterWrap = viewWriter.wrap( viewRange, viewElement );\n\n\t\t\tfor ( const element of rangeAfterWrap.getItems() ) {\n\t\t\t\tif ( element.is( 'attributeElement' ) && element.isSimilar( viewElement ) ) {\n\t\t\t\t\tconversionApi.mapper.bindElementToMarker( element, data.markerName );\n\n\t\t\t\t\t// One attribute element is enough, because all of them are bound together by the view writer.\n\t\t\t\t\t// Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.\n//\n// The converter checks if an element has the `addHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.\n// In such case the converter will consume all element's children, assuming that they were handled by the element itself.\n//\n// When the `addHighlight` custom property is not present, the element is not converted in any special way.\n// This means that converters will proceed to convert the element's child nodes.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using\n// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction highlightElement( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !data.item ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !( data.item instanceof ModelElement ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !conversionApi.consumable.test( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewElement = conversionApi.mapper.toViewElement( data.item );\n\n\t\tif ( viewElement && viewElement.getCustomProperty( 'addHighlight' ) ) {\n\t\t\t// Consume element itself.\n\t\t\tconversionApi.consumable.consume( data.item, evt.name );\n\n\t\t\t// Consume all children nodes.\n\t\t\tfor ( const value of ModelRange._createIn( data.item ) ) {\n\t\t\t\tconversionApi.consumable.consume( value.item, evt.name );\n\t\t\t}\n\n\t\t\tviewElement.getCustomProperty( 'addHighlight' )( viewElement, descriptor, conversionApi.writer );\n\n\t\t\tconversionApi.mapper.bindElementToMarker( viewElement, data.markerName );\n\t\t}\n\t};\n}\n\n// Function factory that creates a converter which converts the removing model marker to the view.\n//\n// Both text nodes and elements are handled by this converter but they are handled a bit differently.\n//\n// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the\n// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.\n//\n// For elements, the converter checks if an element has the `removeHighlight` function stored as a\n// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.\n// In such case, the children of that element will not be converted.\n//\n// When `removeHighlight` is not present, the element is not converted in any special way.\n// The converter will proceed to convert the element's child nodes instead.\n//\n// If the highlight descriptor does not provide the `priority` property, `10` will be used.\n//\n// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.\n//\n// This converter unbinds elements from the marker name.\n//\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor\n// @returns {Function}\nfunction removeHighlight( highlightDescriptor ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// This conversion makes sense only for non-collapsed range.\n\t\tif ( data.markerRange.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst descriptor = prepareDescriptor( highlightDescriptor, data, conversionApi );\n\n\t\tif ( !descriptor ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// View element that will be used to unwrap `AttributeElement`s.\n\t\tconst viewHighlightElement = createViewElementFromHighlightDescriptor( conversionApi.writer, descriptor );\n\n\t\t// Get all elements bound with given marker name.\n\t\tconst elements = conversionApi.mapper.markerNameToElements( data.markerName );\n\n\t\tif ( !elements ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( const element of elements ) {\n\t\t\tconversionApi.mapper.unbindElementFromMarkerName( element, data.markerName );\n\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tconversionApi.writer.unwrap( conversionApi.writer.createRangeOn( element ), viewHighlightElement );\n\t\t\t} else {\n\t\t\t\t// if element.is( 'containerElement' ).\n\t\t\t\telement.getCustomProperty( 'removeHighlight' )( element, descriptor.id, conversionApi.writer );\n\t\t\t}\n\t\t}\n\n\t\tconversionApi.writer.clearClonedElementsGroup( data.markerName );\n\n\t\tevt.stop();\n\t};\n}\n\n// Model element to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model element to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view container element.\n// @returns {Function} Conversion helper.\nfunction downcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'container' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'insert:' + config.model, insertElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array\n// of `String`s with possible values if the model attribute is an enumerable.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function\n// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}\n// as parameters and returns a view attribute element. If `config.model.values` is\n// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToElementConfig( config.view[ modelValue ], 'attribute' );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToElementConfig( config.view, 'attribute' );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, wrap( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model attribute to view attribute conversion helper.\n//\n// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing\n// the attribute key, possible values and, optionally, an element name to convert from.\n// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes\n// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an\n// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.\n// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to\n// `{ key, value }` objects or a functions.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst modelKey = config.model.key ? config.model.key : config.model;\n\tlet eventName = 'attribute:' + modelKey;\n\n\tif ( config.model.name ) {\n\t\teventName += ':' + config.model.name;\n\t}\n\n\tif ( config.model.values ) {\n\t\tfor ( const modelValue of config.model.values ) {\n\t\t\tconfig.view[ modelValue ] = normalizeToAttributeConfig( config.view[ modelValue ] );\n\t\t}\n\t} else {\n\t\tconfig.view = normalizeToAttributeConfig( config.view );\n\t}\n\n\tconst elementCreator = getFromAttributeCreator( config );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, changeAttribute( elementCreator ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to view element conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function\n// that takes the model marker data as a parameter and returns a view UI element.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconfig.view = normalizeToElementConfig( config.view, 'ui' );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, insertUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeUIElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Model marker to highlight conversion helper.\n//\n// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String} config.model The name of the model marker (or model marker group) to convert.\n// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor\n// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction downcastMarkerToHighlight( config ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightText( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'addMarker:' + config.model, highlightElement( config.view ), { priority: config.converterPriority || 'normal' } );\n\t\tdispatcher.on( 'removeMarker:' + config.model, removeHighlight( config.view ), { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it\n// to a function (because lower level converters accept only element creator functions).\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.\n// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.\n// @returns {Function} Element creator function to use in lower level converters.\nfunction normalizeToElementConfig( view, viewElementType ) {\n\tif ( typeof view == 'function' ) {\n\t\t// If `view` is already a function, don't do anything.\n\t\treturn view;\n\t}\n\n\treturn ( modelData, viewWriter ) => createViewElementFromDefinition( view, viewWriter, viewElementType );\n}\n\n// Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.\n//\n// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition\n// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter\n// @param {'container'|'attribute'|'ui'} viewElementType\n// @returns {module:engine/view/element~Element}\nfunction createViewElementFromDefinition( viewElementDefinition, viewWriter, viewElementType ) {\n\tif ( typeof viewElementDefinition == 'string' ) {\n\t\t// If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.\n\t\tviewElementDefinition = { name: viewElementDefinition };\n\t}\n\n\tlet element;\n\tconst attributes = Object.assign( {}, viewElementDefinition.attributes );\n\n\tif ( viewElementType == 'container' ) {\n\t\telement = viewWriter.createContainerElement( viewElementDefinition.name, attributes );\n\t} else if ( viewElementType == 'attribute' ) {\n\t\tconst options = {\n\t\t\tpriority: viewElementDefinition.priority || ViewAttributeElement.DEFAULT_PRIORITY\n\t\t};\n\n\t\telement = viewWriter.createAttributeElement( viewElementDefinition.name, attributes, options );\n\t} else {\n\t\t// 'ui'.\n\t\telement = viewWriter.createUIElement( viewElementDefinition.name, attributes );\n\t}\n\n\tif ( viewElementDefinition.styles ) {\n\t\tconst keys = Object.keys( viewElementDefinition.styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tviewWriter.setStyle( key, viewElementDefinition.styles[ key ], element );\n\t\t}\n\t}\n\n\tif ( viewElementDefinition.classes ) {\n\t\tconst classes = viewElementDefinition.classes;\n\n\t\tif ( typeof classes == 'string' ) {\n\t\t\tviewWriter.addClass( classes, element );\n\t\t} else {\n\t\t\tfor ( const className of classes ) {\n\t\t\t\tviewWriter.addClass( className, element );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn element;\n}\n\nfunction getFromAttributeCreator( config ) {\n\tif ( config.model.values ) {\n\t\treturn ( modelAttributeValue, viewWriter ) => {\n\t\t\tconst view = config.view[ modelAttributeValue ];\n\n\t\t\tif ( view ) {\n\t\t\t\treturn view( modelAttributeValue, viewWriter );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\t} else {\n\t\treturn config.view;\n\t}\n}\n\n// Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters\n// for generating a view attribute.\n//\n// @param {Object} view View configuration.\nfunction normalizeToAttributeConfig( view ) {\n\tif ( typeof view == 'string' ) {\n\t\treturn modelAttributeValue => ( { key: view, value: modelAttributeValue } );\n\t} else if ( typeof view == 'object' ) {\n\t\t// { key, value, ... }\n\t\tif ( view.value ) {\n\t\t\treturn () => view;\n\t\t}\n\t\t// { key, ... }\n\t\telse {\n\t\t\treturn modelAttributeValue => ( { key: view.key, value: modelAttributeValue } );\n\t\t}\n\t} else {\n\t\t// function.\n\t\treturn view;\n\t}\n}\n\n// Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.\nfunction prepareDescriptor( highlightDescriptor, data, conversionApi ) {\n\t// If passed descriptor is a creator function, call it. If not, just use passed value.\n\tconst descriptor = typeof highlightDescriptor == 'function' ?\n\t\thighlightDescriptor( data, conversionApi ) :\n\t\thighlightDescriptor;\n\n\tif ( !descriptor ) {\n\t\treturn null;\n\t}\n\n\t// Apply default descriptor priority.\n\tif ( !descriptor.priority ) {\n\t\tdescriptor.priority = 10;\n\t}\n\n\t// Default descriptor id is marker name.\n\tif ( !descriptor.id ) {\n\t\tdescriptor.id = data.markerName;\n\t}\n\n\treturn descriptor;\n}\n\n/**\n * An object describing how the marker highlight should be represented in the view.\n *\n * Each text node contained in a highlighted range will be wrapped in a `<span>`\n * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority\n * described by this object.\n *\n * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight\n * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:\n *\n *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to\n *  the element.\n *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the\n *  given ID from the element.\n *\n * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor\n *\n * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to\n * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set\n * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n *\n * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.\n *\n * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's\n * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,\n * the priority will be used to determine which descriptor is more important.\n *\n * @property {Object} [attributes] Attributes to set. If the descriptor is used to create\n * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that\n * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,\n * this depends on how the element converts the descriptor.\n */\n"]}]}