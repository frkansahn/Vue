{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\range.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\range.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL3ZpZXcvcmFuZ2UKICovCmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJzsKaW1wb3J0IFRyZWVXYWxrZXIgZnJvbSAnLi90cmVld2Fsa2VyJzsKLyoqCiAqIFJhbmdlIGluIHRoZSB2aWV3IHRyZWUuIEEgcmFuZ2UgaXMgcmVwcmVzZW50ZWQgYnkgaXRzIHN0YXJ0IGFuZCBlbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9LgogKgogKiBJbiBvcmRlciB0byBjcmVhdGUgYSBuZXcgcG9zaXRpb24gaW5zdGFuY2UgdXNlIHRoZSBgY3JlYXRlUG9zaXRpb24qKClgIGZhY3RvcnkgbWV0aG9kcyBhdmFpbGFibGUgaW46CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3flZpZXd9CiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlcn0KICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VwY2FzdHdyaXRlcn5VcGNhc3RXcml0ZXJ9CiAqLwoKdmFyIFJhbmdlID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIHNwYW5uaW5nIGZyb20gYHN0YXJ0YCBwb3NpdGlvbiB0byBgZW5kYCBwb3NpdGlvbi4KICAgKgogICAqICoqTm90ZToqKiBDb25zdHJ1Y3RvciBjcmVhdGVzIGl0J3Mgb3duIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IGluc3RhbmNlcyBiYXNpbmcgb24gcGFzc2VkIHZhbHVlcy4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBzdGFydCBTdGFydCBwb3NpdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCB0aGUgYHN0YXJ0YCBwb3NpdGlvbi4KICAgKi8KICBmdW5jdGlvbiBSYW5nZShzdGFydCkgewogICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFuZ2UpOwoKICAgIC8qKgogICAgICogU3RhcnQgcG9zaXRpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KICAgIHRoaXMuc3RhcnQgPSBzdGFydC5jbG9uZSgpOwogICAgLyoqCiAgICAgKiBFbmQgcG9zaXRpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgICB0aGlzLmVuZCA9IGVuZCA/IGVuZC5jbG9uZSgpIDogc3RhcnQuY2xvbmUoKTsKICB9CiAgLyoqCiAgICogSXRlcmFibGUgaW50ZXJmYWNlLgogICAqCiAgICogSXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0gdG9nZXRoZXIgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGxpa2UgbGVuZ3RoIG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfSwKICAgKiBncm91cGVkIGFzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9LgogICAqCiAgICogVGhpcyBpdGVyYXRvciB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyIFRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlIGFuZAogICAqIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24KICAgKiBzZXQgdG8gYHRydWVgLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWU+fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFJhbmdlLCBbewogICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkgewogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0KSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5kZWxlZ2F0ZVlpZWxkKG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICAgICAgICAgIGJvdW5kYXJpZXM6IHRoaXMsCiAgICAgICAgICAgICAgICBpZ25vcmVFbGVtZW50RW5kOiB0cnVlCiAgICAgICAgICAgICAgfSksICJ0MCIsIDEpOwoKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCB2YWx1ZSwgdGhpcyk7CiAgICB9KQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdGhhdCBpcyBpdCBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICAgKgogICAgICogQHR5cGUge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0RW5sYXJnZWQiLAoKICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG1heGltYWwgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgY29udGVudCBhcyB0aGlzIHJhbmdlIGJ1dCBpcyBleHBhbmRlZCBpbiBib3RoIHdheXMgKGF0IHRoZSBiZWdpbm5pbmcKICAgICAqIGFuZCBhdCB0aGUgZW5kKS4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZToKICAgICAqCiAgICAgKgkJPHA+Rm9vPC9wPjxwPjxiPntCYXJ9PC9iPjwvcD4gLT4gPHA+Rm9vPC9wPls8cD48Yj5CYXI8L2I+XTwvcD4KICAgICAqCQk8cD48Yj5mb288L2I+e2Jhcn08c3Bhbj48L3NwYW4+PC9wPiAtPiA8cD48Yj5mb29bPC9iPmJhcjxzcGFuPjwvc3Bhbj5dPC9wPgogICAgICoKICAgICAqIE5vdGUgdGhhdCBpbiB0aGUgc2FtcGxlIGFib3ZlOgogICAgICoKICAgICAqIC0gYDxwPmAgaGF2ZSB0eXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fSwKICAgICAqIC0gYDxiPmAgaGF2ZSB0eXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSwKICAgICAqIC0gYDxzcGFuPmAgaGF2ZSB0eXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gRW5sYXJnZWQgcmFuZ2UuCiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbmxhcmdlZCgpIHsKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXAsIHsKICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCcKICAgICAgfSk7CiAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXApOyAvLyBGaXggcG9zaXRpb25zLCBpbiBjYXNlIGlmIHRoZXkgYXJlIGluIFRleHQgbm9kZS4KCiAgICAgIGlmIChzdGFydC5wYXJlbnQuaXMoJ3RleHQnKSAmJiBzdGFydC5pc0F0U3RhcnQpIHsKICAgICAgICBzdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoc3RhcnQucGFyZW50KTsKICAgICAgfQoKICAgICAgaWYgKGVuZC5wYXJlbnQuaXMoJ3RleHQnKSAmJiBlbmQuaXNBdEVuZCkgewogICAgICAgIGVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBZnRlcihlbmQucGFyZW50KTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG1pbmltdW0gcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgY29udGVudCBhcyB0aGlzIHJhbmdlIGJ1dCBpcyB0cmltbWVkIGluIGJvdGggd2F5cyAoYXQgdGhlIGJlZ2lubmluZwogICAgICogYW5kIGF0IHRoZSBlbmQpLgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqCQk8cD5Gb288L3A+WzxwPjxiPkJhcjwvYj5dPC9wPiAtPiA8cD5Gb288L3A+PHA+PGI+e0Jhcn08L2I+PC9wPgogICAgICoJCTxwPjxiPmZvb1s8L2I+YmFyPHNwYW4+PC9zcGFuPl08L3A+IC0+IDxwPjxiPmZvbzwvYj57YmFyfTxzcGFuPjwvc3Bhbj48L3A+CiAgICAgKgogICAgICogTm90ZSB0aGF0IGluIHRoZSBzYW1wbGUgYWJvdmU6CiAgICAgKgogICAgICogLSBgPHA+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9LAogICAgICogLSBgPGI+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LAogICAgICogLSBgPHNwYW4+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBTaHJpbmsgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0VHJpbW1lZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJpbW1lZCgpIHsKICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXApOwoKICAgICAgaWYgKHN0YXJ0LmlzQWZ0ZXIodGhpcy5lbmQpIHx8IHN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpKSB7CiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOwogICAgICB9CgogICAgICB2YXIgZW5kID0gdGhpcy5lbmQuZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oZW5sYXJnZVRyaW1Ta2lwLCB7CiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgICB2YXIgbm9kZUFmdGVyU3RhcnQgPSBzdGFydC5ub2RlQWZ0ZXI7CiAgICAgIHZhciBub2RlQmVmb3JlRW5kID0gZW5kLm5vZGVCZWZvcmU7IC8vIEJlY2F1c2UgVHJlZVdhbGtlciBwcmVmZXJzIHBvc2l0aW9ucyBuZXh0IHRvIHRleHQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZW0gbWFudWFsbHkgaW50byB0aGVzZSB0ZXh0IG5vZGVzLgoKICAgICAgaWYgKG5vZGVBZnRlclN0YXJ0ICYmIG5vZGVBZnRlclN0YXJ0LmlzKCd0ZXh0JykpIHsKICAgICAgICBzdGFydCA9IG5ldyBQb3NpdGlvbihub2RlQWZ0ZXJTdGFydCwgMCk7CiAgICAgIH0KCiAgICAgIGlmIChub2RlQmVmb3JlRW5kICYmIG5vZGVCZWZvcmVFbmQuaXMoJ3RleHQnKSkgewogICAgICAgIGVuZCA9IG5ldyBQb3NpdGlvbihub2RlQmVmb3JlRW5kLCBub2RlQmVmb3JlRW5kLmRhdGEubGVuZ3RoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogVHdvIHJhbmdlcyBhcmUgZXF1YWwgaWYgdGhlaXIgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgYXJlIGVxdWFsLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgcmFuZ2VzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0VxdWFsIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VxdWFsKG90aGVyUmFuZ2UpIHsKICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXJSYW5nZSB8fCB0aGlzLnN0YXJ0LmlzRXF1YWwob3RoZXJSYW5nZS5zdGFydCkgJiYgdGhpcy5lbmQuaXNFcXVhbChvdGhlclJhbmdlLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSBpcyBjb250YWluZWQgaW4gdGhpcyByYW5nZSwKICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNvbnRhaW5zUG9zaXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pIHsKICAgICAgcmV0dXJuIHBvc2l0aW9uLmlzQWZ0ZXIodGhpcy5zdGFydCkgJiYgcG9zaXRpb24uaXNCZWZvcmUodGhpcy5lbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJhbmdlIGNvbnRhaW5zIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2V9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9ZmFsc2VdIFdoZXRoZXIgdGhlIGNoZWNrIGlzIGxvb3NlIG9yIHN0cmljdC4gSWYgdGhlIGNoZWNrIGlzIHN0cmljdCAoYGZhbHNlYCksIGNvbXBhcmVkIHJhbmdlIGNhbm5vdAogICAgICogc3RhcnQgb3IgZW5kIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoaXMgcmFuZ2UgYm91bmRhcmllcy4gSWYgdGhlIGNoZWNrIGlzIGxvb3NlIChgdHJ1ZWApLCBjb21wYXJlZCByYW5nZSBjYW4gc3RhcnQsIGVuZCBvcgogICAgICogZXZlbiBiZSBlcXVhbCB0byB0aGlzIHJhbmdlLiBOb3RlIHRoYXQgY29sbGFwc2VkIHJhbmdlcyBhcmUgYWx3YXlzIGNvbXBhcmVkIGluIHN0cmljdCBtb2RlLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfSBib3VuZGFyaWVzIGFyZSBjb250YWluZWQgYnkgdGhpcyByYW5nZSwgYGZhbHNlYAogICAgICogb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNvbnRhaW5zUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zUmFuZ2Uob3RoZXJSYW5nZSkgewogICAgICB2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwoKICAgICAgaWYgKG90aGVyUmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgICAgICBsb29zZSA9IGZhbHNlOwogICAgICB9CgogICAgICB2YXIgY29udGFpbnNTdGFydCA9IHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLnN0YXJ0KSB8fCBsb29zZSAmJiB0aGlzLnN0YXJ0LmlzRXF1YWwob3RoZXJSYW5nZS5zdGFydCk7CiAgICAgIHZhciBjb250YWluc0VuZCA9IHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkgfHwgbG9vc2UgJiYgdGhpcy5lbmQuaXNFcXVhbChvdGhlclJhbmdlLmVuZCk7CiAgICAgIHJldHVybiBjb250YWluc1N0YXJ0ICYmIGNvbnRhaW5zRW5kOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB3aGljaCBwYXJ0KHMpIG9mIHRoaXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0gaXMgbm90IGEgcGFydCBvZiBnaXZlbgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKiBSZXR1cm5lZCBhcnJheSBjb250YWlucyB6ZXJvLCBvbmUgb3IgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2VzfS4KICAgICAqCiAgICAgKiBFeGFtcGxlczoKICAgICAqCiAgICAgKgkJbGV0IGZvbyA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICAgKgkJbGV0IGltZyA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdpbWcnICk7CiAgICAgKgkJbGV0IGJhciA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZVRleHQoICdiYXInICk7CiAgICAgKgkJbGV0IHAgPSBkb3duY2FzdFdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcsIG51bGwsIFsgZm9vLCBpbWcsIGJhciBdICk7CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggZm9vLCAyICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAxICk7IC8vICJvIiwgaW1nLCAiYiIgYXJlIGluIHJhbmdlLgogICAgICoJCWxldCBvdGhlclJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggLy8gIm9vIiwgaW1nLCAiYmEiIGFyZSBpbiByYW5nZS4KICAgICAqCQkJdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDEgKSwKICAgICAqCQkJdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBiYXIsIDIgKQogICAgICoJCSk7CiAgICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBubyByYW5nZXMgYmVjYXVzZSBgb3RoZXJSYW5nZWAgY29udGFpbnMgYHJhbmdlYAogICAgICoKICAgICAqCQlvdGhlclJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDEgKSwgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBwLCAyICk7IC8vICJvbyIsIGltZyBhcmUgaW4gcmFuZ2UuCiAgICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZTogZnJvbSAoIHAsIDIgKSB0byAoIGJhciwgMSApCiAgICAgKgogICAgICoJCW90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIHAsIDEgKSwgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBwLCAyICkgKTsgLy8gaW1nIGlzIGluIHJhbmdlLgogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyB0d28gcmFuZ2VzOiBmcm9tICggZm9vLCAxICkgdG8gKCBwLCAxICkgYW5kIGZyb20gKCBwLCAyICkgdG8gKCBiYXIsIDEgKQogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGRpZmZlcmVudGlhdGUgYWdhaW5zdC4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlPn0gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiByYW5nZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0RGlmZmVyZW5jZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlmZmVyZW5jZShvdGhlclJhbmdlKSB7CiAgICAgIHZhciByYW5nZXMgPSBbXTsKCiAgICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgICAgLy8gUmFuZ2VzIGludGVyc2VjdC4KICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICAvLyBHaXZlbiByYW5nZSBzdGFydCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIGFkZCBzaHJ1bmtlbiByYW5nZSAtIGZyb20gdGhlIHN0YXJ0IHRvIHRoZSBtaWRkbGUgb2YgdGhpcyByYW5nZS4KICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCBvdGhlclJhbmdlLnN0YXJ0KSk7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSkgewogICAgICAgICAgLy8gR2l2ZW4gcmFuZ2UgZW5kIGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSB0bwogICAgICAgICAgLy8gYWRkIHNocnVua2VuIHJhbmdlIC0gZnJvbSB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UgdG8gdGhlIGVuZC4KICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShvdGhlclJhbmdlLmVuZCwgdGhpcy5lbmQpKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gUmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3QsIHJldHVybiB0aGUgb3JpZ2luYWwgcmFuZ2UuCiAgICAgICAgcmFuZ2VzLnB1c2godGhpcy5jbG9uZSgpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpbnRlcnNlY3Rpb24gb2YgdGhpcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfSBhbmQgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICAgKiBJbnRlcnNlY3Rpb24gaXMgYSBjb21tb24gcGFydCBvZiBib3RoIG9mIHRob3NlIHJhbmdlcy4gSWYgcmFuZ2VzIGhhcyBubyBjb21tb24gcGFydCwgcmV0dXJucyBgbnVsbGAuCiAgICAgKgogICAgICogRXhhbXBsZXM6CiAgICAgKgogICAgICoJCWxldCBmb28gPSBkb3duY2FzdFdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAgICoJCWxldCBpbWcgPSBkb3duY2FzdFdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAnaW1nJyApOwogICAgICoJCWxldCBiYXIgPSBkb3duY2FzdFdyaXRlci5jcmVhdGVUZXh0KCAnYmFyJyApOwogICAgICoJCWxldCBwID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnLCBudWxsLCBbIGZvbywgaW1nLCBiYXIgXSApOwogICAgICoKICAgICAqCQlsZXQgcmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGZvbywgMiApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMSApOyAvLyAibyIsIGltZywgImIiIGFyZSBpbiByYW5nZS4KICAgICAqCQlsZXQgb3RoZXJSYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggZm9vLCAxICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggcCwgMiApOyAvLyAib28iLCBpbWcgYXJlIGluIHJhbmdlLgogICAgICoJCWxldCB0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldEludGVyc2VjdGlvbiggb3RoZXJSYW5nZSApOyAvLyByYW5nZSBmcm9tICggZm9vLCAxICkgdG8gKCBwLCAyICkuCiAgICAgKgogICAgICoJCW90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMSApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMyApOyAiYXIiIGlzIGluIHJhbmdlLgogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKCBvdGhlclJhbmdlICk7IC8vIG51bGwgLSBubyBjb21tb24gcGFydC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZXxudWxsfSBBIGNvbW1vbiBwYXJ0IG9mIGdpdmVuIHJhbmdlcyBvciBgbnVsbGAgaWYgcmFuZ2VzIGhhdmUgbm8gY29tbW9uIHBhcnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0SW50ZXJzZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24ob3RoZXJSYW5nZSkgewogICAgICBpZiAodGhpcy5pc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKSkgewogICAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QsIHNvIGEgY29tbW9uIHJhbmdlIHdpbGwgYmUgcmV0dXJuZWQuCiAgICAgICAgLy8gQXQgbW9zdCwgaXQgd2lsbCBiZSBzYW1lIGFzIHRoaXMgcmFuZ2UuCiAgICAgICAgdmFyIGNvbW1vblJhbmdlU3RhcnQgPSB0aGlzLnN0YXJ0OwogICAgICAgIHZhciBjb21tb25SYW5nZUVuZCA9IHRoaXMuZW5kOwoKICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICAvLyBHaXZlbiByYW5nZSBzdGFydCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGFOdCB3ZSBoYXZlIHRvCiAgICAgICAgICAvLyBzaHJpbmsgY29tbW9uIHJhbmdlIHRvIHRoZSBnaXZlbiByYW5nZSBzdGFydC4KICAgICAgICAgIGNvbW1vblJhbmdlU3RhcnQgPSBvdGhlclJhbmdlLnN0YXJ0OwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIGVuZCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIHNocmluayBjb21tb24gcmFuZ2UgdG8gdGhlIGdpdmVuIHJhbmdlIGVuZC4KICAgICAgICAgIGNvbW1vblJhbmdlRW5kID0gb3RoZXJSYW5nZS5lbmQ7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbW1vblJhbmdlU3RhcnQsIGNvbW1vblJhbmdlRW5kKTsKICAgICAgfSAvLyBSYW5nZXMgZG8gbm90IGludGVyc2VjdCwgc28gdGhleSBkbyBub3QgaGF2ZSBjb21tb24gcGFydC4KCgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyIFRyZWVXYWxrZXJ9IGluc3RhbmNlIHdpdGggdGhpcyByYW5nZSBhcyBhIGJvdW5kYXJ5LgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBbb3B0aW9ucy5zdGFydFBvc2l0aW9uXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaW5nbGVDaGFyYWN0ZXJzPWZhbHNlXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaGFsbG93PWZhbHNlXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kPWZhbHNlXQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0V2Fsa2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXYWxrZXIoKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgICAgcmV0dXJuIG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogd2hpY2ggaXMgYSBjb21tb24gYW5jZXN0b3Igb2YgcmFuZ2UncyBib3RoIGVuZHMgKGluIHdoaWNoIHRoZSBlbnRpcmUgcmFuZ2UgaXMgY29udGFpbmVkKS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q29tbW9uQW5jZXN0b3IiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yKCkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5nZXRDb21tb25BbmNlc3Rvcih0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgRWxlbWVudH0gY29udGFpbmVkIGJ5IHRoZSByYW5nZS4KICAgICAqIFRoZSBlbGVtZW50IHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBpdCBpcyB0aGUgKipvbmx5Kiogbm9kZSB3aXRoaW4gdGhlIHJhbmdlIGFuZCAqKmZ1bGx54oCTY29udGFpbmVkKioKICAgICAqIGF0IHRoZSBzYW1lIHRpbWUuCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb250YWluZWRFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250YWluZWRFbGVtZW50KCkgewogICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CgogICAgICB2YXIgbm9kZUFmdGVyU3RhcnQgPSB0aGlzLnN0YXJ0Lm5vZGVBZnRlcjsKICAgICAgdmFyIG5vZGVCZWZvcmVFbmQgPSB0aGlzLmVuZC5ub2RlQmVmb3JlOyAvLyBIYW5kbGUgdGhlIHNpdHVhdGlvbiB3aGVuIHRoZSByYW5nZSBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIC8gYXQgdGhlIGVuZCBvZiBhIHRleHQgbm9kZS4KICAgICAgLy8gSW4gc3VjaCBzaXR1YXRpb24gYC5ub2RlQWZ0ZXJgIGFuZCBgLm5vZGVCZWZvcmVgIGFyZSBgbnVsbGAgYnV0IHRoZSByYW5nZSBzdGlsbCBtaWdodCBiZSBzcGFubmluZwogICAgICAvLyBvdmVyIG9uZSBlbGVtZW50LgogICAgICAvLwogICAgICAvLyA8cD5Gb297PHNwYW4gY2xhc3M9IndpZGdldCI+PC9zcGFuPn1iYXI8L3A+IHZzIDxwPkZvb1s8c3BhbiBjbGFzcz0id2lkZ2V0Ij48L3NwYW4+XWJhcjwvcD4KICAgICAgLy8KICAgICAgLy8gVGhlc2UgYXJlIGJhc2ljYWxseSB0aGUgc2FtZSByYW5nZSwgb25seSB0aGUgZGlmZmVyZW5jZSBpcyBpZiB0aGUgcmFuZ2UgcG9zaXRpb24gaXMgYXQKICAgICAgLy8gYXQgdGhlIGVuZC9hdCB0aGUgYmVnaW5uaW5nIG9mIGEgdGV4dCBub2RlIG9yIGp1c3QgYmVmb3JlL2p1c3QgYWZ0ZXIgdGhlIHRleHQgbm9kZS4KICAgICAgLy8KCiAgICAgIGlmICh0aGlzLnN0YXJ0LnBhcmVudC5pcygndGV4dCcpICYmIHRoaXMuc3RhcnQuaXNBdEVuZCAmJiB0aGlzLnN0YXJ0LnBhcmVudC5uZXh0U2libGluZykgewogICAgICAgIG5vZGVBZnRlclN0YXJ0ID0gdGhpcy5zdGFydC5wYXJlbnQubmV4dFNpYmxpbmc7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmVuZC5wYXJlbnQuaXMoJ3RleHQnKSAmJiB0aGlzLmVuZC5pc0F0U3RhcnQgJiYgdGhpcy5lbmQucGFyZW50LnByZXZpb3VzU2libGluZykgewogICAgICAgIG5vZGVCZWZvcmVFbmQgPSB0aGlzLmVuZC5wYXJlbnQucHJldmlvdXNTaWJsaW5nOwogICAgICB9CgogICAgICBpZiAobm9kZUFmdGVyU3RhcnQgJiYgbm9kZUFmdGVyU3RhcnQuaXMoJ2VsZW1lbnQnKSAmJiBub2RlQWZ0ZXJTdGFydCA9PT0gbm9kZUJlZm9yZUVuZCkgewogICAgICAgIHJldHVybiBub2RlQWZ0ZXJTdGFydDsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIENsb25lcyB0aGlzIHJhbmdlLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2xvbmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbXN9IHRoYXQgYXJlIGluIHRoaXMgcmFuZ2UgYW5kIHJldHVybnMKICAgICAqIHRoZW0uCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gd2l0aCBgYm91bmRhcmllc2Agc2V0IHRvIHRoaXMgcmFuZ2UgYW5kIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24KICAgICAqIHNldCB0byBgdHJ1ZWAuIEhvd2V2ZXIgaXQgcmV0dXJucyBvbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW1zfSwKICAgICAqIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfS4KICAgICAqCiAgICAgKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJlZSB3YWxrZXIuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gZm9yCiAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEl0ZW1zIiwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gZ2V0SXRlbXMoKSB7CiAgICAgIHZhciBvcHRpb25zLAogICAgICAgICAgdHJlZVdhbGtlciwKICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sCiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciwKICAgICAgICAgIF9pdGVyYXRvckVycm9yLAogICAgICAgICAgX2l0ZXJhdG9yLAogICAgICAgICAgX3N0ZXAsCiAgICAgICAgICBfdmFsdWUsCiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0SXRlbXMkKF9jb250ZXh0MikgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczIubGVuZ3RoID4gMCAmJiBfYXJnczJbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlswXSA6IHt9OwogICAgICAgICAgICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICAgICAgICAgICAgb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kID0gdHJ1ZTsKICAgICAgICAgICAgICB0cmVlV2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIob3B0aW9ucyk7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDc7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gdHJlZVdhbGtlcltTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfdmFsdWUgPSBfc3RlcC52YWx1ZTsKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzOwogICAgICAgICAgICAgIHJldHVybiBfdmFsdWUuaXRlbTsKCiAgICAgICAgICAgIGNhc2UgMTM6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxNjoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIyOwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxODoKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4OwogICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MlsiY2F0Y2giXSg3KTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dDIudDA7CgogICAgICAgICAgICBjYXNlIDIyOgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjI7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMzsKCiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNTsKCiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyODsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7CgogICAgICAgICAgICBjYXNlIDI4OgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI1KTsKCiAgICAgICAgICAgIGNhc2UgMjk6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjIpOwoKICAgICAgICAgICAgY2FzZSAzMDoKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIGdldEl0ZW1zLCB0aGlzLCBbWzcsIDE4LCAyMiwgMzBdLCBbMjMsLCAyNSwgMjldXSk7CiAgICB9KQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9IHRoYXQgYXJlIGJvdW5kYXJpZXMgb3IKICAgICAqIGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlLiBIb3dldmVyIGl0IHJldHVybnMgb25seQogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9LCBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICAgKgogICAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IGZvcgogICAgICogYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMuCiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBvc2l0aW9ucyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldFBvc2l0aW9ucygpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICB0cmVlV2Fsa2VyLAogICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIsCiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIsCiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIsCiAgICAgICAgICBfaXRlcmF0b3IyLAogICAgICAgICAgX3N0ZXAyLAogICAgICAgICAgX3ZhbHVlMiwKICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRQb3NpdGlvbnMkKF9jb250ZXh0MykgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczMubGVuZ3RoID4gMCAmJiBfYXJnczNbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzM1swXSA6IHt9OwogICAgICAgICAgICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICAgICAgICAgICAgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTsKICAgICAgICAgICAgICByZXR1cm4gdHJlZVdhbGtlci5wb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gODsKICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gdHJlZVdhbGtlcltTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNzsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX3ZhbHVlMiA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0OwogICAgICAgICAgICAgIHJldHVybiBfdmFsdWUyLm5leHRQb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE3OgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjM7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTk7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzWyJjYXRjaCJdKDgpOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQzLnQwOwoKICAgICAgICAgICAgY2FzZSAyMzoKICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDIzOwogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjQ7CgogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjY7CgogICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI5OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CgogICAgICAgICAgICBjYXNlIDI5OgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDI2KTsKCiAgICAgICAgICAgIGNhc2UgMzA6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjMpOwoKICAgICAgICAgICAgY2FzZSAzMToKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIGdldFBvc2l0aW9ucywgdGhpcywgW1s4LCAxOSwgMjMsIDMxXSwgWzI0LCwgMjYsIDMwXV0pOwogICAgfSkKICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2YgdGhlIGdpdmVuIHR5cGUuCiAgICAgKgogICAgICoJCXJhbmdlLmlzKCAncmFuZ2UnICk7IC8vIC0+IHRydWUKICAgICAqCQlyYW5nZS5pcyggJ3ZpZXc6cmFuZ2UnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJcmFuZ2UuaXMoICdtb2RlbDpyYW5nZScgKTsgLy8gLT4gZmFsc2UKICAgICAqCQlyYW5nZS5pcyggJ2VsZW1lbnQnICk7IC8vIC0+IGZhbHNlCiAgICAgKgkJcmFuZ2UuaXMoICdzZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUjaXMgQ2hlY2sgdGhlIGVudGlyZSBsaXN0IG9mIHZpZXcgb2JqZWN0c30gd2hpY2ggaW1wbGVtZW50IHRoZSBgaXMoKWAgbWV0aG9kLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXModHlwZSkgewogICAgICByZXR1cm4gdHlwZSA9PSAncmFuZ2UnIHx8IHR5cGUgPT0gJ3ZpZXc6cmFuZ2UnOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgYW5kIHJldHVybnMgd2hldGhlciB0aGlzIHJhbmdlIGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgcmFuZ2VzIGludGVyc2VjdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ludGVyc2VjdGluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlcnNlY3Rpbmcob3RoZXJSYW5nZSkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5pc0JlZm9yZShvdGhlclJhbmdlLmVuZCkgJiYgdGhpcy5lbmQuaXNBZnRlcihvdGhlclJhbmdlLnN0YXJ0KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGZyb20gdGhlIGdpdmVuIHBhcmVudHMgYW5kIG9mZnNldHMuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHN0YXJ0RWxlbWVudCBTdGFydCBwb3NpdGlvbgogICAgICogcGFyZW50IGVsZW1lbnQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZmZzZXQgU3RhcnQgcG9zaXRpb24gb2Zmc2V0LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVuZEVsZW1lbnQgRW5kIHBvc2l0aW9uCiAgICAgKiBwYXJlbnQgZWxlbWVudC4KICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRPZmZzZXQgRW5kIHBvc2l0aW9uIG9mZnNldC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IENyZWF0ZWQgcmFuZ2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNDb2xsYXBzZWQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpcyBmbGF0LCB0aGF0IGlzIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IHBvc2l0aW9uIGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbiBhcmUgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fS4KICAgICAqCiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ZsYXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnBhcmVudCA9PT0gdGhpcy5lbmQucGFyZW50OwogICAgfQogICAgLyoqCiAgICAgKiBSYW5nZSByb290IGVsZW1lbnQuCiAgICAgKgogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyb290IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5yb290OwogICAgfQogIH1dLCBbewogICAga2V5OiAiX2NyZWF0ZUZyb21QYXJlbnRzQW5kT2Zmc2V0cyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUZyb21QYXJlbnRzQW5kT2Zmc2V0cyhzdGFydEVsZW1lbnQsIHN0YXJ0T2Zmc2V0LCBlbmRFbGVtZW50LCBlbmRPZmZzZXQpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzKG5ldyBQb3NpdGlvbihzdGFydEVsZW1lbnQsIHN0YXJ0T2Zmc2V0KSwgbmV3IFBvc2l0aW9uKGVuZEVsZW1lbnQsIGVuZE9mZnNldCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHJhbmdlLCBzcHJlYWRpbmcgZnJvbSBzcGVjaWZpZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0gdG8gYSBwb3NpdGlvbiBtb3ZlZCBieQogICAgICogZ2l2ZW4gYHNoaWZ0YC4gSWYgYHNoaWZ0YCBpcyBhIG5lZ2F0aXZlIHZhbHVlLCBzaGlmdGVkIHBvc2l0aW9uIGlzIHRyZWF0ZWQgYXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIEJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2hpZnQgSG93IGxvbmcgdGhlIHJhbmdlIHNob3VsZCBiZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQocG9zaXRpb24sIHNoaWZ0KSB7CiAgICAgIHZhciBzdGFydCA9IHBvc2l0aW9uOwogICAgICB2YXIgZW5kID0gcG9zaXRpb24uZ2V0U2hpZnRlZEJ5KHNoaWZ0KTsKICAgICAgcmV0dXJuIHNoaWZ0ID4gMCA/IG5ldyB0aGlzKHN0YXJ0LCBlbmQpIDogbmV3IHRoaXMoZW5kLCBzdGFydCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSByYW5nZSBpbnNpZGUgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YKICAgICAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgd2hpY2ggaXMgYSBwYXJlbnQgZm9yIHRoZSByYW5nZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NyZWF0ZUluIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlSW4oZWxlbWVudCkgewogICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKGVsZW1lbnQsIDAsIGVsZW1lbnQsIGVsZW1lbnQuY2hpbGRDb3VudCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSByYW5nZSB0aGF0IHN0YXJ0cyBiZWZvcmUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtfSBhbmQgZW5kcyBhZnRlciBpdC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IGl0ZW0KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NyZWF0ZU9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlT24oaXRlbSkgewogICAgICB2YXIgc2l6ZSA9IGl0ZW0uaXMoJ3RleHRQcm94eScpID8gaXRlbS5vZmZzZXRTaXplIDogMTsKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSksIHNpemUpOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIFJhbmdlOwp9KCk7IC8vIEZ1bmN0aW9uIHVzZWQgYnkgZ2V0RW5sYXJnZWQgYW5kIGdldFRyaW1tZWQgbWV0aG9kcy4KCgpleHBvcnQgeyBSYW5nZSBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBlbmxhcmdlVHJpbVNraXAodmFsdWUpIHsKICBpZiAodmFsdWUuaXRlbS5pcygnYXR0cmlidXRlRWxlbWVudCcpIHx8IHZhbHVlLml0ZW0uaXMoJ3VpRWxlbWVudCcpKSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9CgogIHJldHVybiBmYWxzZTsKfQ=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js"],"names":["Position","TreeWalker","Range","start","end","clone","Symbol","iterator","boundaries","ignoreElementEnd","getLastMatchingPosition","enlargeTrimSkip","direction","parent","is","isAtStart","_createBefore","isAtEnd","_createAfter","isAfter","isEqual","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","data","length","otherRange","position","isBefore","loose","isCollapsed","containsStart","containsPosition","containsEnd","ranges","isIntersecting","push","commonRangeStart","commonRangeEnd","options","getCommonAncestor","nextSibling","previousSibling","treeWalker","value","item","nextPosition","type","root","startElement","startOffset","endElement","endOffset","shift","getShiftedBy","element","_createFromParentsAndOffsets","childCount","size","offsetSize","_createFromPositionAndShift"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\n\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.start = start.clone();\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.end = end ? end.clone() : start.clone();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/view/position~Position positions},\n\t * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n\t * `ignoreElementEnd` option\n\t * set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is it start and end positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n\t * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n\t *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Enlarged range.\n\t */\n\tgetEnlarged() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\t// Fix positions, in case if they are in Text node.\n\t\tif ( start.parent.is( 'text' ) && start.isAtStart ) {\n\t\t\tstart = Position._createBefore( start.parent );\n\t\t}\n\n\t\tif ( end.parent.is( 'text' ) && end.isAtEnd ) {\n\t\t\tend = Position._createAfter( end.parent );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n\t *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Shrink range.\n\t */\n\tgetTrimmed() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\tif ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {\n\t\t\treturn new Range( start, start );\n\t\t}\n\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tconst nodeAfterStart = start.nodeAfter;\n\t\tconst nodeBeforeEnd = end.nodeBefore;\n\n\t\t// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'text' ) ) {\n\t\t\tstart = new Position( nodeAfterStart, 0 );\n\t\t}\n\n\t\tif ( nodeBeforeEnd && nodeBeforeEnd.is( 'text' ) ) {\n\t\t\tend = new Position( nodeBeforeEnd, nodeBeforeEnd.data.length );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Two ranges are equal if their start and end positions are equal.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n\t * `false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n\t * otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n\t * {@link module:engine/view/range~Range range}.\n\t * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n\t *\t\t\tview.createPositionAt( foo, 1 ),\n\t *\t\t\tview.createPositionAt( bar, 2 )\n\t *\t\t);\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( this.clone() );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n\t *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @param {module:engine/view/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t * @returns {module:engine/view/treewalker~TreeWalker}\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/view/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fully–contained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/view/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet nodeAfterStart = this.start.nodeAfter;\n\t\tlet nodeBeforeEnd = this.end.nodeBefore;\n\n\t\t// Handle the situation when the range position is at the beginning / at the end of a text node.\n\t\t// In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning\n\t\t// over one element.\n\t\t//\n\t\t// <p>Foo{<span class=\"widget\"></span>}bar</p> vs <p>Foo[<span class=\"widget\"></span>]bar</p>\n\t\t//\n\t\t// These are basically the same range, only the difference is if the range position is at\n\t\t// at the end/at the beginning of a text node or just before/just after the text node.\n\t\t//\n\t\tif ( this.start.parent.is( 'text' ) && this.start.isAtEnd && this.start.parent.nextSibling ) {\n\t\t\tnodeAfterStart = this.start.parent.nextSibling;\n\t\t}\n\n\t\tif ( this.end.parent.is( 'text' ) && this.end.isAtStart && this.end.parent.previousSibling ) {\n\t\t\tnodeBeforeEnd = this.end.parent.previousSibling;\n\t\t}\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Clones this range.\n\t *\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tclone() {\n\t\treturn new Range( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n\t * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'view:range' ); // -> true\n\t *\n\t *\t\trange.is( 'model:range' ); // -> false\n\t *\t\trange.is( 'element' ); // -> false\n\t *\t\trange.is( 'selection' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'range' || type == 'view:range';\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with the given range.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} True if ranges intersect.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Creates a range from the given parents and offsets.\n\t *\n\t * @protected\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n\t * parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n\t * parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/view/range~Range} Created range.\n\t */\n\tstatic _createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tnew Position( startElement, startOffset ),\n\t\t\tnew Position( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/view/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn this._createFromParentsAndOffsets( element, 0, element, element.childCount );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\tconst size = item.is( 'textProxy' ) ? item.offsetSize : 1;\n\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), size );\n\t}\n}\n\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip( value ) {\n\tif ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]}]}