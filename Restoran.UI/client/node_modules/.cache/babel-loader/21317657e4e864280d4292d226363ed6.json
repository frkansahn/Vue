{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\selection.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\selection.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuYW5jaG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1zZXQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7CmltcG9ydCAicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvc2VsZWN0aW9uCiAqLwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBOb2RlIGZyb20gJy4vbm9kZSc7CmltcG9ydCBSYW5nZSBmcm9tICcuL3JhbmdlJzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IG1peCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9taXgnOwppbXBvcnQgaXNJdGVyYWJsZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9pc2l0ZXJhYmxlJzsKLyoqCiAqIFNlbGVjdGlvbiBpcyBhIHNldCBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSByYW5nZXN9LiBJdCBoYXMgYSBkaXJlY3Rpb24gc3BlY2lmaWVkIGJ5IGl0cwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uI2FuY2hvciBhbmNob3J9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uI2ZvY3VzIGZvY3VzfQogKiAoaXQgY2FuIGJlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24jaXNCYWNrd2FyZCBmb3J3YXJkIG9yIGJhY2t3YXJkfSkuCiAqIEFkZGl0aW9uYWxseSwgc2VsZWN0aW9uIG1heSBoYXZlIGl0cyBvd24gYXR0cmlidXRlcyAodGhpbmsg4oCTIHdoZXRoZXIgdGV4dCB0eXBlZCBpbiBpbiB0aGlzIHNlbGVjdGlvbgogKiBzaG91bGQgaGF2ZSB0aG9zZSBhdHRyaWJ1dGVzIOKAkyBlLmcuIHdoZXRoZXIgeW91IHR5cGUgYSBib2xkZWQgdGV4dCkuCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJNaXhpbgogKi8KCnZhciBTZWxlY3Rpb24gPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHNlbGVjdGlvbiBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGFibGUgc2VsZWN0YWJsZX0KICAgKiBvciBjcmVhdGVzIGFuIGVtcHR5IHNlbGVjdGlvbiBpZiBubyBhcmd1bWVudHMgd2VyZSBwYXNzZWQuCiAgICoKICAgKgkJLy8gQ3JlYXRlcyBlbXB0eSBzZWxlY3Rpb24gd2l0aG91dCByYW5nZXMuCiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHJhbmdlcwogICAqCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcjIsIGVuZDIgKSBdOwogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZXMgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBvdGhlciBzZWxlY3Rpb24uCiAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggb3RoZXJTZWxlY3Rpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBnaXZlbiBkb2N1bWVudCBzZWxlY3Rpb24uCiAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAqCQljb25zdCBkb2N1bWVudFNlbGVjdGlvbiA9IG1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbjsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggZG9jdW1lbnRTZWxlY3Rpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICoJCWNvbnN0IHBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIHBhdGggKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcG9zaXRpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHRoZSBnaXZlbiBlbGVtZW50LgogICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZQogICAqCQkvLyBmaXJzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdpbicgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2Ugb24gYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMKICAgKgkJLy8ganVzdCBhZnRlciB0aGUgaXRlbS4KICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnb24nICk7CiAgICoKICAgKiBTZWxlY3Rpb24ncyBjb25zdHJ1Y3RvciBhbGxvdyBwYXNzaW5nIGFkZGl0aW9uYWwgb3B0aW9ucyAoYCdiYWNrd2FyZCdgKSBhcyB0aGUgbGFzdCBhcmd1bWVudC4KICAgKgogICAqCQkvLyBDcmVhdGVzIGJhY2t3YXJkIHNlbGVjdGlvbi4KICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcmFuZ2UsIHsgYmFja3dhcmQ6IHRydWUgfSApOwogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlfSBzZWxlY3RhYmxlCiAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAqLwogIGZ1bmN0aW9uIFNlbGVjdGlvbihzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uKTsKCiAgICAvKioKICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBsYXN0IGFkZGVkIHJhbmdlIHdhcyBhZGRlZCBhcyBhIGJhY2t3YXJkIG9yIGZvcndhcmQgcmFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCiAgICB0aGlzLl9sYXN0UmFuZ2VCYWNrd2FyZCA9IGZhbHNlOwogICAgLyoqCiAgICAgKiBTdG9yZXMgc2VsZWN0aW9uIHJhbmdlcy4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQogICAgICovCgogICAgdGhpcy5fcmFuZ2VzID0gW107CiAgICAvKioKICAgICAqIExpc3Qgb2YgYXR0cmlidXRlcyBzZXQgb24gY3VycmVudCBzZWxlY3Rpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHR5cGUge01hcC48U3RyaW5nLCo+fQogICAgICovCgogICAgdGhpcy5fYXR0cnMgPSBuZXcgTWFwKCk7CgogICAgaWYgKHNlbGVjdGFibGUpIHsKICAgICAgdGhpcy5zZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICAgIH0KICB9CiAgLyoqCiAgICogU2VsZWN0aW9uIGFuY2hvci4gQW5jaG9yIGlzIHRoZSBwb3NpdGlvbiBmcm9tIHdoaWNoIHRoZSBzZWxlY3Rpb24gd2FzIHN0YXJ0ZWQuIElmIGEgdXNlciBpcyBtYWtpbmcgYSBzZWxlY3Rpb24KICAgKiBieSBkcmFnZ2luZyB0aGUgbW91c2UsIHRoZSBhbmNob3IgaXMgd2hlcmUgdGhlIHVzZXIgcHJlc3NlZCB0aGUgbW91c2UgYnV0dG9uICh0aGUgYmVnZ2luaW5nIG9mIHRoZSBzZWxlY3Rpb24pLgogICAqCiAgICogQW5jaG9yIGFuZCB7QGxpbmsgI2ZvY3VzfSBkZWZpbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLCB3aGljaCBpcyBpbXBvcnRhbnQKICAgKiB3aGVuIGV4cGFuZGluZy9zaHJpbmtpbmcgc2VsZWN0aW9uLiBUaGUgZm9jdXMgbW92ZXMsIHdoaWxlIHRoZSBhbmNob3Igc2hvdWxkIHJlbWFpbiBpbiB0aGUgc2FtZSBwbGFjZS4KICAgKgogICAqIEFuY2hvciBpcyBhbHdheXMgc2V0IHRvIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gb3IKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBvZiBzZWxlY3Rpb24ncyByYW5nZXMuIFdoZXRoZXIgaXQgaXMKICAgKiB0aGUgYHN0YXJ0YCBvciBgZW5kYCBkZXBlbmRzIG9uIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnMuYmFja3dhcmRgLiBTZWUgdGhlIHtAbGluayAjc2V0VG8gYHNldFRvKClgfSBtZXRob2QuCiAgICoKICAgKiBNYXkgYmUgc2V0IHRvIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24uCiAgICoKICAgKiBAc2VlICNmb2N1cwogICAqIEByZWFkb25seQogICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG51bGx9CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoU2VsZWN0aW9uLCBbewogICAga2V5OiAiaXNFcXVhbCIsCgogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHNlbGVjdGlvbiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc2VsZWN0aW9uLiBTZWxlY3Rpb25zIGFyZSBlcXVhbCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgZGlyZWN0aW9ucywKICAgICAqIHRoZSBzYW1lIG51bWJlciBvZiByYW5nZXMgYW5kIGFsbCByYW5nZXMgZnJvbSBvbmUgc2VsZWN0aW9uIGVxdWFsIHRvIHJhbmdlcyBmcm9tIHRoZSBhbm90aGVyIHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9ufSBvdGhlclNlbGVjdGlvbgogICAgICogU2VsZWN0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgc2VsZWN0aW9ucyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChvdGhlclNlbGVjdGlvbikgewogICAgICBpZiAodGhpcy5yYW5nZUNvdW50ICE9IG90aGVyU2VsZWN0aW9uLnJhbmdlQ291bnQpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5nZUNvdW50ID09PSAwKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIGlmICghdGhpcy5hbmNob3IuaXNFcXVhbChvdGhlclNlbGVjdGlvbi5hbmNob3IpIHx8ICF0aGlzLmZvY3VzLmlzRXF1YWwob3RoZXJTZWxlY3Rpb24uZm9jdXMpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX3Jhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciB0aGlzUmFuZ2UgPSBfc3RlcC52YWx1ZTsKICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlOwogICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG90aGVyU2VsZWN0aW9uLl9yYW5nZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgICAgICB2YXIgb3RoZXJSYW5nZSA9IF9zdGVwMi52YWx1ZTsKCiAgICAgICAgICAgICAgaWYgKHRoaXNSYW5nZS5pc0VxdWFsKG90aGVyUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlOwogICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGlmICghZm91bmQpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmFibGUgb2JqZWN0IHRoYXQgaXRlcmF0ZXMgb3ZlciBjb3BpZXMgb2Ygc2VsZWN0aW9uIHJhbmdlcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFJhbmdlcyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldFJhbmdlcygpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zLCBfZGlkSXRlcmF0b3JFcnJvcjMsIF9pdGVyYXRvckVycm9yMywgX2l0ZXJhdG9yMywgX3N0ZXAzLCByYW5nZTsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRSYW5nZXMkKF9jb250ZXh0KSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMyA9IHRoaXMuX3Jhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJhbmdlID0gX3N0ZXAzLnZhbHVlOwogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5OwogICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7CgogICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSAxMjoKICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE0OgogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNDsKICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WyJjYXRjaCJdKDMpOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gX2NvbnRleHQudDA7CgogICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODsKICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTk7CgogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICBjYXNlIDIxOgogICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMTsKCiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwoKICAgICAgICAgICAgY2FzZSAyNDoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIxKTsKCiAgICAgICAgICAgIGNhc2UgMjU6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxOCk7CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBnZXRSYW5nZXMsIHRoaXMsIFtbMywgMTQsIDE4LCAyNl0sIFsxOSwsIDIxLCAyNV1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBmaXJzdCByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLgogICAgICogRmlyc3QgcmFuZ2UgaXMgdGhlIG9uZSB3aGljaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gcG9zaXRpb24KICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI2lzQmVmb3JlIGlzIGJlZm9yZX0gc3RhcnQgcG9zaXRpb24gb2YgYWxsIG90aGVyIHJhbmdlcwogICAgICogKG5vdCB0byBjb25mdXNlIHdpdGggdGhlIGZpcnN0IHJhbmdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24pLgogICAgICoKICAgICAqIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyByYW5nZXMgaW4gc2VsZWN0aW9uLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Rmlyc3RSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RSYW5nZSgpIHsKICAgICAgdmFyIGZpcnN0ID0gbnVsbDsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gdGhpcy5fcmFuZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgcmFuZ2UgPSBfc3RlcDQudmFsdWU7CgogICAgICAgICAgaWYgKCFmaXJzdCB8fCByYW5nZS5zdGFydC5pc0JlZm9yZShmaXJzdC5zdGFydCkpIHsKICAgICAgICAgICAgZmlyc3QgPSByYW5nZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZmlyc3QgPyBuZXcgUmFuZ2UoZmlyc3Quc3RhcnQsIGZpcnN0LmVuZCkgOiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGFzdCByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLgogICAgICogTGFzdCByYW5nZSBpcyB0aGUgb25lIHdoaWNoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9uCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc0FmdGVyIGlzIGFmdGVyfSBlbmQgcG9zaXRpb24gb2YgYWxsIG90aGVyIHJhbmdlcyAobm90IHRvIGNvbmZ1c2Ugd2l0aCB0aGUgcmFuZ2UgbW9zdAogICAgICogcmVjZW50bHkgYWRkZWQgdG8gdGhlIHNlbGVjdGlvbikuCiAgICAgKgogICAgICogUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHJhbmdlcyBpbiBzZWxlY3Rpb24uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRMYXN0UmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhc3RSYW5nZSgpIHsKICAgICAgdmFyIGxhc3QgPSBudWxsOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSB0aGlzLl9yYW5nZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHsKICAgICAgICAgIHZhciByYW5nZSA9IF9zdGVwNS52YWx1ZTsKCiAgICAgICAgICBpZiAoIWxhc3QgfHwgcmFuZ2UuZW5kLmlzQWZ0ZXIobGFzdC5lbmQpKSB7CiAgICAgICAgICAgIGxhc3QgPSByYW5nZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbGFzdCA/IG5ldyBSYW5nZShsYXN0LnN0YXJ0LCBsYXN0LmVuZCkgOiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgc2VsZWN0aW9uLgogICAgICogRmlyc3QgcG9zaXRpb24gaXMgdGhlIHBvc2l0aW9uIHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jaXNCZWZvcmUgaXMgYmVmb3JlfQogICAgICogYW55IG90aGVyIHBvc2l0aW9uIGluIHRoZSBzZWxlY3Rpb24uCiAgICAgKgogICAgICogUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIHJhbmdlcyBpbiBzZWxlY3Rpb24uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb258bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRGaXJzdFBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdFBvc2l0aW9uKCkgewogICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0UmFuZ2UoKTsKICAgICAgcmV0dXJuIGZpcnN0ID8gZmlyc3Quc3RhcnQuY2xvbmUoKSA6IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGxhc3QgcG9zaXRpb24gaW4gdGhlIHNlbGVjdGlvbi4KICAgICAqIExhc3QgcG9zaXRpb24gaXMgdGhlIHBvc2l0aW9uIHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jaXNBZnRlciBpcyBhZnRlcn0KICAgICAqIGFueSBvdGhlciBwb3NpdGlvbiBpbiB0aGUgc2VsZWN0aW9uLgogICAgICoKICAgICAqIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyByYW5nZXMgaW4gc2VsZWN0aW9uLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0TGFzdFBvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0UG9zaXRpb24oKSB7CiAgICAgIHZhciBsYXN0UmFuZ2UgPSB0aGlzLmdldExhc3RSYW5nZSgpOwogICAgICByZXR1cm4gbGFzdFJhbmdlID8gbGFzdFJhbmdlLmVuZC5jbG9uZSgpIDogbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyB0aGlzIHNlbGVjdGlvbidzIHJhbmdlcyBhbmQgZGlyZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24gYmFzZWQgb24gdGhlIGdpdmVuCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZSBzZWxlY3RhYmxlfS4KICAgICAqCiAgICAgKgkJLy8gUmVtb3ZlcyBhbGwgc2VsZWN0aW9uJ3MgcmFuZ2VzLgogICAgICoJCXNlbGVjdGlvbi5zZXRUbyggbnVsbCApOwogICAgICoKICAgICAqCQkvLyBTZXRzIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICAgKgkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0LCBlbmQgKTsKICAgICAqCQlzZWxlY3Rpb24uc2V0VG8oIHJhbmdlICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIGdpdmVuIHJhbmdlcy4KICAgICAqCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcjIsIGVuZDIgKSBdOwogICAgICoJCXNlbGVjdGlvbi5zZXRUbyggcmFuZ2VzICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIG90aGVyIHNlbGVjdGlvbi4KICAgICAqCQkvLyBOb3RlOiBJdCBkb2Vzbid0IGNvcGllcyBzZWxlY3Rpb24gYXR0cmlidXRlcy4KICAgICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgICAqCQlzZWxlY3Rpb24uc2V0VG8oIG90aGVyU2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBzZWxlY3Rpb24uCiAgICAgKgkJLy8gTm90ZTogSXQgZG9lc24ndCBjb3BpZXMgc2VsZWN0aW9uIGF0dHJpYnV0ZXMuCiAgICAgKgkJY29uc3QgZG9jdW1lbnRTZWxlY3Rpb24gPSBuZXcgRG9jdW1lbnRTZWxlY3Rpb24oIGRvYyApOwogICAgICoJCXNlbGVjdGlvbi5zZXRUbyggZG9jdW1lbnRTZWxlY3Rpb24gKTsKICAgICAqCiAgICAgKgkJLy8gU2V0cyBjb2xsYXBzZWQgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4KICAgICAqCQljb25zdCBwb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBwYXRoICk7CiAgICAgKgkJc2VsZWN0aW9uLnNldFRvKCBwb3NpdGlvbiApOwogICAgICoKICAgICAqCQkvLyBTZXRzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBhbiBvZmZzZXQuCiAgICAgKgkJc2VsZWN0aW9uLnNldFRvKCBwYXJhZ3JhcGgsIG9mZnNldCApOwogICAgICoKICAgICAqIENyZWF0ZXMgYSByYW5nZSBpbnNpZGUgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mCiAgICAJICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCiAgICAgKgkJc2VsZWN0aW9uLnNldFRvKCBwYXJhZ3JhcGgsICdpbicgKTsKICAgICAqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2Ugb24gYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMganVzdCBhZnRlciB0aGUgaXRlbS4KICAgICAqCiAgICAgKgkJc2VsZWN0aW9uLnNldFRvKCBwYXJhZ3JhcGgsICdvbicgKTsKICAgICAqCiAgICAgKiBgU2VsZWN0aW9uI3NldFRvKClgJyBtZXRob2QgYWxsb3cgcGFzc2luZyBhZGRpdGlvbmFsIG9wdGlvbnMgKGBiYWNrd2FyZGApIGFzIHRoZSBsYXN0IGFyZ3VtZW50LgogICAgICoKICAgICAqCQkvLyBTZXRzIGJhY2t3YXJkIHNlbGVjdGlvbi4KICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSwgeyBiYWNrd2FyZDogdHJ1ZSB9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlfSBzZWxlY3RhYmxlCiAgICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIFNldHMgcGxhY2Ugb3Igb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb24uCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJhY2t3YXJkXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIGJhY2t3YXJkLgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldFRvIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKSB7CiAgICAgIGlmIChzZWxlY3RhYmxlID09PSBudWxsKSB7CiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKFtdKTsKICAgICAgfSBlbHNlIGlmIChzZWxlY3RhYmxlIGluc3RhbmNlb2YgU2VsZWN0aW9uKSB7CiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKHNlbGVjdGFibGUuZ2V0UmFuZ2VzKCksIHNlbGVjdGFibGUuaXNCYWNrd2FyZCk7CiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0YWJsZSAmJiB0eXBlb2Ygc2VsZWN0YWJsZS5nZXRSYW5nZXMgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSBzZWxlY3RhYmxlIGlzIGEgRG9jdW1lbnRTZWxlY3Rpb24uCiAgICAgICAgLy8gSXQgY2FuJ3QgYmUgaW1wb3J0ZWQgaGVyZSwgYmVjYXVzZSBpdCB3b3VsZCBsZWFkIHRvIGNpcmN1bGFyIGltcG9ydHMuCiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKHNlbGVjdGFibGUuZ2V0UmFuZ2VzKCksIHNlbGVjdGFibGUuaXNCYWNrd2FyZCk7CiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0YWJsZSBpbnN0YW5jZW9mIFJhbmdlKSB7CiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKFtzZWxlY3RhYmxlXSwgISFwbGFjZU9yT2Zmc2V0ICYmICEhcGxhY2VPck9mZnNldC5iYWNrd2FyZCk7CiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0YWJsZSBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKFtuZXcgUmFuZ2Uoc2VsZWN0YWJsZSldKTsKICAgICAgfSBlbHNlIGlmIChzZWxlY3RhYmxlIGluc3RhbmNlb2YgTm9kZSkgewogICAgICAgIHZhciBiYWNrd2FyZCA9ICEhb3B0aW9ucyAmJiAhIW9wdGlvbnMuYmFja3dhcmQ7CiAgICAgICAgdmFyIHJhbmdlOwoKICAgICAgICBpZiAocGxhY2VPck9mZnNldCA9PSAnaW4nKSB7CiAgICAgICAgICByYW5nZSA9IFJhbmdlLl9jcmVhdGVJbihzZWxlY3RhYmxlKTsKICAgICAgICB9IGVsc2UgaWYgKHBsYWNlT3JPZmZzZXQgPT0gJ29uJykgewogICAgICAgICAgcmFuZ2UgPSBSYW5nZS5fY3JlYXRlT24oc2VsZWN0YWJsZSk7CiAgICAgICAgfSBlbHNlIGlmIChwbGFjZU9yT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVBdChzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0KSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8qKgogICAgICAgICAgICogc2VsZWN0aW9uLnNldFRvIHJlcXVpcmVzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIG5vZGUuCiAgICAgICAgICAgKgogICAgICAgICAgICogQGVycm9yIG1vZGVsLXNlbGVjdGlvbi1zZXRUby1yZXF1aXJlZC1zZWNvbmQtcGFyYW1ldGVyCiAgICAgICAgICAgKi8KICAgICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1zZWxlY3Rpb24tc2V0VG8tcmVxdWlyZWQtc2Vjb25kLXBhcmFtZXRlcjogJyArICdzZWxlY3Rpb24uc2V0VG8gcmVxdWlyZXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgbm9kZS4nLCBbdGhpcywgc2VsZWN0YWJsZV0pOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5fc2V0UmFuZ2VzKFtyYW5nZV0sIGJhY2t3YXJkKTsKICAgICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKHNlbGVjdGFibGUpKSB7CiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIHNlbGVjdGFibGUgaXMgYW4gaXRlcmFibGUgb2YgcmFuZ2VzLgogICAgICAgIHRoaXMuX3NldFJhbmdlcyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0ICYmICEhcGxhY2VPck9mZnNldC5iYWNrd2FyZCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IHNldCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiBwbGFjZS4KICAgICAgICAgKgogICAgICAgICAqIEludmFsaWQgcGFyYW1ldGVycyB3ZXJlIHNwZWNpZmllZCB3aGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbi4gQ29tbW9uIGlzc3VlczoKICAgICAgICAgKgogICAgICAgICAqICogQSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSBpbnN0YW5jZSB3YXMgcGFzc2VkIGluc3RlYWQgb2YKICAgICAgICAgKiBhIHJlYWwge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0fS4KICAgICAgICAgKiAqIFZpZXcgbm9kZXMgd2VyZSBwYXNzZWQgaW5zdGVhZCBvZiBtb2RlbCBub2Rlcy4KICAgICAgICAgKiAqIGBudWxsYC9gdW5kZWZpbmVkYCB3YXMgcGFzc2VkLgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIG1vZGVsLXNlbGVjdGlvbi1zZXRUby1ub3Qtc2VsZWN0YWJsZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1zZWxlY3Rpb24tc2V0VG8tbm90LXNlbGVjdGFibGU6IENhbm5vdCBzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gcGxhY2UuJywgW3RoaXMsIHNlbGVjdGFibGVdKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXBsYWNlcyBhbGwgcmFuZ2VzIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgc2VsZWN0aW9uIHdpdGggZ2l2ZW4gYXJyYXkgb2YgcmFuZ2VzLiBMYXN0IHJhbmdlIG9mIHRoZSBhcnJheQogICAgICogaXMgdHJlYXRlZCBsaWtlIHRoZSBsYXN0IGFkZGVkIHJhbmdlIGFuZCBpcyB1c2VkIHRvIHNldCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uI2FuY2hvcn0gYW5kCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uI2ZvY3VzfS4gQWNjZXB0cyBhIGZsYWcgZGVzY3JpYmluZyBpbiB3aGljaCBkaXJlY3Rpb24gdGhlIHNlbGVjdGlvbiBpcyBtYWRlLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBmaXJlcyBjaGFuZ2U6cmFuZ2UKICAgICAqIEBwYXJhbSB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBuZXdSYW5nZXMgUmFuZ2VzIHRvIHNldC4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzTGFzdEJhY2t3YXJkPWZhbHNlXSBGbGFnIGRlc2NyaWJpbmcgaWYgbGFzdCBhZGRlZCByYW5nZSB3YXMgc2VsZWN0ZWQgZm9yd2FyZCAtIGZyb20gc3RhcnQgdG8gZW5kIChgZmFsc2VgKQogICAgICogb3IgYmFja3dhcmQgLSBmcm9tIGVuZCB0byBzdGFydCAoYHRydWVgKS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfc2V0UmFuZ2VzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UmFuZ2VzKG5ld1JhbmdlcykgewogICAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgICAgdmFyIGlzTGFzdEJhY2t3YXJkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgbmV3UmFuZ2VzID0gQXJyYXkuZnJvbShuZXdSYW5nZXMpOyAvLyBDaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFueSByYW5nZSBpbiBuZXcgcmFuZ2VzIHNldCB0aGF0IGlzIGRpZmZlcmVudCB0aGFuIGFsbCBhbHJlYWR5IGFkZGVkIHJhbmdlcy4KCiAgICAgIHZhciBhbnlOZXdSYW5nZSA9IG5ld1Jhbmdlcy5zb21lKGZ1bmN0aW9uIChuZXdSYW5nZSkgewogICAgICAgIGlmICghKG5ld1JhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7CiAgICAgICAgICAvKioKICAgICAgICAgICAqIFNlbGVjdGlvbiByYW5nZSBzZXQgdG8gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGFuIGluc3RhbmNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfS4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBPbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgdG8gc2V0IGEgc2VsZWN0aW9uLgogICAgICAgICAgICogQ29tbW9uIG1pc3Rha2VzIGxlYWRpbmcgdG8gdGhpcyBlcnJvciBhcmU6CiAgICAgICAgICAgKgogICAgICAgICAgICogKiB1c2luZyBET00gYFJhbmdlYCBvYmplY3QsCiAgICAgICAgICAgKiAqIGluY29ycmVjdCBDS0VkaXRvciA1IGluc3RhbGxhdGlvbiB3aXRoIG11bHRpcGxlIGBja2VkaXRvcjUtZW5naW5lYCBwYWNrYWdlcyBoYXZpbmcgZGlmZmVyZW50IHZlcnNpb25zLgogICAgICAgICAgICoKICAgICAgICAgICAqIEBlcnJvciBtb2RlbC1zZWxlY3Rpb24tc2V0LXJhbmdlcy1ub3QtcmFuZ2UKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXNlbGVjdGlvbi1zZXQtcmFuZ2VzLW5vdC1yYW5nZTogJyArICdTZWxlY3Rpb24gcmFuZ2Ugc2V0IHRvIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBtb2RlbC5SYW5nZS4nLCBbX3RoaXMsIG5ld1Jhbmdlc10pOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIF90aGlzLl9yYW5nZXMuZXZlcnkoZnVuY3Rpb24gKG9sZFJhbmdlKSB7CiAgICAgICAgICByZXR1cm4gIW9sZFJhbmdlLmlzRXF1YWwobmV3UmFuZ2UpOwogICAgICAgIH0pOwogICAgICB9KTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgbm90aGluZyBjaGFuZ2VkLgoKICAgICAgaWYgKG5ld1Jhbmdlcy5sZW5ndGggPT09IHRoaXMuX3Jhbmdlcy5sZW5ndGggJiYgIWFueU5ld1JhbmdlKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB0aGlzLl9yZW1vdmVBbGxSYW5nZXMoKTsKCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IG5ld1Jhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIHJhbmdlID0gX3N0ZXA2LnZhbHVlOwoKICAgICAgICAgIHRoaXMuX3B1c2hSYW5nZShyYW5nZSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5fbGFzdFJhbmdlQmFja3dhcmQgPSAhIWlzTGFzdEJhY2t3YXJkOwogICAgICB0aGlzLmZpcmUoJ2NoYW5nZTpyYW5nZScsIHsKICAgICAgICBkaXJlY3RDaGFuZ2U6IHRydWUKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIE1vdmVzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb24jZm9jdXN9IHRvIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uCiAgICAgKgogICAgICogVGhlIGxvY2F0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIHNhbWUgZm9ybSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVQb3NpdGlvbkF0IHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KCl9IHBhcmFtZXRlcnMuCiAgICAgKgogICAgICogQGZpcmVzIGNoYW5nZTpyYW5nZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpdGVtT3JQb3NpdGlvbgogICAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0Rm9jdXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvY3VzKGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpIHsKICAgICAgaWYgKHRoaXMuYW5jaG9yID09PSBudWxsKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IHNldCBzZWxlY3Rpb24gZm9jdXMgaWYgdGhlcmUgYXJlIG5vIHJhbmdlcyBpbiBzZWxlY3Rpb24uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgbW9kZWwtc2VsZWN0aW9uLXNldEZvY3VzLW5vLXJhbmdlcwogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1zZWxlY3Rpb24tc2V0Rm9jdXMtbm8tcmFuZ2VzOiBDYW5ub3Qgc2V0IHNlbGVjdGlvbiBmb2N1cyBpZiB0aGVyZSBhcmUgbm8gcmFuZ2VzIGluIHNlbGVjdGlvbi4nLCBbdGhpcywgaXRlbU9yUG9zaXRpb25dKTsKICAgICAgfQoKICAgICAgdmFyIG5ld0ZvY3VzID0gUG9zaXRpb24uX2NyZWF0ZUF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwoKICAgICAgaWYgKG5ld0ZvY3VzLmNvbXBhcmVXaXRoKHRoaXMuZm9jdXMpID09ICdzYW1lJykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGFuY2hvciA9IHRoaXMuYW5jaG9yOwoKICAgICAgaWYgKHRoaXMuX3Jhbmdlcy5sZW5ndGgpIHsKICAgICAgICB0aGlzLl9wb3BSYW5nZSgpOwogICAgICB9CgogICAgICBpZiAobmV3Rm9jdXMuY29tcGFyZVdpdGgoYW5jaG9yKSA9PSAnYmVmb3JlJykgewogICAgICAgIHRoaXMuX3B1c2hSYW5nZShuZXcgUmFuZ2UobmV3Rm9jdXMsIGFuY2hvcikpOwoKICAgICAgICB0aGlzLl9sYXN0UmFuZ2VCYWNrd2FyZCA9IHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fcHVzaFJhbmdlKG5ldyBSYW5nZShhbmNob3IsIG5ld0ZvY3VzKSk7CgogICAgICAgIHRoaXMuX2xhc3RSYW5nZUJhY2t3YXJkID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlOnJhbmdlJywgewogICAgICAgIGRpcmVjdENoYW5nZTogdHJ1ZQogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyBhbiBhdHRyaWJ1dGUgdmFsdWUgZm9yIGdpdmVuIGtleSBvciBgdW5kZWZpbmVkYCBpZiB0aGF0IGF0dHJpYnV0ZSBpcyBub3Qgc2V0IG9uIHRoZSBzZWxlY3Rpb24uCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIGxvb2sgZm9yLgogICAgICogQHJldHVybnMgeyp9IEF0dHJpYnV0ZSB2YWx1ZSBvciBgdW5kZWZpbmVkYC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShrZXkpIHsKICAgICAgcmV0dXJuIHRoaXMuX2F0dHJzLmdldChrZXkpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGl0ZXJhYmxlIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGlzIHNlbGVjdGlvbidzIGF0dHJpYnV0ZXMuCiAgICAgKgogICAgICogQXR0cmlidXRlcyBhcmUgcmV0dXJuZWQgYXMgYXJyYXlzIGNvbnRhaW5pbmcgdHdvIGl0ZW1zLiBGaXJzdCBvbmUgaXMgYXR0cmlidXRlIGtleSBhbmQgc2Vjb25kIGlzIGF0dHJpYnV0ZSB2YWx1ZS4KICAgICAqIFRoaXMgZm9ybWF0IGlzIGFjY2VwdGVkIGJ5IG5hdGl2ZSBgTWFwYCBvYmplY3QgYW5kIGFsc28gY2FuIGJlIHBhc3NlZCBpbiBgTm9kZWAgY29uc3RydWN0b3IuCiAgICAgKgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjwqPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKCkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMuZW50cmllcygpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGl0ZXJhYmxlIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGlzIHNlbGVjdGlvbidzIGF0dHJpYnV0ZSBrZXlzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGVLZXlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVLZXlzKCkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMua2V5cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgdGhlIHNlbGVjdGlvbiBoYXMgYW4gYXR0cmlidXRlIGZvciBnaXZlbiBrZXkuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgaXMgc2V0IG9uIHNlbGVjdGlvbiwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaGFzQXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNBdHRyaWJ1dGUoa2V5KSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5oYXMoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgZnJvbSB0aGUgc2VsZWN0aW9uLgogICAgICoKICAgICAqIElmIGdpdmVuIGF0dHJpYnV0ZSB3YXMgc2V0IG9uIHRoZSBzZWxlY3Rpb24sIGZpcmVzIHRoZSB7QGxpbmsgI2V2ZW50OmNoYW5nZTpyYW5nZX0gZXZlbnQgd2l0aAogICAgICogcmVtb3ZlZCBhdHRyaWJ1dGUga2V5LgogICAgICoKICAgICAqIEBmaXJlcyBjaGFuZ2U6YXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiBhdHRyaWJ1dGUgdG8gcmVtb3ZlLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZUF0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGtleSkgewogICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoa2V5KSkgewogICAgICAgIHRoaXMuX2F0dHJzLmRlbGV0ZShrZXkpOwoKICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZTphdHRyaWJ1dGUnLCB7CiAgICAgICAgICBhdHRyaWJ1dGVLZXlzOiBba2V5XSwKICAgICAgICAgIGRpcmVjdENoYW5nZTogdHJ1ZQogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldHMgYXR0cmlidXRlIG9uIHRoZSBzZWxlY3Rpb24uIElmIGF0dHJpYnV0ZSB3aXRoIHRoZSBzYW1lIGtleSBhbHJlYWR5IGlzIHNldCwgaXQncyB2YWx1ZSBpcyBvdmVyd3JpdHRlbi4KICAgICAqCiAgICAgKiBJZiB0aGUgYXR0cmlidXRlIHZhbHVlIGhhcyBjaGFuZ2VkLCBmaXJlcyB0aGUge0BsaW5rICNldmVudDpjaGFuZ2U6cmFuZ2V9IGV2ZW50IHdpdGgKICAgICAqIHRoZSBhdHRyaWJ1dGUga2V5LgogICAgICoKICAgICAqIEBmaXJlcyBjaGFuZ2U6YXR0cmlidXRlCiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiBhdHRyaWJ1dGUgdG8gc2V0LgogICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgewogICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoa2V5KSAhPT0gdmFsdWUpIHsKICAgICAgICB0aGlzLl9hdHRycy5zZXQoa2V5LCB2YWx1ZSk7CgogICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlOmF0dHJpYnV0ZScsIHsKICAgICAgICAgIGF0dHJpYnV0ZUtleXM6IFtrZXldLAogICAgICAgICAgZGlyZWN0Q2hhbmdlOiB0cnVlCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0aGUgc2VsZWN0ZWQgZWxlbWVudC4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IEVsZW1lbnR9IGlzIGNvbnNpZGVyZWQgYXMgc2VsZWN0ZWQgaWYgdGhlcmUgaXMgb25seQogICAgICogb25lIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24sIGFuZCB0aGF0IHJhbmdlIGNvbnRhaW5zIGV4YWN0bHkgb25lIGVsZW1lbnQuCiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGVyZSBpcyBubyBzZWxlY3RlZCBlbGVtZW50LgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFNlbGVjdGVkRWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRFbGVtZW50KCkgewogICAgICBpZiAodGhpcy5yYW5nZUNvdW50ICE9PSAxKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLmdldEZpcnN0UmFuZ2UoKS5nZXRDb250YWluZWRFbGVtZW50KCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgICAqCiAgICAgKgkJc2VsZWN0aW9uLmlzKCAnc2VsZWN0aW9uJyApOyAvLyAtPiB0cnVlCiAgICAgKgkJc2VsZWN0aW9uLmlzKCAnbW9kZWw6c2VsZWN0aW9uJyApOyAvLyAtPiB0cnVlCiAgICAgKgogICAgICoJCXNlbGVjdGlvbi5pcyggJ3ZpZXc6c2VsZWN0aW9uJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXNlbGVjdGlvbi5pcyggJ3JhbmdlJyApOyAvLyAtPiBmYWxzZQogICAgICoKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNpcyBDaGVjayB0aGUgZW50aXJlIGxpc3Qgb2YgbW9kZWwgb2JqZWN0c30gd2hpY2ggaW1wbGVtZW50IHRoZSBgaXMoKWAgbWV0aG9kLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXModHlwZSkgewogICAgICByZXR1cm4gdHlwZSA9PSAnc2VsZWN0aW9uJyB8fCB0eXBlID09ICdtb2RlbDpzZWxlY3Rpb24nOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIGVsZW1lbnRzIG9mIHR5cGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc0Jsb2NrICJibG9jayJ9IHRvdWNoZWQgYnkgdGhlIHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCdzIHJlc3VsdCBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBhcHBseSBibG9jayBzdHlsaW5nIHRvIGFsbCBibG9ja3MgY292ZXJlZCBieSB0aGlzIHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogYGdldFNlbGVjdGVkQmxvY2tzKClgIHJldHVybnMgYmxvY2tzIHRoYXQgYXJlIG5lc3RlZCBpbiBvdGhlciBub24tYmxvY2sgZWxlbWVudHMKICAgICAqIGJ1dCB3aWxsIG5vdCByZXR1cm4gYmxvY2tzIG5lc3RlZCBpbiBvdGhlciBibG9ja3MuCiAgICAgKgogICAgICogSW4gdGhpcyBjYXNlIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBleGFjdGx5IGFsbCAzIHBhcmFncmFwaHMgKG5vdGU6IGA8YmxvY2tRdW90ZT5gIGlzIG5vdCBhIGJsb2NrIGl0c2VsZik6CiAgICAgKgogICAgICoJCTxwYXJhZ3JhcGg+W2E8L3BhcmFncmFwaD4KICAgICAqCQk8YmxvY2tRdW90ZT4KICAgICAqCQkJPHBhcmFncmFwaD5iPC9wYXJhZ3JhcGg+CiAgICAgKgkJPC9ibG9ja1F1b3RlPgogICAgICoJCTxwYXJhZ3JhcGg+Y11kPC9wYXJhZ3JhcGg+CiAgICAgKgogICAgICogSW4gdGhpcyBjYXNlIHRoZSBwYXJhZ3JhcGggd2lsbCBhbHNvIGJlIHJldHVybmVkLCBkZXNwaXRlIHRoZSBjb2xsYXBzZWQgc2VsZWN0aW9uOgogICAgICoKICAgICAqCQk8cGFyYWdyYXBoPltdYTwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIEluIHN1Y2ggYSBzY2VuYXJpbywgaG93ZXZlciwgb25seSBibG9ja3MgQSwgQiAmIEUgd2lsbCBiZSByZXR1cm5lZCBhcyBibG9ja3MgQyAmIEQgYXJlIG5lc3RlZCBpbiBibG9jayBCOgogICAgICoKICAgICAqCQlbPGJsb2NrQT48L2Jsb2NrQT4KICAgICAqCQk8YmxvY2tCPgogICAgICoJCQk8YmxvY2tDPjwvYmxvY2tDPgogICAgICoJCQk8YmxvY2tEPjwvYmxvY2tEPgogICAgICoJCTwvYmxvY2tCPgogICAgICoJCTxibG9ja0U+PC9ibG9ja0U+XQogICAgICoKICAgICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgaW5zaWRlIGEgYmxvY2sgYWxsIHRoZSBpbm5lciBibG9ja3MgKEEgJiBCKSBhcmUgcmV0dXJuZWQ6CiAgICAgKgogICAgICogCQk8YmxvY2s+CiAgICAgKgkJCTxibG9ja0E+W2E8L2Jsb2NrQT4KICAgICAqIAkJCTxibG9ja0I+Yl08L2Jsb2NrQj4KICAgICAqIAkJPC9ibG9jaz4KICAgICAqCiAgICAgKiAqKlNwZWNpYWwgY2FzZSoqOiBJZiBhIHNlbGVjdGlvbiBlbmRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBibG9jaywgdGhhdCBibG9jayBpcyBub3QgcmV0dXJuZWQgYXMgZnJvbSB1c2VyIHBlcnNwZWN0aXZlCiAgICAgKiB0aGlzIGJsb2NrIHdhc24ndCBzZWxlY3RlZC4gU2VlIFsjOTg0XShodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvOTg0KSBmb3IgbW9yZSBkZXRhaWxzLgogICAgICoKICAgICAqCQk8cGFyYWdyYXBoPlthPC9wYXJhZ3JhcGg+CiAgICAgKgkJPHBhcmFncmFwaD5iPC9wYXJhZ3JhcGg+CiAgICAgKgkJPHBhcmFncmFwaD5dYzwvcGFyYWdyYXBoPiAvLyB0aGlzIGJsb2NrIHdpbGwgbm90IGJlIHJldHVybmVkCiAgICAgKgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0U2VsZWN0ZWRCbG9ja3MiLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRTZWxlY3RlZEJsb2NrcygpIHsKICAgICAgdmFyIHZpc2l0ZWQsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243LCBfZGlkSXRlcmF0b3JFcnJvcjcsIF9pdGVyYXRvckVycm9yNywgX2l0ZXJhdG9yNywgX3N0ZXA3LCByYW5nZSwgc3RhcnRCbG9jaywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjgsIF9kaWRJdGVyYXRvckVycm9yOCwgX2l0ZXJhdG9yRXJyb3I4LCBfaXRlcmF0b3I4LCBfc3RlcDgsIHZhbHVlLCBibG9jaywgZW5kQmxvY2s7CgogICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gZ2V0U2VsZWN0ZWRCbG9ja3MkKF9jb250ZXh0MikgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHZpc2l0ZWQgPSBuZXcgV2Vha1NldCgpOwogICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSBmYWxzZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA0OwogICAgICAgICAgICAgIF9pdGVyYXRvcjcgPSB0aGlzLmdldFJhbmdlcygpW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgICAgIGNhc2UgNjoKICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSAoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDc7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJhbmdlID0gX3N0ZXA3LnZhbHVlOwogICAgICAgICAgICAgIC8vIEdldCBzdGFydCBibG9jayBvZiByYW5nZSBpbiBjYXNlIG9mIGEgY29sbGFwc2VkIHJhbmdlLgogICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBnZXRQYXJlbnRCbG9jayhyYW5nZS5zdGFydCwgdmlzaXRlZCk7CgogICAgICAgICAgICAgIGlmICghKHN0YXJ0QmxvY2sgJiYgaXNUb3BCbG9ja0luUmFuZ2Uoc3RhcnRCbG9jaywgcmFuZ2UpKSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjsKICAgICAgICAgICAgICByZXR1cm4gc3RhcnRCbG9jazsKCiAgICAgICAgICAgIGNhc2UgMTI6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yOCA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE1OwogICAgICAgICAgICAgIF9pdGVyYXRvcjggPSByYW5nZS5nZXRXYWxrZXIoKVtTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDE3OgogICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IChfc3RlcDggPSBfaXRlcmF0b3I4Lm5leHQoKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDgudmFsdWU7CiAgICAgICAgICAgICAgYmxvY2sgPSB2YWx1ZS5pdGVtOwoKICAgICAgICAgICAgICBpZiAoISh2YWx1ZS50eXBlID09ICdlbGVtZW50RW5kJyAmJiBpc1VudmlzaXRlZFRvcEJsb2NrKGJsb2NrLCB2aXNpdGVkLCByYW5nZSkpKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIzOwogICAgICAgICAgICAgIHJldHVybiBibG9jazsKCiAgICAgICAgICAgIGNhc2UgMjM6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzI7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDI4OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjg7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDE1KTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yOCA9IF9jb250ZXh0Mi50MDsKCiAgICAgICAgICAgIGNhc2UgMzI6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzMjsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDMzOwoKICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSAzNToKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDM1OwoKICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yOCkgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzODsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4OwoKICAgICAgICAgICAgY2FzZSAzODoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgzNSk7CgogICAgICAgICAgICBjYXNlIDM5OgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDMyKTsKCiAgICAgICAgICAgIGNhc2UgNDA6CiAgICAgICAgICAgICAgZW5kQmxvY2sgPSBnZXRQYXJlbnRCbG9jayhyYW5nZS5lbmQsIHZpc2l0ZWQpOyAvLyAjOTg0LiBEb24ndCByZXR1cm4gdGhlIGVuZCBibG9jayBpZiB0aGUgcmFuZ2UgZW5kcyByaWdodCBhdCBpdHMgYmVnaW5uaW5nLgoKICAgICAgICAgICAgICBpZiAoIShlbmRCbG9jayAmJiAhcmFuZ2UuZW5kLmlzVG91Y2hpbmcoUG9zaXRpb24uX2NyZWF0ZUF0KGVuZEJsb2NrLCAwKSkgJiYgaXNUb3BCbG9ja0luUmFuZ2UoZW5kQmxvY2ssIHJhbmdlKSkpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDQ7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDQ7CiAgICAgICAgICAgICAgcmV0dXJuIGVuZEJsb2NrOwoKICAgICAgICAgICAgY2FzZSA0NDoKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWU7CiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2OwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSA0NzoKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDUzOwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSA0OToKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDQ5OwogICAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0MlsiY2F0Y2giXSg0KTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNyA9IF9jb250ZXh0Mi50MTsKCiAgICAgICAgICAgIGNhc2UgNTM6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA1MzsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDU0OwoKICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgIF9pdGVyYXRvcjcucmV0dXJuKCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSA1NjoKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDU2OwoKICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yNykgewogICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1OTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I3OwoKICAgICAgICAgICAgY2FzZSA1OToKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCg1Nik7CgogICAgICAgICAgICBjYXNlIDYwOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDUzKTsKCiAgICAgICAgICAgIGNhc2UgNjE6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LCBnZXRTZWxlY3RlZEJsb2NrcywgdGhpcywgW1s0LCA0OSwgNTMsIDYxXSwgWzE1LCAyOCwgMzIsIDQwXSwgWzMzLCwgMzUsIDM5XSwgWzU0LCwgNTYsIDYwXV0pOwogICAgfSkKICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjb250YWlucyB0aGUgZW50aXJlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnQuIFRoaXMgbWVhbnMgdGhhdCBzZWxlY3Rpb24gbXVzdCBzdGFydAogICAgICogYXQgYSBwb3NpdGlvbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc1RvdWNoaW5nIHRvdWNoaW5nfSB0aGUgZWxlbWVudCdzIHN0YXJ0IGFuZCBlbmRzIGF0IHBvc2l0aW9uCiAgICAgKiB0b3VjaGluZyB0aGUgZWxlbWVudCdzIGVuZC4KICAgICAqCiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGVudGlyZSBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24ncyBjdXJyZW50IHJvb3QgaXMgc2VsZWN0ZWQuCiAgICAgKiBVc2VmdWwgdG8gY2hlY2sgaWYgZS5nLiB0aGUgdXNlciBoYXMganVzdCBwcmVzc2VkIDxrYmQ+Q3RybDwva2JkPiArIDxrYmQ+QTwva2JkPi4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBbZWxlbWVudD10aGlzLmFuY2hvci5yb290XQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNFbnRpcmVDb250ZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc0VudGlyZUNvbnRlbnQoKSB7CiAgICAgIHZhciBlbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLmFuY2hvci5yb290OwoKICAgICAgdmFyIGxpbWl0U3RhcnRQb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCAwKTsKCiAgICAgIHZhciBsaW1pdEVuZFBvc2l0aW9uID0gUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsICdlbmQnKTsKCiAgICAgIHJldHVybiBsaW1pdFN0YXJ0UG9zaXRpb24uaXNUb3VjaGluZyh0aGlzLmdldEZpcnN0UG9zaXRpb24oKSkgJiYgbGltaXRFbmRQb3NpdGlvbi5pc1RvdWNoaW5nKHRoaXMuZ2V0TGFzdFBvc2l0aW9uKCkpOwogICAgfQogICAgLyoqCiAgICAgKiBBZGRzIGdpdmVuIHJhbmdlIHRvIGludGVybmFsIHtAbGluayAjX3JhbmdlcyByYW5nZXMgYXJyYXl9LiBUaHJvd3MgYW4gZXJyb3IKICAgICAqIGlmIGdpdmVuIHJhbmdlIGlzIGludGVyc2VjdGluZyB3aXRoIGFueSByYW5nZSB0aGF0IGlzIGFscmVhZHkgc3RvcmVkIGluIHRoaXMgc2VsZWN0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgdG8gYWRkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9wdXNoUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXNoUmFuZ2UocmFuZ2UpIHsKICAgICAgdGhpcy5fY2hlY2tSYW5nZShyYW5nZSk7CgogICAgICB0aGlzLl9yYW5nZXMucHVzaChuZXcgUmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gcmFuZ2UgaW50ZXJzZWN0cyB3aXRoIHJhbmdlcyB0aGF0IGFyZSBhbHJlYWR5IGluIHRoZSBzZWxlY3Rpb24uIFRocm93cyBhbiBlcnJvciBpZiBpdCBkb2VzLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgdG8gY2hlY2suCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NoZWNrUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1JhbmdlKHJhbmdlKSB7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmFuZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKHJhbmdlLmlzSW50ZXJzZWN0aW5nKHRoaXMuX3Jhbmdlc1tpXSkpIHsKICAgICAgICAgIC8qKgogICAgICAgICAgICogVHJ5aW5nIHRvIGFkZCBhIHJhbmdlIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtc2VsZWN0aW9uLXJhbmdlLWludGVyc2VjdHMKICAgICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gYWRkZWRSYW5nZSBSYW5nZSB0aGF0IHdhcyBhZGRlZCB0byB0aGUgc2VsZWN0aW9uLgogICAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpbnRlcnNlY3RpbmdSYW5nZSBSYW5nZSBpbiB0aGUgc2VsZWN0aW9uIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGBhZGRlZFJhbmdlYC4KICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXNlbGVjdGlvbi1yYW5nZS1pbnRlcnNlY3RzOiBUcnlpbmcgdG8gYWRkIGEgcmFuZ2UgdGhhdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLicsIFt0aGlzLCByYW5nZV0sIHsKICAgICAgICAgICAgYWRkZWRSYW5nZTogcmFuZ2UsCiAgICAgICAgICAgIGludGVyc2VjdGluZ1JhbmdlOiB0aGlzLl9yYW5nZXNbaV0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBEZWxldGVzIHJhbmdlcyBmcm9tIGludGVybmFsIHJhbmdlIGFycmF5LiBVc2VzIHtAbGluayAjX3BvcFJhbmdlIF9wb3BSYW5nZX0gdG8KICAgICAqIGVuc3VyZSBwcm9wZXIgcmFuZ2VzIHJlbW92YWwuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVBbGxSYW5nZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVBbGxSYW5nZXMoKSB7CiAgICAgIHdoaWxlICh0aGlzLl9yYW5nZXMubGVuZ3RoID4gMCkgewogICAgICAgIHRoaXMuX3BvcFJhbmdlKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBtb3N0IHJlY2VudGx5IGFkZGVkIHJhbmdlIGZyb20gdGhlIHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3BvcFJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9wUmFuZ2UoKSB7CiAgICAgIHRoaXMuX3Jhbmdlcy5wb3AoKTsKICAgIH0KICAgIC8qKgogICAgICogRmlyZWQgd2hlbiBzZWxlY3Rpb24gcmFuZ2UocykgY2hhbmdlZC4KICAgICAqCiAgICAgKiBAZXZlbnQgY2hhbmdlOnJhbmdlCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcmVjdENoYW5nZSBJbiBjYXNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb259IGNsYXNzIGl0IGlzIGFsd2F5cyBzZXQKICAgICAqIHRvIGB0cnVlYCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VsZWN0aW9uIGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgZGlyZWN0IHVzZSBvZiBzZWxlY3Rpb24ncyBBUEkuCiAgICAgKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259LCBob3dldmVyLCBtYXkgY2hhbmdlIGJlY2F1c2UgaXRzIHBvc2l0aW9uCiAgICAgKiB3YXMgZGlyZWN0bHkgY2hhbmdlZCB0aHJvdWdoIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIHdyaXRlcn0gb3IgYmVjYXVzZSBpdHMgcG9zaXRpb24gd2FzCiAgICAgKiBjaGFuZ2VkIGJlY2F1c2UgdGhlIHN0cnVjdHVyZSBvZiB0aGUgbW9kZWwgaGFzIGJlZW4gY2hhbmdlZCAod2hpY2ggbWVhbnMgYW4gaW5kaXJlY3QgY2hhbmdlKS4KICAgICAqIFRoZSBpbmRpcmVjdCBjaGFuZ2UgZG9lcyBub3Qgb2NjdXIgaW4gY2FzZSBvZiBub3JtYWwgKGRldGFjaGVkKSBzZWxlY3Rpb25zIGJlY2F1c2UgdGhleSBhcmUgInN0YXRpYyIgKGFzICJub3QgbGl2ZSIpCiAgICAgKiB3aGljaCBtZWFuIHRoYXQgdGhleSBhcmUgbm90IHVwZGF0ZWQgb25jZSB0aGUgZG9jdW1lbnQgY2hhbmdlcy4KICAgICAqLwoKICAgIC8qKgogICAgICogRmlyZWQgd2hlbiBzZWxlY3Rpb24gYXR0cmlidXRlIGNoYW5nZWQuCiAgICAgKgogICAgICogQGV2ZW50IGNoYW5nZTphdHRyaWJ1dGUKICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlyZWN0Q2hhbmdlIEluIGNhc2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbn0gY2xhc3MgaXQgaXMgYWx3YXlzIHNldAogICAgICogdG8gYHRydWVgIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBzZWxlY3Rpb24gY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBkaXJlY3QgdXNlIG9mIHNlbGVjdGlvbidzIEFQSS4KICAgICAqIFRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0sIGhvd2V2ZXIsIG1heSBjaGFuZ2UgYmVjYXVzZSBpdHMgYXR0cmlidXRlcwogICAgICogd2VyZSBkaXJlY3RseSBjaGFuZ2VkIHRocm91Z2ggdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIgd3JpdGVyfSBvciBiZWNhdXNlIGl0cyBwb3NpdGlvbiB3YXMKICAgICAqIGNoYW5nZWQgaW4gdGhlIG1vZGVsIGFuZCBpdHMgYXR0cmlidXRlcyB3ZXJlIHJlZnJlc2hlZCAod2hpY2ggbWVhbnMgYW4gaW5kaXJlY3QgY2hhbmdlKS4KICAgICAqIFRoZSBpbmRpcmVjdCBjaGFuZ2UgZG9lcyBub3Qgb2NjdXIgaW4gY2FzZSBvZiBub3JtYWwgKGRldGFjaGVkKSBzZWxlY3Rpb25zIGJlY2F1c2UgdGhleSBhcmUgInN0YXRpYyIgKGFzICJub3QgbGl2ZSIpCiAgICAgKiB3aGljaCBtZWFuIHRoYXQgdGhleSBhcmUgbm90IHVwZGF0ZWQgb25jZSB0aGUgZG9jdW1lbnQgY2hhbmdlcy4KICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGF0dHJpYnV0ZUtleXMgQXJyYXkgY29udGFpbmluZyBrZXlzIG9mIGF0dHJpYnV0ZXMgdGhhdCBjaGFuZ2VkLgogICAgICovCgogIH0sIHsKICAgIGtleTogImFuY2hvciIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgaWYgKHRoaXMuX3Jhbmdlcy5sZW5ndGggPiAwKSB7CiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzW3RoaXMuX3Jhbmdlcy5sZW5ndGggLSAxXTsKICAgICAgICByZXR1cm4gdGhpcy5fbGFzdFJhbmdlQmFja3dhcmQgPyByYW5nZS5lbmQgOiByYW5nZS5zdGFydDsKICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFNlbGVjdGlvbiBmb2N1cy4gRm9jdXMgaXMgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBzZWxlY3Rpb24gZW5kcy4gSWYgYSB1c2VyIGlzIG1ha2luZyBhIHNlbGVjdGlvbgogICAgICogYnkgZHJhZ2dpbmcgdGhlIG1vdXNlLCB0aGUgZm9jdXMgaXMgd2hlcmUgdGhlIG1vdXNlIGN1cnNvciBpcy4KICAgICAqCiAgICAgKiBNYXkgYmUgc2V0IHRvIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gcmFuZ2VzIGluIHRoZSBzZWxlY3Rpb24uCiAgICAgKgogICAgICogQHNlZSAjYW5jaG9yCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZm9jdXMiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIGlmICh0aGlzLl9yYW5nZXMubGVuZ3RoID4gMCkgewogICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1t0aGlzLl9yYW5nZXMubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RSYW5nZUJhY2t3YXJkID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLiBTZWxlY3Rpb24gaXMgY29sbGFwc2VkIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgcmFuZ2UgaW4gaXQKICAgICAqIGFuZCBpdCBpcyBjb2xsYXBzZWQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0NvbGxhcHNlZCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7CgogICAgICBpZiAobGVuZ3RoID09PSAxKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1swXS5pc0NvbGxhcHNlZDsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJyYW5nZUNvdW50IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fcmFuZ2VzLmxlbmd0aDsKICAgIH0KICAgIC8qKgogICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbidzIHtAbGluayAjZm9jdXN9IHByZWNlZGVzIHRoZSBzZWxlY3Rpb24ncyB7QGxpbmsgI2FuY2hvcn0uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0JhY2t3YXJkIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gIXRoaXMuaXNDb2xsYXBzZWQgJiYgdGhpcy5fbGFzdFJhbmdlQmFja3dhcmQ7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gU2VsZWN0aW9uOwp9KCk7CgpleHBvcnQgeyBTZWxlY3Rpb24gYXMgZGVmYXVsdCB9OwptaXgoU2VsZWN0aW9uLCBFbWl0dGVyTWl4aW4pOyAvLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBleHRlbmRzICRibG9jayBpbiB0aGUgc2NoZW1hIGFuZCBoYXMgYSBwYXJlbnQgKGlzIG5vdCBhIHJvb3QpLgovLyBNYXJrcyBpdCBhcyBhbHJlYWR5IHZpc2l0ZWQuCgpmdW5jdGlvbiBpc1VudmlzaXRlZEJsb2NrKGVsZW1lbnQsIHZpc2l0ZWQpIHsKICBpZiAodmlzaXRlZC5oYXMoZWxlbWVudCkpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CgogIHZpc2l0ZWQuYWRkKGVsZW1lbnQpOwogIHJldHVybiBlbGVtZW50LnJvb3QuZG9jdW1lbnQubW9kZWwuc2NoZW1hLmlzQmxvY2soZWxlbWVudCkgJiYgZWxlbWVudC5wYXJlbnQ7Cn0gLy8gQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGEgJGJsb2NrIHdhcyBub3QgcHJldmlvdXNseSB2aXNpdGVkIGFuZCBpcyBhIHRvcCBibG9jayBpbiBhIHJhbmdlLgoKCmZ1bmN0aW9uIGlzVW52aXNpdGVkVG9wQmxvY2soZWxlbWVudCwgdmlzaXRlZCwgcmFuZ2UpIHsKICByZXR1cm4gaXNVbnZpc2l0ZWRCbG9jayhlbGVtZW50LCB2aXNpdGVkKSAmJiBpc1RvcEJsb2NrSW5SYW5nZShlbGVtZW50LCByYW5nZSk7Cn0gLy8gRmluZHMgdGhlIGxvd2VzdCBlbGVtZW50IGluIHBvc2l0aW9uJ3MgYW5jZXN0b3JzIHdoaWNoIGlzIGEgYmxvY2suCi8vIEl0IHdpbGwgc2VhcmNoIHVudGlsIGZpcnN0IGFuY2VzdG9yIHRoYXQgaXMgYSBsaW1pdCBlbGVtZW50LgovLyBNYXJrcyBhbGwgYW5jZXN0b3JzIGFzIGFscmVhZHkgdmlzaXRlZCB0byBub3QgaW5jbHVkZSBhbnkgb2YgdGhlbSBsYXRlciBvbi4KCgpmdW5jdGlvbiBnZXRQYXJlbnRCbG9jayhwb3NpdGlvbiwgdmlzaXRlZCkgewogIHZhciBlbGVtZW50ID0gcG9zaXRpb24ucGFyZW50OwogIHZhciBzY2hlbWEgPSBlbGVtZW50LnJvb3QuZG9jdW1lbnQubW9kZWwuc2NoZW1hOwogIHZhciBhbmNlc3RvcnMgPSBwb3NpdGlvbi5wYXJlbnQuZ2V0QW5jZXN0b3JzKHsKICAgIHBhcmVudEZpcnN0OiB0cnVlLAogICAgaW5jbHVkZVNlbGY6IHRydWUKICB9KTsKICB2YXIgaGFzUGFyZW50TGltaXQgPSBmYWxzZTsKICB2YXIgYmxvY2sgPSBhbmNlc3RvcnMuZmluZChmdW5jdGlvbiAoZWxlbWVudCkgewogICAgLy8gU3RvcCBzZWFyY2hpbmcgYWZ0ZXIgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBpcyBsaW1pdCBlbGVtZW50LgogICAgaWYgKGhhc1BhcmVudExpbWl0KSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICBoYXNQYXJlbnRMaW1pdCA9IHNjaGVtYS5pc0xpbWl0KGVsZW1lbnQpOwogICAgcmV0dXJuICFoYXNQYXJlbnRMaW1pdCAmJiBpc1VudmlzaXRlZEJsb2NrKGVsZW1lbnQsIHZpc2l0ZWQpOwogIH0pOyAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBwb3NpdGlvbidzIHBhcmVudCwgYmVjYXVzZSBmaW5kKCkgbWlnaHQndmUgc3RvcHBlZCBlYXJseSBhbmQKICAvLyB0aGUgZm91bmQgYmxvY2sgbWF5IGJlIGEgY2hpbGQgb2YgYW5vdGhlciBibG9jay4KCiAgYW5jZXN0b3JzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsKICAgIHJldHVybiB2aXNpdGVkLmFkZChlbGVtZW50KTsKICB9KTsKICByZXR1cm4gYmxvY2s7Cn0gLy8gQ2hlY2tzIGlmIHRoZSBibG9ja3MgaXMgbm90IG5lc3RlZCBpbiBvdGhlciBibG9jayBpbnNpZGUgYSByYW5nZS4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsbWVuZW50fkVsZW1lbnR9IGJsb2NrIEJsb2NrIHRvIGNoZWNrLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIGNoZWNrLgoKCmZ1bmN0aW9uIGlzVG9wQmxvY2tJblJhbmdlKGJsb2NrLCByYW5nZSkgewogIHZhciBwYXJlbnRCbG9jayA9IGZpbmRBbmNlc3RvckJsb2NrKGJsb2NrKTsKCiAgaWYgKCFwYXJlbnRCbG9jaykgewogICAgcmV0dXJuIHRydWU7CiAgfSAvLyBBZGQgbG9vc2UgZmxhZyB0byBjaGVjayBhcyBwYXJlbnRSYW5nZSBjYW4gYmUgZXF1YWwgdG8gcmFuZ2UuCgoKICB2YXIgaXNQYXJlbnRJblJhbmdlID0gcmFuZ2UuY29udGFpbnNSYW5nZShSYW5nZS5fY3JlYXRlT24ocGFyZW50QmxvY2spLCB0cnVlKTsKICByZXR1cm4gIWlzUGFyZW50SW5SYW5nZTsKfSAvLyBSZXR1cm5zIGZpcnN0IGFuY2VzdG9yIGJsb2NrIG9mIGEgbm9kZS4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gbm9kZQovLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8dW5kZWZpbmVkfQoKCmZ1bmN0aW9uIGZpbmRBbmNlc3RvckJsb2NrKG5vZGUpIHsKICB2YXIgc2NoZW1hID0gbm9kZS5yb290LmRvY3VtZW50Lm1vZGVsLnNjaGVtYTsKICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7CgogIHdoaWxlIChwYXJlbnQpIHsKICAgIGlmIChzY2hlbWEuaXNCbG9jayhwYXJlbnQpKSB7CiAgICAgIHJldHVybiBwYXJlbnQ7CiAgICB9CgogICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICB9Cn0KLyoqCiAqIEFuIGVudGl0eSB0aGF0IGlzIHVzZWQgdG8gc2V0IHNlbGVjdGlvbi4KICoKICogU2VlIGFsc28ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbiNzZXRUb30KICoKICogQHR5cGVkZWYgewogKiAgICAgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufAogKiAgICAgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbnwKICogICAgIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb258CiAqICAgICBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfAogKiAgICAgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8CiAqICAgICBJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT58CiAqICAgICBudWxsCiAqIH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZQogKi8="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js"],"names":["Position","Node","Range","EmitterMixin","CKEditorError","mix","isIterable","Selection","selectable","placeOrOffset","options","_lastRangeBackward","_ranges","_attrs","Map","setTo","otherSelection","rangeCount","anchor","isEqual","focus","thisRange","found","otherRange","range","start","end","first","isBefore","last","isAfter","getFirstRange","clone","lastRange","getLastRange","_setRanges","getRanges","isBackward","backward","_createIn","_createOn","undefined","_createAt","newRanges","isLastBackward","Array","from","anyNewRange","some","newRange","every","oldRange","length","_removeAllRanges","_pushRange","fire","directChange","itemOrPosition","offset","newFocus","compareWith","_popRange","key","get","entries","keys","has","hasAttribute","delete","attributeKeys","value","getAttribute","set","getContainedElement","type","visited","WeakSet","startBlock","getParentBlock","isTopBlockInRange","getWalker","block","item","isUnvisitedTopBlock","endBlock","isTouching","element","root","limitStartPosition","limitEndPosition","getFirstPosition","getLastPosition","_checkRange","push","i","isIntersecting","addedRange","intersectingRange","pop","isCollapsed","isUnvisitedBlock","add","document","model","schema","isBlock","parent","position","ancestors","getAncestors","parentFirst","includeSelf","hasParentLimit","find","isLimit","forEach","parentBlock","findAncestorBlock","isParentInRange","containsRange","node"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/selection\n */\n\nimport Position from './position';\nimport Node from './node';\nimport Range from './range';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\n\n/**\n * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its\n * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}\n * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).\n * Additionally, selection may have its own attributes (think – whether text typed in in this selection\n * should have those attributes – e.g. whether you type a bolded text).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Selection {\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * Selection's constructor allow passing additional options (`'backward'`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tconstructor( selectable, placeOrOffset, options ) {\n\t\t/**\n\t\t * Specifies whether the last added range was added as a backward or forward range.\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._lastRangeBackward = false;\n\n\t\t/**\n\t\t * Stores selection ranges.\n\t\t *\n\t\t * @protected\n\t\t * @type {Array.<module:engine/model/range~Range>}\n\t\t */\n\t\tthis._ranges = [];\n\n\t\t/**\n\t\t * List of attributes set on current selection.\n\t\t *\n\t\t * @protected\n\t\t * @type {Map.<String,*>}\n\t\t */\n\t\tthis._attrs = new Map();\n\n\t\tif ( selectable ) {\n\t\t\tthis.setTo( selectable, placeOrOffset, options );\n\t\t}\n\t}\n\n\t/**\n\t * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection\n\t * by dragging the mouse, the anchor is where the user pressed the mouse button (the beggining of the selection).\n\t *\n\t * Anchor and {@link #focus} define the direction of the selection, which is important\n\t * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.\n\t *\n\t * Anchor is always set to the {@link module:engine/model/range~Range#start start} or\n\t * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is\n\t * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.\n\t *\n\t * May be set to `null` if there are no ranges in the selection.\n\t *\n\t * @see #focus\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget anchor() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.end : range.start;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Selection focus. Focus is the position where the selection ends. If a user is making a selection\n\t * by dragging the mouse, the focus is where the mouse cursor is.\n\t *\n\t * May be set to `null` if there are no ranges in the selection.\n\t *\n\t * @see #anchor\n\t * @readonly\n\t * @type {module:engine/model/position~Position|null}\n\t */\n\tget focus() {\n\t\tif ( this._ranges.length > 0 ) {\n\t\t\tconst range = this._ranges[ this._ranges.length - 1 ];\n\n\t\t\treturn this._lastRangeBackward ? range.start : range.end;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it\n\t * and it is collapsed.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\tconst length = this._ranges.length;\n\n\t\tif ( length === 1 ) {\n\t\t\treturn this._ranges[ 0 ].isCollapsed;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of ranges in the selection.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget rangeCount() {\n\t\treturn this._ranges.length;\n\t}\n\n\t/**\n\t * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isBackward() {\n\t\treturn !this.isCollapsed && this._lastRangeBackward;\n\t}\n\n\t/**\n\t * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,\n\t * the same number of ranges and all ranges from one selection equal to ranges from the another selection.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection\n\t * Selection to compare with.\n\t * @returns {Boolean} `true` if selections are equal, `false` otherwise.\n\t */\n\tisEqual( otherSelection ) {\n\t\tif ( this.rangeCount != otherSelection.rangeCount ) {\n\t\t\treturn false;\n\t\t} else if ( this.rangeCount === 0 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( !this.anchor.isEqual( otherSelection.anchor ) || !this.focus.isEqual( otherSelection.focus ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor ( const thisRange of this._ranges ) {\n\t\t\tlet found = false;\n\n\t\t\tfor ( const otherRange of otherSelection._ranges ) {\n\t\t\t\tif ( thisRange.isEqual( otherRange ) ) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !found ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns an iterable object that iterates over copies of selection ranges.\n\t *\n\t * @returns {Iterable.<module:engine/model/range~Range>}\n\t */\n\t* getRanges() {\n\t\tfor ( const range of this._ranges ) {\n\t\t\tyield new Range( range.start, range.end );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the first range in the selection.\n\t * First range is the one which {@link module:engine/model/range~Range#start start} position\n\t * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges\n\t * (not to confuse with the first range added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetFirstRange() {\n\t\tlet first = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !first || range.start.isBefore( first.start ) ) {\n\t\t\t\tfirst = range;\n\t\t\t}\n\t\t}\n\n\t\treturn first ? new Range( first.start, first.end ) : null;\n\t}\n\n\t/**\n\t * Returns a copy of the last range in the selection.\n\t * Last range is the one which {@link module:engine/model/range~Range#end end} position\n\t * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most\n\t * recently added to the selection).\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/range~Range|null}\n\t */\n\tgetLastRange() {\n\t\tlet last = null;\n\n\t\tfor ( const range of this._ranges ) {\n\t\t\tif ( !last || range.end.isAfter( last.end ) ) {\n\t\t\t\tlast = range;\n\t\t\t}\n\t\t}\n\n\t\treturn last ? new Range( last.start, last.end ) : null;\n\t}\n\n\t/**\n\t * Returns the first position in the selection.\n\t * First position is the position that {@link module:engine/model/position~Position#isBefore is before}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetFirstPosition() {\n\t\tconst first = this.getFirstRange();\n\n\t\treturn first ? first.start.clone() : null;\n\t}\n\n\t/**\n\t * Returns the last position in the selection.\n\t * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}\n\t * any other position in the selection.\n\t *\n\t * Returns `null` if there are no ranges in selection.\n\t *\n\t * @returns {module:engine/model/position~Position|null}\n\t */\n\tgetLastPosition() {\n\t\tconst lastRange = this.getLastRange();\n\n\t\treturn lastRange ? lastRange.end.clone() : null;\n\t}\n\n\t/**\n\t * Sets this selection's ranges and direction to the specified location based on the given\n\t * {@link module:engine/model/selection~Selectable selectable}.\n\t *\n\t *\t\t// Removes all selection's ranges.\n\t *\t\tselection.setTo( null );\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tselection.setTo( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tselection.setTo( ranges );\n\t *\n\t *\t\t// Sets selection to other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tselection.setTo( otherSelection );\n\t *\n\t *\t\t// Sets selection to the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = new DocumentSelection( doc );\n\t *\t\tselection.setTo( documentSelection );\n\t *\n\t *\t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tselection.setTo( position );\n\t *\n\t *\t\t// Sets collapsed selection at the position of the given node and an offset.\n\t *\t\tselection.setTo( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t *\t\tselection.setTo( paragraph, 'in' );\n\t *\n\t * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\tselection.setTo( paragraph, 'on' );\n\t *\n\t * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.\n\t *\n\t *\t\t// Sets backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t */\n\tsetTo( selectable, placeOrOffset, options ) {\n\t\tif ( selectable === null ) {\n\t\t\tthis._setRanges( [] );\n\t\t} else if ( selectable instanceof Selection ) {\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable && typeof selectable.getRanges == 'function' ) {\n\t\t\t// We assume that the selectable is a DocumentSelection.\n\t\t\t// It can't be imported here, because it would lead to circular imports.\n\t\t\tthis._setRanges( selectable.getRanges(), selectable.isBackward );\n\t\t} else if ( selectable instanceof Range ) {\n\t\t\tthis._setRanges( [ selectable ], !!placeOrOffset && !!placeOrOffset.backward );\n\t\t} else if ( selectable instanceof Position ) {\n\t\t\tthis._setRanges( [ new Range( selectable ) ] );\n\t\t} else if ( selectable instanceof Node ) {\n\t\t\tconst backward = !!options && !!options.backward;\n\t\t\tlet range;\n\n\t\t\tif ( placeOrOffset == 'in' ) {\n\t\t\t\trange = Range._createIn( selectable );\n\t\t\t} else if ( placeOrOffset == 'on' ) {\n\t\t\t\trange = Range._createOn( selectable );\n\t\t\t} else if ( placeOrOffset !== undefined ) {\n\t\t\t\trange = new Range( Position._createAt( selectable, placeOrOffset ) );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * selection.setTo requires the second parameter when the first parameter is a node.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-setTo-required-second-parameter\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-setTo-required-second-parameter: ' +\n\t\t\t\t\t'selection.setTo requires the second parameter when the first parameter is a node.',\n\t\t\t\t\t[ this, selectable ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis._setRanges( [ range ], backward );\n\t\t} else if ( isIterable( selectable ) ) {\n\t\t\t// We assume that the selectable is an iterable of ranges.\n\t\t\tthis._setRanges( selectable, placeOrOffset && !!placeOrOffset.backward );\n\t\t} else {\n\t\t\t/**\n\t\t\t * Cannot set the selection to the given place.\n\t\t\t *\n\t\t\t * Invalid parameters were specified when setting the selection. Common issues:\n\t\t\t *\n\t\t\t * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of\n\t\t\t * a real {@link module:engine/model/text~Text}.\n\t\t\t * * View nodes were passed instead of model nodes.\n\t\t\t * * `null`/`undefined` was passed.\n\t\t\t *\n\t\t\t * @error model-selection-setTo-not-selectable\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-selection-setTo-not-selectable: Cannot set the selection to the given place.',\n\t\t\t\t[ this, selectable ]\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array\n\t * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and\n\t * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.\n\t *\n\t * @protected\n\t * @fires change:range\n\t * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.\n\t * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)\n\t * or backward - from end to start (`true`).\n\t */\n\t_setRanges( newRanges, isLastBackward = false ) {\n\t\tnewRanges = Array.from( newRanges );\n\n\t\t// Check whether there is any range in new ranges set that is different than all already added ranges.\n\t\tconst anyNewRange = newRanges.some( newRange => {\n\t\t\tif ( !( newRange instanceof Range ) ) {\n\t\t\t\t/**\n\t\t\t\t * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.\n\t\t\t\t *\n\t\t\t\t * Only {@link module:engine/model/range~Range} instances can be used to set a selection.\n\t\t\t\t * Common mistakes leading to this error are:\n\t\t\t\t *\n\t\t\t\t * * using DOM `Range` object,\n\t\t\t\t * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-set-ranges-not-range\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-set-ranges-not-range: ' +\n\t\t\t\t\t'Selection range set to an object that is not an instance of model.Range.',\n\t\t\t\t\t[ this, newRanges ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this._ranges.every( oldRange => {\n\t\t\t\treturn !oldRange.isEqual( newRange );\n\t\t\t} );\n\t\t} );\n\n\t\t// Don't do anything if nothing changed.\n\t\tif ( newRanges.length === this._ranges.length && !anyNewRange ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._removeAllRanges();\n\n\t\tfor ( const range of newRanges ) {\n\t\t\tthis._pushRange( range );\n\t\t}\n\n\t\tthis._lastRangeBackward = !!isLastBackward;\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as\n\t * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.\n\t *\n\t * @fires change:range\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tsetFocus( itemOrPosition, offset ) {\n\t\tif ( this.anchor === null ) {\n\t\t\t/**\n\t\t\t * Cannot set selection focus if there are no ranges in selection.\n\t\t\t *\n\t\t\t * @error model-selection-setFocus-no-ranges\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.',\n\t\t\t\t[ this, itemOrPosition ]\n\t\t\t);\n\t\t}\n\n\t\tconst newFocus = Position._createAt( itemOrPosition, offset );\n\n\t\tif ( newFocus.compareWith( this.focus ) == 'same' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst anchor = this.anchor;\n\n\t\tif ( this._ranges.length ) {\n\t\t\tthis._popRange();\n\t\t}\n\n\t\tif ( newFocus.compareWith( anchor ) == 'before' ) {\n\t\t\tthis._pushRange( new Range( newFocus, anchor ) );\n\t\t\tthis._lastRangeBackward = true;\n\t\t} else {\n\t\t\tthis._pushRange( new Range( anchor, newFocus ) );\n\t\t\tthis._lastRangeBackward = false;\n\t\t}\n\n\t\tthis.fire( 'change:range', { directChange: true } );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterable that iterates over this selection's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Checks if the selection has an attribute for given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the selection.\n\t *\n\t * If given attribute was set on the selection, fires the {@link #event:change:range} event with\n\t * removed attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to remove.\n\t */\n\tremoveAttribute( key ) {\n\t\tif ( this.hasAttribute( key ) ) {\n\t\t\tthis._attrs.delete( key );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * If the attribute value has changed, fires the {@link #event:change:range} event with\n\t * the attribute key.\n\t *\n\t * @fires change:attribute\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\tsetAttribute( key, value ) {\n\t\tif ( this.getAttribute( key ) !== value ) {\n\t\t\tthis._attrs.set( key, value );\n\n\t\t\tthis.fire( 'change:attribute', { attributeKeys: [ key ], directChange: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only\n\t * one range in the selection, and that range contains exactly one element.\n\t * Returns `null` if there is no selected element.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetSelectedElement() {\n\t\tif ( this.rangeCount !== 1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.getFirstRange().getContainedElement();\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tselection.is( 'selection' ); // -> true\n\t *\t\tselection.is( 'model:selection' ); // -> true\n\t *\n\t *\t\tselection.is( 'view:selection' ); // -> false\n\t *\t\tselection.is( 'range' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'selection' || type == 'model:selection';\n\t}\n\n\t/**\n\t * Gets elements of type {@link module:engine/model/schema~Schema#isBlock \"block\"} touched by the selection.\n\t *\n\t * This method's result can be used for example to apply block styling to all blocks covered by this selection.\n\t *\n\t * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements\n\t * but will not return blocks nested in other blocks.\n\t *\n\t * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<blockQuote>\n\t *\t\t\t<paragraph>b</paragraph>\n\t *\t\t</blockQuote>\n\t *\t\t<paragraph>c]d</paragraph>\n\t *\n\t * In this case the paragraph will also be returned, despite the collapsed selection:\n\t *\n\t *\t\t<paragraph>[]a</paragraph>\n\t *\n\t * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:\n\t *\n\t *\t\t[<blockA></blockA>\n\t *\t\t<blockB>\n\t *\t\t\t<blockC></blockC>\n\t *\t\t\t<blockD></blockD>\n\t *\t\t</blockB>\n\t *\t\t<blockE></blockE>]\n\t *\n\t * If the selection is inside a block all the inner blocks (A & B) are returned:\n\t *\n\t * \t\t<block>\n\t *\t\t\t<blockA>[a</blockA>\n\t * \t\t\t<blockB>b]</blockB>\n\t * \t\t</block>\n\t *\n\t * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective\n\t * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.\n\t *\n\t *\t\t<paragraph>[a</paragraph>\n\t *\t\t<paragraph>b</paragraph>\n\t *\t\t<paragraph>]c</paragraph> // this block will not be returned\n\t *\n\t * @returns {Iterable.<module:engine/model/element~Element>}\n\t */\n\t* getSelectedBlocks() {\n\t\tconst visited = new WeakSet();\n\n\t\tfor ( const range of this.getRanges() ) {\n\t\t\t// Get start block of range in case of a collapsed range.\n\t\t\tconst startBlock = getParentBlock( range.start, visited );\n\n\t\t\tif ( startBlock && isTopBlockInRange( startBlock, range ) ) {\n\t\t\t\tyield startBlock;\n\t\t\t}\n\n\t\t\tfor ( const value of range.getWalker() ) {\n\t\t\t\tconst block = value.item;\n\n\t\t\t\tif ( value.type == 'elementEnd' && isUnvisitedTopBlock( block, visited, range ) ) {\n\t\t\t\t\tyield block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst endBlock = getParentBlock( range.end, visited );\n\n\t\t\t// #984. Don't return the end block if the range ends right at its beginning.\n\t\t\tif ( endBlock && !range.end.isTouching( Position._createAt( endBlock, 0 ) ) && isTopBlockInRange( endBlock, range ) ) {\n\t\t\t\tyield endBlock;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether the selection contains the entire content of the given element. This means that selection must start\n\t * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position\n\t * touching the element's end.\n\t *\n\t * By default, this method will check whether the entire content of the selection's current root is selected.\n\t * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.\n\t *\n\t * @param {module:engine/model/element~Element} [element=this.anchor.root]\n\t * @returns {Boolean}\n\t */\n\tcontainsEntireContent( element = this.anchor.root ) {\n\t\tconst limitStartPosition = Position._createAt( element, 0 );\n\t\tconst limitEndPosition = Position._createAt( element, 'end' );\n\n\t\treturn limitStartPosition.isTouching( this.getFirstPosition() ) &&\n\t\t\tlimitEndPosition.isTouching( this.getLastPosition() );\n\t}\n\n\t/**\n\t * Adds given range to internal {@link #_ranges ranges array}. Throws an error\n\t * if given range is intersecting with any range that is already stored in this selection.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to add.\n\t */\n\t_pushRange( range ) {\n\t\tthis._checkRange( range );\n\t\tthis._ranges.push( new Range( range.start, range.end ) );\n\t}\n\n\t/**\n\t * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.\n\t *\n\t * @protected\n\t * @param {module:engine/model/range~Range} range Range to check.\n\t */\n\t_checkRange( range ) {\n\t\tfor ( let i = 0; i < this._ranges.length; i++ ) {\n\t\t\tif ( range.isIntersecting( this._ranges[ i ] ) ) {\n\t\t\t\t/**\n\t\t\t\t * Trying to add a range that intersects with another range in the selection.\n\t\t\t\t *\n\t\t\t\t * @error model-selection-range-intersects\n\t\t\t\t * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.\n\t\t\t\t * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.',\n\t\t\t\t\t[ this, range ],\n\t\t\t\t\t{ addedRange: range, intersectingRange: this._ranges[ i ] }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to\n\t * ensure proper ranges removal.\n\t *\n\t * @protected\n\t */\n\t_removeAllRanges() {\n\t\twhile ( this._ranges.length > 0 ) {\n\t\t\tthis._popRange();\n\t\t}\n\t}\n\n\t/**\n\t * Removes most recently added range from the selection.\n\t *\n\t * @protected\n\t */\n\t_popRange() {\n\t\tthis._ranges.pop();\n\t}\n\n\t/**\n\t * Fired when selection range(s) changed.\n\t *\n\t * @event change:range\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position\n\t * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed because the structure of the model has been changed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t */\n\n\t/**\n\t * Fired when selection attribute changed.\n\t *\n\t * @event change:attribute\n\t * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set\n\t * to `true` which indicates that the selection change was caused by a direct use of selection's API.\n\t * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes\n\t * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was\n\t * changed in the model and its attributes were refreshed (which means an indirect change).\n\t * The indirect change does not occur in case of normal (detached) selections because they are \"static\" (as \"not live\")\n\t * which mean that they are not updated once the document changes.\n\t * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.\n\t */\n}\n\nmix( Selection, EmitterMixin );\n\n// Checks whether the given element extends $block in the schema and has a parent (is not a root).\n// Marks it as already visited.\nfunction isUnvisitedBlock( element, visited ) {\n\tif ( visited.has( element ) ) {\n\t\treturn false;\n\t}\n\n\tvisited.add( element );\n\n\treturn element.root.document.model.schema.isBlock( element ) && element.parent;\n}\n\n// Checks if the given element is a $block was not previously visited and is a top block in a range.\nfunction isUnvisitedTopBlock( element, visited, range ) {\n\treturn isUnvisitedBlock( element, visited ) && isTopBlockInRange( element, range );\n}\n\n// Finds the lowest element in position's ancestors which is a block.\n// It will search until first ancestor that is a limit element.\n// Marks all ancestors as already visited to not include any of them later on.\nfunction getParentBlock( position, visited ) {\n\tconst element = position.parent;\n\tconst schema = element.root.document.model.schema;\n\n\tconst ancestors = position.parent.getAncestors( { parentFirst: true, includeSelf: true } );\n\n\tlet hasParentLimit = false;\n\n\tconst block = ancestors.find( element => {\n\t\t// Stop searching after first parent node that is limit element.\n\t\tif ( hasParentLimit ) {\n\t\t\treturn false;\n\t\t}\n\n\t\thasParentLimit = schema.isLimit( element );\n\n\t\treturn !hasParentLimit && isUnvisitedBlock( element, visited );\n\t} );\n\n\t// Mark all ancestors of this position's parent, because find() might've stopped early and\n\t// the found block may be a child of another block.\n\tancestors.forEach( element => visited.add( element ) );\n\n\treturn block;\n}\n\n// Checks if the blocks is not nested in other block inside a range.\n//\n// @param {module:engine/model/elmenent~Element} block Block to check.\n// @param {module:engine/model/range~Range} range Range to check.\nfunction isTopBlockInRange( block, range ) {\n\tconst parentBlock = findAncestorBlock( block );\n\n\tif ( !parentBlock ) {\n\t\treturn true;\n\t}\n\n\t// Add loose flag to check as parentRange can be equal to range.\n\tconst isParentInRange = range.containsRange( Range._createOn( parentBlock ), true );\n\n\treturn !isParentInRange;\n}\n\n// Returns first ancestor block of a node.\n//\n// @param {module:engine/model/node~Node} node\n// @returns {module:engine/model/node~Node|undefined}\nfunction findAncestorBlock( node ) {\n\tconst schema = node.root.document.model.schema;\n\n\tlet parent = node.parent;\n\n\twhile ( parent ) {\n\t\tif ( schema.isBlock( parent ) ) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tparent = parent.parent;\n\t}\n}\n\n/**\n * An entity that is used to set selection.\n *\n * See also {@link module:engine/model/selection~Selection#setTo}\n *\n * @typedef {\n *     module:engine/model/selection~Selection|\n *     module:engine/model/documentselection~DocumentSelection|\n *     module:engine/model/position~Position|\n *     module:engine/model/range~Range|\n *     module:engine/model/node~Node|\n *     Iterable.<module:engine/model/range~Range>|\n *     null\n * } module:engine/model/selection~Selectable\n */\n"]}]}