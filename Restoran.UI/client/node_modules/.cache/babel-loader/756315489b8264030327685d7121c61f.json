{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\position.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\position.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvcG9zaXRpb24KICovCmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IHsgbGFzdCB9IGZyb20gJ2xvZGFzaC1lcyc7IC8vIFRvIGNoZWNrIGlmIGNvbXBvbmVudCBpcyBsb2FkZWQgbW9yZSB0aGFuIG9uY2UuCgppbXBvcnQgJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL3ZlcnNpb24nOwovKioKICogUmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBtb2RlbCB0cmVlLgogKgogKiBBIHBvc2l0aW9uIGlzIHJlcHJlc2VudGVkIGJ5IGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNyb290fSBhbmQKICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRofSBpbiB0aGF0IHJvb3QuCiAqCiAqIFlvdSBjYW4gY3JlYXRlIHBvc2l0aW9uIGluc3RhbmNlcyB2aWEgaXRzIGNvbnN0cnVjdG9yIG9yIHRoZSBgY3JlYXRlUG9zaXRpb24qKClgIGZhY3RvcnkgbWV0aG9kcyBvZgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9LgogKgogKiAqKk5vdGU6KiogUG9zaXRpb24gaXMgYmFzZWQgb24gb2Zmc2V0cywgbm90IGluZGV4ZXMuIFRoaXMgbWVhbnMgdGhhdCBhIHBvc2l0aW9uIGJldHdlZW4gdHdvIHRleHQgbm9kZXMKICogYGZvb2AgYW5kIGBiYXJgIGhhcyBvZmZzZXQgYDNgLCBub3QgYDFgLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAqCiAqIFNpbmNlIGEgcG9zaXRpb24gaW4gdGhlIG1vZGVsIGlzIHJlcHJlc2VudGVkIGJ5IGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcm9vdCBwb3NpdGlvbiByb290fSBhbmQKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwb3NpdGlvbiBwYXRofSBpdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgcG9zaXRpb25zIHBsYWNlZCBpbiBub24tZXhpc3RpbmcgcGxhY2VzLgogKiBUaGlzIHJlcXVpcmVtZW50IGlzIGltcG9ydGFudCBmb3Igb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24gYWxnb3JpdGhtcy4KICoKICogQWxzbywge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9uc30KICoga2VwdCBpbiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjaGlzdG9yeSBkb2N1bWVudCBoaXN0b3J5fQogKiBhcmUgc3RvcmluZyBwb3NpdGlvbnMgKGFuZCByYW5nZXMpIHdoaWNoIHdlcmUgY29ycmVjdCB3aGVuIHRob3NlIG9wZXJhdGlvbnMgd2VyZSBhcHBsaWVkLCBidXQgbWF5IG5vdCBiZSBjb3JyZWN0CiAqIGFmdGVyIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZC4KICoKICogV2hlbiBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIHRoZSBtb2RlbCwgaXQgbWF5IGFsc28gaGFwcGVuIHRoYXQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50IHBvc2l0aW9uIHBhcmVudH0KICogd2lsbCBjaGFuZ2UgZXZlbiBpZiBwb3NpdGlvbiBwYXRoIGhhcyBub3QgY2hhbmdlZC4gS2VlcCBpbiBtaW5kLCB0aGF0IGlmIGEgcG9zaXRpb24gbGVhZHMgdG8gbm9uLWV4aXN0aW5nIGVsZW1lbnQsCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhcmVudH0gYW5kIHNvbWUgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB3aWxsIHRocm93IGVycm9ycy4KICoKICogSW4gbW9zdCBjYXNlcywgcG9zaXRpb24gd2l0aCB3cm9uZyBwYXRoIGlzIGNhdXNlZCBieSBhbiBlcnJvciBpbiBjb2RlLCBidXQgaXQgaXMgc29tZXRpbWVzIG5lZWRlZCwgYXMgZGVzY3JpYmVkIGFib3ZlLgogKi8KCnZhciBQb3NpdGlvbiA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSBwb3NpdGlvbi4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHJvb3QgUm9vdCBvZiB0aGUgcG9zaXRpb24uCiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcGF0aCBQb3NpdGlvbiBwYXRoLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30uCiAgICovCiAgZnVuY3Rpb24gUG9zaXRpb24ocm9vdCwgcGF0aCkgewogICAgdmFyIHN0aWNraW5lc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0b05vbmUnOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3NpdGlvbik7CgogICAgaWYgKCFyb290LmlzKCdlbGVtZW50JykgJiYgIXJvb3QuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAvKioKICAgICAgICogUG9zaXRpb24gcm9vdCBpcyBpbnZhbGlkLgogICAgICAgKgogICAgICAgKiBQb3NpdGlvbnMgY2FuIG9ubHkgYmUgYW5jaG9yZWQgaW4gZWxlbWVudHMgb3IgZG9jdW1lbnQgZnJhZ21lbnRzLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tcm9vdC1pbnZhbGlkCiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tcm9vdC1pbnZhbGlkOiBQb3NpdGlvbiByb290IGludmFsaWQuJywgcm9vdCk7CiAgICB9CgogICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSB8fCBwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgICAvKioKICAgICAgICogUG9zaXRpb24gcGF0aCBtdXN0IGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGl0ZW0uCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1wYXRoLWluY29ycmVjdC1mb3JtYXQKICAgICAgICogQHBhcmFtIHBhdGgKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1wYXRoLWluY29ycmVjdC1mb3JtYXQ6IFBvc2l0aW9uIHBhdGggbXVzdCBiZSBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtLicsIHJvb3QsIHsKICAgICAgICBwYXRoOiBwYXRoCiAgICAgIH0pOwogICAgfSAvLyBOb3JtYWxpemUgdGhlIHJvb3QgYW5kIHBhdGggKGlmIGVsZW1lbnQgd2FzIHBhc3NlZCkuCgoKICAgIHBhdGggPSByb290LmdldFBhdGgoKS5jb25jYXQocGF0aCk7CiAgICByb290ID0gcm9vdC5yb290OwogICAgLyoqCiAgICAgKiBSb290IG9mIHRoZSBwb3NpdGlvbiBwYXRoLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKiBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3Jvb3QKICAgICAqLwoKICAgIHRoaXMucm9vdCA9IHJvb3Q7CiAgICAvKioKICAgICAqIFBvc2l0aW9uIG9mIHRoZSBub2RlIGluIHRoZSB0cmVlLiAqKlBhdGggY29udGFpbnMgb2Zmc2V0cywgbm90IGluZGV4ZXMuKioKICAgICAqCiAgICAgKiBQb3NpdGlvbiBjYW4gYmUgcGxhY2VkIGJlZm9yZSwgYWZ0ZXIgb3IgaW4gYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUgbm9kZX0gaWYgdGhhdCBub2RlIGhhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI29mZnNldFNpemV9IGdyZWF0ZXIgdGhhbiBgMWAuIEl0ZW1zIGluIHBvc2l0aW9uIHBhdGggYXJlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjc3RhcnRPZmZzZXQgc3RhcnRpbmcgb2Zmc2V0c30gb2YgcG9zaXRpb24gYW5jZXN0b3JzLCBzdGFydGluZyBmcm9tIGRpcmVjdCByb290IGNoaWxkcmVuLAogICAgICogZG93biB0byB0aGUgcG9zaXRpb24gb2Zmc2V0IGluIGl0J3MgcGFyZW50LgogICAgICoKICAgICAqCQkgUk9PVAogICAgICoJCSAgfC0gUCAgICAgICAgICAgIGJlZm9yZTogWyAwIF0gICAgICAgICBhZnRlcjogWyAxIF0KICAgICAqCQkgIHwtIFVMICAgICAgICAgICBiZWZvcmU6IFsgMSBdICAgICAgICAgYWZ0ZXI6IFsgMiBdCiAgICAgKgkJICAgICB8LSBMSSAgICAgICAgYmVmb3JlOiBbIDEsIDAgXSAgICAgIGFmdGVyOiBbIDEsIDEgXQogICAgICoJCSAgICAgfCAgfC0gZm9vICAgIGJlZm9yZTogWyAxLCAwLCAwIF0gICBhZnRlcjogWyAxLCAwLCAzIF0KICAgICAqCQkgICAgIHwtIExJICAgICAgICBiZWZvcmU6IFsgMSwgMSBdICAgICAgYWZ0ZXI6IFsgMSwgMiBdCiAgICAgKgkJICAgICAgICB8LSBiYXIgICAgYmVmb3JlOiBbIDEsIDEsIDAgXSAgIGFmdGVyOiBbIDEsIDEsIDMgXQogICAgICoKICAgICAqIGBmb29gIGFuZCBgYmFyYCBhcmUgcmVwcmVzZW50aW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCB0ZXh0IG5vZGVzfS4gU2luY2UgdGV4dCBub2RlcyBoYXMgb2Zmc2V0IHNpemUKICAgICAqIGdyZWF0ZXIgdGhhbiBgMWAgeW91IGNhbiBwbGFjZSBwb3NpdGlvbiBvZmZzZXQgYmV0d2VlbiB0aGVpciBzdGFydCBhbmQgZW5kOgogICAgICoKICAgICAqCQkgUk9PVAogICAgICoJCSAgfC0gUAogICAgICoJCSAgfC0gVUwKICAgICAqCQkgICAgIHwtIExJCiAgICAgKgkJICAgICB8ICB8LSBmXm98byAgXiBoYXMgcGF0aDogWyAxLCAwLCAxIF0gICB8IGhhcyBwYXRoOiBbIDEsIDAsIDIgXQogICAgICoJCSAgICAgfC0gTEkKICAgICAqCQkgICAgICAgIHwtIGJeYXxyICBeIGhhcyBwYXRoOiBbIDEsIDEsIDEgXSAgIHwgaGFzIHBhdGg6IFsgMSwgMSwgMiBdCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtBcnJheS48TnVtYmVyPn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoCiAgICAgKi8KCiAgICB0aGlzLnBhdGggPSBwYXRoOwogICAgLyoqCiAgICAgKiBQb3NpdGlvbiBzdGlja2luZXNzLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfS4KICAgICAqCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNzdGlja2luZXNzCiAgICAgKi8KCiAgICB0aGlzLnN0aWNraW5lc3MgPSBzdGlja2luZXNzOwogIH0KICAvKioKICAgKiBPZmZzZXQgYXQgd2hpY2ggdGhpcyBwb3NpdGlvbiBpcyBsb2NhdGVkIGluIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fS4gSXQgaXMgZXF1YWwKICAgKiB0byB0aGUgbGFzdCBpdGVtIGluIHBvc2l0aW9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGggcGF0aH0uCiAgICoKICAgKiBAdHlwZSB7TnVtYmVyfQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFBvc2l0aW9uLCBbewogICAga2V5OiAiY29tcGFyZVdpdGgiLAoKICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3IgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG90aGVyUG9zaXRpb24gUG9zaXRpb24gdG8gY29tcGFyZSB3aXRoLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25SZWxhdGlvbn0KICAgICAqLwogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pIHsKICAgICAgaWYgKHRoaXMucm9vdCAhPSBvdGhlclBvc2l0aW9uLnJvb3QpIHsKICAgICAgICByZXR1cm4gJ2RpZmZlcmVudCc7CiAgICAgIH0KCiAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXJyYXlzKHRoaXMucGF0aCwgb3RoZXJQb3NpdGlvbi5wYXRoKTsKCiAgICAgIHN3aXRjaCAocmVzdWx0KSB7CiAgICAgICAgY2FzZSAnc2FtZSc6CiAgICAgICAgICByZXR1cm4gJ3NhbWUnOwoKICAgICAgICBjYXNlICdwcmVmaXgnOgogICAgICAgICAgcmV0dXJuICdiZWZvcmUnOwoKICAgICAgICBjYXNlICdleHRlbnNpb24nOgogICAgICAgICAgcmV0dXJuICdhZnRlcic7CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoW3Jlc3VsdF0gPCBvdGhlclBvc2l0aW9uLnBhdGhbcmVzdWx0XSA/ICdiZWZvcmUnIDogJ2FmdGVyJzsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBmYXJ0aGVzdCBwb3NpdGlvbiB3aGljaCBtYXRjaGVzIHRoZSBjYWxsYmFjayB1c2luZwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyIFRyZWVXYWxrZXJ9LgogICAgICoKICAgICAqIEZvciBleGFtcGxlOgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IHZhbHVlLnR5cGUgPT0gJ3RleHQnICk7CiAgICAgKiAJCS8vIDxwYXJhZ3JhcGg+W11mb288L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5mb29bXTwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IHZhbHVlLnR5cGUgPT0gJ3RleHQnLCB7IGRpcmVjdGlvbjogJ2JhY2t3YXJkJyB9ICk7CiAgICAgKiAJCS8vIDxwYXJhZ3JhcGg+Zm9vW108L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5bXWZvbzwvcGFyYWdyYXBoPgogICAgICoKICAgICAqIAkJZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oIHZhbHVlID0+IGZhbHNlICk7CiAgICAgKiAJCS8vIERvIG5vdCBtb3ZlIHRoZSBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBza2lwIENhbGxiYWNrIGZ1bmN0aW9uLiBHZXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSBhbmQgc2hvdWxkCiAgICAgKiByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2tpcHBlZCBvciBgZmFsc2VgIGlmIG5vdC4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRoZSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIGBza2lwYCBjYWxsYmFjayB0ZXN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldExhc3RNYXRjaGluZ1Bvc2l0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihza2lwKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKICAgICAgb3B0aW9ucy5zdGFydFBvc2l0aW9uID0gdGhpczsKICAgICAgdmFyIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgdHJlZVdhbGtlci5za2lwKHNraXApOwogICAgICByZXR1cm4gdHJlZVdhbGtlci5wb3NpdGlvbjsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHBhdGggdG8gdGhpcyBwb3NpdGlvbidzIHBhcmVudC4gUGFyZW50IHBhdGggaXMgZXF1YWwgdG8gcG9zaXRpb24ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwYXRofQogICAgICogYnV0IHdpdGhvdXQgdGhlIGxhc3QgaXRlbS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gUGF0aCB0byB0aGUgcGFyZW50LgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBhcmVudFBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmVudFBhdGgoKSB7CiAgICAgIHJldHVybiB0aGlzLnBhdGguc2xpY2UoMCwgLTEpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuY2VzdG9ycyBhcnJheSBvZiB0aGlzIHBvc2l0aW9uLCB0aGF0IGlzIHRoaXMgcG9zaXRpb24ncyBwYXJlbnQgYW5kIGl0cyBhbmNlc3RvcnMuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59IEFycmF5IHdpdGggYW5jZXN0b3JzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEFuY2VzdG9ycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QW5jZXN0b3JzKCkgewogICAgICBpZiAodGhpcy5wYXJlbnQuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgIHJldHVybiBbdGhpcy5wYXJlbnRdOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRBbmNlc3RvcnMoewogICAgICAgICAgaW5jbHVkZVNlbGY6IHRydWUKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBzbGljZSBvZiB0d28gcG9zaXRpb24ge0BsaW5rICNwYXRoIHBhdGhzfSB3aGljaCBpcyBpZGVudGljYWwuIFRoZSB7QGxpbmsgI3Jvb3Qgcm9vdHN9CiAgICAgKiBvZiB0aGVzZSB0d28gcGF0aHMgbXVzdCBiZSBpZGVudGljYWwuCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFRoZSBzZWNvbmQgcG9zaXRpb24uCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IFRoZSBjb21tb24gcGF0aC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb21tb25QYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21tb25QYXRoKHBvc2l0aW9uKSB7CiAgICAgIGlmICh0aGlzLnJvb3QgIT0gcG9zaXRpb24ucm9vdCkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfSAvLyBXZSBmaW5kIG9uIHdoaWNoIHRyZWUtbGV2ZWwgc3RhcnQgYW5kIGVuZCBoYXZlIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yCgoKICAgICAgdmFyIGNtcCA9IGNvbXBhcmVBcnJheXModGhpcy5wYXRoLCBwb3NpdGlvbi5wYXRoKTsgLy8gSWYgY29tcGFyaXNvbiByZXR1cm5lZCBzdHJpbmcgaXQgbWVhbnMgdGhhdCBhcnJheXMgYXJlIHNhbWUuCgogICAgICB2YXIgZGlmZkF0ID0gdHlwZW9mIGNtcCA9PSAnc3RyaW5nJyA/IE1hdGgubWluKHRoaXMucGF0aC5sZW5ndGgsIHBvc2l0aW9uLnBhdGgubGVuZ3RoKSA6IGNtcDsKICAgICAgcmV0dXJuIHRoaXMucGF0aC5zbGljZSgwLCBkaWZmQXQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogd2hpY2ggaXMgYSBjb21tb24gYW5jZXN0b3Igb2YgYm90aCBwb3NpdGlvbnMuIFRoZSB7QGxpbmsgI3Jvb3Qgcm9vdHN9IG9mIHRoZXNlIHR3byBwb3NpdGlvbnMgbXVzdCBiZSBpZGVudGljYWwuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBUaGUgc2Vjb25kIHBvc2l0aW9uLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q29tbW9uQW5jZXN0b3IiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yKHBvc2l0aW9uKSB7CiAgICAgIHZhciBhbmNlc3RvcnNBID0gdGhpcy5nZXRBbmNlc3RvcnMoKTsKICAgICAgdmFyIGFuY2VzdG9yc0IgPSBwb3NpdGlvbi5nZXRBbmNlc3RvcnMoKTsKICAgICAgdmFyIGkgPSAwOwoKICAgICAgd2hpbGUgKGFuY2VzdG9yc0FbaV0gPT0gYW5jZXN0b3JzQltpXSAmJiBhbmNlc3RvcnNBW2ldKSB7CiAgICAgICAgaSsrOwogICAgICB9CgogICAgICByZXR1cm4gaSA9PT0gMCA/IG51bGwgOiBhbmNlc3RvcnNBW2kgLSAxXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBgUG9zaXRpb25gLCB0aGF0IGhhcyBzYW1lIHtAbGluayAjcGFyZW50IHBhcmVudH0gYnV0IGl0J3Mgb2Zmc2V0CiAgICAgKiBpcyBzaGlmdGVkIGJ5IGBzaGlmdGAgdmFsdWUgKGNhbiBiZSBhIG5lZ2F0aXZlIHZhbHVlKS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaGlmdCBPZmZzZXQgc2hpZnQuIENhbiBiZSBhIG5lZ2F0aXZlIHZhbHVlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFNoaWZ0ZWQgcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0U2hpZnRlZEJ5IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGlmdGVkQnkoc2hpZnQpIHsKICAgICAgdmFyIHNoaWZ0ZWQgPSB0aGlzLmNsb25lKCk7CiAgICAgIHZhciBvZmZzZXQgPSBzaGlmdGVkLm9mZnNldCArIHNoaWZ0OwogICAgICBzaGlmdGVkLm9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0OwogICAgICByZXR1cm4gc2hpZnRlZDsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBhZnRlciBnaXZlbiBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc0JlZm9yZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoaXMgcG9zaXRpb24gaXMgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNBZnRlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBZnRlcihvdGhlclBvc2l0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pID09ICdhZnRlcic7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcG9zaXRpb24gaXMgYmVmb3JlIGdpdmVuIHBvc2l0aW9uLgogICAgICoKICAgICAqICoqTm90ZToqKiB3YXRjaCBvdXQgd2hlbiB1c2luZyBuZWdhdGlvbiBvZiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QsIGJlY2F1c2UgdGhlIG5lZ2F0aW9uIHdpbGwgYWxzbwogICAgICogYmUgYHRydWVgIGlmIHBvc2l0aW9ucyBhcmUgaW4gZGlmZmVyZW50IHJvb3RzIGFuZCB5b3UgbWlnaHQgbm90IGV4cGVjdCB0aGlzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZQogICAgICogYGEuaXNBZnRlciggYiApIHx8IGEuaXNFcXVhbCggYiApYCBvciBgIWEuaXNCZWZvcmUoIHAgKSAmJiBhLnJvb3QgPT0gYi5yb290YCBpbiBtb3N0IHNjZW5hcmlvcy4gSWYgeW91cgogICAgICogY29uZGl0aW9uIHVzZXMgbXVsdGlwbGUgYGlzQWZ0ZXJgIGFuZCBgaXNCZWZvcmVgIGNoZWNrcywgYnVpbGQgdGhlbSBzbyB0aGV5IGRvIG5vdCB1c2UgbmVnYXRlZCB2YWx1ZXMsIGkuZS46CiAgICAgKgogICAgICoJCWlmICggYS5pc0JlZm9yZSggYiApICYmIGMuaXNBZnRlciggZCApICkgewogICAgICoJCQkvLyBkbyBBLgogICAgICoJCX0gZWxzZSB7CiAgICAgKgkJCS8vIGRvIEIuCiAgICAgKgkJfQogICAgICoKICAgICAqIG9yLCBpZiB5b3UgaGF2ZSBvbmx5IG9uZSBpZi1icmFuY2g6CiAgICAgKgogICAgICoJCWlmICggISggYS5pc0JlZm9yZSggYiApICYmIGMuaXNBZnRlciggZCApICkgewogICAgICoJCQkvLyBkbyBCLgogICAgICoJCX0KICAgICAqCiAgICAgKiByYXRoZXIgdGhhbjoKICAgICAqCiAgICAgKgkJaWYgKCAhYS5pc0JlZm9yZSggYiApIHx8ICYmICFjLmlzQWZ0ZXIoIGQgKSApIHsKICAgICAqCQkJLy8gZG8gQi4KICAgICAqCQl9IGVsc2UgewogICAgICoJCQkvLyBkbyBBLgogICAgICoJCX0KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gb3RoZXJQb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBnaXZlbiBwb3NpdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0JlZm9yZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCZWZvcmUob3RoZXJQb3NpdGlvbikgewogICAgICByZXR1cm4gdGhpcy5jb21wYXJlV2l0aChvdGhlclBvc2l0aW9uKSA9PSAnYmVmb3JlJzsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBlcXVhbCB0byBnaXZlbiBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gb3RoZXJQb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb3NpdGlvbnMgYXJlIHNhbWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNFcXVhbCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChvdGhlclBvc2l0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pID09ICdzYW1lJzsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyB0b3VjaGluZyBnaXZlbiBwb3NpdGlvbi4gUG9zaXRpb25zIHRvdWNoIHdoZW4gdGhlcmUgYXJlIG5vIHRleHQgbm9kZXMKICAgICAqIG9yIGVtcHR5IG5vZGVzIGluIGEgcmFuZ2UgYmV0d2VlbiB0aGVtLiBUZWNobmljYWxseSwgdGhvc2UgcG9zaXRpb25zIGFyZSBub3QgZXF1YWwgYnV0IGluIG1hbnkgY2FzZXMKICAgICAqIHRoZXkgYXJlIHZlcnkgc2ltaWxhciBvciBldmVuIGluZGlzdGluZ3Vpc2hhYmxlLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gb3RoZXJQb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb3NpdGlvbnMgdG91Y2guCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNUb3VjaGluZyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNUb3VjaGluZyhvdGhlclBvc2l0aW9uKSB7CiAgICAgIHZhciBsZWZ0ID0gbnVsbDsKICAgICAgdmFyIHJpZ2h0ID0gbnVsbDsKICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pOwoKICAgICAgc3dpdGNoIChjb21wYXJlKSB7CiAgICAgICAgY2FzZSAnc2FtZSc6CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgICAgY2FzZSAnYmVmb3JlJzoKICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7CiAgICAgICAgICByaWdodCA9IFBvc2l0aW9uLl9jcmVhdGVBdChvdGhlclBvc2l0aW9uKTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdhZnRlcic6CiAgICAgICAgICBsZWZ0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KG90aGVyUG9zaXRpb24pOwogICAgICAgICAgcmlnaHQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDYWNoZWQgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4KCgogICAgICB2YXIgbGVmdFBhcmVudCA9IGxlZnQucGFyZW50OwoKICAgICAgd2hpbGUgKGxlZnQucGF0aC5sZW5ndGggKyByaWdodC5wYXRoLmxlbmd0aCkgewogICAgICAgIGlmIChsZWZ0LmlzRXF1YWwocmlnaHQpKSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGlmIChsZWZ0LnBhdGgubGVuZ3RoID4gcmlnaHQucGF0aC5sZW5ndGgpIHsKICAgICAgICAgIGlmIChsZWZ0Lm9mZnNldCAhPT0gbGVmdFBhcmVudC5tYXhPZmZzZXQpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQoKICAgICAgICAgIGxlZnQucGF0aCA9IGxlZnQucGF0aC5zbGljZSgwLCAtMSk7CiAgICAgICAgICBsZWZ0UGFyZW50ID0gbGVmdFBhcmVudC5wYXJlbnQ7CiAgICAgICAgICBsZWZ0Lm9mZnNldCsrOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAocmlnaHQub2Zmc2V0ICE9PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICByaWdodC5wYXRoID0gcmlnaHQucGF0aC5zbGljZSgwLCAtMSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgICAqCiAgICAgKgkJcG9zaXRpb24uaXMoICdwb3NpdGlvbicgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXBvc2l0aW9uLmlzKCAnbW9kZWw6cG9zaXRpb24nICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJcG9zaXRpb24uaXMoICd2aWV3OnBvc2l0aW9uJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXBvc2l0aW9uLmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiBtb2RlbCBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUKICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpcyh0eXBlKSB7CiAgICAgIHJldHVybiB0eXBlID09ICdwb3NpdGlvbicgfHwgdHlwZSA9PSAnbW9kZWw6cG9zaXRpb24nOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3MgaWYgdHdvIHBvc2l0aW9ucyBhcmUgaW4gdGhlIHNhbWUgcGFyZW50LgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHBvc2l0aW9ucyBoYXZlIHRoZSBzYW1lIHBhcmVudCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaGFzU2FtZVBhcmVudEFzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNTYW1lUGFyZW50QXMocG9zaXRpb24pIHsKICAgICAgaWYgKHRoaXMucm9vdCAhPT0gcG9zaXRpb24ucm9vdCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgdmFyIHRoaXNQYXJlbnRQYXRoID0gdGhpcy5nZXRQYXJlbnRQYXRoKCk7CiAgICAgIHZhciBwb3NQYXJlbnRQYXRoID0gcG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpOwogICAgICByZXR1cm4gY29tcGFyZUFycmF5cyh0aGlzUGFyZW50UGF0aCwgcG9zUGFyZW50UGF0aCkgPT0gJ3NhbWUnOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRoYXQgaXMgdHJhbnNmb3JtZWQgYnkgZ2l2ZW4gYG9wZXJhdGlvbmAuCiAgICAgKgogICAgICogVGhlIG5ldyBwb3NpdGlvbidzIHBhcmFtZXRlcnMgYXJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkgdG8gdGhlIGVmZmVjdCBvZiB0aGUgYG9wZXJhdGlvbmAuCiAgICAgKgogICAgICogRm9yIGV4YW1wbGUsIGlmIGBuYCBub2RlcyBhcmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBwb3NpdGlvbiwgdGhlIHJldHVybmVkIHBvc2l0aW9uIHtAbGluayB+UG9zaXRpb24jb2Zmc2V0fSB3aWxsIGJlCiAgICAgKiBpbmNyZWFzZWQgYnkgYG5gLiBJZiB0aGUgcG9zaXRpb24gd2FzIGluIGEgbWVyZ2VkIGVsZW1lbnQsIGl0IHdpbGwgYmUgYWNjb3JkaW5nbHkgbW92ZWQgdG8gdGhlIG5ldyBlbGVtZW50LCBldGMuCiAgICAgKgogICAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wZXJhdGlvbiBPcGVyYXRpb24gdG8gdHJhbnNmb3JtIGJ5LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRyYW5zZm9ybWVkIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFRyYW5zZm9ybWVkQnlPcGVyYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybWVkQnlPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIHZhciByZXN1bHQ7CgogICAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7CiAgICAgICAgY2FzZSAnaW5zZXJ0JzoKICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICdtb3ZlJzoKICAgICAgICBjYXNlICdyZW1vdmUnOgogICAgICAgIGNhc2UgJ3JlaW5zZXJ0JzoKICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnc3BsaXQnOgogICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgY2FzZSAnbWVyZ2UnOgogICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgICAgICBicmVhazsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJlc3VsdCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgICAgICAgIGJyZWFrOwogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRyYW5zZm9ybWVkIGJ5IGFuIGluc2VydCBvcGVyYXRpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9pbnNlcnRvcGVyYXRpb25+SW5zZXJ0T3BlcmF0aW9ufSBvcGVyYXRpb24KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24ob3BlcmF0aW9uLnBvc2l0aW9uLCBvcGVyYXRpb24uaG93TWFueSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgYSBtb3ZlIG9wZXJhdGlvbi4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbiwgb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uLCBvcGVyYXRpb24uaG93TWFueSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgYSBzcGxpdCBvcGVyYXRpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9zcGxpdG9wZXJhdGlvbn5TcGxpdE9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgbW92ZWRSYW5nZSA9IG9wZXJhdGlvbi5tb3ZlZFJhbmdlOwogICAgICB2YXIgaXNDb250YWluZWQgPSBtb3ZlZFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcykgfHwgbW92ZWRSYW5nZS5zdGFydC5pc0VxdWFsKHRoaXMpICYmIHRoaXMuc3RpY2tpbmVzcyA9PSAndG9OZXh0JzsKCiAgICAgIGlmIChpc0NvbnRhaW5lZCkgewogICAgICAgIHJldHVybiB0aGlzLl9nZXRDb21iaW5lZChvcGVyYXRpb24uc3BsaXRQb3NpdGlvbiwgb3BlcmF0aW9uLm1vdmVUYXJnZXRQb3NpdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbiwgb3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLCAxKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24ob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLCAxKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0cmFuc2Zvcm1lZCBieSBtZXJnZSBvcGVyYXRpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tZXJnZW9wZXJhdGlvbn5NZXJnZU9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgbW92ZWRSYW5nZSA9IG9wZXJhdGlvbi5tb3ZlZFJhbmdlOwogICAgICB2YXIgaXNDb250YWluZWQgPSBtb3ZlZFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcykgfHwgbW92ZWRSYW5nZS5zdGFydC5pc0VxdWFsKHRoaXMpOwogICAgICB2YXIgcG9zOwoKICAgICAgaWYgKGlzQ29udGFpbmVkKSB7CiAgICAgICAgcG9zID0gdGhpcy5fZ2V0Q29tYmluZWQob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLCBvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24pOwoKICAgICAgICBpZiAob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLmlzQmVmb3JlKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgIC8vIEFib3ZlIGhhcHBlbnMgZHVyaW5nIE9UIHdoZW4gdGhlIG1lcmdlZCBlbGVtZW50IGlzIG1vdmVkIGJlZm9yZSB0aGUgbWVyZ2VkLXRvIGVsZW1lbnQuCiAgICAgICAgICBwb3MgPSBwb3MuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbiwgMSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFcXVhbChvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgICAgICBwb3MgPSBQb3NpdGlvbi5fY3JlYXRlQXQob3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24pOwogICAgICB9IGVsc2UgewogICAgICAgIHBvcyA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uLCBvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24sIDEpOwogICAgICB9CgogICAgICByZXR1cm4gcG9zOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRoYXQgaXMgdXBkYXRlZCBieSByZW1vdmluZyBgaG93TWFueWAgbm9kZXMgc3RhcnRpbmcgZnJvbSBgZGVsZXRlUG9zaXRpb25gLgogICAgICogSXQgbWF5IGhhcHBlbiB0aGF0IHRoaXMgcG9zaXRpb24gaXMgaW4gYSByZW1vdmVkIG5vZGUuIElmIHRoYXQgaXMgdGhlIGNhc2UsIGBudWxsYCBpcyByZXR1cm5lZCBpbnN0ZWFkLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gZGVsZXRlUG9zaXRpb24gUG9zaXRpb24gYmVmb3JlIHRoZSBmaXJzdCByZW1vdmVkIG5vZGUuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG93TWFueSBIb3cgbWFueSBub2RlcyBhcmUgcmVtb3ZlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG51bGx9IFRyYW5zZm9ybWVkIHBvc2l0aW9uIG9yIGBudWxsYC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGRlbGV0ZVBvc2l0aW9uLCBob3dNYW55KSB7CiAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsgLy8gVGhpcyBwb3NpdGlvbiBjYW4ndCBiZSBhZmZlY3RlZCBpZiBkZWxldGlvbiB3YXMgaW4gYSBkaWZmZXJlbnQgcm9vdC4KCgogICAgICBpZiAodGhpcy5yb290ICE9IGRlbGV0ZVBvc2l0aW9uLnJvb3QpIHsKICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgICAgIH0KCiAgICAgIGlmIChjb21wYXJlQXJyYXlzKGRlbGV0ZVBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgdGhpcy5nZXRQYXJlbnRQYXRoKCkpID09ICdzYW1lJykgewogICAgICAgIC8vIElmIG5vZGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIG5vZGUgdGhhdCBpcyBwb2ludGVkIGJ5IHRoaXMgcG9zaXRpb24uLi4KICAgICAgICBpZiAoZGVsZXRlUG9zaXRpb24ub2Zmc2V0IDwgdGhpcy5vZmZzZXQpIHsKICAgICAgICAgIC8vIEFuZCBhcmUgcmVtb3ZlZCBmcm9tIGJlZm9yZSBhbiBvZmZzZXQgb2YgdGhhdCBwb3NpdGlvbi4uLgogICAgICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCArIGhvd01hbnkgPiB0aGlzLm9mZnNldCkgewogICAgICAgICAgICAvLyBQb3NpdGlvbiBpcyBpbiByZW1vdmVkIHJhbmdlLCBpdCdzIG5vIGxvbmdlciBpbiB0aGUgdHJlZS4KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIG9mZnNldCBhY2NvcmRpbmdseS4KICAgICAgICAgICAgdHJhbnNmb3JtZWQub2Zmc2V0IC09IGhvd01hbnk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGNvbXBhcmVBcnJheXMoZGVsZXRlUG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpLCB0aGlzLmdldFBhcmVudFBhdGgoKSkgPT0gJ3ByZWZpeCcpIHsKICAgICAgICAvLyBJZiBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIGEgbm9kZSB0aGF0IGlzIG9uIGEgcGF0aCB0byB0aGlzIHBvc2l0aW9uLi4uCiAgICAgICAgdmFyIGkgPSBkZWxldGVQb3NpdGlvbi5wYXRoLmxlbmd0aCAtIDE7CgogICAgICAgIGlmIChkZWxldGVQb3NpdGlvbi5vZmZzZXQgPD0gdGhpcy5wYXRoW2ldKSB7CiAgICAgICAgICAvLyBBbmQgYXJlIHJlbW92ZWQgZnJvbSBiZWZvcmUgbmV4dCBub2RlIG9mIHRoYXQgcGF0aC4uLgogICAgICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCArIGhvd01hbnkgPiB0aGlzLnBhdGhbaV0pIHsKICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgbm9kZSBvZiB0aGF0IHBhdGggaXMgcmVtb3ZlZCByZXR1cm4gbnVsbAogICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhpcyBwb3NpdGlvbiBnb3QgcmVtb3ZlZC4KICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRlY3JlbWVudCBpbmRleCBvbiB0aGF0IHBhdGguCiAgICAgICAgICAgIHRyYW5zZm9ybWVkLnBhdGhbaV0gLT0gaG93TWFueTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0aGF0IGlzIHVwZGF0ZWQgYnkgaW5zZXJ0aW5nIGBob3dNYW55YCBub2RlcyBhdCBgaW5zZXJ0UG9zaXRpb25gLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaW5zZXJ0UG9zaXRpb24gUG9zaXRpb24gd2hlcmUgbm9kZXMgYXJlIGluc2VydGVkLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIGluc2VydGVkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRyYW5zZm9ybWVkIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihpbnNlcnRQb3NpdGlvbiwgaG93TWFueSkgewogICAgICB2YXIgdHJhbnNmb3JtZWQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7IC8vIFRoaXMgcG9zaXRpb24gY2FuJ3QgYmUgYWZmZWN0ZWQgaWYgaW5zZXJ0aW9uIHdhcyBpbiBhIGRpZmZlcmVudCByb290LgoKCiAgICAgIGlmICh0aGlzLnJvb3QgIT0gaW5zZXJ0UG9zaXRpb24ucm9vdCkgewogICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDsKICAgICAgfQoKICAgICAgaWYgKGNvbXBhcmVBcnJheXMoaW5zZXJ0UG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpLCB0aGlzLmdldFBhcmVudFBhdGgoKSkgPT0gJ3NhbWUnKSB7CiAgICAgICAgLy8gSWYgbm9kZXMgYXJlIGluc2VydGVkIGluIHRoZSBub2RlIHRoYXQgaXMgcG9pbnRlZCBieSB0aGlzIHBvc2l0aW9uLi4uCiAgICAgICAgaWYgKGluc2VydFBvc2l0aW9uLm9mZnNldCA8IHRoaXMub2Zmc2V0IHx8IGluc2VydFBvc2l0aW9uLm9mZnNldCA9PSB0aGlzLm9mZnNldCAmJiB0aGlzLnN0aWNraW5lc3MgIT0gJ3RvUHJldmlvdXMnKSB7CiAgICAgICAgICAvLyBBbmQgYXJlIGluc2VydGVkIGJlZm9yZSBhbiBvZmZzZXQgb2YgdGhhdCBwb3NpdGlvbi4uLgogICAgICAgICAgLy8gIlB1c2giIHRoaXMgcG9zaXRpb25zIG9mZnNldC4KICAgICAgICAgIHRyYW5zZm9ybWVkLm9mZnNldCArPSBob3dNYW55OwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChjb21wYXJlQXJyYXlzKGluc2VydFBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgdGhpcy5nZXRQYXJlbnRQYXRoKCkpID09ICdwcmVmaXgnKSB7CiAgICAgICAgLy8gSWYgbm9kZXMgYXJlIGluc2VydGVkIGluIGEgbm9kZSB0aGF0IGlzIG9uIGEgcGF0aCB0byB0aGlzIHBvc2l0aW9uLi4uCiAgICAgICAgdmFyIGkgPSBpbnNlcnRQb3NpdGlvbi5wYXRoLmxlbmd0aCAtIDE7CgogICAgICAgIGlmIChpbnNlcnRQb3NpdGlvbi5vZmZzZXQgPD0gdGhpcy5wYXRoW2ldKSB7CiAgICAgICAgICAvLyBBbmQgYXJlIGluc2VydGVkIGJlZm9yZSBuZXh0IG5vZGUgb2YgdGhhdCBwYXRoLi4uCiAgICAgICAgICAvLyAiUHVzaCIgdGhlIGluZGV4IG9uIHRoYXQgcGF0aC4KICAgICAgICAgIHRyYW5zZm9ybWVkLnBhdGhbaV0gKz0gaG93TWFueTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0aGF0IGlzIHVwZGF0ZWQgYnkgbW92aW5nIGBob3dNYW55YCBub2RlcyBmcm9tIGBzb3VyY2VQb3NpdGlvbmAgdG8gYHRhcmdldFBvc2l0aW9uYC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHNvdXJjZVBvc2l0aW9uIFBvc2l0aW9uIGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudCB0byBtb3ZlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXRQb3NpdGlvbiBQb3NpdGlvbiB3aGVyZSBtb3ZlZCBlbGVtZW50cyB3aWxsIGJlIGluc2VydGVkLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgY29uc2VjdXRpdmUgbm9kZXMgdG8gbW92ZSwgc3RhcnRpbmcgZnJvbSBgc291cmNlUG9zaXRpb25gLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRyYW5zZm9ybWVkIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSkgewogICAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uLCBhcyBpdCBjb3VsZCBiZSBhZmZlY3RlZCBieSBub2RlcyByZW1vdmFsLgogICAgICB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgaWYgKHNvdXJjZVBvc2l0aW9uLmlzRXF1YWwodGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgLy8gSWYgYHRhcmdldFBvc2l0aW9uYCBpcyBlcXVhbCB0byBgc291cmNlUG9zaXRpb25gIHRoaXMgaXNuJ3QgcmVhbGx5IGFueSBtb3ZlLiBKdXN0IHJldHVybiBwb3NpdGlvbiBhcyBpdCBpcy4KICAgICAgICByZXR1cm4gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMpOwogICAgICB9IC8vIE1vdmluZyBhIHJhbmdlIHJlbW92ZXMgbm9kZXMgZnJvbSB0aGVpciBvcmlnaW5hbCBwb3NpdGlvbi4gV2UgYWNrbm93bGVkZ2UgdGhpcyBieSBwcm9wZXIgdHJhbnNmb3JtYXRpb24uCgoKICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgIHZhciBpc01vdmVkID0gdHJhbnNmb3JtZWQgPT09IG51bGwgfHwgc291cmNlUG9zaXRpb24uaXNFcXVhbCh0aGlzKSAmJiB0aGlzLnN0aWNraW5lc3MgPT0gJ3RvTmV4dCcgfHwgc291cmNlUG9zaXRpb24uZ2V0U2hpZnRlZEJ5KGhvd01hbnkpLmlzRXF1YWwodGhpcykgJiYgdGhpcy5zdGlja2luZXNzID09ICd0b1ByZXZpb3VzJzsKCiAgICAgIGlmIChpc01vdmVkKSB7CiAgICAgICAgLy8gVGhpcyBwb3NpdGlvbiBpcyBpbnNpZGUgbW92ZWQgcmFuZ2UgKG9yIHN0aWNrcyB0byBpdCkuCiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBjYWxjdWxhdGUgYSBjb21iaW5hdGlvbiBvZiB0aGlzIHBvc2l0aW9uLCBtb3ZlIHNvdXJjZSBwb3NpdGlvbiBhbmQgdGFyZ2V0IHBvc2l0aW9uLgogICAgICAgIHJldHVybiB0aGlzLl9nZXRDb21iaW5lZChzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoaXMgcG9zaXRpb24gaXMgbm90IGluc2lkZSBhIHJlbW92ZWQgcmFuZ2UuCiAgICAgICAgLy8KICAgICAgICAvLyBJbiBuZXh0IHN0ZXAsIHdlIHNpbXBseSByZWZsZWN0IGluc2VydGluZyBgaG93TWFueWAgbm9kZXMsIHdoaWNoIG1pZ2h0IGZ1cnRoZXIgYWZmZWN0IHRoZSBwb3NpdGlvbi4KICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24odGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBuZXcgcG9zaXRpb24gdGhhdCBpcyBhIGNvbWJpbmF0aW9uIG9mIHRoaXMgcG9zaXRpb24gYW5kIGdpdmVuIHBvc2l0aW9ucy4KICAgICAqCiAgICAgKiBUaGUgY29tYmluZWQgcG9zaXRpb24gaXMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgbW92aW5nIGEgcmFuZ2Ugc3RhcnRpbmcgYXQgYHNvdXJjZWAgcG9zaXRpb24KICAgICAqIHRvIHRoZSBgdGFyZ2V0YCBwb3NpdGlvbi4gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGlzIHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgbW92ZWQgcmFuZ2UuCiAgICAgKgogICAgICogRXhhbXBsZToKICAgICAqCiAgICAgKgkJbGV0IG9yaWdpbmFsID0gbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAyLCAzLCAxIF0gKTsKICAgICAqCQlsZXQgc291cmNlID0gbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAyLCAyIF0gKTsKICAgICAqCQlsZXQgdGFyZ2V0ID0gbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggb3RoZXJSb290LCBbIDEsIDEsIDMgXSApOwogICAgICoJCW9yaWdpbmFsLl9nZXRDb21iaW5lZCggc291cmNlLCB0YXJnZXQgKTsgLy8gcGF0aCBpcyBbIDEsIDEsIDQsIDEgXSwgcm9vdCBpcyBgb3RoZXJSb290YAogICAgICoKICAgICAqIEV4cGxhbmF0aW9uOgogICAgICoKICAgICAqIFdlIGhhdmUgYSBwb3NpdGlvbiBgWyAyLCAzLCAxIF1gIGFuZCBtb3ZlIHNvbWUgbm9kZXMgZnJvbSBgWyAyLCAyIF1gIHRvIGBbIDEsIDEsIDMgXWAuIFRoZSBvcmlnaW5hbCBwb3NpdGlvbgogICAgICogd2FzIGluc2lkZSBtb3ZlZCBub2RlcyBhbmQgbm93IHNob3VsZCBwb2ludCB0byB0aGUgbmV3IHBsYWNlLiBUaGUgbW92ZWQgbm9kZXMgd2lsbCBiZSBhZnRlcgogICAgICogcG9zaXRpb25zIGBbIDEsIDEsIDMgXWAsIGBbIDEsIDEsIDQgXWAsIGBbIDEsIDEsIDUgXWAuIFNpbmNlIG91ciBwb3NpdGlvbiB3YXMgaW4gdGhlIHNlY29uZCBtb3ZlZCBub2RlLAogICAgICogdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIHdpbGwgYmUgaW4gYSBzdWItdHJlZSBvZiBhIG5vZGUgYXQgYFsgMSwgMSwgNCBdYC4gTG9va2luZyBhdCBvcmlnaW5hbCBwYXRoLCB3ZQogICAgICogdG9vayBjYXJlIG9mIGBbIDIsIDMgXWAgcGFydCBvZiBpdC4gTm93IHdlIGhhdmUgdG8gYWRkIHRoZSByZXN0IG9mIHRoZSBvcmlnaW5hbCBwYXRoIHRvIHRoZSB0cmFuc2Zvcm1lZCBwYXRoLgogICAgICogRmluYWxseSwgdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIHdpbGwgcG9pbnQgdG8gYFsgMSwgMSwgNCwgMSBdYC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHNvdXJjZSBCZWdpbm5pbmcgb2YgdGhlIG1vdmVkIHJhbmdlLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXQgUG9zaXRpb24gd2hlcmUgdGhlIHJhbmdlIGlzIG1vdmVkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IENvbWJpbmVkIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRDb21iaW5lZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbWJpbmVkKHNvdXJjZSwgdGFyZ2V0KSB7CiAgICAgIHZhciBpID0gc291cmNlLnBhdGgubGVuZ3RoIC0gMTsgLy8gVGhlIGZpcnN0IHBhcnQgb2YgYSBwYXRoIHRvIGNvbWJpbmVkIHBvc2l0aW9uIGlzIGEgcGF0aCB0byB0aGUgcGxhY2Ugd2hlcmUgbm9kZXMgd2VyZSBtb3ZlZC4KCiAgICAgIHZhciBjb21iaW5lZCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0YXJnZXQpOwoKICAgICAgY29tYmluZWQuc3RpY2tpbmVzcyA9IHRoaXMuc3RpY2tpbmVzczsgLy8gVGhlbiB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgcmVzdCBvZiB0aGUgcGF0aC4KICAgICAgLy8gRml4IHRoZSBvZmZzZXQgYmVjYXVzZSB0aGlzIHBvc2l0aW9uIG1pZ2h0IGJlIGFmdGVyIGBmcm9tYCBwb3NpdGlvbiBhbmQgd2UgaGF2ZSB0byByZWZsZWN0IHRoYXQuCgogICAgICBjb21iaW5lZC5vZmZzZXQgPSBjb21iaW5lZC5vZmZzZXQgKyB0aGlzLnBhdGhbaV0gLSBzb3VyY2Uub2Zmc2V0OyAvLyBUaGVuLCBhZGQgdGhlIHJlc3Qgb2YgdGhlIHBhdGguCiAgICAgIC8vIElmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIHNhbWUgbGV2ZWwgYXMgYGZyb21gIHBvc2l0aW9uIG5vdGhpbmcgd2lsbCBnZXQgYWRkZWQuCgogICAgICBjb21iaW5lZC5wYXRoID0gY29tYmluZWQucGF0aC5jb25jYXQodGhpcy5wYXRoLnNsaWNlKGkgKyAxKSk7CiAgICAgIHJldHVybiBjb21iaW5lZDsKICAgIH0KICAgIC8qKgogICAgICogQGluaGVyaXREb2MKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b0pTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICByb290OiB0aGlzLnJvb3QudG9KU09OKCksCiAgICAgICAgcGF0aDogQXJyYXkuZnJvbSh0aGlzLnBhdGgpLAogICAgICAgIHN0aWNraW5lc3M6IHRoaXMuc3RpY2tpbmVzcwogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvc2l0aW9uIHRoYXQgaXMgZXF1YWwgdG8gY3VycmVudCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjbG9uZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJvb3QsIHRoaXMucGF0aCwgdGhpcy5zdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAgICoKICAgICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0sCiAgICAgKiAqIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXQgKG9mZnNldCBkZWZhdWx0cyB0byBgMGApLAogICAgICogKiBwYXJlbnQgZWxlbWVudCBhbmQgYCdlbmQnYCAoc2V0cyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoYXQgZWxlbWVudCksCiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfSBhbmQgYCdiZWZvcmUnYCBvciBgJ2FmdGVyJ2AgKHNldHMgcG9zaXRpb24gYmVmb3JlIG9yIGFmdGVyIGdpdmVuIG1vZGVsIGl0ZW0pLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRjdXQgdG8gb3RoZXIgZmFjdG9yeSBtZXRob2RzIHN1Y2ggYXM6CiAgICAgKgogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbi5fY3JlYXRlQmVmb3JlfSwKICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24uX2NyZWF0ZUFmdGVyfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4gdGhlCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4gVXNlZCBvbmx5IHdoZW4gdGhlCiAgICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAib2Zmc2V0IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gbGFzdCh0aGlzLnBhdGgpOwogICAgfQogICAgLyoqCiAgICAgKiBAcGFyYW0ge051bWJlcn0gbmV3T2Zmc2V0CiAgICAgKi8KICAgICwKICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld09mZnNldCkgewogICAgICB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdID0gbmV3T2Zmc2V0OwogICAgfQogICAgLyoqCiAgICAgKiBQYXJlbnQgZWxlbWVudCBvZiB0aGlzIHBvc2l0aW9uLgogICAgICoKICAgICAqIEtlZXAgaW4gbWluZCB0aGF0IGBwYXJlbnRgIHZhbHVlIGlzIGNhbGN1bGF0ZWQgd2hlbiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQuCiAgICAgKiBJZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoIHBvc2l0aW9uIHBhdGh9CiAgICAgKiBsZWFkcyB0byBhIG5vbi1leGlzdGluZyBlbGVtZW50LCBgcGFyZW50YCBwcm9wZXJ0eSB3aWxsIHRocm93IGVycm9yLgogICAgICoKICAgICAqIEFsc28gaXQgaXMgYSBnb29kIGlkZWEgdG8gY2FjaGUgYHBhcmVudGAgcHJvcGVydHkgaWYgaXQgaXMgdXNlZCBmcmVxdWVudGx5IGluIGFuIGFsZ29yaXRobSAoaS5lLiBpbiBhIGxvbmcgbG9vcCkuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicGFyZW50IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICB2YXIgcGFyZW50ID0gdGhpcy5yb290OwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7CiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldENoaWxkKHBhcmVudC5vZmZzZXRUb0luZGV4KHRoaXMucGF0aFtpXSkpOwoKICAgICAgICBpZiAoIXBhcmVudCkgewogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLXBhdGgtaW5jb3JyZWN0OiBUaGUgcG9zaXRpb25cJ3MgcGF0aCBpcyBpbmNvcnJlY3QuJywgdGhpcywgewogICAgICAgICAgICBwb3NpdGlvbjogdGhpcwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAocGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgcG9zaXRpb24ncyBwYXRoIGlzIGluY29ycmVjdC4gVGhpcyBtZWFucyB0aGF0IGEgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8KICAgICAgICAgKiBhIGNvcnJlY3QgcGxhY2UgaW4gdGhlIHRyZWUgYW5kIGhlbmNlLCBzb21lIG9mIGl0cyBtZXRob2RzIGFuZCBnZXR0ZXJzIGNhbm5vdCB3b3JrIGNvcnJlY3RseS4KICAgICAgICAgKgogICAgICAgICAqICoqTm90ZSoqOiBVbmxpa2UgRE9NIGFuZCB2aWV3IHBvc2l0aW9ucywgaW4gdGhlIG1vZGVsLCB0aGUKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcG9zaXRpb24ncyBwYXJlbnR9IGlzIGFsd2F5cyBhbiBlbGVtZW50IG9yIGEgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgICAgICogVGhlIGxhc3Qgb2Zmc2V0IGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoIHBvc2l0aW9uJ3MgcGF0aH0gaXMgdGhlIHBvaW50IGluIHRoaXMgZWxlbWVudCB3aGVyZQogICAgICAgICAqIHRoaXMgcG9zaXRpb24gcG9pbnRzLgogICAgICAgICAqCiAgICAgICAgICogUmVhZCBtb3JlIGFib3V0IG1vZGVsIHBvc2l0aW9ucyBhbmQgb2Zmc2V0cyBpbgogICAgICAgICAqIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2luZGV4ZXMtYW5kLW9mZnNldHMgRWRpdGluZyBlbmdpbmUgYXJjaGl0ZWN0dXJlIGd1aWRlfS4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBwb3NpdGlvbi1pbmNvcnJlY3QtcGF0aAogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gVGhlIGluY29ycmVjdCBwb3NpdGlvbi4KICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tcGF0aC1pbmNvcnJlY3Q6IFRoZSBwb3NpdGlvblwncyBwYXRoIGlzIGluY29ycmVjdC4nLCB0aGlzLCB7CiAgICAgICAgICBwb3NpdGlvbjogdGhpcwogICAgICAgIH0pOwogICAgICB9CgogICAgICByZXR1cm4gcGFyZW50OwogICAgfQogICAgLyoqCiAgICAgKiBQb3NpdGlvbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNvZmZzZXQgb2Zmc2V0fSBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggaW4gcG9zaXRpb24ncyBwYXJlbnQgbm9kZS4gSXQgaXMKICAgICAqIGVxdWFsIHRvIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaW5kZXggaW5kZXh9IG9mIGEgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uLiBJZiBwb3NpdGlvbiBpcyBwbGFjZWQKICAgICAqIGluIHRleHQgbm9kZSwgcG9zaXRpb24gaW5kZXggaXMgZXF1YWwgdG8gdGhlIGluZGV4IG9mIHRoYXQgdGV4dCBub2RlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpbmRleCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9mZnNldFRvSW5kZXgodGhpcy5vZmZzZXQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCB0ZXh0IG5vZGV9IGluc3RhbmNlIGluIHdoaWNoIHRoaXMgcG9zaXRpb24gaXMgcGxhY2VkIG9yIGBudWxsYCBpZiB0aGlzCiAgICAgKiBwb3NpdGlvbiBpcyBub3QgaW4gYSB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0ZXh0Tm9kZSIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhcmVudC5nZXRDaGlsZCh0aGlzLmluZGV4KTsKICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIG5vZGUuc3RhcnRPZmZzZXQgPCB0aGlzLm9mZnNldCA/IG5vZGUgOiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBOb2RlIGRpcmVjdGx5IGFmdGVyIHRoaXMgcG9zaXRpb24gb3IgYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgaW4gdGV4dCBub2RlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG51bGx9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibm9kZUFmdGVyIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZSA9PT0gbnVsbCA/IHRoaXMucGFyZW50LmdldENoaWxkKHRoaXMuaW5kZXgpIDogbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogTm9kZSBkaXJlY3RseSBiZWZvcmUgdGhpcyBwb3NpdGlvbiBvciBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBpbiB0ZXh0IG5vZGUuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Tm9kZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJub2RlQmVmb3JlIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZSA9PT0gbnVsbCA/IHRoaXMucGFyZW50LmdldENoaWxkKHRoaXMuaW5kZXggLSAxKSA6IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIElzIGB0cnVlYCBpZiBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0F0U3RhcnQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLm9mZnNldCA9PT0gMDsKICAgIH0KICAgIC8qKgogICAgICogSXMgYHRydWVgIGlmIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2YgaXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhcmVudCBwYXJlbnR9LCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQXRFbmQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLm9mZnNldCA9PSB0aGlzLnBhcmVudC5tYXhPZmZzZXQ7CiAgICB9CiAgfV0sIFt7CiAgICBrZXk6ICJfY3JlYXRlQXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICAgIHZhciBzdGlja2luZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndG9Ob25lJzsKCiAgICAgIGlmIChpdGVtT3JQb3NpdGlvbiBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihpdGVtT3JQb3NpdGlvbi5yb290LCBpdGVtT3JQb3NpdGlvbi5wYXRoLCBpdGVtT3JQb3NpdGlvbi5zdGlja2luZXNzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgbm9kZSA9IGl0ZW1PclBvc2l0aW9uOwoKICAgICAgICBpZiAob2Zmc2V0ID09ICdlbmQnKSB7CiAgICAgICAgICBvZmZzZXQgPSBub2RlLm1heE9mZnNldDsKICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnYmVmb3JlJykgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJlZm9yZShub2RlLCBzdGlja2luZXNzKTsKICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnYWZ0ZXInKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQWZ0ZXIobm9kZSwgc3RpY2tpbmVzcyk7CiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgIT09IDAgJiYgIW9mZnNldCkgewogICAgICAgICAgLyoqCiAgICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkF0IGBNb2RlbCNjcmVhdGVQb3NpdGlvbkF0KClgfQogICAgICAgICAgICogcmVxdWlyZXMgdGhlIG9mZnNldCB0byBiZSBzcGVjaWZpZWQgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgbW9kZWwgaXRlbS4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtY3JlYXRlUG9zaXRpb25BdC1vZmZzZXQtcmVxdWlyZWQKICAgICAgICAgICAqLwogICAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLWNyZWF0ZVBvc2l0aW9uQXQtb2Zmc2V0LXJlcXVpcmVkOiAnICsgJ01vZGVsI2NyZWF0ZVBvc2l0aW9uQXQoKSByZXF1aXJlcyB0aGUgb2Zmc2V0IHdoZW4gdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIG1vZGVsIGl0ZW0uJywgW3RoaXMsIGl0ZW1PclBvc2l0aW9uXSk7CiAgICAgICAgfQoKICAgICAgICBpZiAoIW5vZGUuaXMoJ2VsZW1lbnQnKSAmJiAhbm9kZS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgICAgICAvKioKICAgICAgICAgICAqIFBvc2l0aW9uIHBhcmVudCBoYXZlIHRvIGJlIGEgbW9kZWwgZWxlbWVudCBvciBtb2RlbCBkb2N1bWVudCBmcmFnbWVudC4KICAgICAgICAgICAqCiAgICAgICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tcGFyZW50LWluY29ycmVjdAogICAgICAgICAgICovCiAgICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tcGFyZW50LWluY29ycmVjdDogUG9zaXRpb24gcGFyZW50IGhhdmUgdG8gYmUgYSBlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50LicsIFt0aGlzLCBpdGVtT3JQb3NpdGlvbl0pOwogICAgICAgIH0KCiAgICAgICAgdmFyIHBhdGggPSBub2RlLmdldFBhdGgoKTsKICAgICAgICBwYXRoLnB1c2gob2Zmc2V0KTsKICAgICAgICByZXR1cm4gbmV3IHRoaXMobm9kZS5yb290LCBwYXRoLCBzdGlja2luZXNzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uLCBhZnRlciBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqIEBwcm90ZWN0ZWQKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlQWZ0ZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZnRlcihpdGVtLCBzdGlja2luZXNzKSB7CiAgICAgIGlmICghaXRlbS5wYXJlbnQpIHsKICAgICAgICAvKioKICAgICAgICAgKiBZb3UgY2FuIG5vdCBtYWtlIGEgcG9zaXRpb24gYWZ0ZXIgYSByb290IGVsZW1lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tYWZ0ZXItcm9vdAogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IHJvb3QKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tYWZ0ZXItcm9vdDogWW91IGNhbm5vdCBtYWtlIGEgcG9zaXRpb24gYWZ0ZXIgcm9vdC4nLCBbdGhpcywgaXRlbV0sIHsKICAgICAgICAgIHJvb3Q6IGl0ZW0KICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUF0KGl0ZW0ucGFyZW50LCBpdGVtLmVuZE9mZnNldCwgc3RpY2tpbmVzcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24sIGJlZm9yZSB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0gSXRlbSBiZWZvcmUgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBwbGFjZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICogQHByb3RlY3RlZAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jcmVhdGVCZWZvcmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCZWZvcmUoaXRlbSwgc3RpY2tpbmVzcykgewogICAgICBpZiAoIWl0ZW0ucGFyZW50KSB7CiAgICAgICAgLyoqCiAgICAgICAgICogWW91IGNhbiBub3QgbWFrZSBhIHBvc2l0aW9uIGJlZm9yZSBhIHJvb3QgZWxlbWVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1iZWZvcmUtcm9vdAogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IHJvb3QKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tYmVmb3JlLXJvb3Q6IFlvdSBjYW5ub3QgbWFrZSBhIHBvc2l0aW9uIGJlZm9yZSByb290LicsIGl0ZW0sIHsKICAgICAgICAgIHJvb3Q6IGl0ZW0KICAgICAgICB9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUF0KGl0ZW0ucGFyZW50LCBpdGVtLnN0YXJ0T2Zmc2V0LCBzdGlja2luZXNzKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIGBQb3NpdGlvbmAgaW5zdGFuY2UgZnJvbSBnaXZlbiBwbGFpbiBvYmplY3QgKGkuZS4gcGFyc2VkIEpTT04gc3RyaW5nKS4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBQb3NpdGlvbmAuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IGRvYyBEb2N1bWVudCBvYmplY3QgdGhhdCB3aWxsIGJlIHBvc2l0aW9uIG93bmVyLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGBQb3NpdGlvbmAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZnJvbUpTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIGRvYykgewogICAgICBpZiAoanNvbi5yb290ID09PSAnJGdyYXZleWFyZCcpIHsKICAgICAgICB2YXIgcG9zID0gbmV3IFBvc2l0aW9uKGRvYy5ncmF2ZXlhcmQsIGpzb24ucGF0aCk7CiAgICAgICAgcG9zLnN0aWNraW5lc3MgPSBqc29uLnN0aWNraW5lc3M7CiAgICAgICAgcmV0dXJuIHBvczsKICAgICAgfQoKICAgICAgaWYgKCFkb2MuZ2V0Um9vdChqc29uLnJvb3QpKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ2Fubm90IGNyZWF0ZSBwb3NpdGlvbiBmb3IgZG9jdW1lbnQuIFJvb3Qgd2l0aCBzcGVjaWZpZWQgbmFtZSBkb2VzIG5vdCBleGlzdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1mcm9tanNvbi1uby1yb290CiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb3ROYW1lCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLWZyb21qc29uLW5vLXJvb3Q6IENhbm5vdCBjcmVhdGUgcG9zaXRpb24gZm9yIGRvY3VtZW50LiBSb290IHdpdGggc3BlY2lmaWVkIG5hbWUgZG9lcyBub3QgZXhpc3QuJywgZG9jLCB7CiAgICAgICAgICByb290TmFtZToganNvbi5yb290CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24oZG9jLmdldFJvb3QoanNvbi5yb290KSwganNvbi5wYXRoLCBqc29uLnN0aWNraW5lc3MpOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuIGAkeyB0aGlzLnJvb3QgfSBbICR7IHRoaXMucGF0aC5qb2luKCAnLCAnICkgfSBdYDsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAljb25zb2xlLmxvZyggJ01vZGVsUG9zaXRpb246ICcgKyB0aGlzICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0KCiAgfV0pOwoKICByZXR1cm4gUG9zaXRpb247Cn0oKTsKLyoqCiAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYCBvciBgJ3NhbWUnYCBhcyBnaXZlbiBwb3NpdGlvbi4KICogSWYgcG9zaXRpb25zIGFyZSBpbiBkaWZmZXJlbnQgcm9vdHMgYCdkaWZmZXJlbnQnYCBmbGFnIGlzIHJldHVybmVkLgogKgogKiBAdHlwZWRlZiB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uUmVsYXRpb24KICovCgovKioKICogUmVwcmVzZW50cyBob3cgcG9zaXRpb24gaXMgInN0aWNraW5nIiB3aXRoIG5laWdoYm91ciBub2Rlcy4gVXNlZCB0byBkZWZpbmUgaG93IHBvc2l0aW9uIHNob3VsZCBiZSB0cmFuc2Zvcm1lZCAobW92ZWQpCiAqIGluIGVkZ2UgY2FzZXMuIFBvc3NpYmxlIHZhbHVlczogYCd0b05vbmUnYCwgYCd0b05leHQnYCwgYCd0b1ByZXZpb3VzJ2AuCiAqCiAqIEV4YW1wbGVzOgogKgogKgkJSW5zZXJ0LiBQb3NpdGlvbiBpcyBhdCB8IGFuZCBub2RlcyBhcmUgaW5zZXJ0ZWQgYXQgdGhlIHNhbWUgcG9zaXRpb24sIG1hcmtlZCBhcyBeOgogKgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZefG9vPC9wPiAgLT4gIDxwPmZiYXJ8b288L3A+CiAqCQktIHN0aWNrcyB0byBuZXh0IG5vZGU6ICAgICAgPHA+Zl58b288L3A+ICAtPiAgPHA+ZmJhcnxvbzwvcD4KICoJCS0gc3RpY2tzIHRvIHByZXZpb3VzIG5vZGU6ICA8cD5mfF5vbzwvcD4gIC0+ICA8cD5mfGJhcm9vPC9wPgogKgogKgogKgkJTW92ZS4gUG9zaXRpb24gaXMgYXQgfCBhbmQgcmFuZ2UgW29vXSBpcyBtb3ZlZCB0byBwb3NpdGlvbiBeOgogKgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgogKgkJLSBzdGlja3MgdG8gbmV4dCBub2RlOiAgICAgIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmY8L3A+PHA+Ynxvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gbmV4dCBub2RlOiAgICAgIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgogKgkJLSBzdGlja3MgdG8gcHJldmlvdXMgbm9kZTogIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gcHJldmlvdXMgbm9kZTogIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmY8L3A+PHA+Ym9vfGFyPC9wPgogKgogKiBAdHlwZWRlZiB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzcwogKi8KCgpleHBvcnQgeyBQb3NpdGlvbiBhcyBkZWZhdWx0IH07"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","Text","last","Position","root","path","stickiness","is","Array","length","getPath","concat","otherPosition","result","skip","options","startPosition","treeWalker","position","slice","parent","getAncestors","includeSelf","cmp","diffAt","Math","min","ancestorsA","ancestorsB","i","shift","shifted","clone","offset","compareWith","left","right","compare","_createAt","leftParent","isEqual","maxOffset","type","thisParentPath","getParentPath","posParentPath","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","isBefore","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","getShiftedBy","source","target","combined","toJSON","from","constructor","newOffset","getChild","offsetToIndex","node","index","startOffset","textNode","itemOrPosition","_createBefore","_createAfter","push","item","endOffset","json","doc","graveyard","getRoot","rootName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Text from './text';\nimport { last } from 'lodash-es';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t */\n\tconstructor( root, path, stickiness = 'toNone' ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-root-invalid: Position root invalid.',\n\t\t\t\troot\n\t\t\t);\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect-format\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-path-incorrect-format: Position path must be an array with at least one item.',\n\t\t\t\troot,\n\t\t\t\t{ path }\n\t\t\t);\n\t\t}\n\n\t\t// Normalize the root and path (if element was passed).\n\t\tpath = root.getPath().concat( path );\n\t\troot = root.root;\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn last( this.path );\n\t}\n\n\t/**\n\t * @param {Number} newOffset\n\t */\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\n\t\t\tif ( !parent ) {\n\t\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t\t}\n\t\t}\n\n\t\tif ( parent.is( 'text' ) ) {\n\t\t\t/**\n\t\t\t * The position's path is incorrect. This means that a position does not point to\n\t\t\t * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n\t\t\t *\n\t\t\t * **Note**: Unlike DOM and view positions, in the model, the\n\t\t\t * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n\t\t\t * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element where\n\t\t\t * this position points.\n\t\t\t *\n\t\t\t * Read more about model positions and offsets in\n\t\t\t * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n\t\t\t *\n\t\t\t * @error position-incorrect-path\n\t\t\t * @param {module:engine/model/position~Position} position The incorrect position.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\tconst node = this.parent.getChild( this.index );\n\n\t\treturn ( node instanceof Text && node.startOffset < this.offset ) ? node : null;\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index ) : null;\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {Node}\n\t */\n\tget nodeBefore() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index - 1 ) : null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = this.clone();\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position._createAt( this );\n\t\t\t\tright = Position._createAt( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position._createAt( otherPosition );\n\t\t\t\tright = Position._createAt( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'model:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'view:position' ); // -> false\n\t *\t\tposition.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'position' || type == 'model:position';\n\t}\n\n\t/**\n\t * Checks if two positions are in the same parent.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position Position to compare with.\n\t * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n\t */\n\thasSameParentAs( position ) {\n\t\tif ( this.root !== position.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisParentPath = this.getParentPath();\n\t\tconst posParentPath = position.getParentPath();\n\n\t\treturn compareArrays( thisParentPath, posParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Returns a copy of this position that is transformed by given `operation`.\n\t *\n\t * The new position's parameters are updated accordingly to the effect of the `operation`.\n\t *\n\t * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n\t * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tlet result;\n\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\tresult = this._getTransformedByInsertOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\tresult = this._getTransformedByMoveOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'split':\n\t\t\t\tresult = this._getTransformedBySplitOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tresult = this._getTransformedByMergeOperation( operation );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = Position._createAt( this );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by an insert operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByInsertOperation( operation ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a move operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMoveOperation( operation ) {\n\t\treturn this._getTransformedByMove( operation.sourcePosition, operation.targetPosition, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a split operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\n\t\tconst isContained = movedRange.containsPosition( this ) ||\n\t\t\t( movedRange.start.isEqual( this ) && this.stickiness == 'toNext' );\n\n\t\tif ( isContained ) {\n\t\t\treturn this._getCombined( operation.splitPosition, operation.moveTargetPosition );\n\t\t} else {\n\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\treturn this._getTransformedByMove( operation.graveyardPosition, operation.insertionPosition, 1 );\n\t\t\t} else {\n\t\t\t\treturn this._getTransformedByInsertion( operation.insertionPosition, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by merge operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\t\tconst isContained = movedRange.containsPosition( this ) || movedRange.start.isEqual( this );\n\n\t\tlet pos;\n\n\t\tif ( isContained ) {\n\t\t\tpos = this._getCombined( operation.sourcePosition, operation.targetPosition );\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Above happens during OT when the merged element is moved before the merged-to element.\n\t\t\t\tpos = pos._getTransformedByDeletion( operation.deletionPosition, 1 );\n\t\t\t}\n\t\t} else if ( this.isEqual( operation.deletionPosition ) ) {\n\t\t\tpos = Position._createAt( operation.deletionPosition );\n\t\t} else {\n\t\t\tpos = this._getTransformedByMove( operation.deletionPosition, operation.graveyardPosition, 1 );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && this.stickiness != 'toPrevious' ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\t// Update target position, as it could be affected by nodes removal.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( sourcePosition.isEqual( targetPosition ) ) {\n\t\t\t// If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n\t\t\treturn Position._createAt( this );\n\t\t}\n\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tconst transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tconst isMoved = transformed === null ||\n\t\t\t( sourcePosition.isEqual( this ) && this.stickiness == 'toNext' ) ||\n\t\t\t( sourcePosition.getShiftedBy( howMany ).isEqual( this ) && this.stickiness == 'toPrevious' );\n\n\t\tif ( isMoved ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\treturn this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t//\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\treturn transformed._getTransformedByInsertion( targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n\t *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position._createAt( target );\n\t\tcombined.stickiness = this.stickiness;\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = combined.path.concat( this.path.slice( i + 1 ) );\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\troot: this.root.toJSON(),\n\t\t\tpath: Array.from( this.path ),\n\t\t\tstickiness: this.stickiness\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new position that is equal to current position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.root, this.path, this.stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/position~Position._createBefore},\n\t * * {@link module:engine/model/position~Position._createAfter}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @protected\n\t */\n\tstatic _createAt( itemOrPosition, offset, stickiness = 'toNone' ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new Position( itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node, stickiness );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node, stickiness );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a model item.\n\t\t\t\t *\n\t\t\t\t * @error model-createPositionAt-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-createPositionAt-offset-required: ' +\n\t\t\t\t\t'Model#createPositionAt() requires the offset when the first parameter is a model item.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !node.is( 'element' ) && !node.is( 'documentFragment' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t\t *\n\t\t\t\t * @error model-position-parent-incorrect\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-position-parent-incorrect: Position parent have to be a element or document fragment.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst path = node.getPath();\n\n\t\t\tpath.push( offset );\n\n\t\t\treturn new this( node.root, path, stickiness );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createAfter( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-after-root: You cannot make a position after root.',\n\t\t\t\t[ this, item ],\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.endOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createBefore( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-before-root: You cannot make a position before root.',\n\t\t\t\titem,\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.startOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\tconst pos = new Position( doc.graveyard, json.path );\n\t\t\tpos.stickiness = json.stickiness;\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',\n\t\t\t\tdoc,\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path, json.stickiness );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n"]}]}