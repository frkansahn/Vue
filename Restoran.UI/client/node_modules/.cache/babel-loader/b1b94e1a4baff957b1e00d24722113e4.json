{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\treewalker.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\treewalker.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC90cmVld2Fsa2VyCiAqLwppbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnOwppbXBvcnQgVGV4dFByb3h5IGZyb20gJy4vdGV4dHByb3h5JzsKaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKLyoqCiAqIFBvc2l0aW9uIGl0ZXJhdG9yIGNsYXNzLiBJdCBhbGxvd3MgdG8gaXRlcmF0ZSBmb3J3YXJkIGFuZCBiYWNrd2FyZCBvdmVyIHRoZSBkb2N1bWVudC4KICovCgp2YXIgVHJlZVdhbGtlciA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBpdGVyYXRvci4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLCBidXQgeW91IGhhdmUgdG8gc3BlY2lmeSBlaXRoZXIgYGJvdW5kYXJpZXNgIG9yIGBzdGFydFBvc2l0aW9uYC4KICAgKgogICAqIEBjb25zdHJ1Y3RvcgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbi4KICAgKiBAcGFyYW0geydmb3J3YXJkJ3wnYmFja3dhcmQnfSBbb3B0aW9ucy5kaXJlY3Rpb249J2ZvcndhcmQnXSBXYWxraW5nIGRpcmVjdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IFtvcHRpb25zLmJvdW5kYXJpZXM9bnVsbF0gUmFuZ2UgdG8gZGVmaW5lIGJvdW5kYXJpZXMgb2YgdGhlIGl0ZXJhdG9yLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gW29wdGlvbnMuc3RhcnRQb3NpdGlvbl0gU3RhcnRpbmcgcG9zaXRpb24uCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaW5nbGVDaGFyYWN0ZXJzPWZhbHNlXSBGbGFnIGluZGljYXRpbmcgd2hldGhlciBhbGwgY29uc2VjdXRpdmUgY2hhcmFjdGVycyB3aXRoIHRoZSBzYW1lIGF0dHJpYnV0ZXMKICAgKiBzaG91bGQgYmUgcmV0dXJuZWQgb25lIGJ5IG9uZSBhcyBtdWx0aXBsZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSAoYHRydWVgKSBvYmplY3RzIG9yIGFzIG9uZQogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHl9IChgZmFsc2VgKS4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWxsb3c9ZmFsc2VdIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGl0ZXJhdG9yIHNob3VsZCBlbnRlciBlbGVtZW50cyBvciBub3QuIElmIHRoZQogICAqIGl0ZXJhdG9yIGlzIHNoYWxsb3cgY2hpbGQgbm9kZXMgb2YgYW55IGl0ZXJhdGVkIG5vZGUgd2lsbCBub3QgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBgZWxlbWVudEVuZGAgdGFnLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlRWxlbWVudEVuZD1mYWxzZV0gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgaXRlcmF0b3Igc2hvdWxkIGlnbm9yZSBgZWxlbWVudEVuZGAKICAgKiB0YWdzLiBJZiB0aGUgb3B0aW9uIGlzIHRydWUgd2Fsa2VyIHdpbGwgbm90IHJldHVybiBhIHBhcmVudCBub2RlIG9mIHN0YXJ0IHBvc2l0aW9uLiBJZiB0aGlzIG9wdGlvbiBpcyBgdHJ1ZWAKICAgKiBlYWNoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gd2lsbCBiZSByZXR1cm5lZCBvbmNlLCB3aGlsZSBpZiB0aGUgb3B0aW9uIGlzIGBmYWxzZWAgdGhleSBtaWdodCBiZSByZXR1cm5lZAogICAqIHR3aWNlOiBmb3IgYCdlbGVtZW50U3RhcnQnYCBhbmQgYCdlbGVtZW50RW5kJ2AuCiAgICovCiAgZnVuY3Rpb24gVHJlZVdhbGtlcigpIHsKICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKCiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZVdhbGtlcik7CgogICAgaWYgKCFvcHRpb25zLmJvdW5kYXJpZXMgJiYgIW9wdGlvbnMuc3RhcnRQb3NpdGlvbikgewogICAgICAvKioKICAgICAgICogTmVpdGhlciBib3VuZGFyaWVzIG5vciBzdGFydGluZyBwb3NpdGlvbiBvZiBhIGBUcmVlV2Fsa2VyYCBoYXZlIGJlZW4gZGVmaW5lZC4KICAgICAgICoKICAgICAgICogQGVycm9yIG1vZGVsLXRyZWUtd2Fsa2VyLW5vLXN0YXJ0LXBvc2l0aW9uCiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtdHJlZS13YWxrZXItbm8tc3RhcnQtcG9zaXRpb246IE5laXRoZXIgYm91bmRhcmllcyBub3Igc3RhcnRpbmcgcG9zaXRpb24gaGF2ZSBiZWVuIGRlZmluZWQuJywgbnVsbCk7CiAgICB9CgogICAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8ICdmb3J3YXJkJzsKCiAgICBpZiAoZGlyZWN0aW9uICE9ICdmb3J3YXJkJyAmJiBkaXJlY3Rpb24gIT0gJ2JhY2t3YXJkJykgewogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtdHJlZS13YWxrZXItdW5rbm93bi1kaXJlY3Rpb246IE9ubHkgYGJhY2t3YXJkYCBhbmQgYGZvcndhcmRgIGRpcmVjdGlvbiBhbGxvd2VkLicsIG9wdGlvbnMsIHsKICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbgogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogV2Fsa2luZyBkaXJlY3Rpb24uIERlZmF1bHRzIGAnZm9yd2FyZCdgLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7J2JhY2t3YXJkJ3wnZm9yd2FyZCd9IG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyI2RpcmVjdGlvbgogICAgICovCgoKICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uOwogICAgLyoqCiAgICAgKiBJdGVyYXRvciBib3VuZGFyaWVzLgogICAgICoKICAgICAqIFdoZW4gdGhlIGl0ZXJhdG9yIGlzIHdhbGtpbmcgYCdmb3J3YXJkJ2Agb24gdGhlIGVuZCBvZiBib3VuZGFyeSBvciBpcyB3YWxraW5nIGAnYmFja3dhcmQnYAogICAgICogb24gdGhlIHN0YXJ0IG9mIGJvdW5kYXJ5LCB0aGVuIGB7IGRvbmU6IHRydWUgfWAgaXMgcmV0dXJuZWQuCiAgICAgKgogICAgICogSWYgYm91bmRhcmllcyBhcmUgbm90IGRlZmluZWQgdGhleSBhcmUgc2V0IGJlZm9yZSBmaXJzdCBhbmQgYWZ0ZXIgbGFzdCBjaGlsZCBvZiB0aGUgcm9vdCBub2RlLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjYm91bmRhcmllcwogICAgICovCgogICAgdGhpcy5ib3VuZGFyaWVzID0gb3B0aW9ucy5ib3VuZGFyaWVzIHx8IG51bGw7CiAgICAvKioKICAgICAqIEl0ZXJhdG9yIHBvc2l0aW9uLiBUaGlzIGlzIGFsd2F5cyBzdGF0aWMgcG9zaXRpb24sIGV2ZW4gaWYgdGhlIGluaXRpYWwgcG9zaXRpb24gd2FzIGEKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVwb3NpdGlvbn5MaXZlUG9zaXRpb24gbGl2ZSBwb3NpdGlvbn0uIElmIHN0YXJ0IHBvc2l0aW9uIGlzIG5vdCBkZWZpbmVkIHRoZW4gcG9zaXRpb24gZGVwZW5kcwogICAgICogb24ge0BsaW5rICNkaXJlY3Rpb259LiBJZiBkaXJlY3Rpb24gaXMgYCdmb3J3YXJkJ2AgcG9zaXRpb24gc3RhcnRzIGZvcm0gdGhlIGJlZ2lubmluZywgd2hlbiBkaXJlY3Rpb24KICAgICAqIGlzIGAnYmFja3dhcmQnYCBwb3NpdGlvbiBzdGFydHMgZnJvbSB0aGUgZW5kLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjcG9zaXRpb24KICAgICAqLwoKICAgIGlmIChvcHRpb25zLnN0YXJ0UG9zaXRpb24pIHsKICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMuc3RhcnRQb3NpdGlvbi5jbG9uZSgpOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy5wb3NpdGlvbiA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzLmJvdW5kYXJpZXNbdGhpcy5kaXJlY3Rpb24gPT0gJ2JhY2t3YXJkJyA/ICdlbmQnIDogJ3N0YXJ0J10pOwogICAgfSAvLyBSZXNldCBwb3NpdGlvbiBzdGlja2luZXNzIGluIGNhc2UgaXQgd2FzIHNldCB0byBvdGhlciB2YWx1ZSwgYXMgdGhlIHN0aWNraW5lc3MgaXMga2VwdCBhZnRlciBjbG9uaW5nLgoKCiAgICB0aGlzLnBvc2l0aW9uLnN0aWNraW5lc3MgPSAndG9Ob25lJzsKICAgIC8qKgogICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgYWxsIGNvbnNlY3V0aXZlIGNoYXJhY3RlcnMgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzIHNob3VsZCBiZQogICAgICogcmV0dXJuZWQgYXMgb25lIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHl9IChgdHJ1ZWApIG9yIG9uZSBieSBvbmUgKGBmYWxzZWApLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjc2luZ2xlQ2hhcmFjdGVycwogICAgICovCgogICAgdGhpcy5zaW5nbGVDaGFyYWN0ZXJzID0gISFvcHRpb25zLnNpbmdsZUNoYXJhY3RlcnM7CiAgICAvKioKICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGl0ZXJhdG9yIHNob3VsZCBlbnRlciBlbGVtZW50cyBvciBub3QuIElmIHRoZSBpdGVyYXRvciBpcyBzaGFsbG93IGNoaWxkIG5vZGVzIG9mIGFueQogICAgICogaXRlcmF0ZWQgbm9kZSB3aWxsIG5vdCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIGBlbGVtZW50RW5kYCB0YWcuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciNzaGFsbG93CiAgICAgKi8KCiAgICB0aGlzLnNoYWxsb3cgPSAhIW9wdGlvbnMuc2hhbGxvdzsKICAgIC8qKgogICAgICogRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgaXRlcmF0b3Igc2hvdWxkIGlnbm9yZSBgZWxlbWVudEVuZGAgdGFncy4gSWYgdGhlIG9wdGlvbiBpcyB0cnVlIHdhbGtlciB3aWxsIG5vdAogICAgICogcmV0dXJuIGEgcGFyZW50IG5vZGUgb2YgdGhlIHN0YXJ0IHBvc2l0aW9uLiBJZiB0aGlzIG9wdGlvbiBpcyBgdHJ1ZWAgZWFjaCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHdpbGwKICAgICAqIGJlIHJldHVybmVkIG9uY2UsIHdoaWxlIGlmIHRoZSBvcHRpb24gaXMgYGZhbHNlYCB0aGV5IG1pZ2h0IGJlIHJldHVybmVkIHR3aWNlOgogICAgICogZm9yIGAnZWxlbWVudFN0YXJ0J2AgYW5kIGAnZWxlbWVudEVuZCdgLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjaWdub3JlRWxlbWVudEVuZAogICAgICovCgogICAgdGhpcy5pZ25vcmVFbGVtZW50RW5kID0gISFvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQ7CiAgICAvKioKICAgICAqIFN0YXJ0IGJvdW5kYXJ5IGNhY2hlZCBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjX2JvdW5kYXJ5U3RhcnRQYXJlbnQKICAgICAqLwoKICAgIHRoaXMuX2JvdW5kYXJ5U3RhcnRQYXJlbnQgPSB0aGlzLmJvdW5kYXJpZXMgPyB0aGlzLmJvdW5kYXJpZXMuc3RhcnQucGFyZW50IDogbnVsbDsKICAgIC8qKgogICAgICogRW5kIGJvdW5kYXJ5IGNhY2hlZCBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2VzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjX2JvdW5kYXJ5RW5kUGFyZW50CiAgICAgKi8KCiAgICB0aGlzLl9ib3VuZGFyeUVuZFBhcmVudCA9IHRoaXMuYm91bmRhcmllcyA/IHRoaXMuYm91bmRhcmllcy5lbmQucGFyZW50IDogbnVsbDsKICAgIC8qKgogICAgICogUGFyZW50IG9mIHRoZSBtb3N0IHJlY2VudGx5IHZpc2l0ZWQgbm9kZS4gQ2FjaGVkIGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjX3Zpc2l0ZWRQYXJlbnQKICAgICAqLwoKICAgIHRoaXMuX3Zpc2l0ZWRQYXJlbnQgPSB0aGlzLnBvc2l0aW9uLnBhcmVudDsKICB9CiAgLyoqCiAgICogSXRlcmFibGUgaW50ZXJmYWNlLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlPn0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhUcmVlV2Fsa2VyLCBbewogICAga2V5OiBTeW1ib2wuaXRlcmF0b3IsCiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgLyoqCiAgICAgKiBNb3ZlcyB7QGxpbmsgI3Bvc2l0aW9ufSBpbiB0aGUge0BsaW5rICNkaXJlY3Rpb259IHNraXBwaW5nIHZhbHVlcyBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYC4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZToKICAgICAqCiAgICAgKiAJCXdhbGtlci5za2lwKCB2YWx1ZSA9PiB2YWx1ZS50eXBlID09ICd0ZXh0JyApOyAvLyA8cGFyYWdyYXBoPltdZm9vPC9wYXJhZ3JhcGg+IC0+IDxwYXJhZ3JhcGg+Zm9vW108L3BhcmFncmFwaD4KICAgICAqIAkJd2Fsa2VyLnNraXAoICgpID0+IHRydWUgKTsgLy8gTW92ZSB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZDogPHBhcmFncmFwaD5bXWZvbzwvcGFyYWdyYXBoPiAtPiA8cGFyYWdyYXBoPmZvbzwvcGFyYWdyYXBoPltdCiAgICAgKiAJCXdhbGtlci5za2lwKCAoKSA9PiBmYWxzZSApOyAvLyBEbyBub3QgbW92ZSB0aGUgcG9zaXRpb24uCiAgICAgKgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2tpcCBDYWxsYmFjayBmdW5jdGlvbi4gR2V0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0gYW5kIHNob3VsZAogICAgICogcmV0dXJuIGB0cnVlYCBpZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHNraXBwZWQgb3IgYGZhbHNlYCBpZiBub3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2tpcCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2tpcChfc2tpcCkgewogICAgICB2YXIgZG9uZSwgdmFsdWUsIHByZXZQb3NpdGlvbiwgcHJldlZpc2l0ZWRQYXJlbnQ7CgogICAgICBkbyB7CiAgICAgICAgcHJldlBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjsKICAgICAgICBwcmV2VmlzaXRlZFBhcmVudCA9IHRoaXMuX3Zpc2l0ZWRQYXJlbnQ7CgogICAgICAgIHZhciBfdGhpcyRuZXh0ID0gdGhpcy5uZXh0KCk7CgogICAgICAgIGRvbmUgPSBfdGhpcyRuZXh0LmRvbmU7CiAgICAgICAgdmFsdWUgPSBfdGhpcyRuZXh0LnZhbHVlOwogICAgICB9IHdoaWxlICghZG9uZSAmJiBfc2tpcCh2YWx1ZSkpOwoKICAgICAgaWYgKCFkb25lKSB7CiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHByZXZQb3NpdGlvbjsKICAgICAgICB0aGlzLl92aXNpdGVkUGFyZW50ID0gcHJldlZpc2l0ZWRQYXJlbnQ7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgbmV4dCB0cmVlIHdhbGtlcidzIHZhbHVlLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSBOZXh0IHRyZWUgd2Fsa2VyJ3MgdmFsdWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibmV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09ICdmb3J3YXJkJykgewogICAgICAgIHJldHVybiB0aGlzLl9uZXh0KCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzKCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogTWFrZXMgYSBzdGVwIGZvcndhcmQgaW4gbW9kZWwuIE1vdmVzIHRoZSB7QGxpbmsgI3Bvc2l0aW9ufSB0byB0aGUgbmV4dCBwb3NpdGlvbiBhbmQgcmV0dXJucyB0aGUgZW5jb3VudGVyZWQgdmFsdWUuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEByZXR1cm5zIHtPYmplY3R9CiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmV0dXJuLmRvbmUgVHJ1ZSBpZiBpdGVyYXRvciBpcyBkb25lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9IHJldHVybi52YWx1ZSBJbmZvcm1hdGlvbiBhYm91dCB0YWtlbiBzdGVwLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9uZXh0IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dCgpIHsKICAgICAgdmFyIHByZXZpb3VzUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uOwogICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmNsb25lKCk7CiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl92aXNpdGVkUGFyZW50OyAvLyBXZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgcm9vdC4KCiAgICAgIGlmIChwYXJlbnQucGFyZW50ID09PSBudWxsICYmIHBvc2l0aW9uLm9mZnNldCA9PT0gcGFyZW50Lm1heE9mZnNldCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfSAvLyBXZSByZWFjaGVkIHRoZSB3YWxrZXIgYm91bmRhcnkuCgoKICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcy5fYm91bmRhcnlFbmRQYXJlbnQgJiYgcG9zaXRpb24ub2Zmc2V0ID09IHRoaXMuYm91bmRhcmllcy5lbmQub2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRvbmU6IHRydWUKICAgICAgICB9OwogICAgICB9CgogICAgICB2YXIgbm9kZSA9IHBvc2l0aW9uLnRleHROb2RlID8gcG9zaXRpb24udGV4dE5vZGUgOiBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHsKICAgICAgICBpZiAoIXRoaXMuc2hhbGxvdykgewogICAgICAgICAgLy8gTWFudWFsIG9wZXJhdGlvbnMgb24gcGF0aCBpbnRlcm5hbHMgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gSGVyZSBhbmQgaW4gdGhlIHJlc3Qgb2YgdGhlIG1ldGhvZC4KICAgICAgICAgIHBvc2l0aW9uLnBhdGgucHVzaCgwKTsKICAgICAgICAgIHRoaXMuX3Zpc2l0ZWRQYXJlbnQgPSBub2RlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwb3NpdGlvbi5vZmZzZXQrKzsKICAgICAgICB9CgogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoJ2VsZW1lbnRTdGFydCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uLCAxKTsKICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCkgewogICAgICAgIHZhciBjaGFyYWN0ZXJzQ291bnQ7CgogICAgICAgIGlmICh0aGlzLnNpbmdsZUNoYXJhY3RlcnMpIHsKICAgICAgICAgIGNoYXJhY3RlcnNDb3VudCA9IDE7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBvZmZzZXQgPSBub2RlLmVuZE9mZnNldDsKCiAgICAgICAgICBpZiAodGhpcy5fYm91bmRhcnlFbmRQYXJlbnQgPT0gcGFyZW50ICYmIHRoaXMuYm91bmRhcmllcy5lbmQub2Zmc2V0IDwgb2Zmc2V0KSB7CiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuYm91bmRhcmllcy5lbmQub2Zmc2V0OwogICAgICAgICAgfQoKICAgICAgICAgIGNoYXJhY3RlcnNDb3VudCA9IG9mZnNldCAtIHBvc2l0aW9uLm9mZnNldDsKICAgICAgICB9CgogICAgICAgIHZhciBvZmZzZXRJblRleHROb2RlID0gcG9zaXRpb24ub2Zmc2V0IC0gbm9kZS5zdGFydE9mZnNldDsKICAgICAgICB2YXIgaXRlbSA9IG5ldyBUZXh0UHJveHkobm9kZSwgb2Zmc2V0SW5UZXh0Tm9kZSwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgICBwb3NpdGlvbi5vZmZzZXQgKz0gY2hhcmFjdGVyc0NvdW50OwogICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsKICAgICAgICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUoJ3RleHQnLCBpdGVtLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgY2hhcmFjdGVyc0NvdW50KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBgbm9kZWAgaXMgbm90IHNldCwgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIGN1cnJlbnQgYHBhcmVudGAuCiAgICAgICAgcG9zaXRpb24ucGF0aC5wb3AoKTsKICAgICAgICBwb3NpdGlvbi5vZmZzZXQrKzsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgdGhpcy5fdmlzaXRlZFBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CgogICAgICAgIGlmICh0aGlzLmlnbm9yZUVsZW1lbnRFbmQpIHsKICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0KCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSgnZWxlbWVudEVuZCcsIHBhcmVudCwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24pOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBNYWtlcyBhIHN0ZXAgYmFja3dhcmQgaW4gbW9kZWwuIE1vdmVzIHRoZSB7QGxpbmsgI3Bvc2l0aW9ufSB0byB0aGUgcHJldmlvdXMgcG9zaXRpb24gYW5kIHJldHVybnMgdGhlIGVuY291bnRlcmVkIHZhbHVlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fQogICAgICogQHJldHVybnMge0Jvb2xlYW59IHJldHVybi5kb25lIFRydWUgaWYgaXRlcmF0b3IgaXMgZG9uZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfSByZXR1cm4udmFsdWUgSW5mb3JtYXRpb24gYWJvdXQgdGFrZW4gc3RlcC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcHJldmlvdXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmV2aW91cygpIHsKICAgICAgdmFyIHByZXZpb3VzUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uOwogICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmNsb25lKCk7CiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl92aXNpdGVkUGFyZW50OyAvLyBXZSBhcmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcm9vdC4KCiAgICAgIGlmIChwYXJlbnQucGFyZW50ID09PSBudWxsICYmIHBvc2l0aW9uLm9mZnNldCA9PT0gMCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkb25lOiB0cnVlCiAgICAgICAgfTsKICAgICAgfSAvLyBXZSByZWFjaGVkIHRoZSB3YWxrZXIgYm91bmRhcnkuCgoKICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLl9ib3VuZGFyeVN0YXJ0UGFyZW50ICYmIHBvc2l0aW9uLm9mZnNldCA9PSB0aGlzLmJvdW5kYXJpZXMuc3RhcnQub2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRvbmU6IHRydWUKICAgICAgICB9OwogICAgICB9IC8vIEdldCBub2RlIGp1c3QgYmVmb3JlIGN1cnJlbnQgcG9zaXRpb24KCgogICAgICB2YXIgbm9kZSA9IHBvc2l0aW9uLnRleHROb2RlID8gcG9zaXRpb24udGV4dE5vZGUgOiBwb3NpdGlvbi5ub2RlQmVmb3JlOwoKICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0LS07CgogICAgICAgIGlmICghdGhpcy5zaGFsbG93KSB7CiAgICAgICAgICBwb3NpdGlvbi5wYXRoLnB1c2gobm9kZS5tYXhPZmZzZXQpOwogICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgICAgdGhpcy5fdmlzaXRlZFBhcmVudCA9IG5vZGU7CgogICAgICAgICAgaWYgKHRoaXMuaWdub3JlRWxlbWVudEVuZCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXMoKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSgnZWxlbWVudEVuZCcsIG5vZGUsIHByZXZpb3VzUG9zaXRpb24sIHBvc2l0aW9uKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCdlbGVtZW50U3RhcnQnLCBub2RlLCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgMSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXh0KSB7CiAgICAgICAgdmFyIGNoYXJhY3RlcnNDb3VudDsKCiAgICAgICAgaWYgKHRoaXMuc2luZ2xlQ2hhcmFjdGVycykgewogICAgICAgICAgY2hhcmFjdGVyc0NvdW50ID0gMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIG9mZnNldCA9IG5vZGUuc3RhcnRPZmZzZXQ7CgogICAgICAgICAgaWYgKHRoaXMuX2JvdW5kYXJ5U3RhcnRQYXJlbnQgPT0gcGFyZW50ICYmIHRoaXMuYm91bmRhcmllcy5zdGFydC5vZmZzZXQgPiBvZmZzZXQpIHsKICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ib3VuZGFyaWVzLnN0YXJ0Lm9mZnNldDsKICAgICAgICAgIH0KCiAgICAgICAgICBjaGFyYWN0ZXJzQ291bnQgPSBwb3NpdGlvbi5vZmZzZXQgLSBvZmZzZXQ7CiAgICAgICAgfQoKICAgICAgICB2YXIgb2Zmc2V0SW5UZXh0Tm9kZSA9IHBvc2l0aW9uLm9mZnNldCAtIG5vZGUuc3RhcnRPZmZzZXQ7CiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgVGV4dFByb3h5KG5vZGUsIG9mZnNldEluVGV4dE5vZGUgLSBjaGFyYWN0ZXJzQ291bnQsIGNoYXJhY3RlcnNDb3VudCk7CiAgICAgICAgcG9zaXRpb24ub2Zmc2V0IC09IGNoYXJhY3RlcnNDb3VudDsKICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247CiAgICAgICAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKCd0ZXh0JywgaXRlbSwgcHJldmlvdXNQb3NpdGlvbiwgcG9zaXRpb24sIGNoYXJhY3RlcnNDb3VudCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gYG5vZGVgIGlzIG5vdCBzZXQsIHdlIHJlYWNoZWQgdGhlIGJlZ2lubmluZyBvZiBjdXJyZW50IGBwYXJlbnRgLgogICAgICAgIHBvc2l0aW9uLnBhdGgucG9wKCk7CiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOwogICAgICAgIHRoaXMuX3Zpc2l0ZWRQYXJlbnQgPSBwYXJlbnQucGFyZW50OwogICAgICAgIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSgnZWxlbWVudFN0YXJ0JywgcGFyZW50LCBwcmV2aW91c1Bvc2l0aW9uLCBwb3NpdGlvbiwgMSk7CiAgICAgIH0KICAgIH0KICB9XSk7CgogIHJldHVybiBUcmVlV2Fsa2VyOwp9KCk7CgpleHBvcnQgeyBUcmVlV2Fsa2VyIGFzIGRlZmF1bHQgfTsKCmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKHR5cGUsIGl0ZW0sIHByZXZpb3VzUG9zaXRpb24sIG5leHRQb3NpdGlvbiwgbGVuZ3RoKSB7CiAgcmV0dXJuIHsKICAgIGRvbmU6IGZhbHNlLAogICAgdmFsdWU6IHsKICAgICAgdHlwZTogdHlwZSwKICAgICAgaXRlbTogaXRlbSwKICAgICAgcHJldmlvdXNQb3NpdGlvbjogcHJldmlvdXNQb3NpdGlvbiwKICAgICAgbmV4dFBvc2l0aW9uOiBuZXh0UG9zaXRpb24sCiAgICAgIGxlbmd0aDogbGVuZ3RoCiAgICB9CiAgfTsKfQovKioKICogVHlwZSBvZiB0aGUgc3RlcCBtYWRlIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAqIFBvc3NpYmxlIHZhbHVlczogYCdlbGVtZW50U3RhcnQnYCBpZiB3YWxrZXIgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIG5vZGUsIGAnZWxlbWVudEVuZCdgIGlmIHdhbGtlciBpcyBhdCB0aGUgZW5kIG9mIG5vZGUsCiAqIGAnY2hhcmFjdGVyJ2AgaWYgd2Fsa2VyIHRyYXZlcnNlZCBvdmVyIGEgY2hhcmFjdGVyLCBvciBgJ3RleHQnYCBpZiB3YWxrZXIgdHJhdmVyc2VkIG92ZXIgbXVsdGlwbGUgY2hhcmFjdGVycyAoYXZhaWxhYmxlIGluCiAqIGNoYXJhY3RlciBtZXJnaW5nIG1vZGUsIHNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIjY29uc3RydWN0b3J9KS4KICoKICogQHR5cGVkZWYgeydlbGVtZW50U3RhcnQnfCdlbGVtZW50RW5kJ3wnY2hhcmFjdGVyJ3wndGV4dCd9IG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWVUeXBlCiAqLwoKLyoqCiAqIE9iamVjdCByZXR1cm5lZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdoZW4gdHJhdmVyc2luZyB0cmVlIG1vZGVsLgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZVR5cGV9IHR5cGUKICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGJldHdlZW4gb2xkIGFuZCBuZXcgcG9zaXRpb25zIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcHJldmlvdXNQb3NpdGlvbiBQcmV2aW91cyBwb3NpdGlvbiBvZiB0aGUgaXRlcmF0b3IuCiAqICogRm9yd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRFbmQnYCBpdCBpcyB0aGUgbGFzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMgdGhlCiAqIHBvc2l0aW9uIGJlZm9yZSB0aGUgaXRlbS4KICogKiBCYWNrd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRTdGFydCdgIGl0IGlzIHRoZSBmaXJzdCBwb3NpdGlvbiBpbnNpZGUgdGhlIGVsZW1lbnQuIEZvciBhbGwgb3RoZXIgdHlwZXMgaXQgaXMKICogdGhlIHBvc2l0aW9uIGFmdGVyIGl0ZW0uCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gbmV4dFBvc2l0aW9uIE5leHQgcG9zaXRpb24gb2YgdGhlIGl0ZXJhdG9yLgogKiAqIEZvcndhcmQgaXRlcmF0aW9uOiBGb3IgYCdlbGVtZW50U3RhcnQnYCBpdCBpcyB0aGUgZmlyc3QgcG9zaXRpb24gaW5zaWRlIHRoZSBlbGVtZW50LiBGb3IgYWxsIG90aGVyIHR5cGVzIGl0IGlzCiAqIHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgaXRlbS4KICogKiBCYWNrd2FyZCBpdGVyYXRpb246IEZvciBgJ2VsZW1lbnRFbmQnYCBpdCBpcyBsYXN0IHBvc2l0aW9uIGluc2lkZSBlbGVtZW50LiBGb3IgYWxsIG90aGVyIHR5cGVzIGl0IGlzIHRoZSBwb3NpdGlvbgogKiBiZWZvcmUgdGhlIGl0ZW0uCiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggb2YgdGhlIGl0ZW0uIEZvciBgJ2VsZW1lbnRTdGFydCdgIGFuZCBgJ2NoYXJhY3RlcidgIGl0IGlzIDEuIEZvciBgJ3RleHQnYCBpdCBpcwogKiB0aGUgbGVuZ3RoIG9mIHRoZSB0ZXh0LiBGb3IgYCdlbGVtZW50RW5kJ2AgaXQgaXMgYHVuZGVmaW5lZGAuCiAqLwoKLyoqCiAqIFRyZWUgd2Fsa2luZyBkaXJlY3Rpb25zLgogKgogKiBAdHlwZWRlZiB7J2ZvcndhcmQnfCdiYWNrd2FyZCd9IG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJEaXJlY3Rpb24KICov"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js"],"names":["Text","TextProxy","Element","Position","CKEditorError","TreeWalker","options","boundaries","startPosition","direction","position","clone","_createAt","stickiness","singleCharacters","shallow","ignoreElementEnd","_boundaryStartParent","start","parent","_boundaryEndParent","end","_visitedParent","Symbol","iterator","skip","done","value","prevPosition","prevVisitedParent","next","_next","_previous","previousPosition","offset","maxOffset","node","textNode","nodeAfter","path","push","formatReturnValue","charactersCount","endOffset","offsetInTextNode","startOffset","item","pop","nodeBefore","type","nextPosition","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/treewalker\n */\n\nimport Text from './text';\nimport TextProxy from './textproxy';\nimport Element from './element';\nimport Position from './position';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n/**\n * Position iterator class. It allows to iterate forward and backward over the document.\n */\nexport default class TreeWalker {\n\t/**\n\t * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.\n\t *\n\t * @constructor\n\t * @param {Object} [options={}] Object with configuration.\n\t * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.\n\t * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.\n\t * @param {module:engine/model/position~Position} [options.startPosition] Starting position.\n\t * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes\n\t * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one\n\t * {@link module:engine/model/textproxy~TextProxy} (`false`).\n\t * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the\n\t * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.\n\t * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`\n\t * tags. If the option is true walker will not return a parent node of start position. If this option is `true`\n\t * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned\n\t * twice: for `'elementStart'` and `'elementEnd'`.\n\t */\n\tconstructor( options = {} ) {\n\t\tif ( !options.boundaries && !options.startPosition ) {\n\t\t\t/**\n\t\t\t * Neither boundaries nor starting position of a `TreeWalker` have been defined.\n\t\t\t *\n\t\t\t * @error model-tree-walker-no-start-position\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.',\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tconst direction = options.direction || 'forward';\n\n\t\tif ( direction != 'forward' && direction != 'backward' ) {\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.',\n\t\t\t\toptions,\n\t\t\t\t{ direction }\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Walking direction. Defaults `'forward'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction\n\t\t */\n\t\tthis.direction = direction;\n\n\t\t/**\n\t\t * Iterator boundaries.\n\t\t *\n\t\t * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`\n\t\t * on the start of boundary, then `{ done: true }` is returned.\n\t\t *\n\t\t * If boundaries are not defined they are set before first and after last child of the root node.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries\n\t\t */\n\t\tthis.boundaries = options.boundaries || null;\n\n\t\t/**\n\t\t * Iterator position. This is always static position, even if the initial position was a\n\t\t * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends\n\t\t * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction\n\t\t * is `'backward'` position starts from the end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position\n\t\t */\n\t\tif ( options.startPosition ) {\n\t\t\tthis.position = options.startPosition.clone();\n\t\t} else {\n\t\t\tthis.position = Position._createAt( this.boundaries[ this.direction == 'backward' ? 'end' : 'start' ] );\n\t\t}\n\n\t\t// Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.\n\t\tthis.position.stickiness = 'toNone';\n\n\t\t/**\n\t\t * Flag indicating whether all consecutive characters with the same attributes should be\n\t\t * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters\n\t\t */\n\t\tthis.singleCharacters = !!options.singleCharacters;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any\n\t\t * iterated node will not be returned along with `elementEnd` tag.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow\n\t\t */\n\t\tthis.shallow = !!options.shallow;\n\n\t\t/**\n\t\t * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not\n\t\t * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will\n\t\t * be returned once, while if the option is `false` they might be returned twice:\n\t\t * for `'elementStart'` and `'elementEnd'`.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd\n\t\t */\n\t\tthis.ignoreElementEnd = !!options.ignoreElementEnd;\n\n\t\t/**\n\t\t * Start boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent\n\t\t */\n\t\tthis._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;\n\n\t\t/**\n\t\t * End boundary cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent\n\t\t */\n\t\tthis._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;\n\n\t\t/**\n\t\t * Parent of the most recently visited node. Cached for optimization purposes.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/treewalker~TreeWalker#_visitedParent\n\t\t */\n\t\tthis._visitedParent = this.position.parent;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.\n\t *\n\t * For example:\n\t *\n\t * \t\twalker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t * \t\twalker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]\n\t * \t\twalker.skip( () => false ); // Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t */\n\tskip( skip ) {\n\t\tlet done, value, prevPosition, prevVisitedParent;\n\n\t\tdo {\n\t\t\tprevPosition = this.position;\n\t\t\tprevVisitedParent = this._visitedParent;\n\n\t\t\t( { done, value } = this.next() );\n\t\t} while ( !done && skip( value ) );\n\n\t\tif ( !done ) {\n\t\t\tthis.position = prevPosition;\n\t\t\tthis._visitedParent = prevVisitedParent;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the next tree walker's value.\n\t *\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.\n\t */\n\tnext() {\n\t\tif ( this.direction == 'forward' ) {\n\t\t\treturn this._next();\n\t\t} else {\n\t\t\treturn this._previous();\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_next() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the end of the root.\n\t\tif ( parent.parent === null && position.offset === parent.maxOffset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\tconst node = position.textNode ? position.textNode : position.nodeAfter;\n\n\t\tif ( node instanceof Element ) {\n\t\t\tif ( !this.shallow ) {\n\t\t\t\t// Manual operations on path internals for optimization purposes. Here and in the rest of the method.\n\t\t\t\tposition.path.push( 0 );\n\t\t\t\tthis._visitedParent = node;\n\t\t\t} else {\n\t\t\t\tposition.offset++;\n\t\t\t}\n\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.endOffset;\n\n\t\t\t\tif ( this._boundaryEndParent == parent && this.boundaries.end.offset < offset ) {\n\t\t\t\t\toffset = this.boundaries.end.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = offset - position.offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode, charactersCount );\n\n\t\t\tposition.offset += charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the end of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tposition.offset++;\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\treturn this._next();\n\t\t\t} else {\n\t\t\t\treturn formatReturnValue( 'elementEnd', parent, previousPosition, position );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.\n\t *\n\t * @private\n\t * @returns {Object}\n\t * @returns {Boolean} return.done True if iterator is done.\n\t * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.\n\t */\n\t_previous() {\n\t\tconst previousPosition = this.position;\n\t\tconst position = this.position.clone();\n\t\tconst parent = this._visitedParent;\n\n\t\t// We are at the beginning of the root.\n\t\tif ( parent.parent === null && position.offset === 0 ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// We reached the walker boundary.\n\t\tif ( parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Get node just before current position\n\t\tconst node = position.textNode ? position.textNode : position.nodeBefore;\n\n\t\tif ( node instanceof Element ) {\n\t\t\tposition.offset--;\n\n\t\t\tif ( !this.shallow ) {\n\t\t\t\tposition.path.push( node.maxOffset );\n\t\t\t\tthis.position = position;\n\t\t\t\tthis._visitedParent = node;\n\n\t\t\t\tif ( this.ignoreElementEnd ) {\n\t\t\t\t\treturn this._previous();\n\t\t\t\t} else {\n\t\t\t\t\treturn formatReturnValue( 'elementEnd', node, previousPosition, position );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.position = position;\n\n\t\t\t\treturn formatReturnValue( 'elementStart', node, previousPosition, position, 1 );\n\t\t\t}\n\t\t} else if ( node instanceof Text ) {\n\t\t\tlet charactersCount;\n\n\t\t\tif ( this.singleCharacters ) {\n\t\t\t\tcharactersCount = 1;\n\t\t\t} else {\n\t\t\t\tlet offset = node.startOffset;\n\n\t\t\t\tif ( this._boundaryStartParent == parent && this.boundaries.start.offset > offset ) {\n\t\t\t\t\toffset = this.boundaries.start.offset;\n\t\t\t\t}\n\n\t\t\t\tcharactersCount = position.offset - offset;\n\t\t\t}\n\n\t\t\tconst offsetInTextNode = position.offset - node.startOffset;\n\t\t\tconst item = new TextProxy( node, offsetInTextNode - charactersCount, charactersCount );\n\n\t\t\tposition.offset -= charactersCount;\n\t\t\tthis.position = position;\n\n\t\t\treturn formatReturnValue( 'text', item, previousPosition, position, charactersCount );\n\t\t} else {\n\t\t\t// `node` is not set, we reached the beginning of current `parent`.\n\t\t\tposition.path.pop();\n\t\t\tthis.position = position;\n\t\t\tthis._visitedParent = parent.parent;\n\n\t\t\treturn formatReturnValue( 'elementStart', parent, previousPosition, position, 1 );\n\t\t}\n\t}\n}\n\nfunction formatReturnValue( type, item, previousPosition, nextPosition, length ) {\n\treturn {\n\t\tdone: false,\n\t\tvalue: {\n\t\t\ttype,\n\t\t\titem,\n\t\t\tpreviousPosition,\n\t\t\tnextPosition,\n\t\t\tlength\n\t\t}\n\t};\n}\n\n/**\n * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.\n * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,\n * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in\n * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).\n *\n * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType\n */\n\n/**\n * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.\n *\n * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue\n * @property {module:engine/model/treewalker~TreeWalkerValueType} type\n * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.\n * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.\n * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the\n * position before the item.\n * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after item.\n * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.\n * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is\n * the position after the item.\n * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position\n * before the item.\n * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is\n * the length of the text. For `'elementEnd'` it is `undefined`.\n */\n\n/**\n * Tree walking directions.\n *\n * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection\n */\n"]}]}