{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\differ.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\differ.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBlYXQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL2RpZmZlcgogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi9yYW5nZSc7Ci8qKgogKiBDYWxjdWxhdGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIG1vZGVsIHN0YXRlcy4KICoKICogUmVjZWl2ZXMgb3BlcmF0aW9ucyB0aGF0IGFyZSB0byBiZSBhcHBsaWVkIG9uIHRoZSBtb2RlbCBkb2N1bWVudC4gTWFya3MgcGFydHMgb2YgdGhlIG1vZGVsIGRvY3VtZW50IHRyZWUgd2hpY2gKICogYXJlIGNoYW5nZWQgYW5kIHNhdmVzIHRoZSBzdGF0ZSBvZiB0aGVzZSBlbGVtZW50cyBiZWZvcmUgdGhlIGNoYW5nZS4gVGhlbiwgaXQgY29tcGFyZXMgc2F2ZWQgZWxlbWVudHMgd2l0aCB0aGUKICogY2hhbmdlZCBlbGVtZW50cywgYWZ0ZXIgYWxsIGNoYW5nZXMgYXJlIGFwcGxpZWQgb24gdGhlIG1vZGVsIGRvY3VtZW50LiBDYWxjdWxhdGVzIHRoZSBkaWZmIGJldHdlZW4gc2F2ZWQKICogZWxlbWVudHMgYW5kIG5ldyBvbmVzIGFuZCByZXR1cm5zIGEgY2hhbmdlIHNldC4KICovCgp2YXIgRGlmZmVyID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIGBEaWZmZXJgIGluc3RhbmNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbn0gbWFya2VyQ29sbGVjdGlvbiBNb2RlbCdzIG1hcmtlciBjb2xsZWN0aW9uLgogICAqLwogIGZ1bmN0aW9uIERpZmZlcihtYXJrZXJDb2xsZWN0aW9uKSB7CiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlmZmVyKTsKCiAgICAvKioKICAgICAqIFJlZmVyZW5jZSB0byB0aGUgbW9kZWwncyBtYXJrZXIgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufQogICAgICovCiAgICB0aGlzLl9tYXJrZXJDb2xsZWN0aW9uID0gbWFya2VyQ29sbGVjdGlvbjsKICAgIC8qKgogICAgICogQSBtYXAgdGhhdCBzdG9yZXMgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIGluIGEgZ2l2ZW4gZWxlbWVudC4KICAgICAqCiAgICAgKiBUaGUga2V5cyBvZiB0aGUgbWFwIGFyZSByZWZlcmVuY2VzIHRvIHRoZSBtb2RlbCBlbGVtZW50cy4KICAgICAqIFRoZSB2YWx1ZXMgb2YgdGhlIG1hcCBhcmUgYXJyYXlzIHdpdGggY2hhbmdlcyB0aGF0IHdlcmUgZG9uZSBvbiB0aGlzIGVsZW1lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50ID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBBIG1hcCB0aGF0IHN0b3JlcyAiZWxlbWVudCdzIGNoaWxkcmVuIHNuYXBzaG90cyIuIEEgc25hcHNob3QgaXMgcmVwcmVzZW50aW5nIGNoaWxkcmVuIG9mIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUKICAgICAqIHRoZSBmaXJzdCBjaGFuZ2Ugd2FzIGFwcGxpZWQgb24gdGhhdCBlbGVtZW50LiBTbmFwc2hvdCBpdGVtcyBhcmUgb2JqZWN0cyB3aXRoIHR3byBwcm9wZXJ0aWVzOiBgbmFtZWAsCiAgICAgKiBjb250YWluaW5nIHRoZSBlbGVtZW50IG5hbWUgKG9yIGAnJHRleHQnYCBmb3IgYSB0ZXh0IG5vZGUpIGFuZCBgYXR0cmlidXRlc2Agd2hpY2ggaXMgYSBtYXAgb2YgdGhlIG5vZGUncyBhdHRyaWJ1dGVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TWFwfQogICAgICovCgogICAgdGhpcy5fZWxlbWVudFNuYXBzaG90cyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgdGhhdCBzdG9yZXMgYWxsIGNoYW5nZWQgbWFya2Vycy4KICAgICAqCiAgICAgKiBUaGUga2V5cyBvZiB0aGUgbWFwIGFyZSBtYXJrZXIgbmFtZXMuCiAgICAgKiBUaGUgdmFsdWVzIG9mIHRoZSBtYXAgYXJlIG9iamVjdHMgd2l0aCB0aGUgYG9sZFJhbmdlYCBhbmQgYG5ld1JhbmdlYCBwcm9wZXJ0aWVzLiBUaGV5IHN0b3JlIHRoZSBtYXJrZXIgcmFuZ2UKICAgICAqIHN0YXRlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNoYW5nZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge01hcH0KICAgICAqLwoKICAgIHRoaXMuX2NoYW5nZWRNYXJrZXJzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBjaGFuZ2VzIHRoYXQgd2VyZSBwcm9jZXNzZWQuIFVzZWQgdG8gb3JkZXIgdGhlIGNoYW5nZXMgY2hyb25vbG9naWNhbGx5LiBJdCBpcyBpbXBvcnRhbnQKICAgICAqIHdoZW4gY2hhbmdlcyBhcmUgc29ydGVkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogICAgdGhpcy5fY2hhbmdlQ291bnQgPSAwOwogICAgLyoqCiAgICAgKiBGb3IgZWZmaWNpZW5jeSBwdXJwb3NlcywgYERpZmZlcmAgc3RvcmVzIHRoZSBjaGFuZ2Ugc2V0IHJldHVybmVkIGJ5IHRoZSBkaWZmZXIgYWZ0ZXIge0BsaW5rICNnZXRDaGFuZ2VzfSBjYWxsLgogICAgICogQ2FjaGUgaXMgcmVzZXQgZWFjaCB0aW1lIGEgbmV3IG9wZXJhdGlvbiBpcyBidWZmZXJlZC4gSWYgdGhlIGNhY2hlIGhhcyBub3QgYmVlbiByZXNldCwge0BsaW5rICNnZXRDaGFuZ2VzfSB3aWxsCiAgICAgKiByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZSBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIGl0IGFnYWluLgogICAgICoKICAgICAqIFRoaXMgcHJvcGVydHkgc3RvcmVzIHRob3NlIGNoYW5nZXMgdGhhdCBkaWQgbm90IHRha2UgcGxhY2UgaW4gZ3JhdmV5YXJkIHJvb3QuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0PnxudWxsfQogICAgICovCgogICAgdGhpcy5fY2FjaGVkQ2hhbmdlcyA9IG51bGw7CiAgICAvKioKICAgICAqIEZvciBlZmZpY2llbmN5IHB1cnBvc2VzLCBgRGlmZmVyYCBzdG9yZXMgdGhlIGNoYW5nZSBzZXQgcmV0dXJuZWQgYnkgdGhlIGRpZmZlciBhZnRlciB0aGUge0BsaW5rICNnZXRDaGFuZ2VzfSBjYWxsLgogICAgICogVGhlIGNhY2hlIGlzIHJlc2V0IGVhY2ggdGltZSBhIG5ldyBvcGVyYXRpb24gaXMgYnVmZmVyZWQuIElmIHRoZSBjYWNoZSBoYXMgbm90IGJlZW4gcmVzZXQsIHtAbGluayAjZ2V0Q2hhbmdlc30gd2lsbAogICAgICogcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWUgaW5zdGVhZCBvZiBjYWxjdWxhdGluZyBpdCBhZ2Fpbi4KICAgICAqCiAgICAgKiBUaGlzIHByb3BlcnR5IHN0b3JlcyBhbGwgY2hhbmdlcyBldmFsdWF0ZWQgYnkgYERpZmZlcmAsIGluY2x1ZGluZyB0aG9zZSB0aGF0IHRvb2sgcGxhY2UgaW4gdGhlIGdyYXZleWFyZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fG51bGx9CiAgICAgKi8KCiAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzV2l0aEdyYXZleWFyZCA9IG51bGw7CiAgfQogIC8qKgogICAqIEluZm9ybXMgd2hldGhlciB0aGVyZSBhcmUgYW55IGNoYW5nZXMgYnVmZmVyZWQgaW4gYERpZmZlcmAuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhEaWZmZXIsIFt7CiAgICBrZXk6ICJyZWZyZXNoSXRlbSIsCgogICAgLyoqCiAgICAgKiBNYXJrcyBnaXZlbiBgaXRlbWAgaW4gZGlmZmVyIHRvIGJlICJyZWZyZXNoZWQiLiBJdCBtZWFucyB0aGF0IHRoZSBpdGVtIHdpbGwgYmUgbWFya2VkIGFzIHJlbW92ZWQgYW5kIGluc2VydGVkIGluIHRoZSBkaWZmZXIgY2hhbmdlcwogICAgICogc2V0LCBzbyBpdCB3aWxsIGJlIGVmZmVjdGl2ZWx5IHJlLWNvbnZlcnRlZCB3aGVuIGRpZmZlciBjaGFuZ2VzIHdpbGwgYmUgaGFuZGxlZCBieSBhIGRpc3BhdGNoZXIuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIHRvIHJlZnJlc2guCiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoSXRlbShpdGVtKSB7CiAgICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KGl0ZW0ucGFyZW50KSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5fbWFya1JlbW92ZShpdGVtLnBhcmVudCwgaXRlbS5zdGFydE9mZnNldCwgaXRlbS5vZmZzZXRTaXplKTsKCiAgICAgIHRoaXMuX21hcmtJbnNlcnQoaXRlbS5wYXJlbnQsIGl0ZW0uc3RhcnRPZmZzZXQsIGl0ZW0ub2Zmc2V0U2l6ZSk7CgogICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5fY3JlYXRlT24oaXRlbSk7CgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX21hcmtlckNvbGxlY3Rpb24uZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlKHJhbmdlKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBtYXJrZXIgPSBfc3RlcC52YWx1ZTsKICAgICAgICAgIHZhciBtYXJrZXJSYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICAgICAgdGhpcy5idWZmZXJNYXJrZXJDaGFuZ2UobWFya2VyLm5hbWUsIG1hcmtlclJhbmdlLCBtYXJrZXJSYW5nZSwgbWFya2VyLmFmZmVjdHNEYXRhKTsKICAgICAgICB9IC8vIENsZWFyIGNhY2hlIGFmdGVyIGVhY2ggYnVmZmVyZWQgb3BlcmF0aW9uIGFzIGl0IGlzIG5vIGxvbmdlciB2YWxpZC4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBCdWZmZXJzIHRoZSBnaXZlbiBvcGVyYXRpb24uIEFuIG9wZXJhdGlvbiBoYXMgdG8gYmUgYnVmZmVyZWQgYmVmb3JlIGl0IGlzIGV4ZWN1dGVkLgogICAgICoKICAgICAqIE9wZXJhdGlvbiB0eXBlIGlzIGNoZWNrZWQgYW5kIGl0IGlzIGNoZWNrZWQgd2hpY2ggbm9kZXMgaXQgd2lsbCBhZmZlY3QuIFRoZXNlIG5vZGVzIGFyZSB0aGVuIHN0b3JlZCBpbiBgRGlmZmVyYAogICAgICogaW4gdGhlIHN0YXRlIGJlZm9yZSB0aGUgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uIEFuIG9wZXJhdGlvbiB0byBidWZmZXIuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYnVmZmVyT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBidWZmZXJPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIC8vIEJlbG93IHdlIHRha2UgYW4gb3BlcmF0aW9uLCBjaGVjayBpdHMgdHlwZSwgdGhlbiB1c2UgaXRzIHBhcmFtZXRlcnMgaW4gbWFya2luZyAocHJpdmF0ZSkgbWV0aG9kcy4KICAgICAgLy8gVGhlIGdlbmVyYWwgcnVsZSBpcyB0byBub3QgbWFyayBlbGVtZW50cyBpbnNpZGUgaW5zZXJ0ZWQgZWxlbWVudC4gQWxsIGluc2VydGVkIGVsZW1lbnRzIGFyZSByZS1yZW5kZXJlZC4KICAgICAgLy8gTWFya2luZyBjaGFuZ2VzIGluIHRoZW0gd291bGQgY2F1c2UgYSAiZG91YmxlIiBjaGFuZ2luZyB0aGVuLgogICAgICAvLwogICAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7CiAgICAgICAgY2FzZSAnaW5zZXJ0JzoKICAgICAgICAgIHsKICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCkpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLm5vZGVzLm1heE9mZnNldCk7CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSAnYWRkQXR0cmlidXRlJzoKICAgICAgICBjYXNlICdyZW1vdmVBdHRyaWJ1dGUnOgogICAgICAgIGNhc2UgJ2NoYW5nZUF0dHJpYnV0ZSc6CiAgICAgICAgICB7CiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG9wZXJhdGlvbi5yYW5nZS5nZXRJdGVtcyh7CiAgICAgICAgICAgICAgICBzaGFsbG93OiB0cnVlCiAgICAgICAgICAgICAgfSlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KGl0ZW0ucGFyZW50KSkgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrQXR0cmlidXRlKGl0ZW0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICBjYXNlICdyZW1vdmUnOgogICAgICAgIGNhc2UgJ21vdmUnOgogICAgICAgIGNhc2UgJ3JlaW5zZXJ0JzoKICAgICAgICAgIHsKICAgICAgICAgICAgLy8gV2hlbiByYW5nZSBpcyBtb3ZlZCB0byB0aGUgc2FtZSBwb3NpdGlvbiB0aGVuIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlLgogICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy8xNjY0LgogICAgICAgICAgICBpZiAob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwob3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKSB8fCBvcGVyYXRpb24uc291cmNlUG9zaXRpb24uZ2V0U2hpZnRlZEJ5KG9wZXJhdGlvbi5ob3dNYW55KS5pc0VxdWFsKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHZhciBzb3VyY2VQYXJlbnRJbnNlcnRlZCA9IHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLnBhcmVudCk7CgogICAgICAgICAgICB2YXIgdGFyZ2V0UGFyZW50SW5zZXJ0ZWQgPSB0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbi5wYXJlbnQpOwoKICAgICAgICAgICAgaWYgKCFzb3VyY2VQYXJlbnRJbnNlcnRlZCkgewogICAgICAgICAgICAgIHRoaXMuX21hcmtSZW1vdmUob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIXRhcmdldFBhcmVudEluc2VydGVkKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya0luc2VydChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24uZ2V0TW92ZWRSYW5nZVN0YXJ0KCkub2Zmc2V0LCBvcGVyYXRpb24uaG93TWFueSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICBjYXNlICdyZW5hbWUnOgogICAgICAgICAgewogICAgICAgICAgICBpZiAodGhpcy5faXNJbkluc2VydGVkRWxlbWVudChvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50KSkgewogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24ucG9zaXRpb24ub2Zmc2V0LCAxKTsKCiAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLnBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnBvc2l0aW9uLm9mZnNldCwgMSk7CgogICAgICAgICAgICB2YXIgcmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQob3BlcmF0aW9uLnBvc2l0aW9uLCAxKTsKCiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7CiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHRoaXMuX21hcmtlckNvbGxlY3Rpb24uZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlKHJhbmdlKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgICAgICAgIHZhciBtYXJrZXJSYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICAgICAgICAgICAgdGhpcy5idWZmZXJNYXJrZXJDaGFuZ2UobWFya2VyLm5hbWUsIG1hcmtlclJhbmdlLCBtYXJrZXJSYW5nZSwgbWFya2VyLmFmZmVjdHNEYXRhKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyOwogICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykgewogICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSAnc3BsaXQnOgogICAgICAgICAgewogICAgICAgICAgICB2YXIgc3BsaXRFbGVtZW50ID0gb3BlcmF0aW9uLnNwbGl0UG9zaXRpb24ucGFyZW50OyAvLyBNYXJrIHRoYXQgY2hpbGRyZW4gb2YgdGhlIHNwbGl0IGVsZW1lbnQgd2VyZSByZW1vdmVkLgoKICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KHNwbGl0RWxlbWVudCkpIHsKICAgICAgICAgICAgICB0aGlzLl9tYXJrUmVtb3ZlKHNwbGl0RWxlbWVudCwgb3BlcmF0aW9uLnNwbGl0UG9zaXRpb24ub2Zmc2V0LCBvcGVyYXRpb24uaG93TWFueSk7CiAgICAgICAgICAgIH0gLy8gTWFyayB0aGF0IHRoZSBuZXcgZWxlbWVudCAoc3BsaXQgY29weSkgd2FzIGluc2VydGVkLgoKCiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbkluc2VydGVkRWxlbWVudChvcGVyYXRpb24uaW5zZXJ0aW9uUG9zaXRpb24ucGFyZW50KSkgewogICAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLm9mZnNldCwgMSk7CiAgICAgICAgICAgIH0gLy8gSWYgdGhlIHNwbGl0IHRvb2sgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZ3JhdmV5YXJkLCBtYXJrIHRoYXQgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZ3JhdmV5YXJkIHdhcyByZW1vdmVkLgoKCiAgICAgICAgICAgIGlmIChvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgICAgICAgICB0aGlzLl9tYXJrUmVtb3ZlKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXJlbnQsIG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5vZmZzZXQsIDEpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSAnbWVyZ2UnOgogICAgICAgICAgewogICAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIG1lcmdlZCBlbGVtZW50IHdhcyByZW1vdmVkLgogICAgICAgICAgICB2YXIgbWVyZ2VkRWxlbWVudCA9IG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQobWVyZ2VkRWxlbWVudC5wYXJlbnQpKSB7CiAgICAgICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShtZXJnZWRFbGVtZW50LnBhcmVudCwgbWVyZ2VkRWxlbWVudC5zdGFydE9mZnNldCwgMSk7CiAgICAgICAgICAgIH0gLy8gTWFyayB0aGF0IHRoZSBtZXJnZWQgZWxlbWVudCB3YXMgaW5zZXJ0ZWQgaW50byBncmF2ZXlhcmQuCgoKICAgICAgICAgICAgdmFyIGdyYXZleWFyZFBhcmVudCA9IG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KGdyYXZleWFyZFBhcmVudCwgb3BlcmF0aW9uLmdyYXZleWFyZFBvc2l0aW9uLm9mZnNldCwgMSk7IC8vIE1hcmsgdGhhdCBjaGlsZHJlbiBvZiBtZXJnZWQgZWxlbWVudCB3ZXJlIGluc2VydGVkIGF0IG5ldyBwYXJlbnQuCgoKICAgICAgICAgICAgdmFyIG1lcmdlZEludG9FbGVtZW50ID0gb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uLnBhcmVudDsKCiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbkluc2VydGVkRWxlbWVudChtZXJnZWRJbnRvRWxlbWVudCkpIHsKICAgICAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KG1lcmdlZEludG9FbGVtZW50LCBvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ub2Zmc2V0LCBtZXJnZWRFbGVtZW50Lm1heE9mZnNldCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICB9IC8vIENsZWFyIGNhY2hlIGFmdGVyIGVhY2ggYnVmZmVyZWQgb3BlcmF0aW9uIGFzIGl0IGlzIG5vIGxvbmdlciB2YWxpZC4KCgogICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQnVmZmVycyBhIG1hcmtlciBjaGFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcmtlck5hbWUgVGhlIG5hbWUgb2YgdGhlIG1hcmtlciB0aGF0IGNoYW5nZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gb2xkUmFuZ2UgTWFya2VyIHJhbmdlIGJlZm9yZSB0aGUgY2hhbmdlIG9yIGBudWxsYCBpZiB0aGUgbWFya2VyIGhhcyBqdXN0CiAgICAgKiBiZWVuIGNyZWF0ZWQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gbmV3UmFuZ2UgTWFya2VyIHJhbmdlIGFmdGVyIHRoZSBjaGFuZ2Ugb3IgYG51bGxgIGlmIHRoZSBtYXJrZXIgd2FzIHJlbW92ZWQuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFmZmVjdHNEYXRhIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIG1hcmtlciBhZmZlY3RzIHRoZSBlZGl0b3IgZGF0YS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJidWZmZXJNYXJrZXJDaGFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGJ1ZmZlck1hcmtlckNoYW5nZShtYXJrZXJOYW1lLCBvbGRSYW5nZSwgbmV3UmFuZ2UsIGFmZmVjdHNEYXRhKSB7CiAgICAgIHZhciBidWZmZXJlZCA9IHRoaXMuX2NoYW5nZWRNYXJrZXJzLmdldChtYXJrZXJOYW1lKTsKCiAgICAgIGlmICghYnVmZmVyZWQpIHsKICAgICAgICB0aGlzLl9jaGFuZ2VkTWFya2Vycy5zZXQobWFya2VyTmFtZSwgewogICAgICAgICAgb2xkUmFuZ2U6IG9sZFJhbmdlLAogICAgICAgICAgbmV3UmFuZ2U6IG5ld1JhbmdlLAogICAgICAgICAgYWZmZWN0c0RhdGE6IGFmZmVjdHNEYXRhCiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnVmZmVyZWQubmV3UmFuZ2UgPSBuZXdSYW5nZTsKICAgICAgICBidWZmZXJlZC5hZmZlY3RzRGF0YSA9IGFmZmVjdHNEYXRhOwoKICAgICAgICBpZiAoYnVmZmVyZWQub2xkUmFuZ2UgPT0gbnVsbCAmJiBidWZmZXJlZC5uZXdSYW5nZSA9PSBudWxsKSB7CiAgICAgICAgICAvLyBUaGUgbWFya2VyIGlzIGdvaW5nIHRvIGJlIHJlbW92ZWQgKGBuZXdSYW5nZSA9PSBudWxsYCkgYnV0IGl0IGRpZCBub3QgZXhpc3QgYmVmb3JlIHRoZSBmaXJzdCBidWZmZXJlZCBjaGFuZ2UKICAgICAgICAgIC8vIChgYnVmZmVyZWQub2xkUmFuZ2UgPT0gbnVsbGApLiBJbiB0aGlzIGNhc2UsIGRvIG5vdCBrZWVwIHRoZSBtYXJrZXIgaW4gYnVmZmVyIGF0IGFsbC4KICAgICAgICAgIHRoaXMuX2NoYW5nZWRNYXJrZXJzLmRlbGV0ZShtYXJrZXJOYW1lKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgbWFya2VycyB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFzIGEgcmVzdWx0IG9mIGJ1ZmZlcmVkIGNoYW5nZXMuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fSBNYXJrZXJzIHRvIHJlbW92ZS4gRWFjaCBhcnJheSBpdGVtIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbmFtZWAgYW5kIGByYW5nZWAgcHJvcGVydGllcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRNYXJrZXJzVG9SZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnNUb1JlbW92ZSgpIHsKICAgICAgdmFyIHJlc3VsdCA9IFtdOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSB0aGlzLl9jaGFuZ2VkTWFya2Vyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNC52YWx1ZSwgMiksCiAgICAgICAgICAgICAgbmFtZSA9IF9zdGVwNCR2YWx1ZVswXSwKICAgICAgICAgICAgICBjaGFuZ2UgPSBfc3RlcDQkdmFsdWVbMV07CgogICAgICAgICAgaWYgKGNoYW5nZS5vbGRSYW5nZSAhPSBudWxsKSB7CiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsKICAgICAgICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgICAgICAgIHJhbmdlOiBjaGFuZ2Uub2xkUmFuZ2UKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgbWFya2VycyB3aGljaCBzaG91bGQgYmUgYWRkZWQgYXMgYSByZXN1bHQgb2YgYnVmZmVyZWQgY2hhbmdlcy4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59IE1hcmtlcnMgdG8gYWRkLiBFYWNoIGFycmF5IGl0ZW0gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBuYW1lYCBhbmQgYHJhbmdlYCBwcm9wZXJ0aWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE1hcmtlcnNUb0FkZCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2Vyc1RvQWRkKCkgewogICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjUgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IHRoaXMuX2NoYW5nZWRNYXJrZXJzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSwKICAgICAgICAgICAgICBuYW1lID0gX3N0ZXA1JHZhbHVlWzBdLAogICAgICAgICAgICAgIGNoYW5nZSA9IF9zdGVwNSR2YWx1ZVsxXTsKCiAgICAgICAgICBpZiAoY2hhbmdlLm5ld1JhbmdlICE9IG51bGwpIHsKICAgICAgICAgICAgcmVzdWx0LnB1c2goewogICAgICAgICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgICAgICAgcmFuZ2U6IGNoYW5nZS5uZXdSYW5nZQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFsbCBtYXJrZXJzIHdoaWNoIGNoYW5nZWQuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENoYW5nZWRNYXJrZXJzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGFuZ2VkTWFya2VycygpIHsKICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY2hhbmdlZE1hcmtlcnMpLm1hcChmdW5jdGlvbiAoaXRlbSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBuYW1lOiBpdGVtWzBdLAogICAgICAgICAgZGF0YTogewogICAgICAgICAgICBvbGRSYW5nZTogaXRlbVsxXS5vbGRSYW5nZSwKICAgICAgICAgICAgbmV3UmFuZ2U6IGl0ZW1bMV0ubmV3UmFuZ2UKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9KTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgc29tZSBvZiB0aGUgYnVmZmVyZWQgY2hhbmdlcyBhZmZlY3QgdGhlIGVkaXRvciBkYXRhLgogICAgICoKICAgICAqIFR5cGVzIG9mIGNoYW5nZXMgd2hpY2ggYWZmZWN0IHRoZSBlZGl0b3IgZGF0YToKICAgICAqCiAgICAgKiAqIG1vZGVsIHN0cnVjdHVyZSBjaGFuZ2VzLAogICAgICogKiBhdHRyaWJ1dGUgY2hhbmdlcywKICAgICAqICogY2hhbmdlcyBvZiBtYXJrZXJzIHdoaWNoIHdlcmUgZGVmaW5lZCBhcyBgYWZmZWN0aW5nRGF0YWAuCiAgICAgKgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaGFzRGF0YUNoYW5nZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0RhdGFDaGFuZ2VzKCkgewogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSB0aGlzLl9jaGFuZ2VkTWFya2Vyc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksCiAgICAgICAgICAgICAgY2hhbmdlID0gX3N0ZXA2JHZhbHVlWzFdOwoKICAgICAgICAgIGlmIChjaGFuZ2UuYWZmZWN0c0RhdGEpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBJZiBtYXJrZXJzIGRvIG5vdCBhZmZlY3QgdGhlIGRhdGEsIGNoZWNrIHdoZXRoZXIgdGhlcmUgYXJlIHNvbWUgY2hhbmdlcyBpbiBlbGVtZW50cy4KCiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yNiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5zaXplID4gMDsKICAgIH0KICAgIC8qKgogICAgICogQ2FsY3VsYXRlcyB0aGUgZGlmZiBiZXR3ZWVuIHRoZSBvbGQgbW9kZWwgdHJlZSBzdGF0ZSAodGhlIHN0YXRlIGJlZm9yZSB0aGUgZmlyc3QgYnVmZmVyZWQgb3BlcmF0aW9ucyBzaW5jZSB0aGUgbGFzdCB7QGxpbmsgI3Jlc2V0fQogICAgICogY2FsbCkgYW5kIHRoZSBuZXcgbW9kZWwgdHJlZSBzdGF0ZSAoYWN0dWFsIG9uZSkuIEl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIGJ1ZmZlcmVkIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkLgogICAgICoKICAgICAqIFRoZSBkaWZmIHNldCBpcyByZXR1cm5lZCBhcyBhbiBhcnJheSBvZiBkaWZmIGl0ZW1zLCBlYWNoIGRlc2NyaWJpbmcgYSBjaGFuZ2UgZG9uZSBvbiB0aGUgbW9kZWwuIFRoZSBpdGVtcyBhcmUgc29ydGVkIGJ5CiAgICAgKiB0aGUgcG9zaXRpb24gb24gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC4gSWYgYSBwb3NpdGlvbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc0JlZm9yZSBpcyBiZWZvcmV9CiAgICAgKiBhbm90aGVyIG9uZSwgaXQgd2lsbCBiZSBvbiBhbiBlYXJsaWVyIGluZGV4IGluIHRoZSBkaWZmIHNldC4KICAgICAqCiAgICAgKiBCZWNhdXNlIGNhbGN1bGF0aW5nIHRoZSBkaWZmIGlzIGEgY29zdGx5IG9wZXJhdGlvbiwgdGhlIHJlc3VsdCBpcyBjYWNoZWQuIElmIG5vIG5ldyBvcGVyYXRpb24gd2FzIGJ1ZmZlcmVkIHNpbmNlIHRoZQogICAgICogcHJldmlvdXMge0BsaW5rICNnZXRDaGFuZ2VzfSBjYWxsLCB0aGUgbmV4dCBjYWxsIHdpbGwgcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWUuCiAgICAgKgogICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkPWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgLCBhbHNvIGNoYW5nZXMgdGhhdCBoYXBwZW5lZAogICAgICogaW4gdGhlIGdyYXZleWFyZCByb290IHdpbGwgYmUgcmV0dXJuZWQuIEJ5IGRlZmF1bHQsIGNoYW5nZXMgaW4gdGhlIGdyYXZleWFyZCByb290IGFyZSBub3QgcmV0dXJuZWQuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59IERpZmYgYmV0d2VlbiB0aGUgb2xkIGFuZCB0aGUgbmV3IG1vZGVsIHRyZWUgc3RhdGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbmdlcygpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsKICAgICAgICBpbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkOiBmYWxzZQogICAgICB9OwoKICAgICAgLy8gSWYgdGhlcmUgYXJlIGNhY2hlZCBjaGFuZ2VzLCBqdXN0IHJldHVybiB0aGVtIGluc3RlYWQgb2YgY2FsY3VsYXRpbmcgY2hhbmdlcyBhZ2Fpbi4KICAgICAgaWYgKHRoaXMuX2NhY2hlZENoYW5nZXMpIHsKICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkKSB7CiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQuc2xpY2UoKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXMuc2xpY2UoKTsKICAgICAgICB9CiAgICAgIH0gLy8gV2lsbCBjb250YWluIHJldHVybmVkIHJlc3VsdHMuCgoKICAgICAgdmFyIGRpZmZTZXQgPSBbXTsgLy8gQ2hlY2sgYWxsIGNoYW5nZWQgZWxlbWVudHMuCgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I3ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjcgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IChfc3RlcDcgPSBfaXRlcmF0b3I3Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGVsZW1lbnQgPSBfc3RlcDcudmFsdWU7CgogICAgICAgICAgLy8gR2V0IGNoYW5nZXMgZm9yIHRoaXMgZWxlbWVudCBhbmQgc29ydCB0aGVtLgogICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmdldChlbGVtZW50KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgICAgIGlmIChhLm9mZnNldCA9PT0gYi5vZmZzZXQpIHsKICAgICAgICAgICAgICBpZiAoYS50eXBlICE9IGIudHlwZSkgewogICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNoYW5nZXMgYXQgdGhlIHNhbWUgcG9zaXRpb24sICJyZW1vdmUiIGNoYW5nZSBzaG91bGQgYmUgZmlyc3QuCiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3JkZXIgaXMgZGlmZmVyZW50LCBmb3IgZXhhbXBsZSwgd2Ugd291bGQgZmlyc3QgYWRkIHNvbWUgbm9kZXMgYW5kIHRoZW4gcmVtb3ZlZCB0aGVtCiAgICAgICAgICAgICAgICAvLyAoaW5zdGVhZCBvZiB0aGUgbm9kZXMgdGhhdCB3ZSBzaG91bGQgcmVtb3ZlKS4KICAgICAgICAgICAgICAgIHJldHVybiBhLnR5cGUgPT0gJ3JlbW92ZScgPyAtMSA6IDE7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIGEub2Zmc2V0IDwgYi5vZmZzZXQgPyAtMSA6IDE7CiAgICAgICAgICB9KTsgLy8gR2V0IGNoaWxkcmVuIG9mIHRoaXMgZWxlbWVudCBiZWZvcmUgYW55IGNoYW5nZSB3YXMgYXBwbGllZCBvbiBpdC4KCgogICAgICAgICAgdmFyIHNuYXBzaG90Q2hpbGRyZW4gPSB0aGlzLl9lbGVtZW50U25hcHNob3RzLmdldChlbGVtZW50KTsgLy8gR2V0IHNuYXBzaG90IG9mIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuLgoKCiAgICAgICAgICB2YXIgZWxlbWVudENoaWxkcmVuID0gX2dldENoaWxkcmVuU25hcHNob3QoZWxlbWVudC5nZXRDaGlsZHJlbigpKTsgLy8gR2VuZXJhdGUgYWN0aW9ucyBiYXNpbmcgb24gY2hhbmdlcyBkb25lIG9uIGVsZW1lbnQuCgoKICAgICAgICAgIHZhciBhY3Rpb25zID0gX2dlbmVyYXRlQWN0aW9uc0Zyb21DaGFuZ2VzKHNuYXBzaG90Q2hpbGRyZW4ubGVuZ3RoLCBjaGFuZ2VzKTsKCiAgICAgICAgICB2YXIgX2kyID0gMDsgLy8gSXRlcmF0b3IgaW4gYGVsZW1lbnRDaGlsZHJlbmAgYXJyYXkgLS0gaXRlcmF0ZXMgdGhyb3VnaCBjdXJyZW50IGNoaWxkcmVuIG9mIGVsZW1lbnQuCgogICAgICAgICAgdmFyIGogPSAwOyAvLyBJdGVyYXRvciBpbiBgc25hcHNob3RDaGlsZHJlbmAgYXJyYXkgLS0gaXRlcmF0ZXMgdGhyb3VnaCBvbGQgY2hpbGRyZW4gb2YgZWxlbWVudC4KICAgICAgICAgIC8vIFByb2Nlc3MgZXZlcnkgYWN0aW9uLgoKICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWU7CiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I4ID0gZmFsc2U7CiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkOwoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjggPSBhY3Rpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA4OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gKF9zdGVwOCA9IF9pdGVyYXRvcjgubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSB0cnVlKSB7CiAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9zdGVwOC52YWx1ZTsKCiAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2knKSB7CiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBkaWZmIGl0ZW0gZm9yIHRoaXMgZWxlbWVudCBhbmQgaW5zZXJ0IGl0IGludG8gdGhlIGRpZmYgc2V0LgogICAgICAgICAgICAgICAgZGlmZlNldC5wdXNoKHRoaXMuX2dldEluc2VydERpZmYoZWxlbWVudCwgX2kyLCBlbGVtZW50Q2hpbGRyZW5bX2kyXS5uYW1lKSk7CiAgICAgICAgICAgICAgICBfaTIrKzsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3InKSB7CiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBkaWZmIGl0ZW0gZm9yIHRoaXMgZWxlbWVudCBhbmQgaW5zZXJ0IGl0IGludG8gdGhlIGRpZmYgc2V0LgogICAgICAgICAgICAgICAgZGlmZlNldC5wdXNoKHRoaXMuX2dldFJlbW92ZURpZmYoZWxlbWVudCwgX2kyLCBzbmFwc2hvdENoaWxkcmVuW2pdLm5hbWUpKTsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2EnKSB7CiAgICAgICAgICAgICAgICAvLyBUYWtlIGF0dHJpYnV0ZXMgZnJvbSBzYXZlZCBhbmQgY3VycmVudCBjaGlsZHJlbi4KICAgICAgICAgICAgICAgIHZhciBlbGVtZW50QXR0cmlidXRlcyA9IGVsZW1lbnRDaGlsZHJlbltfaTJdLmF0dHJpYnV0ZXM7CiAgICAgICAgICAgICAgICB2YXIgc25hcHNob3RBdHRyaWJ1dGVzID0gc25hcHNob3RDaGlsZHJlbltqXS5hdHRyaWJ1dGVzOwogICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdm9pZCAwOwoKICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Q2hpbGRyZW5bX2kyXS5uYW1lID09ICckdGV4dCcpIHsKICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIF9pMiksIFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCBfaTIgKyAxKSk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlbGVtZW50Lm9mZnNldFRvSW5kZXgoX2kyKTsKICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIF9pMiksIFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LmdldENoaWxkKGluZGV4KSwgMCkpOwogICAgICAgICAgICAgICAgfSAvLyBHZW5lcmF0ZSBkaWZmIGl0ZW1zIGZvciB0aGlzIGNoYW5nZSAodGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgYXR0cmlidXRlcyBjaGFuZ2VkIGFuZAogICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBzaW5nbGUgZGlmZiBmb3IgZWFjaCBvZiB0aGVtKSBhbmQgaW5zZXJ0IHRoZW0gaW50byB0aGUgZGlmZiBzZXQuCgoKICAgICAgICAgICAgICAgIGRpZmZTZXQucHVzaC5hcHBseShkaWZmU2V0LCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fZ2V0QXR0cmlidXRlc0RpZmYocmFuZ2UsIHNuYXBzaG90QXR0cmlidXRlcywgZWxlbWVudEF0dHJpYnV0ZXMpKSk7CiAgICAgICAgICAgICAgICBfaTIrKzsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gYGFjdGlvbmAgaXMgJ2VxdWFsJy4gQ2hpbGQgbm90IGNoYW5nZWQuCiAgICAgICAgICAgICAgICBfaTIrKzsKICAgICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjggPSB0cnVlOwogICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjggPSBlcnI7CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggJiYgX2l0ZXJhdG9yOC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yOC5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yOCkgewogICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gLy8gVGhlbiwgc29ydCB0aGUgY2hhbmdlcyBieSB0aGUgcG9zaXRpb24gKGNoYW5nZSBhdCBwb3NpdGlvbiBiZWZvcmUgb3RoZXIgY2hhbmdlcyBpcyBmaXJzdCkuCgogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjcucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I3OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgZGlmZlNldC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbiBkaWZmZXJlbnQgcm9vdCwgd2UgZG9uJ3QgY2FyZSBtdWNoLCBidXQgd2UnZCBsaWtlIHRvIGhhdmUgYWxsIGNoYW5nZXMgaW4gZ2l2ZW4KICAgICAgICAvLyByb290ICJ0b2dldGhlciIgaW4gdGhlIGFycmF5LiBTbyBsZXQncyBqdXN0IHNvcnQgdGhlbSBieSB0aGUgcm9vdCBuYW1lLiBJdCBkb2VzIG5vdCBtYXR0ZXIgd2hpY2ggcm9vdAogICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGZpcnN0LgogICAgICAgIGlmIChhLnBvc2l0aW9uLnJvb3QgIT0gYi5wb3NpdGlvbi5yb290KSB7CiAgICAgICAgICByZXR1cm4gYS5wb3NpdGlvbi5yb290LnJvb3ROYW1lIDwgYi5wb3NpdGlvbi5yb290LnJvb3ROYW1lID8gLTEgOiAxOwogICAgICAgIH0gLy8gSWYgY2hhbmdlIGhhcHBlbnMgYXQgdGhlIHNhbWUgcG9zaXRpb24uLi4KCgogICAgICAgIGlmIChhLnBvc2l0aW9uLmlzRXF1YWwoYi5wb3NpdGlvbikpIHsKICAgICAgICAgIC8vIEtlZXAgY2hyb25vbG9naWNhbCBvcmRlciBvZiBvcGVyYXRpb25zLgogICAgICAgICAgcmV0dXJuIGEuY2hhbmdlQ291bnQgLSBiLmNoYW5nZUNvdW50OwogICAgICAgIH0gLy8gSWYgcG9zaXRpb25zIGRpZmZlciwgcG9zaXRpb24gIm9uIHRoZSBsZWZ0IiBzaG91bGQgYmUgZWFybGllciBpbiB0aGUgcmVzdWx0LgoKCiAgICAgICAgcmV0dXJuIGEucG9zaXRpb24uaXNCZWZvcmUoYi5wb3NpdGlvbikgPyAtMSA6IDE7CiAgICAgIH0pOyAvLyBHbHVlIHRvZ2V0aGVyIG11bHRpcGxlIGNoYW5nZXMgKG1vc3RseSBvbiB0ZXh0IG5vZGVzKS4KCiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGlmZlNldC5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBwcmV2RGlmZiA9IGRpZmZTZXRbaSAtIDFdOwogICAgICAgIHZhciB0aGlzRGlmZiA9IGRpZmZTZXRbaV07IC8vIEdsdWUgcmVtb3ZlIGNoYW5nZXMgaWYgdGhleSBoYXBwZW4gb24gdGV4dCBvbiBzYW1lIHBvc2l0aW9uLgoKICAgICAgICB2YXIgaXNDb25zZWN1dGl2ZVRleHRSZW1vdmUgPSBwcmV2RGlmZi50eXBlID09ICdyZW1vdmUnICYmIHRoaXNEaWZmLnR5cGUgPT0gJ3JlbW92ZScgJiYgcHJldkRpZmYubmFtZSA9PSAnJHRleHQnICYmIHRoaXNEaWZmLm5hbWUgPT0gJyR0ZXh0JyAmJiBwcmV2RGlmZi5wb3NpdGlvbi5pc0VxdWFsKHRoaXNEaWZmLnBvc2l0aW9uKTsgLy8gR2x1ZSBpbnNlcnQgY2hhbmdlcyBpZiB0aGV5IGhhcHBlbiBvbiB0ZXh0IG9uIGNvbnNlY3V0aXZlIGZyYWdtZW50cy4KCiAgICAgICAgdmFyIGlzQ29uc2VjdXRpdmVUZXh0QWRkID0gcHJldkRpZmYudHlwZSA9PSAnaW5zZXJ0JyAmJiB0aGlzRGlmZi50eXBlID09ICdpbnNlcnQnICYmIHByZXZEaWZmLm5hbWUgPT0gJyR0ZXh0JyAmJiB0aGlzRGlmZi5uYW1lID09ICckdGV4dCcgJiYgcHJldkRpZmYucG9zaXRpb24ucGFyZW50ID09IHRoaXNEaWZmLnBvc2l0aW9uLnBhcmVudCAmJiBwcmV2RGlmZi5wb3NpdGlvbi5vZmZzZXQgKyBwcmV2RGlmZi5sZW5ndGggPT0gdGhpc0RpZmYucG9zaXRpb24ub2Zmc2V0OyAvLyBHbHVlIGF0dHJpYnV0ZSBjaGFuZ2VzIGlmIHRoZXkgaGFwcGVuIG9uIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhbmQgaGF2ZSBzYW1lIGtleSwgb2xkIHZhbHVlIGFuZCBuZXcgdmFsdWUuCgogICAgICAgIHZhciBpc0NvbnNlY3V0aXZlQXR0cmlidXRlQ2hhbmdlID0gcHJldkRpZmYudHlwZSA9PSAnYXR0cmlidXRlJyAmJiB0aGlzRGlmZi50eXBlID09ICdhdHRyaWJ1dGUnICYmIHByZXZEaWZmLnBvc2l0aW9uLnBhcmVudCA9PSB0aGlzRGlmZi5wb3NpdGlvbi5wYXJlbnQgJiYgcHJldkRpZmYucmFuZ2UuaXNGbGF0ICYmIHRoaXNEaWZmLnJhbmdlLmlzRmxhdCAmJiBwcmV2RGlmZi5wb3NpdGlvbi5vZmZzZXQgKyBwcmV2RGlmZi5sZW5ndGggPT0gdGhpc0RpZmYucG9zaXRpb24ub2Zmc2V0ICYmIHByZXZEaWZmLmF0dHJpYnV0ZUtleSA9PSB0aGlzRGlmZi5hdHRyaWJ1dGVLZXkgJiYgcHJldkRpZmYuYXR0cmlidXRlT2xkVmFsdWUgPT0gdGhpc0RpZmYuYXR0cmlidXRlT2xkVmFsdWUgJiYgcHJldkRpZmYuYXR0cmlidXRlTmV3VmFsdWUgPT0gdGhpc0RpZmYuYXR0cmlidXRlTmV3VmFsdWU7CgogICAgICAgIGlmIChpc0NvbnNlY3V0aXZlVGV4dFJlbW92ZSB8fCBpc0NvbnNlY3V0aXZlVGV4dEFkZCB8fCBpc0NvbnNlY3V0aXZlQXR0cmlidXRlQ2hhbmdlKSB7CiAgICAgICAgICBkaWZmU2V0W2kgLSAxXS5sZW5ndGgrKzsKCiAgICAgICAgICBpZiAoaXNDb25zZWN1dGl2ZUF0dHJpYnV0ZUNoYW5nZSkgewogICAgICAgICAgICBkaWZmU2V0W2kgLSAxXS5yYW5nZS5lbmQgPSBkaWZmU2V0W2kgLSAxXS5yYW5nZS5lbmQuZ2V0U2hpZnRlZEJ5KDEpOwogICAgICAgICAgfQoKICAgICAgICAgIGRpZmZTZXQuc3BsaWNlKGksIDEpOwogICAgICAgICAgaS0tOwogICAgICAgIH0KICAgICAgfSAvLyBSZW1vdmUgYGNoYW5nZUNvdW50YCBwcm9wZXJ0eSBmcm9tIGRpZmYgaXRlbXMuIEl0IGlzIHVzZWQgb25seSBmb3Igc29ydGluZyBhbmQgaXMgaW50ZXJuYWwgdGhpbmcuCgoKICAgICAgZm9yICh2YXIgX2kgPSAwLCBfZGlmZlNldCA9IGRpZmZTZXQ7IF9pIDwgX2RpZmZTZXQubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgdmFyIGl0ZW0gPSBfZGlmZlNldFtfaV07CiAgICAgICAgZGVsZXRlIGl0ZW0uY2hhbmdlQ291bnQ7CgogICAgICAgIGlmIChpdGVtLnR5cGUgPT0gJ2F0dHJpYnV0ZScpIHsKICAgICAgICAgIGRlbGV0ZSBpdGVtLnBvc2l0aW9uOwogICAgICAgICAgZGVsZXRlIGl0ZW0ubGVuZ3RoOwogICAgICAgIH0KICAgICAgfQoKICAgICAgdGhpcy5fY2hhbmdlQ291bnQgPSAwOyAvLyBDYWNoZSBjaGFuZ2VzLgoKICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQgPSBkaWZmU2V0LnNsaWNlKCk7CiAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBkaWZmU2V0LnNsaWNlKCkuZmlsdGVyKF9jaGFuZ2VzSW5HcmF2ZXlhcmRGaWx0ZXIpOwoKICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUNoYW5nZXNJbkdyYXZleWFyZCkgewogICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzV2l0aEdyYXZleWFyZDsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ2hhbmdlczsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXNldHMgYERpZmZlcmAuIFJlbW92ZXMgYWxsIGJ1ZmZlcmVkIGNoYW5nZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkgewogICAgICB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmNsZWFyKCk7CgogICAgICB0aGlzLl9lbGVtZW50U25hcHNob3RzLmNsZWFyKCk7CgogICAgICB0aGlzLl9jaGFuZ2VkTWFya2Vycy5jbGVhcigpOwoKICAgICAgdGhpcy5fY2FjaGVkQ2hhbmdlcyA9IG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIFNhdmVzIGFuZCBoYW5kbGVzIGFuIGluc2VydCBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWFya0luc2VydCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21hcmtJbnNlcnQocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpIHsKICAgICAgdmFyIGNoYW5nZUl0ZW0gPSB7CiAgICAgICAgdHlwZTogJ2luc2VydCcsCiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsCiAgICAgICAgaG93TWFueTogaG93TWFueSwKICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9OwoKICAgICAgdGhpcy5fbWFya0NoYW5nZShwYXJlbnQsIGNoYW5nZUl0ZW0pOwogICAgfQogICAgLyoqCiAgICAgKiBTYXZlcyBhbmQgaGFuZGxlcyBhIHJlbW92ZSBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWFya1JlbW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21hcmtSZW1vdmUocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpIHsKICAgICAgdmFyIGNoYW5nZUl0ZW0gPSB7CiAgICAgICAgdHlwZTogJ3JlbW92ZScsCiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsCiAgICAgICAgaG93TWFueTogaG93TWFueSwKICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9OwoKICAgICAgdGhpcy5fbWFya0NoYW5nZShwYXJlbnQsIGNoYW5nZUl0ZW0pOwoKICAgICAgdGhpcy5fcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyhwYXJlbnQsIG9mZnNldCwgaG93TWFueSk7CiAgICB9CiAgICAvKioKICAgICAqIFNhdmVzIGFuZCBoYW5kbGVzIGFuIGF0dHJpYnV0ZSBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWFya0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21hcmtBdHRyaWJ1dGUoaXRlbSkgewogICAgICB2YXIgY2hhbmdlSXRlbSA9IHsKICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICBvZmZzZXQ6IGl0ZW0uc3RhcnRPZmZzZXQsCiAgICAgICAgaG93TWFueTogaXRlbS5vZmZzZXRTaXplLAogICAgICAgIGNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgIH07CgogICAgICB0aGlzLl9tYXJrQ2hhbmdlKGl0ZW0ucGFyZW50LCBjaGFuZ2VJdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogU2F2ZXMgYW5kIGhhbmRsZXMgYSBtb2RlbCBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZUl0ZW0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfbWFya0NoYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21hcmtDaGFuZ2UocGFyZW50LCBjaGFuZ2VJdGVtKSB7CiAgICAgIC8vIEZpcnN0LCBtYWtlIGEgc25hcHNob3Qgb2YgdGhpcyBwYXJlbnQncyBjaGlsZHJlbiAoaXQgd2lsbCBiZSBtYWRlIG9ubHkgaWYgaXQgd2FzIG5vdCBtYWRlIGJlZm9yZSkuCiAgICAgIHRoaXMuX21ha2VTbmFwc2hvdChwYXJlbnQpOyAvLyBUaGVuLCBnZXQgYWxsIGNoYW5nZXMgdGhhdCBhbHJlYWR5IHdlcmUgZG9uZSBvbiB0aGUgZWxlbWVudCAoZW1wdHkgYXJyYXkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgY2hhbmdlKS4KCgogICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2dldENoYW5nZXNGb3JFbGVtZW50KHBhcmVudCk7IC8vIFRoZW4sIGxvb2sgdGhyb3VnaCBhbGwgdGhlIGNoYW5nZXMsIGFuZCB0cmFuc2Zvcm0gdGhlbSBvciB0aGUgbmV3IGNoYW5nZS4KCgogICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoY2hhbmdlSXRlbSwgY2hhbmdlcyk7IC8vIEFkZCB0aGUgbmV3IGNoYW5nZS4KCgogICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlSXRlbSk7IC8vIFJlbW92ZSBpbmNvcnJlY3QgY2hhbmdlcy4gRHVyaW5nIHRyYW5zZm9ybWF0aW9uIHNvbWUgY2hhbmdlIG1pZ2h0IGJlLCBmb3IgZXhhbXBsZSwgaW5jbHVkZWQgaW4gYW5vdGhlci4KICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgY2hhbmdlIHdpbGwgaGF2ZSBgaG93TWFueWAgcHJvcGVydHkgc2V0IHRvIGAwYCBvciBsZXNzLiBXZSBuZWVkIHRvIHJlbW92ZSB0aG9zZSBjaGFuZ2VzLgoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgaWYgKGNoYW5nZXNbaV0uaG93TWFueSA8IDEpIHsKICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGksIDEpOwogICAgICAgICAgaS0tOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIGFuIGFycmF5IG9mIGNoYW5nZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBzYXZlZCBmb3IgYSBnaXZlbiBlbGVtZW50LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldENoYW5nZXNGb3JFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2hhbmdlc0ZvckVsZW1lbnQoZWxlbWVudCkgewogICAgICB2YXIgY2hhbmdlczsKCiAgICAgIGlmICh0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmhhcyhlbGVtZW50KSkgewogICAgICAgIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmdldChlbGVtZW50KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjaGFuZ2VzID0gW107CgogICAgICAgIHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuc2V0KGVsZW1lbnQsIGNoYW5nZXMpOwogICAgICB9CgogICAgICByZXR1cm4gY2hhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogU2F2ZXMgYSBjaGlsZHJlbiBzbmFwc2hvdCBmb3IgYSBnaXZlbiBlbGVtZW50LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21ha2VTbmFwc2hvdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTbmFwc2hvdChlbGVtZW50KSB7CiAgICAgIGlmICghdGhpcy5fZWxlbWVudFNuYXBzaG90cy5oYXMoZWxlbWVudCkpIHsKICAgICAgICB0aGlzLl9lbGVtZW50U25hcHNob3RzLnNldChlbGVtZW50LCBfZ2V0Q2hpbGRyZW5TbmFwc2hvdChlbGVtZW50LmdldENoaWxkcmVuKCkpKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBGb3IgYSBnaXZlbiBuZXdseSBzYXZlZCBjaGFuZ2UsIGNvbXBhcmVzIGl0IHdpdGggYSBjaGFuZ2UgYWxyZWFkeSBkb25lIG9uIHRoZSBlbGVtZW50IGFuZCBtb2RpZmllcyB0aGUgaW5jb21pbmcKICAgICAqIGNoYW5nZSBhbmQvb3IgdGhlIG9sZCBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmMgSW5jb21pbmcgKG5ldykgY2hhbmdlLgogICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY2hhbmdlcyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgY2hhbmdlcyBkb25lIG9uIHRoYXQgZWxlbWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfaGFuZGxlQ2hhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGluYywgY2hhbmdlcykgewogICAgICAvLyBXZSBuZWVkIGEgaGVscGVyIHZhcmlhYmxlIHRoYXQgd2lsbCBzdG9yZSBob3cgbWFueSBub2RlcyBhcmUgdG8gYmUgc3RpbGwgaGFuZGxlZCBmb3IgdGhpcyBjaGFuZ2UgaXRlbS4KICAgICAgLy8gYG5vZGVzVG9IYW5kbGVgIChob3cgbWFueSBub2RlcyBzdGlsbCBuZWVkIHRvIGJlIGhhbmRsZWQpIGFuZCBgaG93TWFueWAgKGhvdyBtYW55IG5vZGVzIHdlcmUgYWZmZWN0ZWQpCiAgICAgIC8vIG5lZWRzIHRvIGJlIGRpZmZlcmVudGlhdGVkLgogICAgICAvLwogICAgICAvLyBUaGlzIGNvbWVzIHVwIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGNoYW5nZXMgdGhhdCBhcmUgYWZmZWN0ZWQgYnkgYGluY2AgY2hhbmdlIGl0ZW0uCiAgICAgIC8vCiAgICAgIC8vIEZvciBleGFtcGxlOiBhc3N1bWUgdHdvIGluc2VydCBjaGFuZ2VzOiBgeyBvZmZzZXQ6IDIsIGhvd01hbnk6IDEgfWAgYW5kIGB7IG9mZnNldDogNSwgaG93TWFueTogMSB9YC4KICAgICAgLy8gQXNzdW1lIHRoYXQgYGluY2AgY2hhbmdlIGlzIHJlbW92ZSBgeyBvZmZzZXQ6IDIsIGhvd01hbnk6IDIsIG5vZGVzVG9IYW5kbGU6IDIgfWAuCiAgICAgIC8vCiAgICAgIC8vIFRoZW4sIHdlOgogICAgICAvLyAtICJmb3JnZXQiIGFib3V0IGZpcnN0IGluc2VydCBjaGFuZ2UgKGl0IGlzICJlYXRlbiIgYnkgcmVtb3ZlKSwKICAgICAgLy8gLSBiZWNhdXNlIG9mIHRoYXQsIGF0IHRoZSBlbmQgd2Ugd2lsbCB3YW50IHRvIHJlbW92ZSBvbmx5IG9uZSBub2RlIChgbm9kZXNUb0hhbmRsZSA9IDFgKSwKICAgICAgLy8gLSBidXQgc3RpbGwgd2UgaGF2ZSB0byBjaGFuZ2Ugb2Zmc2V0IG9mIHRoZSBzZWNvbmQgaW5zZXJ0IGNoYW5nZSBmcm9tIGA1YCB0byBgM2AhCiAgICAgIC8vCiAgICAgIC8vIFNvLCBgaG93TWFueWAgZG9lcyBub3QgY2hhbmdlIHRocm91Z2hvdXQgaXRlbXMgdHJhbnNmb3JtYXRpb24gYW5kIGtlZXBzIGluZm9ybWF0aW9uIGFib3V0IGhvdyBtYW55IG5vZGVzIHdlcmUgYWZmZWN0ZWQsCiAgICAgIC8vIHdoaWxlIGBub2Rlc1RvSGFuZGxlYCBtZWFucyBob3cgbWFueSBub2RlcyBuZWVkIHRvIGJlIGhhbmRsZWQgYWZ0ZXIgdGhlIGNoYW5nZSBpdGVtIGlzIHRyYW5zZm9ybWVkIGJ5IG90aGVyIGNoYW5nZXMuCiAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gaW5jLmhvd01hbnk7CiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yOSA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOSA9IGNoYW5nZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDk7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSAoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IHRydWUpIHsKICAgICAgICAgIHZhciBvbGQgPSBfc3RlcDkudmFsdWU7CiAgICAgICAgICB2YXIgaW5jRW5kID0gaW5jLm9mZnNldCArIGluYy5ob3dNYW55OwogICAgICAgICAgdmFyIG9sZEVuZCA9IG9sZC5vZmZzZXQgKyBvbGQuaG93TWFueTsKCiAgICAgICAgICBpZiAoaW5jLnR5cGUgPT0gJ2luc2VydCcpIHsKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgb2xkLm9mZnNldCArPSBpbmMuaG93TWFueTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ICs9IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPCBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0ICs9IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgb2xkLm9mZnNldCArPSBpbmMuaG93TWFueTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FzZSBpcyBtb3JlIGNvbXBsaWNhdGVkLCBiZWNhdXNlIGF0dHJpYnV0ZSBjaGFuZ2UgaGFzIHRvIGJlIHNwbGl0IGludG8gdHdvLgogICAgICAgICAgICAgICAgLy8gRXhhbXBsZSAoYXNzdW1lIHRoYXQgdXBwZXJjYXNlIGFuZCBsb3dlcmNhc2UgbGV0dGVycyBtZWFuIGRpZmZlcmVudCBhdHRyaWJ1dGVzKToKICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHN0YXRlOgkJYWJjeHl6CiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgY2hhbmdlOglhQkNYWXoKICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGluc2VydDoJCWFCQ2Zvb1hZegogICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgIC8vIENoYW5nZSByYW5nZXMgY2Fubm90IGludGVyc2VjdCBiZWNhdXNlIGVhY2ggaXRlbSBoYXMgdG8gYmUgZGVzY3JpYmVkIGV4YWN0bHkgKGl0IHdhcyBlaXRoZXIKICAgICAgICAgICAgICAgIC8vIG5vdCBjaGFuZ2VkLCBpbnNlcnRlZCwgcmVtb3ZlZCwgb3IgaXRzIGF0dHJpYnV0ZSB3YXMgY2hhbmdlZCkuIFRoYXQncyB3aHkgb2xkIGF0dHJpYnV0ZQogICAgICAgICAgICAgICAgLy8gY2hhbmdlIGhhcyB0byBiZSBzcGxpdCBhbmQgYm90aCBwYXJ0cyBoYXMgdG8gYmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGZyb20gbm93IG9uLgogICAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBvbGQuaG93TWFueTsKICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gaW5jLm9mZnNldCAtIG9sZC5vZmZzZXQ7IC8vIEFkZCB0aGUgc2Vjb25kIHBhcnQgb2YgYXR0cmlidXRlIGNoYW5nZSB0byB0aGUgYmVnaW5uaW5nIG9mIHByb2Nlc3NlZCBhcnJheSBzbyBpdCB3b24ndAogICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFnYWluIGluIHRoaXMgbG9vcC4KCiAgICAgICAgICAgICAgICBjaGFuZ2VzLnVuc2hpZnQoewogICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmNFbmQsCiAgICAgICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnkgLSBvbGQuaG93TWFueSwKICAgICAgICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGlmIChpbmMudHlwZSA9PSAncmVtb3ZlJykgewogICAgICAgICAgICBpZiAob2xkLnR5cGUgPT0gJ2luc2VydCcpIHsKICAgICAgICAgICAgICBpZiAoaW5jRW5kIDw9IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIG9sZC5vZmZzZXQgLT0gaW5jLmhvd01hbnk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNFbmQgPD0gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbkxlbmd0aCA9IGluY0VuZCAtIG9sZC5vZmZzZXQ7CiAgICAgICAgICAgICAgICAgIG9sZC5vZmZzZXQgPSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBpbnRlcnNlY3Rpb25MZW5ndGg7CiAgICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlIC09IGludGVyc2VjdGlvbkxlbmd0aDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChpbmMub2Zmc2V0IDw9IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgLT0gb2xkLmhvd01hbnk7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gMDsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZEVuZCkgewogICAgICAgICAgICAgICAgICB2YXIgX2ludGVyc2VjdGlvbkxlbmd0aCA9IG9sZEVuZCAtIGluYy5vZmZzZXQ7CgogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgaWYgKGluY0VuZCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0IC09IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlICs9IG9sZC5ob3dNYW55OwogICAgICAgICAgICAgICAgb2xkLmhvd01hbnkgPSAwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgICAgaWYgKGluY0VuZCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgICBvbGQub2Zmc2V0IC09IGluYy5ob3dNYW55OwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIHZhciBfaW50ZXJzZWN0aW9uTGVuZ3RoMiA9IGluY0VuZCAtIG9sZC5vZmZzZXQ7CgogICAgICAgICAgICAgICAgb2xkLm9mZnNldCA9IGluYy5vZmZzZXQ7CiAgICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBfaW50ZXJzZWN0aW9uTGVuZ3RoMjsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIGlmIChpbmNFbmQgPD0gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICAgIC8vIE9uIGZpcnN0IHNpZ2h0IGluIHRoaXMgY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHNwbGl0IGF0dHJpYnV0ZSBvcGVyYXRpb24gaW50byB0d28uCiAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhlIGNoYW5nZXMgc2V0IGlzIGxhdGVyIGNvbnZlcnRlZCB0byBhY3Rpb25zIChzZWUgYF9nZW5lcmF0ZUFjdGlvbnNGcm9tQ2hhbmdlc2ApLgogICAgICAgICAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24sIG5vIHR3byBjaGFuZ2VzIG1heSBpbnRlcnNlY3QuCiAgICAgICAgICAgICAgICAgIC8vIFNvIHdlIGNhbm5vdCBoYXZlIGFuIGF0dHJpYnV0ZSBjaGFuZ2UgdGhhdCAiY29udGFpbnMiIHJlbW92ZSBjaGFuZ2UuCiAgICAgICAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBjaGFuZ2UgbmVlZHMgdG8gYmUgc3BsaXQuCiAgICAgICAgICAgICAgICAgIHZhciBfaG93TWFueSA9IG9sZC5ob3dNYW55OwogICAgICAgICAgICAgICAgICBvbGQuaG93TWFueSA9IGluYy5vZmZzZXQgLSBvbGQub2Zmc2V0OwogICAgICAgICAgICAgICAgICB2YXIgaG93TWFueUFmdGVyID0gX2hvd01hbnkgLSBvbGQuaG93TWFueSAtIGluYy5ub2Rlc1RvSGFuZGxlOyAvLyBBZGQgdGhlIHNlY29uZCBwYXJ0IG9mIGF0dHJpYnV0ZSBjaGFuZ2UgdG8gdGhlIGJlZ2lubmluZyBvZiBwcm9jZXNzZWQgYXJyYXkgc28gaXQgd29uJ3QKICAgICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFnYWluIGluIHRoaXMgbG9vcC4KCiAgICAgICAgICAgICAgICAgIGNoYW5nZXMudW5zaGlmdCh7CiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmMub2Zmc2V0LAogICAgICAgICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnlBZnRlciwKICAgICAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IG9sZEVuZCAtIGluYy5vZmZzZXQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGluYy50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYXR0cmlidXRlIGNoYW5nZSwgYGhvd01hbnlgIHNob3VsZCBiZSBrZXB0IHNhbWUgYXMgYG5vZGVzVG9IYW5kbGVgLiBJdCdzIG5vdCBhbiBlcnJvci4KICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPCBvbGQub2Zmc2V0ICYmIGluY0VuZCA+IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgICAgIGlmIChpbmNFbmQgPiBvbGRFbmQpIHsKICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIHNpbWlsYXIgdG8gYSBjYXNlIGRlc2NyaWJlZCB3aGVuIGluY29taW5nIGNoYW5nZSB3YXMgaW5zZXJ0IGFuZCBvbGQgY2hhbmdlIHdhcyBhdHRyaWJ1dGUuCiAgICAgICAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLgogICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbWUgaW5jb21pbmcgY2hhbmdlIGlzIGF0dHJpYnV0ZS4gV2UgbmVlZCB0byBzcGxpdCBpbmNvbWluZyBjaGFuZ2UgaW4gdGhpcyBjYXNlIHRvby4KICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGlzIHRpbWUsIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgYXR0cmlidXRlIGNoYW5nZSBuZWVkcyB0byBiZSBwcm9jZXNzZWQgZnVydGhlcgogICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG90aGVyIGNoYW5nZXMgdGhhdCBpdCBjb2xsaWRlcyB3aXRoLgogICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlUGFydCA9IHsKICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9sZEVuZCwKICAgICAgICAgICAgICAgICAgICBob3dNYW55OiBpbmNFbmQgLSBvbGRFbmQsCiAgICAgICAgICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoYW5nZShhdHRyaWJ1dGVQYXJ0LCBjaGFuZ2VzKTsKCiAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChhdHRyaWJ1dGVQYXJ0KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IG9sZC5vZmZzZXQgLSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSBpbmMubm9kZXNUb0hhbmRsZTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPj0gb2xkLm9mZnNldCAmJiBpbmMub2Zmc2V0IDwgb2xkRW5kKSB7CiAgICAgICAgICAgICAgICBpZiAoaW5jRW5kID4gb2xkRW5kKSB7CiAgICAgICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gaW5jRW5kIC0gb2xkRW5kOwogICAgICAgICAgICAgICAgICBpbmMub2Zmc2V0ID0gb2xkRW5kOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNhc2Ugd2hlbiBhdHRyaWJ1dGUgY2hhbmdlICJjb250YWlucyIgcmVtb3ZlIGNoYW5nZS4KICAgICAgICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGNoYW5nZSBuZWVkcyB0byBiZSBzcGxpdCBpbnRvIHR3byBiZWNhdXNlIGNoYW5nZXMgY2Fubm90IGludGVyc2VjdC4KICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQgJiYgaW5jRW5kID4gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgICAgdmFyIF9hdHRyaWJ1dGVQYXJ0ID0gewogICAgICAgICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvbGQub2Zmc2V0LAogICAgICAgICAgICAgICAgICBob3dNYW55OiBpbmNFbmQgLSBvbGQub2Zmc2V0LAogICAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoX2F0dHJpYnV0ZVBhcnQsIGNoYW5nZXMpOwoKICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChfYXR0cmlidXRlUGFydCk7CiAgICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IG9sZC5vZmZzZXQgLSBpbmMub2Zmc2V0OwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSBpbmMubm9kZXNUb0hhbmRsZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChvbGQudHlwZSA9PSAnYXR0cmlidXRlJykgewogICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBvbmx5IHR3byBjb25mbGljdGluZyBzY2VuYXJpb3MgcG9zc2libGUgaGVyZToKICAgICAgICAgICAgICBpZiAoaW5jLm9mZnNldCA+PSBvbGQub2Zmc2V0ICYmIGluY0VuZCA8PSBvbGRFbmQpIHsKICAgICAgICAgICAgICAgIC8vIGBvbGRgIGNoYW5nZSBpbmNsdWRlcyBgaW5jYCBjaGFuZ2UsIG9yIHRoZXkgYXJlIHRoZSBzYW1lLgogICAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICAgICAgaW5jLmhvd01hbnkgPSAwOwogICAgICAgICAgICAgICAgaW5jLm9mZnNldCA9IDA7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDw9IG9sZC5vZmZzZXQgJiYgaW5jRW5kID49IG9sZEVuZCkgewogICAgICAgICAgICAgICAgLy8gYGluY2AgY2hhbmdlIGluY2x1ZGVzIGBvbGRgIGNoYW5nZS4KICAgICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yOSA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3I5ID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ICYmIF9pdGVyYXRvcjkucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yOS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yOSkgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpbmMuaG93TWFueSA9IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICBkZWxldGUgaW5jLm5vZGVzVG9IYW5kbGU7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUgaW5zZXJ0IGNoYW5nZSBkZXNjcmlwdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcGFyZW50IFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBjaGFuZ2UgaGFwcGVuZWQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggY2hhbmdlIGhhcHBlbmVkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlbW92ZWQgZWxlbWVudCBvciBgJyR0ZXh0J2AgZm9yIGEgY2hhcmFjdGVyLgogICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRpZmYgaXRlbS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0SW5zZXJ0RGlmZiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEluc2VydERpZmYocGFyZW50LCBvZmZzZXQsIG5hbWUpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB0eXBlOiAnaW5zZXJ0JywKICAgICAgICBwb3NpdGlvbjogUG9zaXRpb24uX2NyZWF0ZUF0KHBhcmVudCwgb2Zmc2V0KSwKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGxlbmd0aDogMSwKICAgICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIHJlbW92ZSBjaGFuZ2UgZGVzY3JpcHRpb24uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudCBUaGUgZWxlbWVudCBpbiB3aGljaCBjaGFuZ2UgaGFwcGVuZWQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggY2hhbmdlIGhhcHBlbmVkLgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlbW92ZWQgZWxlbWVudCBvciBgJyR0ZXh0J2AgZm9yIGEgY2hhcmFjdGVyLgogICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRpZmYgaXRlbS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0UmVtb3ZlRGlmZiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJlbW92ZURpZmYocGFyZW50LCBvZmZzZXQsIG5hbWUpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB0eXBlOiAncmVtb3ZlJywKICAgICAgICBwb3NpdGlvbjogUG9zaXRpb24uX2NyZWF0ZUF0KHBhcmVudCwgb2Zmc2V0KSwKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGxlbmd0aDogMSwKICAgICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2hlcmUgZWFjaCBvbmUgaXMgYSBzaW5nbGUgYXR0cmlidXRlIGNoYW5nZSBkZXNjcmlwdGlvbi4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBUaGUgcmFuZ2Ugd2hlcmUgdGhlIGNoYW5nZSBoYXBwZW5lZC4KICAgICAqIEBwYXJhbSB7TWFwfSBvbGRBdHRyaWJ1dGVzIEEgbWFwLCBtYXAgaXRlcmF0b3Igb3IgY29tcGF0aWJsZSBvYmplY3QgdGhhdCBjb250YWlucyBhdHRyaWJ1dGVzIGJlZm9yZSB0aGUgY2hhbmdlLgogICAgICogQHBhcmFtIHtNYXB9IG5ld0F0dHJpYnV0ZXMgQSBtYXAsIG1hcCBpdGVyYXRvciBvciBjb21wYXRpYmxlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGF0dHJpYnV0ZXMgYWZ0ZXIgdGhlIGNoYW5nZS4KICAgICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0gQW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgbW9yZSBkaWZmIGl0ZW1zLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRBdHRyaWJ1dGVzRGlmZiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEF0dHJpYnV0ZXNEaWZmKHJhbmdlLCBvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKSB7CiAgICAgIC8vIFJlc3VsdHMgaG9sZGVyLgogICAgICB2YXIgZGlmZnMgPSBbXTsgLy8gQ2xvbmUgbmV3IGF0dHJpYnV0ZXMgYXMgd2Ugd2lsbCBiZSBwZXJmb3JtaW5nIGNoYW5nZXMgb24gdGhpcyBvYmplY3QuCgogICAgICBuZXdBdHRyaWJ1dGVzID0gbmV3IE1hcChuZXdBdHRyaWJ1dGVzKTsgLy8gTG9vayB0aHJvdWdoIG9sZCBhdHRyaWJ1dGVzLgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEwID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEwID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IG9sZEF0dHJpYnV0ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IChfc3RlcDEwID0gX2l0ZXJhdG9yMTAubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gdHJ1ZSkgewogICAgICAgICAgdmFyIF9zdGVwMTAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDEwLnZhbHVlLCAyKSwKICAgICAgICAgICAgICBrZXkgPSBfc3RlcDEwJHZhbHVlWzBdLAogICAgICAgICAgICAgIG9sZFZhbHVlID0gX3N0ZXAxMCR2YWx1ZVsxXTsKCiAgICAgICAgICAvLyBDaGVjayB3aGF0IGlzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAob3IgaWYgaXQgd2FzIHJlbW92ZWQpLgogICAgICAgICAgdmFyIG5ld1ZhbHVlID0gbmV3QXR0cmlidXRlcy5oYXMoa2V5KSA/IG5ld0F0dHJpYnV0ZXMuZ2V0KGtleSkgOiBudWxsOyAvLyBJZiB2YWx1ZXMgYXJlIGRpZmZlcmVudCAob3IgYXR0cmlidXRlIHdhcyByZW1vdmVkKS4uLgoKICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHsKICAgICAgICAgICAgLy8gQWRkIGRpZmYgaXRlbS4KICAgICAgICAgICAgZGlmZnMucHVzaCh7CiAgICAgICAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgICAgICAgcG9zaXRpb246IHJhbmdlLnN0YXJ0LAogICAgICAgICAgICAgIHJhbmdlOiByYW5nZS5jbG9uZSgpLAogICAgICAgICAgICAgIGxlbmd0aDogMSwKICAgICAgICAgICAgICBhdHRyaWJ1dGVLZXk6IGtleSwKICAgICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogb2xkVmFsdWUsCiAgICAgICAgICAgICAgYXR0cmlidXRlTmV3VmFsdWU6IG5ld1ZhbHVlLAogICAgICAgICAgICAgIGNoYW5nZUNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSAvLyBQcmV2ZW50IHJldHVybmluZyB0d28gZGlmZiBpdGVtcyBmb3IgdGhlIHNhbWUgY2hhbmdlLgoKCiAgICAgICAgICBuZXdBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpOwogICAgICAgIH0gLy8gTG9vayB0aHJvdWdoIG5ldyBhdHRyaWJ1dGVzIHRoYXQgd2VyZW4ndCBoYW5kbGVkIGFib3ZlLgoKICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxMCA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IxMCA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTAgJiYgX2l0ZXJhdG9yMTAucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMTAucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEwKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTEgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMTEgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjExID0gbmV3QXR0cmlidXRlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjExID0gKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTEgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgX3N0ZXAxMSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMTEudmFsdWUsIDIpLAogICAgICAgICAgICAgIF9rZXkgPSBfc3RlcDExJHZhbHVlWzBdLAogICAgICAgICAgICAgIF9uZXdWYWx1ZSA9IF9zdGVwMTEkdmFsdWVbMV07CgogICAgICAgICAgLy8gRWFjaCBvZiB0aGVtIGlzIGEgbmV3IGF0dHJpYnV0ZS4gQWRkIGRpZmYgaXRlbS4KICAgICAgICAgIGRpZmZzLnB1c2goewogICAgICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICAgICAgcG9zaXRpb246IHJhbmdlLnN0YXJ0LAogICAgICAgICAgICByYW5nZTogcmFuZ2UuY2xvbmUoKSwKICAgICAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgICAgICBhdHRyaWJ1dGVLZXk6IF9rZXksCiAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiBudWxsLAogICAgICAgICAgICBhdHRyaWJ1dGVOZXdWYWx1ZTogX25ld1ZhbHVlLAogICAgICAgICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjExID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjExID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMSAmJiBfaXRlcmF0b3IxMS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IxMS5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTEpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBkaWZmczsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gZWxlbWVudCBvciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgYW4gZWxlbWVudCB0aGF0IGlzIGJ1ZmZlcmVkIGFzIGFuIGluc2VydGVkIGVsZW1lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBjaGVjay4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9pc0luSW5zZXJ0ZWRFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNJbkluc2VydGVkRWxlbWVudChlbGVtZW50KSB7CiAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudDsKCiAgICAgIGlmICghcGFyZW50KSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZ2V0KHBhcmVudCk7CgogICAgICB2YXIgb2Zmc2V0ID0gZWxlbWVudC5zdGFydE9mZnNldDsKCiAgICAgIGlmIChjaGFuZ2VzKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMiA9IHRydWU7CiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTIgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IxMiA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjEyID0gY2hhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyID0gKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTIgPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBfc3RlcDEyLnZhbHVlOwoKICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09ICdpbnNlcnQnICYmIG9mZnNldCA+PSBjaGFuZ2Uub2Zmc2V0ICYmIG9mZnNldCA8IGNoYW5nZS5vZmZzZXQgKyBjaGFuZ2UuaG93TWFueSkgewogICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEyID0gdHJ1ZTsKICAgICAgICAgIF9pdGVyYXRvckVycm9yMTIgPSBlcnI7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEyICYmIF9pdGVyYXRvcjEyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yMTIucmV0dXJuKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEyKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQocGFyZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBkZWVwbHkgYWxsIGJ1ZmZlcmVkIGNoYW5nZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCBpbiBlbGVtZW50cyBmcm9tIHJhbmdlIHNwZWNpZmllZCBieSBgcGFyZW50YCwgYG9mZnNldGAKICAgICAqIGFuZCBgaG93TWFueWAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldAogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUFsbE5lc3RlZENoYW5nZXMocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpIHsKICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVBdChwYXJlbnQsIG9mZnNldCksIFBvc2l0aW9uLl9jcmVhdGVBdChwYXJlbnQsIG9mZnNldCArIGhvd01hbnkpKTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjEzID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjEzID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMyA9IHJhbmdlLmdldEl0ZW1zKHsKICAgICAgICAgIHNoYWxsb3c6IHRydWUKICAgICAgICB9KVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEzID0gKF9zdGVwMTMgPSBfaXRlcmF0b3IxMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTMgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwMTMudmFsdWU7CgogICAgICAgICAgaWYgKGl0ZW0uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgICAgICB0aGlzLl9lbGVtZW50U25hcHNob3RzLmRlbGV0ZShpdGVtKTsKCiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZGVsZXRlKGl0ZW0pOwoKICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyhpdGVtLCAwLCBpdGVtLm1heE9mZnNldCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEzID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjEzID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMyAmJiBfaXRlcmF0b3IxMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IxMy5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTMpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9LCB7CiAgICBrZXk6ICJpc0VtcHR5IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5zaXplID09IDAgJiYgdGhpcy5fY2hhbmdlZE1hcmtlcnMuc2l6ZSA9PSAwOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIERpZmZlcjsKfSgpOyAvLyBSZXR1cm5zIGFuIGFycmF5IHRoYXQgaXMgYSBjb3B5IG9mIHBhc3NlZCBjaGlsZCBsaXN0IHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IHRleHQgbm9kZXMgYXJlIHNwbGl0IHRvIG9uZSBvciBtb3JlCi8vIG9iamVjdHMsIGVhY2ggcmVwcmVzZW50aW5nIG9uZSBjaGFyYWN0ZXIgYW5kIGF0dHJpYnV0ZXMgc2V0IG9uIHRoYXQgY2hhcmFjdGVyLgoKCmV4cG9ydCB7IERpZmZlciBhcyBkZWZhdWx0IH07CgpmdW5jdGlvbiBfZ2V0Q2hpbGRyZW5TbmFwc2hvdChjaGlsZHJlbikgewogIHZhciBzbmFwc2hvdCA9IFtdOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjE0ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yMTQgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3IxNCA9IGNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgPSAoX3N0ZXAxNCA9IF9pdGVyYXRvcjE0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNCA9IHRydWUpIHsKICAgICAgdmFyIGNoaWxkID0gX3N0ZXAxNC52YWx1ZTsKCiAgICAgIGlmIChjaGlsZC5pcygndGV4dCcpKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5kYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBzbmFwc2hvdC5wdXNoKHsKICAgICAgICAgICAgbmFtZTogJyR0ZXh0JywKICAgICAgICAgICAgYXR0cmlidXRlczogbmV3IE1hcChjaGlsZC5nZXRBdHRyaWJ1dGVzKCkpCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc25hcHNob3QucHVzaCh7CiAgICAgICAgICBuYW1lOiBjaGlsZC5uYW1lLAogICAgICAgICAgYXR0cmlidXRlczogbmV3IE1hcChjaGlsZC5nZXRBdHRyaWJ1dGVzKCkpCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yMTQgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IxNCA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTQgJiYgX2l0ZXJhdG9yMTQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IxNC5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTQpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjE0OwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gc25hcHNob3Q7Cn0gLy8gR2VuZXJhdGVzIGFycmF5IG9mIGFjdGlvbnMgZm9yIGdpdmVuIGNoYW5nZXMgc2V0LgovLyBJdCBzaW11bGF0ZXMgd2hhdCBgZGlmZmAgZnVuY3Rpb24gZG9lcy4KLy8gR2VuZXJhdGVkIGFjdGlvbnMgYXJlOgovLyAtICdlJyBmb3IgJ2VxdWFsJyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIGRpZCBub3QgY2hhbmdlLAovLyAtICdpJyBmb3IgJ2luc2VydCcgLSB3aGVuIGl0ZW0gYXQgdGhhdCBwb3NpdGlvbiB3YXMgaW5zZXJ0ZWQsCi8vIC0gJ3InIGZvciAncmVtb3ZlJyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIHdhcyByZW1vdmVkLAovLyAtICdhJyBmb3IgJ2F0dHJpYnV0ZScgLSB3aGVuIGl0ZW0gYXQgdGhhdCBwb3NpdGlvbiBoYXMgaXQgYXR0cmlidXRlcyBjaGFuZ2VkLgovLwovLyBFeGFtcGxlIChhc3N1bWUgdGhhdCB1cHBlcmNhc2UgbGV0dGVycyBoYXZlIGJvbGQgYXR0cmlidXRlLCBjb21wYXJlIHdpdGggZnVuY3Rpb24gY29kZSk6Ci8vCi8vIGNoaWxkcmVuIGJlZm9yZToJZm9vQkFSCi8vIGNoaWxkcmVuIGFmdGVyOglmb3h5YkFSCi8vCi8vIGNoYW5nZXM6IHR5cGU6IHJlbW92ZSwgb2Zmc2V0OiAxLCBob3dNYW55OiAxCi8vCQkJdHlwZTogaW5zZXJ0LCBvZmZzZXQ6IDIsIGhvd01hbnk6IDIKLy8JCQl0eXBlOiBhdHRyaWJ1dGUsIG9mZnNldDogNCwgaG93TWFueTogMQovLwovLyBleHBlY3RlZCBhY3Rpb25zOiBlcXVhbCAoZiksIHJlbW92ZSAobyksIGVxdWFsIChvKSwgaW5zZXJ0ICh4KSwgaW5zZXJ0ICh5KSwgYXR0cmlidXRlIChiKSwgZXF1YWwgKEEpLCBlcXVhbCAoUikKLy8KLy8gc3RlcHMgdGFrZW4gYnkgdGggc2NyaXB0OgovLwovLyAxLiBjaGFuZ2UgPSAidHlwZTogcmVtb3ZlLCBvZmZzZXQ6IDEsIGhvd01hbnk6IDEiOyBvZmZzZXQgPSAwOyBvbGRDaGlsZHJlbkhhbmRsZWQgPSAwCi8vICAgIDEuMSBiZXR3ZWVuIHRoaXMgY2hhbmdlIGFuZCB0aGUgYmVnaW5uaW5nIGlzIG9uZSBub3QtY2hhbmdlZCBub2RlLCBmaWxsIHdpdGggb25lIGVxdWFsIGFjdGlvbiwgb25lIG9sZCBjaGlsZCBoYXMgYmVlbiBoYW5kbGVkCi8vICAgIDEuMiB0aGlzIGNoYW5nZSByZW1vdmVzIG9uZSBub2RlLCBhZGQgb25lIHJlbW92ZSBhY3Rpb24KLy8gICAgMS4zIGNoYW5nZSBsYXN0IHZpc2l0ZWQgYG9mZnNldGAgdG8gMQovLyAgICAxLjQgc2luY2UgYW4gb2xkIGNoaWxkIGhhcyBiZWVuIHJlbW92ZWQsIG9uZSBtb3JlIG9sZCBjaGlsZCBoYXMgYmVlbiBoYW5kbGVkCi8vICAgIDEuNSBhY3Rpb25zIGF0IHRoaXMgcG9pbnQgYXJlOiBlcXVhbCwgcmVtb3ZlCi8vCi8vIDIuIGNoYW5nZSA9ICJ0eXBlOiBpbnNlcnQsIG9mZnNldDogMiwgaG93TWFueTogMiI7IG9mZnNldCA9IDE7IG9sZENoaWxkcmVuSGFuZGxlZCA9IDIKLy8gICAgMi4xIGJldHdlZW4gdGhpcyBjaGFuZ2UgYW5kIHByZXZpb3VzIGNoYW5nZSBpcyBvbmUgbm90LWNoYW5nZWQgbm9kZSwgYWRkIGVxdWFsIGFjdGlvbiwgYW5vdGhlciBvbmUgb2xkIGNoaWxkcmVuIGhhcyBiZWVuIGhhbmRsZWQKLy8gICAgMi4yIHRoaXMgY2hhbmdlIGluc2VydHMgdHdvIG5vZGVzLCBhZGQgdHdvIGluc2VydCBhY3Rpb25zCi8vICAgIDIuMyBjaGFuZ2UgbGFzdCB2aXNpdGVkIG9mZnNldCB0byB0aGUgZW5kIG9mIHRoZSBpbnNlcnRlZCByYW5nZSwgdGhhdCBpcyA0Ci8vICAgIDIuNCBhY3Rpb25zIGF0IHRoaXMgcG9pbnQgYXJlOiBlcXVhbCwgcmVtb3ZlLCBlcXVhbCwgaW5zZXJ0LCBpbnNlcnQKLy8KLy8gMy4gY2hhbmdlID0gInR5cGU6IGF0dHJpYnV0ZSwgb2Zmc2V0OiA0LCBob3dNYW55OiAxIjsgb2Zmc2V0ID0gNCwgb2xkQ2hpbGRyZW5IYW5kbGVkID0gMwovLyAgICAzLjEgYmV0d2VlbiB0aGlzIGNoYW5nZSBhbmQgcHJldmlvdXMgY2hhbmdlIGFyZSBubyBub3QtY2hhbmdlZCBub2RlcwovLyAgICAzLjIgdGhpcyBjaGFuZ2UgY2hhbmdlcyBvbmUgbm9kZSwgYWRkIG9uZSBhdHRyaWJ1dGUgYWN0aW9uCi8vICAgIDMuMyBjaGFuZ2UgbGFzdCB2aXNpdGVkIGBvZmZzZXRgIHRvIHRoZSBlbmQgb2YgY2hhbmdlIHJhbmdlLCB0aGF0IGlzIDUKLy8gICAgMy40IHNpbmNlIGFuIG9sZCBjaGlsZCBoYXMgYmVlbiBjaGFuZ2VkLCBvbmUgbW9yZSBvbGQgY2hpbGQgaGFzIGJlZW4gaGFuZGxlZAovLyAgICAzLjUgYWN0aW9ucyBhdCB0aGlzIHBvaW50IGFyZTogZXF1YWwsIHJlbW92ZSwgZXF1YWwsIGluc2VydCwgaW5zZXJ0LCBhdHRyaWJ1dGUKLy8KLy8gNC4gYWZ0ZXIgbG9vcCBvbGRDaGlsZHJlbkhhbmRsZWQgPSA0LCBvbGRDaGlsZHJlbkxlbmd0aCA9IDYgKGZvb0JBUiBpcyA2IGNoYXJhY3RlcnMpCi8vICAgIDQuMSBmaWxsIHVwIHdpdGggdHdvIGVxdWFsIGFjdGlvbnMKLy8KLy8gVGhlIHJlc3VsdCBhY3Rpb25zIGFyZTogZXF1YWwsIHJlbW92ZSwgZXF1YWwsIGluc2VydCwgaW5zZXJ0LCBhdHRyaWJ1dGUsIGVxdWFsLCBlcXVhbC4KCgpmdW5jdGlvbiBfZ2VuZXJhdGVBY3Rpb25zRnJvbUNoYW5nZXMob2xkQ2hpbGRyZW5MZW5ndGgsIGNoYW5nZXMpIHsKICB2YXIgYWN0aW9ucyA9IFtdOwogIHZhciBvZmZzZXQgPSAwOwogIHZhciBvbGRDaGlsZHJlbkhhbmRsZWQgPSAwOyAvLyBHbyB0aHJvdWdoIGFsbCBidWZmZXJlZCBjaGFuZ2VzLgoKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjE1ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IxNSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjE1ID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMTUgPSBjaGFuZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxNTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMTUgPSAoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNSA9IHRydWUpIHsKICAgICAgdmFyIGNoYW5nZSA9IF9zdGVwMTUudmFsdWU7CgogICAgICAvLyBGaXJzdCwgZmlsbCAiaG9sZXMiIGJldHdlZW4gY2hhbmdlcyB3aXRoICJlcXVhbCIgYWN0aW9ucy4KICAgICAgaWYgKGNoYW5nZS5vZmZzZXQgPiBvZmZzZXQpIHsKICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBjaGFuZ2Uub2Zmc2V0IC0gb2Zmc2V0OyBfaTMrKykgewogICAgICAgICAgYWN0aW9ucy5wdXNoKCdlJyk7CiAgICAgICAgfQoKICAgICAgICBvbGRDaGlsZHJlbkhhbmRsZWQgKz0gY2hhbmdlLm9mZnNldCAtIG9mZnNldDsKICAgICAgfSAvLyBUaGVuLCBmaWxsIHVwIGFjdGlvbnMgYWNjb3JkaW5nbHkgdG8gY2hhbmdlIHR5cGUuCgoKICAgICAgaWYgKGNoYW5nZS50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgY2hhbmdlLmhvd01hbnk7IF9pNCsrKSB7CiAgICAgICAgICBhY3Rpb25zLnB1c2goJ2knKTsKICAgICAgICB9IC8vIFRoZSBsYXN0IGhhbmRsZWQgb2Zmc2V0IGlzIGFmdGVyIGluc2VydGVkIHJhbmdlLgoKCiAgICAgICAgb2Zmc2V0ID0gY2hhbmdlLm9mZnNldCArIGNoYW5nZS5ob3dNYW55OwogICAgICB9IGVsc2UgaWYgKGNoYW5nZS50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgY2hhbmdlLmhvd01hbnk7IF9pNSsrKSB7CiAgICAgICAgICBhY3Rpb25zLnB1c2goJ3InKTsKICAgICAgICB9IC8vIFRoZSBsYXN0IGhhbmRsZWQgb2Zmc2V0IGlzIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgbm9kZXMgd2VyZSByZW1vdmVkLgoKCiAgICAgICAgb2Zmc2V0ID0gY2hhbmdlLm9mZnNldDsgLy8gV2UgcmVtb3ZlZCBgaG93TWFueWAgb2xkIG5vZGVzLCB1cGRhdGUgYG9sZENoaWxkcmVuSGFuZGxlZGAuCgogICAgICAgIG9sZENoaWxkcmVuSGFuZGxlZCArPSBjaGFuZ2UuaG93TWFueTsKICAgICAgfSBlbHNlIHsKICAgICAgICBhY3Rpb25zLnB1c2guYXBwbHkoYWN0aW9ucywgX3RvQ29uc3VtYWJsZUFycmF5KCdhJy5yZXBlYXQoY2hhbmdlLmhvd01hbnkpLnNwbGl0KCcnKSkpOyAvLyBUaGUgbGFzdCBoYW5kbGVkIG9mZnNldCBpcyBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGNoYW5nZWQgcmFuZ2UuCgogICAgICAgIG9mZnNldCA9IGNoYW5nZS5vZmZzZXQgKyBjaGFuZ2UuaG93TWFueTsgLy8gV2UgY2hhbmdlZCBgaG93TWFueWAgb2xkIG5vZGVzLCB1cGRhdGUgYG9sZENoaWxkcmVuSGFuZGxlZGAuCgogICAgICAgIG9sZENoaWxkcmVuSGFuZGxlZCArPSBjaGFuZ2UuaG93TWFueTsKICAgICAgfQogICAgfSAvLyBGaWxsICJlcXVhbCIgYWN0aW9ucyBhdCB0aGUgZW5kIG9mIGFjdGlvbnMgc2V0LiBVc2UgYG9sZENoaWxkcmVuSGFuZGxlZGAgdG8gc2VlIGhvdyBtYW55IGNoaWxkcmVuCiAgICAvLyBoYXMgbm90IGJlZW4gY2hhbmdlZCAvIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGVpciBwYXJlbnQuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IxNSA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjE1ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xNSAmJiBfaXRlcmF0b3IxNS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjE1LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxNSkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTU7CiAgICAgIH0KICAgIH0KICB9CgogIGlmIChvbGRDaGlsZHJlbkhhbmRsZWQgPCBvbGRDaGlsZHJlbkxlbmd0aCkgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbkxlbmd0aCAtIG9sZENoaWxkcmVuSGFuZGxlZCAtIG9mZnNldDsgaSsrKSB7CiAgICAgIGFjdGlvbnMucHVzaCgnZScpOwogICAgfQogIH0KCiAgcmV0dXJuIGFjdGlvbnM7Cn0gLy8gRmlsdGVyIGNhbGxiYWNrIGZvciBBcnJheS5maWx0ZXIgdGhhdCBmaWx0ZXJzIG91dCBjaGFuZ2UgZW50cmllcyB0aGF0IGFyZSBpbiBncmF2ZXlhcmQuCgoKZnVuY3Rpb24gX2NoYW5nZXNJbkdyYXZleWFyZEZpbHRlcihlbnRyeSkgewogIHZhciBwb3NJbkd5ID0gZW50cnkucG9zaXRpb24gJiYgZW50cnkucG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7CiAgdmFyIHJhbmdlSW5HeSA9IGVudHJ5LnJhbmdlICYmIGVudHJ5LnJhbmdlLnJvb3Qucm9vdE5hbWUgPT0gJyRncmF2ZXlhcmQnOwogIHJldHVybiAhcG9zSW5HeSAmJiAhcmFuZ2VJbkd5Owp9"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"names":["Position","Range","Differ","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","item","_isInInsertedElement","parent","_markRemove","startOffset","offsetSize","_markInsert","range","_createOn","getMarkersIntersectingRange","marker","markerRange","getRange","bufferMarkerChange","name","affectsData","operation","type","position","offset","nodes","maxOffset","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","getMovedRangeStart","_createFromPositionAndShift","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","graveyardParent","mergedIntoElement","markerName","oldRange","newRange","buffered","get","set","delete","result","change","push","Array","from","map","data","size","options","includeChangesInGraveyard","slice","diffSet","keys","element","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","splice","filter","_changesInGraveyardFilter","clear","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n\t\t * state before and after the change.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Marks given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted in the differ changes\n\t * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.\n\t *\n\t * @param {module:engine/model/item~Item} item Item to refresh.\n\t */\n\trefreshItem( item ) {\n\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._markRemove( item.parent, item.startOffset, item.offsetSize );\n\t\tthis._markInsert( item.parent, item.startOffset, item.offsetSize );\n\n\t\tconst range = Range._createOn( item );\n\n\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\t// Below we take an operation, check its type, then use its parameters in marking (private) methods.\n\t\t// The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n\t\t// Marking changes in them would cause a \"double\" changing then.\n\t\t//\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems( { shallow: true } ) ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\t// When range is moved to the same position then not mark it as a change.\n\t\t\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n\t\t\t\tif (\n\t\t\t\t\toperation.sourcePosition.isEqual( operation.targetPosition ) ||\n\t\t\t\t\toperation.sourcePosition.getShiftedBy( operation.howMany ).isEqual( operation.targetPosition )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range._createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'split': {\n\t\t\t\tconst splitElement = operation.splitPosition.parent;\n\n\t\t\t\t// Mark that children of the split element were removed.\n\t\t\t\tif ( !this._isInInsertedElement( splitElement ) ) {\n\t\t\t\t\tthis._markRemove( splitElement, operation.splitPosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the new element (split copy) was inserted.\n\t\t\t\tif ( !this._isInInsertedElement( operation.insertionPosition.parent ) ) {\n\t\t\t\t\tthis._markInsert( operation.insertionPosition.parent, operation.insertionPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\t\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\t\tthis._markRemove( operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'merge': {\n\t\t\t\t// Mark that the merged element was removed.\n\t\t\t\tconst mergedElement = operation.sourcePosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedElement.parent ) ) {\n\t\t\t\t\tthis._markRemove( mergedElement.parent, mergedElement.startOffset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the merged element was inserted into graveyard.\n\t\t\t\tconst graveyardParent = operation.graveyardPosition.parent;\n\n\t\t\t\tthis._markInsert( graveyardParent, operation.graveyardPosition.offset, 1 );\n\n\t\t\t\t// Mark that children of merged element were inserted at new parent.\n\t\t\t\tconst mergedIntoElement = operation.targetPosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedIntoElement ) ) {\n\t\t\t\t\tthis._markInsert( mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n\t * been created.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n\t * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n\t */\n\tbufferMarkerChange( markerName, oldRange, newRange, affectsData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\toldRange,\n\t\t\t\tnewRange,\n\t\t\t\taffectsData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newRange = newRange;\n\t\t\tbuffered.affectsData = affectsData;\n\n\t\t\tif ( buffered.oldRange == null && buffered.newRange == null ) {\n\t\t\t\t// The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldRange != null ) {\n\t\t\t\tresult.push( { name, range: change.oldRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newRange != null ) {\n\t\t\t\tresult.push( { name, range: change.newRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which changed.\n\t *\n\t * @returns {Array.<Object>}\n\t */\n\tgetChangedMarkers() {\n\t\treturn Array.from( this._changedMarkers ).map( item => (\n\t\t\t{\n\t\t\t\tname: item[ 0 ],\n\t\t\t\tdata: {\n\t\t\t\t\toldRange: item[ 1 ].oldRange,\n\t\t\t\t\tnewRange: item[ 1 ].newRange\n\t\t\t\t}\n\t\t\t}\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectingData`.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tfor ( const [ , change ] of this._changedMarkers ) {\n\t\t\tif ( change.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If markers do not affect the data, check whether there are some changes in elements.\n\t\treturn this._changesInElement.size > 0;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of diff items, each describing a change done on the model. The items are sorted by\n\t * the position on which the change happened. If a position {@link module:engine/model/position~Position#isBefore is before}\n\t * another one, it will be on an earlier index in the diff set.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<Object>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tconst diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ].name ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ].name ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element, i + 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element.getChild( index ), 0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount - b.changeCount;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ i - 1 ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tdiffSet[ i - 1 ].length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tdiffSet[ i - 1 ].range.end = diffSet[ i - 1 ].range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet.slice();\n\t\tthis._cachedChanges = diffSet.slice().filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard;\n\t\t} else {\n\t\t\treturn this._cachedChanges;\n\t\t}\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\t// This is a case when attribute change \"contains\" remove change.\n\t\t\t\t\t// The attribute change needs to be split into two because changes cannot intersect.\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: old.offset,\n\t\t\t\t\t\t\thowMany: incEnd - old.offset,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\tchanges.push( attributePart );\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: range.clone(),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: range.clone(),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = new Range( Position._createAt( parent, offset ), Position._createAt( parent, offset + howMany ) );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( 'text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tfor ( let i = 0; i < change.offset - offset; i++ ) {\n\t\t\t\tactions.push( 'e' );\n\t\t\t}\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'i' );\n\t\t\t}\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'r' );\n\t\t\t}\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tfor ( let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++ ) {\n\t\t\tactions.push( 'e' );\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n"]}]}