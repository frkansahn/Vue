{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\range.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\range.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0ICJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9yYW5nZQogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgVHJlZVdhbGtlciBmcm9tICcuL3RyZWV3YWxrZXInOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY29tcGFyZWFycmF5cyc7Ci8qKgogKiBSZXByZXNlbnRzIGEgcmFuZ2UgaW4gdGhlIG1vZGVsIHRyZWUuCiAqCiAqIEEgcmFuZ2UgaXMgZGVmaW5lZCBieSBpdHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2Ujc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNlbmR9CiAqIHBvc2l0aW9ucy4KICoKICogWW91IGNhbiBjcmVhdGUgcmFuZ2UgaW5zdGFuY2VzIHZpYSBpdHMgY29uc3RydWN0b3Igb3IgdGhlIGBjcmVhdGVSYW5nZSooKWAgZmFjdG9yeSBtZXRob2RzIG9mCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0uCiAqLwoKdmFyIFJhbmdlID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIHNwYW5uaW5nIGZyb20gYHN0YXJ0YCBwb3NpdGlvbiB0byBgZW5kYCBwb3NpdGlvbi4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc3RhcnQgU3RhcnQgcG9zaXRpb24uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBbZW5kXSBFbmQgcG9zaXRpb24uIElmIG5vdCBzZXQsIHJhbmdlIHdpbGwgYmUgY29sbGFwc2VkIGF0IGBzdGFydGAgcG9zaXRpb24uCiAgICovCiAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQpIHsKICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmdlKTsKCiAgICAvKioKICAgICAqIFN0YXJ0IHBvc2l0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwogICAgdGhpcy5zdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChzdGFydCk7CiAgICAvKioKICAgICAqIEVuZCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgICB0aGlzLmVuZCA9IGVuZCA/IFBvc2l0aW9uLl9jcmVhdGVBdChlbmQpIDogUG9zaXRpb24uX2NyZWF0ZUF0KHN0YXJ0KTsgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdHJlYXQgaW4gYSBzaW1pbGFyIHdheSBhcyBhIHBvc2l0aW9uIGFuZCBzZXQgaXRzIGJvdW5kYXJpZXMgc3RpY2tpbmVzcyB0byAndG9Ob25lJy4KICAgIC8vIEluIG90aGVyIGNhc2UsIG1ha2UgdGhlIGJvdW5kYXJpZXMgc3RpY2sgdG8gdGhlICJpbnNpZGUiIG9mIHRoZSByYW5nZS4KCiAgICB0aGlzLnN0YXJ0LnN0aWNraW5lc3MgPSB0aGlzLmlzQ29sbGFwc2VkID8gJ3RvTm9uZScgOiAndG9OZXh0JzsKICAgIHRoaXMuZW5kLnN0aWNraW5lc3MgPSB0aGlzLmlzQ29sbGFwc2VkID8gJ3RvTm9uZScgOiAndG9QcmV2aW91cyc7CiAgfQogIC8qKgogICAqIEl0ZXJhYmxlIGludGVyZmFjZS4KICAgKgogICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0gdG9nZXRoZXIgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGxpa2UgbGVuZ3RoIG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sCiAgICogZ3JvdXBlZCBhcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICogSXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eSB0ZXh0IGNvbnRlbnRzfSB0aGF0IGFyZSBpbnNpZGUgdGhlIHJhbmdlCiAgICogYW5kIGFsbCB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fXMgdGhhdCBhcmUgZW50ZXJlZCBpbnRvIHdoZW4gaXRlcmF0aW5nIG92ZXIgdGhpcyByYW5nZS4KICAgKgogICAqIFRoaXMgaXRlcmF0b3IgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlCiAgICogYW5kIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24gc2V0IHRvIGB0cnVlYC4KICAgKgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZT59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoUmFuZ2UsIFt7CiAgICBrZXk6IFN5bWJvbC5pdGVyYXRvciwKICAgIHZhbHVlOgogICAgLyojX19QVVJFX18qLwogICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7CiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQpIHsKICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmRlbGVnYXRlWWllbGQobmV3IFRyZWVXYWxrZXIoewogICAgICAgICAgICAgICAgYm91bmRhcmllczogdGhpcywKICAgICAgICAgICAgICAgIGlnbm9yZUVsZW1lbnRFbmQ6IHRydWUKICAgICAgICAgICAgICB9KSwgInQwIiwgMSk7CgogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIGNhc2UgImVuZCI6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIHZhbHVlLCB0aGlzKTsKICAgIH0pCiAgICAvKioKICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCB0aGF0IGlzIGlmIHtAbGluayAjc3RhcnR9IGFuZAogICAgICoge0BsaW5rICNlbmR9IHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICAgKgogICAgICogQHR5cGUge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNQb3NpdGlvbiIsCgogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJhbmdlIGNvbnRhaW5zIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0gaXMgY29udGFpbmVkCiAgICAgKiBpbiB0aGlzIHJhbmdlLGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikgewogICAgICByZXR1cm4gcG9zaXRpb24uaXNBZnRlcih0aGlzLnN0YXJ0KSAmJiBwb3NpdGlvbi5pc0JlZm9yZSh0aGlzLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIH5SYW5nZSByYW5nZX0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9ZmFsc2VdIFdoZXRoZXIgdGhlIGNoZWNrIGlzIGxvb3NlIG9yIHN0cmljdC4gSWYgdGhlIGNoZWNrIGlzIHN0cmljdCAoYGZhbHNlYCksIGNvbXBhcmVkIHJhbmdlIGNhbm5vdAogICAgICogc3RhcnQgb3IgZW5kIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoaXMgcmFuZ2UgYm91bmRhcmllcy4gSWYgdGhlIGNoZWNrIGlzIGxvb3NlIChgdHJ1ZWApLCBjb21wYXJlZCByYW5nZSBjYW4gc3RhcnQsIGVuZCBvcgogICAgICogZXZlbiBiZSBlcXVhbCB0byB0aGlzIHJhbmdlLiBOb3RlIHRoYXQgY29sbGFwc2VkIHJhbmdlcyBhcmUgYWx3YXlzIGNvbXBhcmVkIGluIHN0cmljdCBtb2RlLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfSBib3VuZGFyaWVzIGFyZSBjb250YWluZWQgYnkgdGhpcyByYW5nZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY29udGFpbnNSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNSYW5nZShvdGhlclJhbmdlKSB7CiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CgogICAgICBpZiAob3RoZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIGxvb3NlID0gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBjb250YWluc1N0YXJ0ID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpIHx8IGxvb3NlICYmIHRoaXMuc3RhcnQuaXNFcXVhbChvdGhlclJhbmdlLnN0YXJ0KTsKICAgICAgdmFyIGNvbnRhaW5zRW5kID0gdGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSB8fCBsb29zZSAmJiB0aGlzLmVuZC5pc0VxdWFsKG90aGVyUmFuZ2UuZW5kKTsKICAgICAgcmV0dXJuIGNvbnRhaW5zU3RhcnQgJiYgY29udGFpbnNFbmQ7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXMgaW5zaWRlIHRoaXMgcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBNb2RlbCBpdGVtIHRvIGNoZWNrLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNvbnRhaW5zSXRlbSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNJdGVtKGl0ZW0pIHsKICAgICAgdmFyIHBvcyA9IFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CgogICAgICByZXR1cm4gdGhpcy5jb250YWluc1Bvc2l0aW9uKHBvcykgfHwgdGhpcy5zdGFydC5pc0VxdWFsKHBvcyk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgICAqCiAgICAgKgkJcmFuZ2UuaXMoICdyYW5nZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCXJhbmdlLmlzKCAnbW9kZWw6cmFuZ2UnICk7IC8vIC0+IHRydWUKICAgICAqCiAgICAgKgkJcmFuZ2UuaXMoICd2aWV3OnJhbmdlJyApOyAvLyAtPiBmYWxzZQogICAgICoJCXJhbmdlLmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICAgKgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiBtb2RlbCBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUKICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpcyh0eXBlKSB7CiAgICAgIHJldHVybiB0eXBlID09ICdyYW5nZScgfHwgdHlwZSA9PSAnbW9kZWw6cmFuZ2UnOwogICAgfQogICAgLyoqCiAgICAgKiBUd28gcmFuZ2VzIGFyZSBlcXVhbCBpZiB0aGVpciB7QGxpbmsgI3N0YXJ0fSBhbmQge0BsaW5rICNlbmR9IHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgcmFuZ2VzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXNFcXVhbCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFcXVhbChvdGhlclJhbmdlKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzRXF1YWwob3RoZXJSYW5nZS5zdGFydCkgJiYgdGhpcy5lbmQuaXNFcXVhbChvdGhlclJhbmdlLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBhbmQgcmV0dXJucyB3aGV0aGVyIHRoaXMgcmFuZ2UgaW50ZXJzZWN0cyB3aXRoIGdpdmVuIHJhbmdlLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHJhbmdlcyBpbnRlcnNlY3QsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImlzSW50ZXJzZWN0aW5nIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzQmVmb3JlKG90aGVyUmFuZ2UuZW5kKSAmJiB0aGlzLmVuZC5pc0FmdGVyKG90aGVyUmFuZ2Uuc3RhcnQpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21wdXRlcyB3aGljaCBwYXJ0KHMpIG9mIHRoaXMge0BsaW5rIH5SYW5nZSByYW5nZX0gaXMgbm90IGEgcGFydCBvZiBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfS4KICAgICAqIFJldHVybmVkIGFycmF5IGNvbnRhaW5zIHplcm8sIG9uZSBvciB0d28ge0BsaW5rIH5SYW5nZSByYW5nZXN9LgogICAgICoKICAgICAqIEV4YW1wbGVzOgogICAgICoKICAgICAqCQlsZXQgcmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSgKICAgICAqCQkJbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAyLCA3IF0gKSwKICAgICAqCQkJbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA0LCAwLCAxIF0gKQogICAgICoJCSk7CiAgICAgKgkJbGV0IG90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAxIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA1IF0gKSApOwogICAgICoJCWxldCB0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgbm8gcmFuZ2VzIGJlY2F1c2UgYG90aGVyUmFuZ2VgIGNvbnRhaW5zIGByYW5nZWAKICAgICAqCiAgICAgKgkJb3RoZXJSYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDEgXSApLCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDMgXSApICk7CiAgICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZTogZnJvbSBbIDMgXSB0byBbIDQsIDAsIDEgXQogICAgICoKICAgICAqCQlvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMyBdICksIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCBdICkgKTsKICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgdHdvIHJhbmdlczogZnJvbSBbIDIsIDcgXSB0byBbIDMgXSBhbmQgZnJvbSBbIDQgXSB0byBbIDQsIDAsIDEgXQogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBkaWZmZXJlbnRpYXRlIGFnYWluc3QuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHJhbmdlcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXREaWZmZXJlbmNlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaWZmZXJlbmNlKG90aGVyUmFuZ2UpIHsKICAgICAgdmFyIHJhbmdlcyA9IFtdOwoKICAgICAgaWYgKHRoaXMuaXNJbnRlcnNlY3Rpbmcob3RoZXJSYW5nZSkpIHsKICAgICAgICAvLyBSYW5nZXMgaW50ZXJzZWN0LgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIHN0YXJ0IGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSB0bwogICAgICAgICAgLy8gYWRkIHNocnVua2VuIHJhbmdlIC0gZnJvbSB0aGUgc3RhcnQgdG8gdGhlIG1pZGRsZSBvZiB0aGlzIHJhbmdlLgogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHRoaXMuc3RhcnQsIG90aGVyUmFuZ2Uuc3RhcnQpKTsKICAgICAgICB9CgogICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5lbmQpKSB7CiAgICAgICAgICAvLyBHaXZlbiByYW5nZSBlbmQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgICAvLyBhZGQgc2hydW5rZW4gcmFuZ2UgLSBmcm9tIHRoZSBtaWRkbGUgb2YgdGhpcyByYW5nZSB0byB0aGUgZW5kLgogICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKG90aGVyUmFuZ2UuZW5kLCB0aGlzLmVuZCkpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBSYW5nZXMgZG8gbm90IGludGVyc2VjdCwgcmV0dXJuIHRoZSBvcmlnaW5hbCByYW5nZS4KICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpbnRlcnNlY3Rpb24gb2YgdGhpcyB7QGxpbmsgflJhbmdlIHJhbmdlfSBhbmQgZ2l2ZW4ge0BsaW5rIH5SYW5nZSByYW5nZX0uCiAgICAgKiBJbnRlcnNlY3Rpb24gaXMgYSBjb21tb24gcGFydCBvZiBib3RoIG9mIHRob3NlIHJhbmdlcy4gSWYgcmFuZ2VzIGhhcyBubyBjb21tb24gcGFydCwgcmV0dXJucyBgbnVsbGAuCiAgICAgKgogICAgICogRXhhbXBsZXM6CiAgICAgKgogICAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIsIDcgXSApLAogICAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDEgXSApCiAgICAgKgkJKTsKICAgICAqCQlsZXQgb3RoZXJSYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDEgXSApLCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIgXSApICk7CiAgICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKCBvdGhlclJhbmdlICk7IC8vIG51bGwgLSByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydAogICAgICoKICAgICAqCQlvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMyBdICksIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNSBdICkgKTsKICAgICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldEludGVyc2VjdGlvbiggb3RoZXJSYW5nZSApOyAvLyByYW5nZSBmcm9tIFsgMyBdIHRvIFsgNCwgMCwgMSBdCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBBIGNvbW1vbiBwYXJ0IG9mIGdpdmVuIHJhbmdlcyBvciBgbnVsbGAgaWYgcmFuZ2VzIGhhdmUgbm8gY29tbW9uIHBhcnQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0SW50ZXJzZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24ob3RoZXJSYW5nZSkgewogICAgICBpZiAodGhpcy5pc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKSkgewogICAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QsIHNvIGEgY29tbW9uIHJhbmdlIHdpbGwgYmUgcmV0dXJuZWQuCiAgICAgICAgLy8gQXQgbW9zdCwgaXQgd2lsbCBiZSBzYW1lIGFzIHRoaXMgcmFuZ2UuCiAgICAgICAgdmFyIGNvbW1vblJhbmdlU3RhcnQgPSB0aGlzLnN0YXJ0OwogICAgICAgIHZhciBjb21tb25SYW5nZUVuZCA9IHRoaXMuZW5kOwoKICAgICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICAvLyBHaXZlbiByYW5nZSBzdGFydCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGFOdCB3ZSBoYXZlIHRvCiAgICAgICAgICAvLyBzaHJpbmsgY29tbW9uIHJhbmdlIHRvIHRoZSBnaXZlbiByYW5nZSBzdGFydC4KICAgICAgICAgIGNvbW1vblJhbmdlU3RhcnQgPSBvdGhlclJhbmdlLnN0YXJ0OwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAgIC8vIEdpdmVuIHJhbmdlIGVuZCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAgIC8vIHNocmluayBjb21tb24gcmFuZ2UgdG8gdGhlIGdpdmVuIHJhbmdlIGVuZC4KICAgICAgICAgIGNvbW1vblJhbmdlRW5kID0gb3RoZXJSYW5nZS5lbmQ7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbW1vblJhbmdlU3RhcnQsIGNvbW1vblJhbmdlRW5kKTsKICAgICAgfSAvLyBSYW5nZXMgZG8gbm90IGludGVyc2VjdCwgc28gdGhleSBkbyBub3QgaGF2ZSBjb21tb24gcGFydC4KCgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IHNldCBvZiB7QGxpbmsgI2lzRmxhdCBmbGF0fSByYW5nZXMsIHRoYXQgY292ZXJzIHRoaXMgcmFuZ2UgaW4gd2hvbGUuCiAgICAgKgogICAgICogU2VlIGFuIGV4YW1wbGUgb2YgYSBtb2RlbCBzdHJ1Y3R1cmUgKGBbYCBhbmQgYF1gIGFyZSByYW5nZSBib3VuZGFyaWVzKToKICAgICAqCiAgICAgKgkJcm9vdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QKICAgICAqCQkgfC0gZWxlbWVudCBESVYgICAgICAgICAgICAgICAgICAgICAgICAgRElWICAgICAgICAgICAgIFAyICAgICAgICAgICAgICBQMyAgICAgICAgICAgICBESVYKICAgICAqCQkgfCAgIHwtIGVsZW1lbnQgSCAgICAgICAgICAgICAgICAgICBIICAgICAgICBQMSAgICAgICAgZiBvIG8gICAgICAgICAgIGIgYSByICAgICAgIEggICAgICAgICBQNAogICAgICoJCSB8ICAgfCAgIHwtICJmaXJbc3QiICAgICAgICAgICAgIGZpcltzdCAgICAgbG9yZW0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VdY29uZCAgICAgaXBzdW0KICAgICAqCQkgfCAgIHwtIGVsZW1lbnQgUDEKICAgICAqCQkgfCAgIHwgICB8LSAibG9yZW0iICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8CiAgICAgKgkJIHwtIGVsZW1lbnQgUDIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fAogICAgICoJCSB8ICAgfC0gImZvbyIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlYKICAgICAqCQkgfC0gZWxlbWVudCBQMwogICAgICoJCSB8ICAgfC0gImJhciIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290CiAgICAgKgkJIHwtIGVsZW1lbnQgRElWICAgICAgICAgICAgICAgICAgICAgICAgIERJViAgICAgICAgICAgICBbUDIgICAgICAgICAgICAgUDNdICAgICAgICAgICAgIERJVgogICAgICoJCSB8ICAgfC0gZWxlbWVudCBIICAgICAgICAgICAgICAgICAgIEggICAgICAgW1AxXSAgICAgICBmIG8gbyAgICAgICAgICAgYiBhIHIgICAgICAgIEggICAgICAgICBQNAogICAgICoJCSB8ICAgfCAgIHwtICJzZV1jb25kIiAgICAgICAgICAgIGZpcltzdF0gICAgbG9yZW0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlXWNvbmQgICAgIGlwc3VtCiAgICAgKgkJIHwgICB8LSBlbGVtZW50IFA0CiAgICAgKgkJIHwgICB8ICAgfC0gImlwc3VtIgogICAgICoKICAgICAqIEFzIGl0IGNhbiBiZSBzZWVuLCBsZXR0ZXJzIGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2UgYXJlOiBgc3Rsb3JlbWZvb2JhcnNlYCwgc3ByZWFkIGFjcm9zcyBkaWZmZXJlbnQgcGFyZW50cy4KICAgICAqIFdlIGFyZSBsb29raW5nIGZvciBtaW5pbWFsIHNldCBvZiBmbGF0IHJhbmdlcyB0aGF0IGNvbnRhaW5zIHRoZSBzYW1lIG5vZGVzLgogICAgICoKICAgICAqIE1pbmltYWwgZmxhdCByYW5nZXMgZm9yIGFib3ZlIHJhbmdlIGAoIFsgMCwgMCwgMyBdLCBbIDMsIDAsIDIgXSApYCB3aWxsIGJlOgogICAgICoKICAgICAqCQkoIFsgMCwgMCwgMyBdLCBbIDAsIDAsIDUgXSApID0gInN0IgogICAgICoJCSggWyAwLCAxIF0sIFsgMCwgMiBdICkgPSBlbGVtZW50IFAxICgibG9yZW0iKQogICAgICoJCSggWyAxIF0sIFsgMyBdICkgPSBlbGVtZW50IFAyLCBlbGVtZW50IFAzICgiZm9vYmFyIikKICAgICAqCQkoIFsgMywgMCwgMCBdLCBbIDMsIDAsIDIgXSApID0gInNlIgogICAgICoKICAgICAqICoqTm90ZToqKiBpZiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaXMgbm90IHdob2xseSBjb250YWluZWQgaW4gdGhpcyByYW5nZSwgaXQgd29uJ3QgYmUgcmV0dXJuZWQKICAgICAqIGluIGFueSBvZiB0aGUgcmV0dXJuZWQgZmxhdCByYW5nZXMuIFNlZSBpbiB0aGUgZXhhbXBsZSBob3cgYEhgIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlCiAgICAgKiB3ZXJlIG9taXR0ZWQuIE9ubHkgdGhlaXIgcGFydHMgdGhhdCB3ZXJlIHdob2xseSBpbiB0aGUgcmFuZ2Ugd2VyZSByZXR1cm5lZC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogdGhpcyBtZXRob2QgaXMgbm90IHJldHVybmluZyBmbGF0IHJhbmdlcyB0aGF0IGNvbnRhaW4gbm8gbm9kZXMuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gQXJyYXkgb2YgZmxhdCByYW5nZXMgY292ZXJpbmcgdGhpcyByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRNaW5pbWFsRmxhdFJhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWluaW1hbEZsYXRSYW5nZXMoKSB7CiAgICAgIHZhciByYW5nZXMgPSBbXTsKICAgICAgdmFyIGRpZmZBdCA9IHRoaXMuc3RhcnQuZ2V0Q29tbW9uUGF0aCh0aGlzLmVuZCkubGVuZ3RoOwoKICAgICAgdmFyIHBvcyA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzLnN0YXJ0KTsKCiAgICAgIHZhciBwb3NQYXJlbnQgPSBwb3MucGFyZW50OyAvLyBHbyB1cC4KCiAgICAgIHdoaWxlIChwb3MucGF0aC5sZW5ndGggPiBkaWZmQXQgKyAxKSB7CiAgICAgICAgdmFyIGhvd01hbnkgPSBwb3NQYXJlbnQubWF4T2Zmc2V0IC0gcG9zLm9mZnNldDsKCiAgICAgICAgaWYgKGhvd01hbnkgIT09IDApIHsKICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShwb3MsIHBvcy5nZXRTaGlmdGVkQnkoaG93TWFueSkpKTsKICAgICAgICB9CgogICAgICAgIHBvcy5wYXRoID0gcG9zLnBhdGguc2xpY2UoMCwgLTEpOwogICAgICAgIHBvcy5vZmZzZXQrKzsKICAgICAgICBwb3NQYXJlbnQgPSBwb3NQYXJlbnQucGFyZW50OwogICAgICB9IC8vIEdvIGRvd24uCgoKICAgICAgd2hpbGUgKHBvcy5wYXRoLmxlbmd0aCA8PSB0aGlzLmVuZC5wYXRoLmxlbmd0aCkgewogICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmVuZC5wYXRoW3Bvcy5wYXRoLmxlbmd0aCAtIDFdOwoKICAgICAgICB2YXIgX2hvd01hbnkgPSBvZmZzZXQgLSBwb3Mub2Zmc2V0OwoKICAgICAgICBpZiAoX2hvd01hbnkgIT09IDApIHsKICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShwb3MsIHBvcy5nZXRTaGlmdGVkQnkoX2hvd01hbnkpKSk7CiAgICAgICAgfQoKICAgICAgICBwb3Mub2Zmc2V0ID0gb2Zmc2V0OwogICAgICAgIHBvcy5wYXRoLnB1c2goMCk7CiAgICAgIH0KCiAgICAgIHJldHVybiByYW5nZXM7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXIgVHJlZVdhbGtlcn0gaW5zdGFuY2Ugd2l0aCB0aGlzIHJhbmdlIGFzIGEgYm91bmRhcnkuCiAgICAgKgogICAgICogRm9yIGV4YW1wbGUsIHRvIGl0ZXJhdGUgb3ZlciBhbGwgaXRlbXMgaW4gdGhlIGVudGlyZSBkb2N1bWVudCByb290OgogICAgICoKICAgICAqCQkvLyBDcmVhdGUgYSByYW5nZSBzcGFubmluZyBvdmVyIHRoZSBlbnRpcmUgcm9vdCBjb250ZW50OgogICAgICoJCWNvbnN0IHJhbmdlID0gZWRpdG9yLm1vZGVsLmNyZWF0ZVJhbmdlSW4oIGVkaXRvci5tb2RlbC5kb2N1bWVudC5nZXRSb290KCkgKTsKICAgICAqCiAgICAgKgkJLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGlzIHJhbmdlOgogICAgICoJCWZvciAoIGNvbnN0IHZhbHVlIG9mIHJhbmdlLmdldFdhbGtlcigpICkgewogICAgICoJCQljb25zb2xlLmxvZyggdmFsdWUuaXRlbSApOwogICAgICoJCX0KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBbb3B0aW9ucy5zdGFydFBvc2l0aW9uXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaW5nbGVDaGFyYWN0ZXJzPWZhbHNlXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaGFsbG93PWZhbHNlXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kPWZhbHNlXQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFdhbGtlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2Fsa2VyKCkgewogICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307CiAgICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICAgIHJldHVybiBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAgICogdGhlbS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gd2l0aCBgYm91bmRhcmllc2Agc2V0IHRvIHRoaXMgcmFuZ2UgYW5kIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24KICAgICAqIHNldCB0byBgdHJ1ZWAuIEhvd2V2ZXIgaXQgcmV0dXJucyBvbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtc30sCiAgICAgKiBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9LgogICAgICoKICAgICAqIFlvdSBtYXkgc3BlY2lmeSBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0cmVlIHdhbGtlci4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gZm9yCiAgICAgKiBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9ucy4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0SXRlbXMiLAogICAgdmFsdWU6CiAgICAvKiNfX1BVUkVfXyovCiAgICByZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBnZXRJdGVtcygpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICB0cmVlV2Fsa2VyLAogICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwKICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yLAogICAgICAgICAgX2l0ZXJhdG9yRXJyb3IsCiAgICAgICAgICBfaXRlcmF0b3IsCiAgICAgICAgICBfc3RlcCwKICAgICAgICAgIF92YWx1ZSwKICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRJdGVtcyQoX2NvbnRleHQyKSB7CiAgICAgICAgd2hpbGUgKDEpIHsKICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzMi5sZW5ndGggPiAwICYmIF9hcmdzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzBdIDoge307CiAgICAgICAgICAgICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgICAgICAgICAgICBvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQgPSB0cnVlOwogICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gNzsKICAgICAgICAgICAgICBfaXRlcmF0b3IgPSB0cmVlV2Fsa2VyW1N5bWJvbC5pdGVyYXRvcl0oKTsKCiAgICAgICAgICAgIGNhc2UgOToKICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIHsKICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIF92YWx1ZSA9IF9zdGVwLnZhbHVlOwogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7CiAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZS5pdGVtOwoKICAgICAgICAgICAgY2FzZSAxMzoKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE4OgogICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7CiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyWyJjYXRjaCJdKDcpOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTsKICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0Mi50MDsKCiAgICAgICAgICAgIGNhc2UgMjI6CiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMjsKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIzOwoKICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSAyNToKICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1OwoKICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI4OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjsKCiAgICAgICAgICAgIGNhc2UgMjg6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjUpOwoKICAgICAgICAgICAgY2FzZSAyOToKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyMik7CgogICAgICAgICAgICBjYXNlIDMwOgogICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSwgZ2V0SXRlbXMsIHRoaXMsIFtbNywgMTgsIDIyLCAzMF0sIFsyMywsIDI1LCAyOV1dKTsKICAgIH0pCiAgICAvKioKICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIGFsbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9IHRoYXQgYXJlIGJvdW5kYXJpZXMgb3IKICAgICAqIGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZS4gSG93ZXZlciBpdCByZXR1cm5zIG9ubHkKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICAgKgogICAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSBmb3IKICAgICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFBvc2l0aW9ucyIsCiAgICB2YWx1ZToKICAgIC8qI19fUFVSRV9fKi8KICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIGdldFBvc2l0aW9ucygpIHsKICAgICAgdmFyIG9wdGlvbnMsCiAgICAgICAgICB0cmVlV2Fsa2VyLAogICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIsCiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIsCiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIsCiAgICAgICAgICBfaXRlcmF0b3IyLAogICAgICAgICAgX3N0ZXAyLAogICAgICAgICAgX3ZhbHVlMiwKICAgICAgICAgIF9hcmdzMyA9IGFyZ3VtZW50czsKCiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBnZXRQb3NpdGlvbnMkKF9jb250ZXh0MykgewogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczMubGVuZ3RoID4gMCAmJiBfYXJnczNbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzM1swXSA6IHt9OwogICAgICAgICAgICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICAgICAgICAgICAgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTsKICAgICAgICAgICAgICByZXR1cm4gdHJlZVdhbGtlci5wb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gODsKICAgICAgICAgICAgICBfaXRlcmF0b3IyID0gdHJlZVdhbGtlcltTeW1ib2wuaXRlcmF0b3JdKCk7CgogICAgICAgICAgICBjYXNlIDEwOgogICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgewogICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNzsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgX3ZhbHVlMiA9IF9zdGVwMi52YWx1ZTsKICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0OwogICAgICAgICAgICAgIHJldHVybiBfdmFsdWUyLm5leHRQb3NpdGlvbjsKCiAgICAgICAgICAgIGNhc2UgMTQ6CiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE3OgogICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjM7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIDE5OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTk7CiAgICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzWyJjYXRjaCJdKDgpOwogICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQzLnQwOwoKICAgICAgICAgICAgY2FzZSAyMzoKICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDIzOwogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjQ7CgogICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICBjYXNlIDI2OgogICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjY7CgogICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI5OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CgogICAgICAgICAgICBjYXNlIDI5OgogICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDI2KTsKCiAgICAgICAgICAgIGNhc2UgMzA6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjMpOwoKICAgICAgICAgICAgY2FzZSAzMToKICAgICAgICAgICAgY2FzZSAiZW5kIjoKICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sIGdldFBvc2l0aW9ucywgdGhpcywgW1s4LCAxOSwgMjMsIDMxXSwgWzI0LCwgMjYsIDMwXV0pOwogICAgfSkKICAgIC8qKgogICAgICogUmV0dXJucyBhIHJhbmdlIHRoYXQgaXMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIHRoaXMgcmFuZ2UgYnkgZ2l2ZW4gYG9wZXJhdGlvbmAuCiAgICAgKgogICAgICogKipOb3RlOioqIHRyYW5zZm9ybWF0aW9uIG1heSBicmVhayBvbmUgcmFuZ2UgaW50byBtdWx0aXBsZSByYW5nZXMgKGZvciBleGFtcGxlLCB3aGVuIGEgcGFydCBvZiB0aGUgcmFuZ2UgaXMKICAgICAqIG1vdmVkIHRvIGEgZGlmZmVyZW50IHBhcnQgb2YgZG9jdW1lbnQgdHJlZSkuIEZvciB0aGlzIHJlYXNvbiwgYW4gYXJyYXkgaXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgYW5kIGl0CiAgICAgKiBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSBgUmFuZ2VgIGluc3RhbmNlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wZXJhdGlvbiBPcGVyYXRpb24gdG8gdHJhbnNmb3JtIHJhbmdlIGJ5LgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gUmFuZ2Ugd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiB0cmFuc2Zvcm1hdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7CiAgICAgICAgY2FzZSAnaW5zZXJ0JzoKICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICAgIGNhc2UgJ21vdmUnOgogICAgICAgIGNhc2UgJ3JlbW92ZSc6CiAgICAgICAgY2FzZSAncmVpbnNlcnQnOgogICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICAgIGNhc2UgJ3NwbGl0JzoKICAgICAgICAgIHJldHVybiBbdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbildOwoKICAgICAgICBjYXNlICdtZXJnZSc6CiAgICAgICAgICByZXR1cm4gW3RoaXMuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pXTsKICAgICAgfQoKICAgICAgcmV0dXJuIFtuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQpXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJhbmdlIHRoYXQgaXMgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIHRoaXMgcmFuZ2UgYnkgbXVsdGlwbGUgYG9wZXJhdGlvbnNgLgogICAgICoKICAgICAqIEBzZWUgflJhbmdlI2dldFRyYW5zZm9ybWVkQnlPcGVyYXRpb24KICAgICAqIEBwYXJhbSB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zIE9wZXJhdGlvbnMgdG8gdHJhbnNmb3JtIHRoZSByYW5nZSBieS4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJhbmdlIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdHJhbnNmb3JtYXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyYW5zZm9ybWVkQnlPcGVyYXRpb25zKG9wZXJhdGlvbnMpIHsKICAgICAgdmFyIHJhbmdlcyA9IFtuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQpXTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gb3BlcmF0aW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IF9zdGVwMy52YWx1ZTsKCiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmFuZ2VzLmxlbmd0aDsgX2krKykgewogICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmFuZ2VzW19pXS5nZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICAgICAgICByYW5nZXMuc3BsaWNlLmFwcGx5KHJhbmdlcywgW19pLCAxXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdCkpKTsKICAgICAgICAgICAgX2kgKz0gcmVzdWx0Lmxlbmd0aCAtIDE7CiAgICAgICAgICB9CiAgICAgICAgfSAvLyBJdCBtYXkgaGFwcGVuIHRoYXQgYSByYW5nZSBpcyBzcGxpdCBpbnRvIHR3bywgYW5kIHRoZW4gdGhlIHBhcnQgb2Ygc2Vjb25kICJwaWVjZSIgaXMgbW92ZWQgaW50byBmaXJzdAogICAgICAgIC8vICJwaWVjZSIuIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGhhdmUgaW5jb3JyZWN0IHRoaXJkIHJhbmdlLCB3aGljaCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgLS0KICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlIGZpcnN0ICJwaWVjZSIuIEluIHRoaXMgbG9vcCB3ZSBhcmUgbG9va2luZyBmb3IgYWxsIHN1Y2ggcmFuZ2VzIHRoYXQKICAgICAgICAvLyBhcmUgaW5zaWRlIG90aGVyIHJhbmdlcyBhbmQgd2Ugc2ltcGx5IHJlbW92ZSB0aGVtLgoKICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMzsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldOwoKICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgIHZhciBuZXh0ID0gcmFuZ2VzW2pdOwoKICAgICAgICAgIGlmIChyYW5nZS5jb250YWluc1JhbmdlKG5leHQpIHx8IG5leHQuY29udGFpbnNSYW5nZShyYW5nZSkgfHwgcmFuZ2UuaXNFcXVhbChuZXh0KSkgewogICAgICAgICAgICByYW5nZXMuc3BsaWNlKGosIDEpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJhbmdlczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqIHdoaWNoIGlzIGEgY29tbW9uIGFuY2VzdG9yIG9mIHRoZSByYW5nZSdzIGJvdGggZW5kcyAoaW4gd2hpY2ggdGhlIGVudGlyZSByYW5nZSBpcyBjb250YWluZWQpLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENvbW1vbkFuY2VzdG9yIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3RvcigpIHsKICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZ2V0Q29tbW9uQW5jZXN0b3IodGhpcy5lbmQpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBFbGVtZW50fSBjb250YWluZWQgYnkgdGhlIHJhbmdlLgogICAgICogVGhlIGVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZCB3aGVuIGl0IGlzIHRoZSAqKm9ubHkqKiBub2RlIHdpdGhpbiB0aGUgcmFuZ2UgYW5kICoqZnVsbHnigJNjb250YWluZWQqKgogICAgICogYXQgdGhlIHNhbWUgdGltZS4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRDb250YWluZWRFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250YWluZWRFbGVtZW50KCkgewogICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CgogICAgICB2YXIgbm9kZUFmdGVyU3RhcnQgPSB0aGlzLnN0YXJ0Lm5vZGVBZnRlcjsKICAgICAgdmFyIG5vZGVCZWZvcmVFbmQgPSB0aGlzLmVuZC5ub2RlQmVmb3JlOwoKICAgICAgaWYgKG5vZGVBZnRlclN0YXJ0ICYmIG5vZGVBZnRlclN0YXJ0LmlzKCdlbGVtZW50JykgJiYgbm9kZUFmdGVyU3RhcnQgPT09IG5vZGVCZWZvcmVFbmQpIHsKICAgICAgICByZXR1cm4gbm9kZUFmdGVyU3RhcnQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgUmFuZ2VgIHRvIHBsYWluIG9iamVjdCBhbmQgcmV0dXJucyBpdC4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgTm9kZWAgY29udmVydGVkIHRvIHBsYWluIG9iamVjdC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b0pTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBzdGFydDogdGhpcy5zdGFydC50b0pTT04oKSwKICAgICAgICBlbmQ6IHRoaXMuZW5kLnRvSlNPTigpCiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBuZXcgcmFuZ2UgdGhhdCBpcyBlcXVhbCB0byBjdXJyZW50IHJhbmdlLgogICAgICoKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNsb25lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgaW5zZXJ0IG9wZXJhdGlvbi4KICAgICAqCiAgICAgKiBPbmUgb3IgbW9yZSByYW5nZXMgbWF5IGJlIHJldHVybmVkIGFzIGEgcmVzdWx0IG9mIHRoaXMgdHJhbnNmb3JtYXRpb24uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9pbnNlcnRvcGVyYXRpb25+SW5zZXJ0T3BlcmF0aW9ufSBvcGVyYXRpb24KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgc3ByZWFkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24ob3BlcmF0aW9uLnBvc2l0aW9uLCBvcGVyYXRpb24uaG93TWFueSwgc3ByZWFkKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgbW92ZSBvcGVyYXRpb24uCiAgICAgKgogICAgICogT25lIG9yIG1vcmUgcmFuZ2VzIG1heSBiZSByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiB0aGlzIHRyYW5zZm9ybWF0aW9uLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbW92ZW9wZXJhdGlvbn5Nb3ZlT3BlcmF0aW9ufSBvcGVyYXRpb24KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIHZhciBzcHJlYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogICAgICB2YXIgc291cmNlUG9zaXRpb24gPSBvcGVyYXRpb24uc291cmNlUG9zaXRpb247CiAgICAgIHZhciBob3dNYW55ID0gb3BlcmF0aW9uLmhvd01hbnk7CiAgICAgIHZhciB0YXJnZXRQb3NpdGlvbiA9IG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbjsKICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSwgc3ByZWFkKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgc3BsaXQgb3BlcmF0aW9uLgogICAgICoKICAgICAqIEFsd2F5cyBvbmUgcmFuZ2UgaXMgcmV0dXJuZWQuIFRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lIGluIGEgd2F5IHRvIG5vdCBicmVhayB0aGUgcmFuZ2UuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9zcGxpdG9wZXJhdGlvbn5TcGxpdE9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24ob3BlcmF0aW9uKTsKCiAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICBpZiAodGhpcy5lbmQuaXNFcXVhbChvcGVyYXRpb24uaW5zZXJ0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgZW5kID0gdGhpcy5lbmQuZ2V0U2hpZnRlZEJ5KDEpOwogICAgICB9IC8vIEJlbG93IG1heSBoYXBwZW4gd2hlbiByYW5nZSBjb250YWlucyBncmF2ZXlhcmQgZWxlbWVudCB1c2VkIGJ5IHNwbGl0IG9wZXJhdGlvbi4KCgogICAgICBpZiAoc3RhcnQucm9vdCAhPSBlbmQucm9vdCkgewogICAgICAgIC8vIEVuZCBwb3NpdGlvbiB3YXMgbmV4dCB0byB0aGUgbW92ZWQgZ3JhdmV5YXJkIGVsZW1lbnQgYW5kIHdhcyBtb3ZlZCB3aXRoIGl0LgogICAgICAgIC8vIEZpeCBpdCBieSB1c2luZyBvbGQgYGVuZGAgd2hpY2ggaGFzIHByb3BlciBgcm9vdGAuCiAgICAgICAgZW5kID0gdGhpcy5lbmQuZ2V0U2hpZnRlZEJ5KC0xKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgbWVyZ2Ugb3BlcmF0aW9uLgogICAgICoKICAgICAqIEFsd2F5cyBvbmUgcmFuZ2UgaXMgcmV0dXJuZWQuIFRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lIGluIGEgd2F5IHRvIG5vdCBicmVhayB0aGUgcmFuZ2UuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tZXJnZW9wZXJhdGlvbn5NZXJnZU9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbikgewogICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiB0aGUgbWFya2VyIGlzIHNldCBvbiAidGhlIGNsb3NpbmcgdGFnIiBvZiBhbiBlbGVtZW50LiBNYXJrZXIgY2FuIGJlIHNldCBsaWtlIHRoYXQgZHVyaW5nCiAgICAgIC8vIHRyYW5zZm9ybWF0aW9ucywgZXNwZWNpYWxseSB3aGVuIGEgY29udGVudCBvZiBhIGZldyBibG9jayBlbGVtZW50cyB3ZXJlIHJlbW92ZWQuIEZvciBleGFtcGxlOgogICAgICAvLwogICAgICAvLyB7fSBpcyB0aGUgdHJhbnNmb3JtZWQgcmFuZ2UsIFtdIGlzIHRoZSByZW1vdmVkIHJhbmdlLgogICAgICAvLyA8cD5GW297bzwvcD48cD5CfWFyPC9wPjxwPlh5XXo8L3A+CiAgICAgIC8vCiAgICAgIC8vIDxwPkZve288L3A+PHA+Qn1hcjwvcD48cD56PC9wPgogICAgICAvLyA8cD5GezwvcD48cD5CfWFyPC9wPjxwPno8L3A+CiAgICAgIC8vIDxwPkZ7PC9wPn08cD56PC9wPgogICAgICAvLyA8cD5Ge316PC9wPgogICAgICAvLwogICAgICBpZiAodGhpcy5zdGFydC5pc0VxdWFsKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikgJiYgdGhpcy5lbmQuaXNFcXVhbChvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQpOwogICAgICB9CgogICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24ob3BlcmF0aW9uKTsKCiAgICAgIHZhciBlbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgICBpZiAoc3RhcnQucm9vdCAhPSBlbmQucm9vdCkgewogICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBlbmQgcG9zaXRpb24gd2FzIG5leHQgdG8gdGhlIG1lcmdlZCAoZGVsZXRlZCkgZWxlbWVudC4KICAgICAgICAvLyBUaGVuLCB0aGUgZW5kIHBvc2l0aW9uIHdhcyBtb3ZlZCB0byB0aGUgZ3JhdmV5YXJkIHJvb3QuIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGZpeAogICAgICAgIC8vIHRoZSByYW5nZSBjYXVzZSBpdHMgYm91bmRhcmllcyB3b3VsZCBiZSBpbiBkaWZmZXJlbnQgcm9vdHMuCiAgICAgICAgZW5kID0gdGhpcy5lbmQuZ2V0U2hpZnRlZEJ5KC0xKTsKICAgICAgfQoKICAgICAgaWYgKHN0YXJ0LmlzQWZ0ZXIoZW5kKSkgewogICAgICAgIC8vIFRoaXMgaGFwcGVucyBpbiB0aHJlZSBmb2xsb3dpbmcgY2FzZXM6CiAgICAgICAgLy8KICAgICAgICAvLyBDYXNlIDE6IE1lcmdlIG9wZXJhdGlvbiBzb3VyY2UgcG9zaXRpb24gaXMgYmVmb3JlIHRoZSB0YXJnZXQgcG9zaXRpb24gKGR1ZSB0byBzb21lIHRyYW5zZm9ybWF0aW9ucywgT1QsIGV0Yy4pCiAgICAgICAgLy8gICAgICAgICBUaGlzIG1lYW5zIHRoYXQgc3RhcnQgY2FuIGJlIG1vdmVkIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSByYW5nZS4KICAgICAgICAvLwogICAgICAgIC8vIEJlZm9yZTogPHA+YXthPC9wPjxwPmJ9YjwvcD48cD5jYzwvcD4KICAgICAgICAvLyBNZXJnZTogIDxwPmJ9YjwvcD48cD5jY2F7YTwvcD4KICAgICAgICAvLyBGaXg6ICAgIDxwPntifWI8L3A+PHA+Y2NhYTwvcD4KICAgICAgICAvLwogICAgICAgIC8vIENhc2UgMjogUmFuZ2Ugc3RhcnQgaXMgYmVmb3JlIG1lcmdlZCBub2RlIGJ1dCBub3QgZGlyZWN0bHkuCiAgICAgICAgLy8gICAgICAgICBSZXN1bHQgc2hvdWxkIGluY2x1ZGUgYWxsIG5vZGVzIHRoYXQgd2VyZSBpbiB0aGUgb3JpZ2luYWwgcmFuZ2UuCiAgICAgICAgLy8KICAgICAgICAvLyBCZWZvcmU6IDxwPmFhPC9wPns8cD5jYzwvcD48cD5ifWI8L3A+CiAgICAgICAgLy8gTWVyZ2U6ICA8cD5hYWJ9YjwvcD57PHA+Y2M8L3A+CiAgICAgICAgLy8gRml4OiAgICA8cD5hYXtiYjwvcD48cD5jYzwvcD59CiAgICAgICAgLy8KICAgICAgICAvLyAgICAgICAgIFRoZSByYW5nZSBpcyBleHBhbmRlZCBieSBhbiBhZGRpdGlvbmFsIGBiYCBsZXR0ZXIgYnV0IGl0IGlzIGJldHRlciB0aGFuIGRyb3BwaW5nIHRoZSB3aG9sZSBgY2NgIHBhcmFncmFwaC4KICAgICAgICAvLwogICAgICAgIC8vIENhc2UgMzogUmFuZ2Ugc3RhcnQgaXMgZGlyZWN0bHkgYmVmb3JlIG1lcmdlZCBub2RlLgogICAgICAgIC8vICAgICAgICAgUmVzdWx0aW5nIHJhbmdlIHNob3VsZCBpbmNsdWRlIG9ubHkgbm9kZXMgZnJvbSB0aGUgbWVyZ2VkIGVsZW1lbnQ6CiAgICAgICAgLy8KICAgICAgICAvLyBCZWZvcmU6IDxwPmFhPC9wPns8cD5ifWI8L3A+PHA+Y2M8L3A+CiAgICAgICAgLy8gTWVyZ2U6ICA8cD5hYWJ9YjwvcD57PHA+Y2M8L3A+CiAgICAgICAgLy8gRml4OiAgICA8cD5hYXtifWI8L3A+PHA+Y2M8L3A+CiAgICAgICAgLy8KICAgICAgICBpZiAob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLmlzQmVmb3JlKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgIC8vIENhc2UgMS4KICAgICAgICAgIHN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KGVuZCk7CiAgICAgICAgICBzdGFydC5vZmZzZXQgPSAwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoIW9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uLmlzRXF1YWwoc3RhcnQpKSB7CiAgICAgICAgICAgIC8vIENhc2UgMi4KICAgICAgICAgICAgZW5kID0gb3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb247CiAgICAgICAgICB9IC8vIEluIGJvdGggY2FzZSAyIGFuZCAzIHN0YXJ0IGlzIGF0IHRoZSBlbmQgb2YgdGhlIG1lcmdlLXRvIGVsZW1lbnQuCgoKICAgICAgICAgIHN0YXJ0ID0gb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIG9uZSBvciB0d28ge0BsaW5rIH5SYW5nZSByYW5nZXN9IHRoYXQgYXJlIGEgcmVzdWx0IG9mIHRyYW5zZm9ybWluZyB0aGlzCiAgICAgKiB7QGxpbmsgflJhbmdlIHJhbmdlfSBieSBpbnNlcnRpbmcgYGhvd01hbnlgIG5vZGVzIGF0IGBpbnNlcnRQb3NpdGlvbmAuIFR3byB7QGxpbmsgflJhbmdlIHJhbmdlc30gYXJlCiAgICAgKiByZXR1cm5lZCBpZiB0aGUgaW5zZXJ0aW9uIHdhcyBpbnNpZGUgdGhpcyB7QGxpbmsgflJhbmdlIHJhbmdlfSBhbmQgYHNwcmVhZGAgaXMgc2V0IHRvIGB0cnVlYC4KICAgICAqCiAgICAgKiBFeGFtcGxlczoKICAgICAqCiAgICAgKgkJbGV0IHJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgNyBdICksCiAgICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCwgMCwgMSBdICkKICAgICAqCQkpOwogICAgICoJCWxldCB0cmFuc2Zvcm1lZCA9IHJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDEgXSApLCAyICk7CiAgICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZSBmcm9tIFsgNCwgNyBdIHRvIFsgNiwgMCwgMSBdCiAgICAgKgogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCwgMCwgMCBdICksIDQgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlIGZyb20gWyAyLCA3IF0gdG8gWyA0LCAwLCA1IF0KICAgICAqCiAgICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbiggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzLCAyIF0gKSwgNCApOwogICAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBvbmUgcmFuZ2UsIHdoaWNoIGlzIGVxdWFsIHRvIG9yaWdpbmFsIHJhbmdlCiAgICAgKgogICAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMywgMiBdICksIDQsIHRydWUgKTsKICAgICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgdHdvIHJhbmdlczogZnJvbSBbIDIsIDcgXSB0byBbIDMsIDIgXSBhbmQgZnJvbSBbIDMsIDYgXSB0byBbIDQsIDAsIDEgXQogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaW5zZXJ0UG9zaXRpb24gUG9zaXRpb24gd2hlcmUgbm9kZXMgYXJlIGluc2VydGVkLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIGluc2VydGVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbc3ByZWFkXSBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHt+UmFuZ2UgcmFuZ2V9IHNob3VsZCBiZSBzcHJlYWQgaWYgaW5zZXJ0aW9uCiAgICAgKiB3YXMgaW5zaWRlIHRoZSByYW5nZS4gRGVmYXVsdHMgdG8gYGZhbHNlYC4KICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGluc2VydFBvc2l0aW9uLCBob3dNYW55KSB7CiAgICAgIHZhciBzcHJlYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlOwoKICAgICAgaWYgKHNwcmVhZCAmJiB0aGlzLmNvbnRhaW5zUG9zaXRpb24oaW5zZXJ0UG9zaXRpb24pKSB7CiAgICAgICAgLy8gUmFuZ2UgaGFzIHRvIGJlIHNwcmVhZC4gVGhlIGZpcnN0IHBhcnQgaXMgZnJvbSBvcmlnaW5hbCBzdGFydCB0byB0aGUgc3ByZWFkIHBvaW50LgogICAgICAgIC8vIFRoZSBvdGhlciBwYXJ0IGlzIGZyb20gc3ByZWFkIHBvaW50IHRvIHRoZSBvcmlnaW5hbCBlbmQsIGJ1dCB0cmFuc2Zvcm1lZCBieQogICAgICAgIC8vIGluc2VydGlvbiB0byByZWZsZWN0IGluc2VydGlvbiBjaGFuZ2VzLgogICAgICAgIHJldHVybiBbbmV3IFJhbmdlKHRoaXMuc3RhcnQsIGluc2VydFBvc2l0aW9uKSwgbmV3IFJhbmdlKGluc2VydFBvc2l0aW9uLmdldFNoaWZ0ZWRCeShob3dNYW55KSwgdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpKV07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTsKICAgICAgICByYW5nZS5zdGFydCA9IHJhbmdlLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGluc2VydFBvc2l0aW9uLCBob3dNYW55KTsKICAgICAgICByYW5nZS5lbmQgPSByYW5nZS5lbmQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpOwogICAgICAgIHJldHVybiBbcmFuZ2VdOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB7QGxpbmsgflJhbmdlIHJhbmdlc30gdGhhdCBhcmUgYSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIHRoaXMKICAgICAqIHtAbGluayB+UmFuZ2UgcmFuZ2V9IGJ5IG1vdmluZyBgaG93TWFueWAgbm9kZXMgZnJvbSBgc291cmNlUG9zaXRpb25gIHRvIGB0YXJnZXRQb3NpdGlvbmAuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzb3VyY2VQb3NpdGlvbiBQb3NpdGlvbiBmcm9tIHdoaWNoIG5vZGVzIGFyZSBtb3ZlZC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0UG9zaXRpb24gUG9zaXRpb24gdG8gd2hlcmUgbm9kZXMgYXJlIG1vdmVkLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIG1vdmVkLgogICAgICogQHBhcmFtIHtCb29sZWFufSBbc3ByZWFkPWZhbHNlXSBXaGV0aGVyIHRoZSByYW5nZSBzaG91bGQgYmUgc3ByZWFkIGlmIHRoZSBtb3ZlIHBvaW50cyBpbnNpZGUgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gUmVzdWx0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbi4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0VHJhbnNmb3JtZWRCeU1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpIHsKICAgICAgdmFyIHNwcmVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7CgogICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRyYW5zZm9ybWluZyBhIGNvbGxhcHNlZCByYW5nZS4gSnVzdCB0cmFuc2Zvcm0gaXQgbGlrZSBhIHBvc2l0aW9uLgogICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkgewogICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgICByZXR1cm4gW25ldyBSYW5nZShuZXdQb3MpXTsKICAgICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIHRyYW5zZm9ybWF0aW9uIHdoZW4gYSBwYXJ0IG9mIHRoZSByYW5nZSBpcyBtb3ZlZCB0b3dhcmRzIHRoZSByYW5nZS4KICAgICAgLy8KICAgICAgLy8gRXhhbXBsZXM6CiAgICAgIC8vCiAgICAgIC8vIDxkaXY+PHA+YWI8L3A+PHA+Y1tkPC9wPjwvZGl2PjxwPmVdZjwvcD4gLS0+IDxkaXY+PHA+YWI8L3A+PC9kaXY+PHA+Y1tkPC9wPjxwPmVdZjwvcD4KICAgICAgLy8gPHA+ZVtmPC9wPjxkaXY+PHA+YV1iPC9wPjxwPmNkPC9wPjwvZGl2PiAtLT4gPHA+ZVtmPC9wPjxwPmFdYjwvcD48ZGl2PjxwPmNkPC9wPjwvZGl2PgogICAgICAvLwogICAgICAvLyBXaXRob3V0IHRoaXMgc3BlY2lhbCBjb25kaXRpb24sIHRoZSBkZWZhdWx0IGFsZ29yaXRobSBsZWF2ZXMgYW4gImFydGlmYWN0IiByYW5nZSBmcm9tIG9uZSBvZiBgZGlmZmVyZW5jZVNldGAgcGFydHM6CiAgICAgIC8vCiAgICAgIC8vIDxkaXY+PHA+YWI8L3A+PHA+Y1tkPC9wPjwvZGl2PjxwPmVdZjwvcD4gLS0+IDxkaXY+PHA+YWI8L3A+ezwvZGl2Pn08cD5jW2Q8L3A+PHA+ZV1mPC9wPgogICAgICAvLwogICAgICAvLyBUaGlzIHNwZWNpYWwgY2FzZSBpcyBhcHBsaWVkIG9ubHkgaWYgdGhlIHJhbmdlIGlzIHRvIGJlIGtlcHQgdG9nZXRoZXIgKG5vdCBzcHJlYWQpLgoKCiAgICAgIHZhciBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoc291cmNlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgdmFyIGluc2VydFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSk7CgogICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKHRhcmdldFBvc2l0aW9uKSAmJiAhc3ByZWFkKSB7CiAgICAgICAgaWYgKG1vdmVSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMuc3RhcnQpIHx8IG1vdmVSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMuZW5kKSkgewogICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSk7CgogICAgICAgICAgcmV0dXJuIFtuZXcgUmFuZ2Uoc3RhcnQsIGVuZCldOwogICAgICAgIH0KICAgICAgfSAvLyBEZWZhdWx0IGFsZ29yaXRobS4KCgogICAgICB2YXIgcmVzdWx0OwogICAgICB2YXIgZGlmZmVyZW5jZVNldCA9IHRoaXMuZ2V0RGlmZmVyZW5jZShtb3ZlUmFuZ2UpOwogICAgICB2YXIgZGlmZmVyZW5jZSA9IG51bGw7CiAgICAgIHZhciBjb21tb24gPSB0aGlzLmdldEludGVyc2VjdGlvbihtb3ZlUmFuZ2UpOwoKICAgICAgaWYgKGRpZmZlcmVuY2VTZXQubGVuZ3RoID09IDEpIHsKICAgICAgICAvLyBgbW92ZVJhbmdlYCBhbmQgdGhpcyByYW5nZSBtYXkgaW50ZXJzZWN0IGJ1dCBtYXkgYmUgc2VwYXJhdGUuCiAgICAgICAgZGlmZmVyZW5jZSA9IG5ldyBSYW5nZShkaWZmZXJlbmNlU2V0WzBdLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpLCBkaWZmZXJlbmNlU2V0WzBdLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KSk7CiAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZVNldC5sZW5ndGggPT0gMikgewogICAgICAgIC8vIGBtb3ZlUmFuZ2VgIGlzIGluc2lkZSB0aGlzIHJhbmdlLgogICAgICAgIGRpZmZlcmVuY2UgPSBuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSkpOwogICAgICB9IC8vIGVsc2UsIGBtb3ZlUmFuZ2VgIGNvbnRhaW5zIHRoaXMgcmFuZ2UuCgoKICAgICAgaWYgKGRpZmZlcmVuY2UpIHsKICAgICAgICByZXN1bHQgPSBkaWZmZXJlbmNlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGluc2VydFBvc2l0aW9uLCBob3dNYW55LCBjb21tb24gIT09IG51bGwgfHwgc3ByZWFkKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQgPSBbXTsKICAgICAgfQoKICAgICAgaWYgKGNvbW1vbikgewogICAgICAgIHZhciB0cmFuc2Zvcm1lZENvbW1vbiA9IG5ldyBSYW5nZShjb21tb24uc3RhcnQuX2dldENvbWJpbmVkKG1vdmVSYW5nZS5zdGFydCwgaW5zZXJ0UG9zaXRpb24pLCBjb21tb24uZW5kLl9nZXRDb21iaW5lZChtb3ZlUmFuZ2Uuc3RhcnQsIGluc2VydFBvc2l0aW9uKSk7CgogICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDIpIHsKICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMSwgMCwgdHJhbnNmb3JtZWRDb21tb24pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXN1bHQucHVzaCh0cmFuc2Zvcm1lZENvbW1vbik7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJhbmdlIHRoYXQgaXMgdHJhbnNmb3JtZWQgYnkgZGVsZXRpb24gb2YgYGhvd01hbnlgIG5vZGVzIGZyb20gYGRlbGV0ZVBvc2l0aW9uYC4KICAgICAqCiAgICAgKiBJZiB0aGUgZGVsZXRlZCByYW5nZSBpcyBpbnRlcnNlY3Rpbmcgd2l0aCB0aGUgdHJhbnNmb3JtZWQgcmFuZ2UsIHRoZSB0cmFuc2Zvcm1lZCByYW5nZSB3aWxsIGJlIHNocmFuay4KICAgICAqCiAgICAgKiBJZiB0aGUgZGVsZXRlZCByYW5nZSBjb250YWlucyB0cmFuc2Zvcm1lZCByYW5nZSwgYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBkZWxldGlvblBvc2l0aW9uIFBvc2l0aW9uIGZyb20gd2hpY2ggbm9kZXMgYXJlIHJlbW92ZWQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gaG93TWFueSBIb3cgbWFueSBub2RlcyBhcmUgcmVtb3ZlZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IFJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihkZWxldGVQb3NpdGlvbiwgaG93TWFueSkgewogICAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oZGVsZXRlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgdmFyIG5ld0VuZCA9IHRoaXMuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oZGVsZXRlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgaWYgKG5ld1N0YXJ0ID09IG51bGwgJiYgbmV3RW5kID09IG51bGwpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKG5ld1N0YXJ0ID09IG51bGwpIHsKICAgICAgICBuZXdTdGFydCA9IGRlbGV0ZVBvc2l0aW9uOwogICAgICB9CgogICAgICBpZiAobmV3RW5kID09IG51bGwpIHsKICAgICAgICBuZXdFbmQgPSBkZWxldGVQb3NpdGlvbjsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShuZXdTdGFydCwgbmV3RW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyByYW5nZSwgc3ByZWFkaW5nIGZyb20gc3BlY2lmaWVkIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSB0byBhIHBvc2l0aW9uIG1vdmVkIGJ5CiAgICAgKiBnaXZlbiBgc2hpZnRgLiBJZiBgc2hpZnRgIGlzIGEgbmVnYXRpdmUgdmFsdWUsIHNoaWZ0ZWQgcG9zaXRpb24gaXMgdHJlYXRlZCBhcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIEJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2hpZnQgSG93IGxvbmcgdGhlIHJhbmdlIHNob3VsZCBiZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQ29sbGFwc2VkIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5zdGFydC5pc0VxdWFsKHRoaXMuZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgcmFuZ2UgaXMgZmxhdCwgdGhhdCBpcyBpZiB7QGxpbmsgI3N0YXJ0fSBwb3NpdGlvbiBhbmQKICAgICAqIHtAbGluayAjZW5kfSBwb3NpdGlvbiBhcmUgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50fS4KICAgICAqCiAgICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0ZsYXQiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciBzdGFydFBhcmVudFBhdGggPSB0aGlzLnN0YXJ0LmdldFBhcmVudFBhdGgoKTsKICAgICAgdmFyIGVuZFBhcmVudFBhdGggPSB0aGlzLmVuZC5nZXRQYXJlbnRQYXRoKCk7CiAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKHN0YXJ0UGFyZW50UGF0aCwgZW5kUGFyZW50UGF0aCkgPT0gJ3NhbWUnOwogICAgfQogICAgLyoqCiAgICAgKiBSYW5nZSByb290IGVsZW1lbnQuCiAgICAgKgogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogInJvb3QiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvb3Q7CiAgICB9CiAgfV0sIFt7CiAgICBrZXk6ICJfY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChwb3NpdGlvbiwgc2hpZnQpIHsKICAgICAgdmFyIHN0YXJ0ID0gcG9zaXRpb247CiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbi5nZXRTaGlmdGVkQnkoc2hpZnQpOwogICAgICByZXR1cm4gc2hpZnQgPiAwID8gbmV3IHRoaXMoc3RhcnQsIGVuZCkgOiBuZXcgdGhpcyhlbmQsIHN0YXJ0KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YKICAgICAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlSW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVJbihlbGVtZW50KSB7CiAgICAgIHJldHVybiBuZXcgdGhpcyhQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgMCksIFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCBlbGVtZW50Lm1heE9mZnNldCkpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfSBhbmQgZW5kcyBhZnRlciBpdC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlT24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVPbihpdGVtKSB7CiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGl0ZW0pLCBpdGVtLm9mZnNldFNpemUpOwogICAgfQogICAgLyoqCiAgICAgKiBDb21iaW5lcyBhbGwgcmFuZ2VzIGZyb20gdGhlIHBhc3NlZCBhcnJheSBpbnRvIGEgb25lIHJhbmdlLiBBdCBsZWFzdCBvbmUgcmFuZ2UgaGFzIHRvIGJlIHBhc3NlZC4KICAgICAqIFBhc3NlZCByYW5nZXMgbXVzdCBub3QgaGF2ZSBjb21tb24gcGFydHMuCiAgICAgKgogICAgICogVGhlIGZpcnN0IHJhbmdlIGZyb20gdGhlIGFycmF5IGlzIGEgcmVmZXJlbmNlIHJhbmdlLiBJZiBvdGhlciByYW5nZXMgc3RhcnQgb3IgZW5kIG9uIHRoZSBleGFjdGx5IHNhbWUgcG9zaXRpb24gd2hlcmUKICAgICAqIHRoZSByZWZlcmVuY2UgcmFuZ2UsIHRoZXkgZ2V0IGNvbWJpbmVkIGludG8gb25lIHJhbmdlLgogICAgICoKICAgICAqCQlbICBdW10gIFsgICAgXVsgXVsgICAgICAgICAgICAgXVsgXVtdICBbICBdICAvLyBQYXNzZWQgcmFuZ2VzLCBzaG93biBzb3J0ZWQKICAgICAqCQlbICAgIF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBpZiB0aGUgZmlyc3QgcmFuZ2Ugd2FzIGEgcmVmZXJlbmNlIHJhbmdlLgogICAgICoJICAgICAgICAgICAgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gICAgICAgIC8vIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlmIHRoZSB0aGlyZC10by1zZXZlbnRoIHJhbmdlIHdhcyBhIHJlZmVyZW5jZSByYW5nZS4KICAgICAqCSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbICBdICAvLyBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBpZiB0aGUgbGFzdCByYW5nZSB3YXMgYSByZWZlcmVuY2UgcmFuZ2UuCiAgICAgKgogICAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcyBSYW5nZXMgdG8gY29tYmluZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBDb21iaW5lZCByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY3JlYXRlRnJvbVJhbmdlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUZyb21SYW5nZXMocmFuZ2VzKSB7CiAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQXQgbGVhc3Qgb25lIHJhbmdlIGhhcyB0byBiZSBwYXNzZWQgdG8KICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZS5fY3JlYXRlRnJvbVJhbmdlcyBgUmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMoKWB9LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHJhbmdlLWNyZWF0ZS1mcm9tLXJhbmdlcy1lbXB0eS1hcnJheQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdyYW5nZS1jcmVhdGUtZnJvbS1yYW5nZXMtZW1wdHktYXJyYXk6IEF0IGxlYXN0IG9uZSByYW5nZSBoYXMgdG8gYmUgcGFzc2VkLicsIG51bGwpOwogICAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPT0gMSkgewogICAgICAgIHJldHVybiByYW5nZXNbMF0uY2xvbmUoKTsKICAgICAgfSAvLyAxLiBTZXQgdGhlIGZpcnN0IHJhbmdlIGluIGByYW5nZXNgIGFycmF5IGFzIGEgcmVmZXJlbmNlIHJhbmdlLgogICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gcmV0dXJuIGp1c3QgYSBvbmUgcmFuZ2UsIG9uZSBvZiB0aGUgcmFuZ2VzIG5lZWQgdG8gYmUgdGhlIHJlZmVyZW5jZSBvbmUuCiAgICAgIC8vIE90aGVyIHJhbmdlcyB3aWxsIGJlIHN0dWNrIHRvIHRoYXQgcmFuZ2UsIGlmIHBvc3NpYmxlLgoKCiAgICAgIHZhciByZWYgPSByYW5nZXNbMF07IC8vIDIuIFNvcnQgYWxsIHRoZSByYW5nZXMgc28gaXQncyBlYXNpZXIgdG8gcHJvY2VzcyB0aGVtLgoKICAgICAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICByZXR1cm4gYS5zdGFydC5pc0FmdGVyKGIuc3RhcnQpID8gMSA6IC0xOwogICAgICB9KTsgLy8gMy4gQ2hlY2sgYXQgd2hpY2ggaW5kZXggdGhlIHJlZmVyZW5jZSByYW5nZSBpcyBub3cuCgogICAgICB2YXIgcmVmSW5kZXggPSByYW5nZXMuaW5kZXhPZihyZWYpOyAvLyA0LiBBdCB0aGlzIG1vbWVudCB3ZSBkb24ndCBuZWVkIHRoZSBvcmlnaW5hbCByYW5nZS4KICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIG1vZGlmeSB0aGUgcmVzdWx0IGFuZCB3ZSBuZWVkIHRvIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBSYW5nZS4KICAgICAgLy8gV2UgaGF2ZSB0byBjcmVhdGUgYSBjb3B5IG9mIHRoZSByZWZlcmVuY2UgcmFuZ2UuCgogICAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMocmVmLnN0YXJ0LCByZWYuZW5kKTsgLy8gNS4gUmFuZ2VzIHNob3VsZCBiZSBjaGVja2VkIGFuZCBnbHVlZCBzdGFydGluZyBmcm9tIHRoZSByYW5nZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHJlZmVyZW5jZSByYW5nZS4KICAgICAgLy8gU2luY2UgcmFuZ2VzIGFyZSBzb3J0ZWQsIHN0YXJ0IHdpdGggdGhlIHJhbmdlIHdpdGggaW5kZXggdGhhdCBpcyBjbG9zZXN0IHRvIHJlZmVyZW5jZSByYW5nZSBpbmRleC4KCiAgICAgIGlmIChyZWZJbmRleCA+IDApIHsKICAgICAgICBmb3IgKHZhciBpID0gcmVmSW5kZXggLSAxOyB0cnVlOyBpKyspIHsKICAgICAgICAgIGlmIChyYW5nZXNbaV0uZW5kLmlzRXF1YWwocmVzdWx0LnN0YXJ0KSkgewogICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQocmFuZ2VzW2ldLnN0YXJ0KTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIElmIHJhbmdlcyBhcmUgbm90IHN0YXJ0aW5nL2VuZGluZyBhdCB0aGUgc2FtZSBwb3NpdGlvbiB0aGVyZSBpcyBubyBwb2ludCBpbiBsb29raW5nIGZ1cnRoZXIuCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyA2LiBSYW5nZXMgc2hvdWxkIGJlIGNoZWNrZWQgYW5kIGdsdWVkIHN0YXJ0aW5nIGZyb20gdGhlIHJhbmdlIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcmVmZXJlbmNlIHJhbmdlLgogICAgICAvLyBTaW5jZSByYW5nZXMgYXJlIHNvcnRlZCwgc3RhcnQgd2l0aCB0aGUgcmFuZ2Ugd2l0aCBpbmRleCB0aGF0IGlzIGNsb3Nlc3QgdG8gcmVmZXJlbmNlIHJhbmdlIGluZGV4LgoKCiAgICAgIGZvciAodmFyIF9pMiA9IHJlZkluZGV4ICsgMTsgX2kyIDwgcmFuZ2VzLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICBpZiAocmFuZ2VzW19pMl0uc3RhcnQuaXNFcXVhbChyZXN1bHQuZW5kKSkgewogICAgICAgICAgcmVzdWx0LmVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBdChyYW5nZXNbX2kyXS5lbmQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiByYW5nZXMgYXJlIG5vdCBzdGFydGluZy9lbmRpbmcgYXQgdGhlIHNhbWUgcG9zaXRpb24gdGhlcmUgaXMgbm8gcG9pbnQgaW4gbG9va2luZyBmdXJ0aGVyLgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgYFJhbmdlYCBpbnN0YW5jZSBmcm9tIGdpdmVuIHBsYWluIG9iamVjdCAoaS5lLiBwYXJzZWQgSlNPTiBzdHJpbmcpLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIFBsYWluIG9iamVjdCB0byBiZSBjb252ZXJ0ZWQgdG8gYFJhbmdlYC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gZG9jIERvY3VtZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgcmFuZ2Ugb3duZXIuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGBSYW5nZWAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZnJvbUpTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24sIGRvYykgewogICAgICByZXR1cm4gbmV3IHRoaXMoUG9zaXRpb24uZnJvbUpTT04oanNvbi5zdGFydCwgZG9jKSwgUG9zaXRpb24uZnJvbUpTT04oanNvbi5lbmQsIGRvYykpOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJcmV0dXJuIGAkeyB0aGlzLnJvb3QgfSBbICR7IHRoaXMuc3RhcnQucGF0aC5qb2luKCAnLCAnICkgfSBdIC0gWyAkeyB0aGlzLmVuZC5wYXRoLmpvaW4oICcsICcgKSB9IF1gOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGxvZygpIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWNvbnNvbGUubG9nKCAnTW9kZWxQb3NpdGlvbjogJyArIHRoaXMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICB9XSk7CgogIHJldHVybiBSYW5nZTsKfSgpOwoKZXhwb3J0IHsgUmFuZ2UgYXMgZGVmYXVsdCB9Ow=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js"],"names":["Position","TreeWalker","CKEditorError","compareArrays","Range","start","end","_createAt","stickiness","isCollapsed","Symbol","iterator","boundaries","ignoreElementEnd","position","isAfter","isBefore","otherRange","loose","containsStart","containsPosition","isEqual","containsEnd","item","pos","_createBefore","type","ranges","isIntersecting","push","commonRangeStart","commonRangeEnd","diffAt","getCommonPath","length","posParent","parent","path","howMany","maxOffset","offset","getShiftedBy","slice","options","treeWalker","value","nextPosition","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","operations","i","result","getTransformedByOperation","splice","range","j","next","containsRange","getCommonAncestor","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","is","toJSON","constructor","spread","_getTransformedByInsertion","sourcePosition","targetPosition","_getTransformedByMove","insertionPosition","root","deletionPosition","insertPosition","newPos","moveRange","_createFromPositionAndShift","_getTransformedByDeletion","differenceSet","getDifference","difference","common","getIntersection","transformedCommon","_getCombined","deletePosition","newStart","newEnd","startParentPath","getParentPath","endParentPath","shift","element","offsetSize","clone","ref","sort","a","b","refIndex","indexOf","json","doc","fromJSON"],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;AAKA;;;AAIA,OAAOA,QAAP,MAAqB,YAArB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA;;;;;;;;;;IASqBC,K;;;AACpB;;;;;;AAMA,iBAAaC,KAAb,EAAiC;AAAA,QAAbC,GAAa,uEAAP,IAAO;;AAAA;;AAChC;;;;;;AAMA,SAAKD,KAAL,GAAaL,QAAQ,CAACO,SAAT,CAAoBF,KAApB,CAAb;AAEA;;;;;;;AAMA,SAAKC,GAAL,GAAWA,GAAG,GAAGN,QAAQ,CAACO,SAAT,CAAoBD,GAApB,CAAH,GAA+BN,QAAQ,CAACO,SAAT,CAAoBF,KAApB,CAA7C,CAfgC,CAiBhC;AACA;;AACA,SAAKA,KAAL,CAAWG,UAAX,GAAwB,KAAKC,WAAL,GAAmB,QAAnB,GAA8B,QAAtD;AACA,SAAKH,GAAL,CAASE,UAAT,GAAsB,KAAKC,WAAL,GAAmB,QAAnB,GAA8B,YAApD;AACA;AAED;;;;;;;;;;;;;;;;;SAcIC,MAAM,CAACC,Q;;;;;;;;AACV,4CAAO,IAAIV,UAAJ,CAAgB;AAAEW,gBAAAA,UAAU,EAAE,IAAd;AAAoBC,gBAAAA,gBAAgB,EAAE;AAAtC,eAAhB,CAAP;;;;;;;;;AAGD;;;;;;;;;;AAgCA;;;;;;;qCAOkBC,Q,EAAW;AAC5B,aAAOA,QAAQ,CAACC,OAAT,CAAkB,KAAKV,KAAvB,KAAkCS,QAAQ,CAACE,QAAT,CAAmB,KAAKV,GAAxB,CAAzC;AACA;AAED;;;;;;;;;;;;kCASeW,U,EAA4B;AAAA,UAAhBC,KAAgB,uEAAR,KAAQ;;AAC1C,UAAKD,UAAU,CAACR,WAAhB,EAA8B;AAC7BS,QAAAA,KAAK,GAAG,KAAR;AACA;;AAED,UAAMC,aAAa,GAAG,KAAKC,gBAAL,CAAuBH,UAAU,CAACZ,KAAlC,KAA+Ca,KAAK,IAAI,KAAKb,KAAL,CAAWgB,OAAX,CAAoBJ,UAAU,CAACZ,KAA/B,CAA9E;AACA,UAAMiB,WAAW,GAAG,KAAKF,gBAAL,CAAuBH,UAAU,CAACX,GAAlC,KAA6CY,KAAK,IAAI,KAAKZ,GAAL,CAASe,OAAT,CAAkBJ,UAAU,CAACX,GAA7B,CAA1E;AAEA,aAAOa,aAAa,IAAIG,WAAxB;AACA;AAED;;;;;;;;iCAKcC,I,EAAO;AACpB,UAAMC,GAAG,GAAGxB,QAAQ,CAACyB,aAAT,CAAwBF,IAAxB,CAAZ;;AAEA,aAAO,KAAKH,gBAAL,CAAuBI,GAAvB,KAAgC,KAAKnB,KAAL,CAAWgB,OAAX,CAAoBG,GAApB,CAAvC;AACA;AAED;;;;;;;;;;;;;;;;;uBAcIE,I,EAAO;AACV,aAAOA,IAAI,IAAI,OAAR,IAAmBA,IAAI,IAAI,aAAlC;AACA;AAED;;;;;;;;;4BAMST,U,EAAa;AACrB,aAAO,KAAKZ,KAAL,CAAWgB,OAAX,CAAoBJ,UAAU,CAACZ,KAA/B,KAA0C,KAAKC,GAAL,CAASe,OAAT,CAAkBJ,UAAU,CAACX,GAA7B,CAAjD;AACA;AAED;;;;;;;;;mCAMgBW,U,EAAa;AAC5B,aAAO,KAAKZ,KAAL,CAAWW,QAAX,CAAqBC,UAAU,CAACX,GAAhC,KAAyC,KAAKA,GAAL,CAASS,OAAT,CAAkBE,UAAU,CAACZ,KAA7B,CAAhD;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAyBeY,U,EAAa;AAC3B,UAAMU,MAAM,GAAG,EAAf;;AAEA,UAAK,KAAKC,cAAL,CAAqBX,UAArB,CAAL,EAAyC;AACxC;AAEA,YAAK,KAAKG,gBAAL,CAAuBH,UAAU,CAACZ,KAAlC,CAAL,EAAiD;AAChD;AACA;AACAsB,UAAAA,MAAM,CAACE,IAAP,CAAa,IAAIzB,KAAJ,CAAW,KAAKC,KAAhB,EAAuBY,UAAU,CAACZ,KAAlC,CAAb;AACA;;AAED,YAAK,KAAKe,gBAAL,CAAuBH,UAAU,CAACX,GAAlC,CAAL,EAA+C;AAC9C;AACA;AACAqB,UAAAA,MAAM,CAACE,IAAP,CAAa,IAAIzB,KAAJ,CAAWa,UAAU,CAACX,GAAtB,EAA2B,KAAKA,GAAhC,CAAb;AACA;AACD,OAdD,MAcO;AACN;AACAqB,QAAAA,MAAM,CAACE,IAAP,CAAa,IAAIzB,KAAJ,CAAW,KAAKC,KAAhB,EAAuB,KAAKC,GAA5B,CAAb;AACA;;AAED,aAAOqB,MAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;oCAmBiBV,U,EAAa;AAC7B,UAAK,KAAKW,cAAL,CAAqBX,UAArB,CAAL,EAAyC;AACxC;AACA;AACA,YAAIa,gBAAgB,GAAG,KAAKzB,KAA5B;AACA,YAAI0B,cAAc,GAAG,KAAKzB,GAA1B;;AAEA,YAAK,KAAKc,gBAAL,CAAuBH,UAAU,CAACZ,KAAlC,CAAL,EAAiD;AAChD;AACA;AACAyB,UAAAA,gBAAgB,GAAGb,UAAU,CAACZ,KAA9B;AACA;;AAED,YAAK,KAAKe,gBAAL,CAAuBH,UAAU,CAACX,GAAlC,CAAL,EAA+C;AAC9C;AACA;AACAyB,UAAAA,cAAc,GAAGd,UAAU,CAACX,GAA5B;AACA;;AAED,eAAO,IAAIF,KAAJ,CAAW0B,gBAAX,EAA6BC,cAA7B,CAAP;AACA,OApB4B,CAsB7B;;;AACA,aAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2CAuCuB;AACtB,UAAMJ,MAAM,GAAG,EAAf;AACA,UAAMK,MAAM,GAAG,KAAK3B,KAAL,CAAW4B,aAAX,CAA0B,KAAK3B,GAA/B,EAAqC4B,MAApD;;AAEA,UAAMV,GAAG,GAAGxB,QAAQ,CAACO,SAAT,CAAoB,KAAKF,KAAzB,CAAZ;;AACA,UAAI8B,SAAS,GAAGX,GAAG,CAACY,MAApB,CALsB,CAOtB;;AACA,aAAQZ,GAAG,CAACa,IAAJ,CAASH,MAAT,GAAkBF,MAAM,GAAG,CAAnC,EAAuC;AACtC,YAAMM,OAAO,GAAGH,SAAS,CAACI,SAAV,GAAsBf,GAAG,CAACgB,MAA1C;;AAEA,YAAKF,OAAO,KAAK,CAAjB,EAAqB;AACpBX,UAAAA,MAAM,CAACE,IAAP,CAAa,IAAIzB,KAAJ,CAAWoB,GAAX,EAAgBA,GAAG,CAACiB,YAAJ,CAAkBH,OAAlB,CAAhB,CAAb;AACA;;AAEDd,QAAAA,GAAG,CAACa,IAAJ,GAAWb,GAAG,CAACa,IAAJ,CAASK,KAAT,CAAgB,CAAhB,EAAmB,CAAC,CAApB,CAAX;AACAlB,QAAAA,GAAG,CAACgB,MAAJ;AACAL,QAAAA,SAAS,GAAGA,SAAS,CAACC,MAAtB;AACA,OAlBqB,CAoBtB;;;AACA,aAAQZ,GAAG,CAACa,IAAJ,CAASH,MAAT,IAAmB,KAAK5B,GAAL,CAAS+B,IAAT,CAAcH,MAAzC,EAAkD;AACjD,YAAMM,MAAM,GAAG,KAAKlC,GAAL,CAAS+B,IAAT,CAAeb,GAAG,CAACa,IAAJ,CAASH,MAAT,GAAkB,CAAjC,CAAf;;AACA,YAAMI,QAAO,GAAGE,MAAM,GAAGhB,GAAG,CAACgB,MAA7B;;AAEA,YAAKF,QAAO,KAAK,CAAjB,EAAqB;AACpBX,UAAAA,MAAM,CAACE,IAAP,CAAa,IAAIzB,KAAJ,CAAWoB,GAAX,EAAgBA,GAAG,CAACiB,YAAJ,CAAkBH,QAAlB,CAAhB,CAAb;AACA;;AAEDd,QAAAA,GAAG,CAACgB,MAAJ,GAAaA,MAAb;AACAhB,QAAAA,GAAG,CAACa,IAAJ,CAASR,IAAT,CAAe,CAAf;AACA;;AAED,aAAOF,MAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;gCAmB0B;AAAA,UAAfgB,OAAe,uEAAL,EAAK;AACzBA,MAAAA,OAAO,CAAC/B,UAAR,GAAqB,IAArB;AAEA,aAAO,IAAIX,UAAJ,CAAgB0C,OAAhB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcYA,cAAAA,O,8DAAU,E;AACrBA,cAAAA,OAAO,CAAC/B,UAAR,GAAqB,IAArB;AACA+B,cAAAA,OAAO,CAAC9B,gBAAR,GAA2B,IAA3B;AAEM+B,cAAAA,U,GAAa,IAAI3C,UAAJ,CAAgB0C,OAAhB,C;;;;;0BAEEC,U;;;;;;;;AAATC,cAAAA,M;;AACX,qBAAMA,MAAK,CAACtB,IAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAagBoB,cAAAA,O,8DAAU,E;AACzBA,cAAAA,OAAO,CAAC/B,UAAR,GAAqB,IAArB;AAEMgC,cAAAA,U,GAAa,IAAI3C,UAAJ,CAAgB0C,OAAhB,C;;AAEnB,qBAAMC,UAAU,CAAC9B,QAAjB;;;;;;;2BAEqB8B,U;;;;;;;;AAATC,cAAAA,O;;AACX,qBAAMA,OAAK,CAACC,YAAZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIF;;;;;;;;;;;;;8CAU2BC,S,EAAY;AACtC,cAASA,SAAS,CAACrB,IAAnB;AACC,aAAK,QAAL;AACC,iBAAO,KAAKsB,gCAAL,CAAuCD,SAAvC,CAAP;;AACD,aAAK,MAAL;AACA,aAAK,QAAL;AACA,aAAK,UAAL;AACC,iBAAO,KAAKE,8BAAL,CAAqCF,SAArC,CAAP;;AACD,aAAK,OAAL;AACC,iBAAO,CAAE,KAAKG,+BAAL,CAAsCH,SAAtC,CAAF,CAAP;;AACD,aAAK,OAAL;AACC,iBAAO,CAAE,KAAKI,+BAAL,CAAsCJ,SAAtC,CAAF,CAAP;AAVF;;AAaA,aAAO,CAAE,IAAI3C,KAAJ,CAAW,KAAKC,KAAhB,EAAuB,KAAKC,GAA5B,CAAF,CAAP;AACA;AAED;;;;;;;;;;+CAO4B8C,U,EAAa;AACxC,UAAMzB,MAAM,GAAG,CAAE,IAAIvB,KAAJ,CAAW,KAAKC,KAAhB,EAAuB,KAAKC,GAA5B,CAAF,CAAf;AADwC;AAAA;AAAA;;AAAA;AAGxC,8BAAyB8C,UAAzB,mIAAsC;AAAA,cAA1BL,SAA0B;;AACrC,eAAM,IAAIM,EAAC,GAAG,CAAd,EAAiBA,EAAC,GAAG1B,MAAM,CAACO,MAA5B,EAAoCmB,EAAC,EAArC,EAA0C;AACzC,gBAAMC,MAAM,GAAG3B,MAAM,CAAE0B,EAAF,CAAN,CAAYE,yBAAZ,CAAuCR,SAAvC,CAAf;;AAEApB,YAAAA,MAAM,CAAC6B,MAAP,OAAA7B,MAAM,GAAS0B,EAAT,EAAY,CAAZ,4BAAkBC,MAAlB,GAAN;AACAD,YAAAA,EAAC,IAAIC,MAAM,CAACpB,MAAP,GAAgB,CAArB;AACA;AACD,SAVuC,CAYxC;AACA;AACA;AACA;;AAfwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBxC,WAAM,IAAImB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG1B,MAAM,CAACO,MAA5B,EAAoCmB,CAAC,EAArC,EAA0C;AACzC,YAAMI,KAAK,GAAG9B,MAAM,CAAE0B,CAAF,CAApB;;AAEA,aAAM,IAAIK,CAAC,GAAGL,CAAC,GAAG,CAAlB,EAAqBK,CAAC,GAAG/B,MAAM,CAACO,MAAhC,EAAwCwB,CAAC,EAAzC,EAA8C;AAC7C,cAAMC,IAAI,GAAGhC,MAAM,CAAE+B,CAAF,CAAnB;;AAEA,cAAKD,KAAK,CAACG,aAAN,CAAqBD,IAArB,KAA+BA,IAAI,CAACC,aAAL,CAAoBH,KAApB,CAA/B,IAA8DA,KAAK,CAACpC,OAAN,CAAesC,IAAf,CAAnE,EAA2F;AAC1FhC,YAAAA,MAAM,CAAC6B,MAAP,CAAeE,CAAf,EAAkB,CAAlB;AACA;AACD;AACD;;AAED,aAAO/B,MAAP;AACA;AAED;;;;;;;;;wCAMoB;AACnB,aAAO,KAAKtB,KAAL,CAAWwD,iBAAX,CAA8B,KAAKvD,GAAnC,CAAP;AACA;AAED;;;;;;;;;;0CAOsB;AACrB,UAAK,KAAKG,WAAV,EAAwB;AACvB,eAAO,IAAP;AACA;;AAED,UAAMqD,cAAc,GAAG,KAAKzD,KAAL,CAAW0D,SAAlC;AACA,UAAMC,aAAa,GAAG,KAAK1D,GAAL,CAAS2D,UAA/B;;AAEA,UAAKH,cAAc,IAAIA,cAAc,CAACI,EAAf,CAAmB,SAAnB,CAAlB,IAAoDJ,cAAc,KAAKE,aAA5E,EAA4F;AAC3F,eAAOF,cAAP;AACA;;AAED,aAAO,IAAP;AACA;AAED;;;;;;;;6BAKS;AACR,aAAO;AACNzD,QAAAA,KAAK,EAAE,KAAKA,KAAL,CAAW8D,MAAX,EADD;AAEN7D,QAAAA,GAAG,EAAE,KAAKA,GAAL,CAAS6D,MAAT;AAFC,OAAP;AAIA;AAED;;;;;;;;4BAKQ;AACP,aAAO,IAAI,KAAKC,WAAT,CAAsB,KAAK/D,KAA3B,EAAkC,KAAKC,GAAvC,CAAP;AACA;AAED;;;;;;;;;;;;qDASkCyC,S,EAA4B;AAAA,UAAjBsB,MAAiB,uEAAR,KAAQ;AAC7D,aAAO,KAAKC,0BAAL,CAAiCvB,SAAS,CAACjC,QAA3C,EAAqDiC,SAAS,CAACT,OAA/D,EAAwE+B,MAAxE,CAAP;AACA;AAED;;;;;;;;;;;;mDASgCtB,S,EAA4B;AAAA,UAAjBsB,MAAiB,uEAAR,KAAQ;AAC3D,UAAME,cAAc,GAAGxB,SAAS,CAACwB,cAAjC;AACA,UAAMjC,OAAO,GAAGS,SAAS,CAACT,OAA1B;AACA,UAAMkC,cAAc,GAAGzB,SAAS,CAACyB,cAAjC;AAEA,aAAO,KAAKC,qBAAL,CAA4BF,cAA5B,EAA4CC,cAA5C,EAA4DlC,OAA5D,EAAqE+B,MAArE,CAAP;AACA;AAED;;;;;;;;;;;;oDASiCtB,S,EAAY;AAC5C,UAAM1C,KAAK,GAAG,KAAKA,KAAL,CAAW6C,+BAAX,CAA4CH,SAA5C,CAAd;;AACA,UAAIzC,GAAG,GAAG,KAAKA,GAAL,CAAS4C,+BAAT,CAA0CH,SAA1C,CAAV;;AAEA,UAAK,KAAKzC,GAAL,CAASe,OAAT,CAAkB0B,SAAS,CAAC2B,iBAA5B,CAAL,EAAuD;AACtDpE,QAAAA,GAAG,GAAG,KAAKA,GAAL,CAASmC,YAAT,CAAuB,CAAvB,CAAN;AACA,OAN2C,CAQ5C;;;AACA,UAAKpC,KAAK,CAACsE,IAAN,IAAcrE,GAAG,CAACqE,IAAvB,EAA8B;AAC7B;AACA;AACArE,QAAAA,GAAG,GAAG,KAAKA,GAAL,CAASmC,YAAT,CAAuB,CAAC,CAAxB,CAAN;AACA;;AAED,aAAO,IAAIrC,KAAJ,CAAWC,KAAX,EAAkBC,GAAlB,CAAP;AACA;AAED;;;;;;;;;;;;oDASiCyC,S,EAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAK,KAAK1C,KAAL,CAAWgB,OAAX,CAAoB0B,SAAS,CAACyB,cAA9B,KAAkD,KAAKlE,GAAL,CAASe,OAAT,CAAkB0B,SAAS,CAAC6B,gBAA5B,CAAvD,EAAwG;AACvG,eAAO,IAAIxE,KAAJ,CAAW,KAAKC,KAAhB,CAAP;AACA;;AAED,UAAIA,KAAK,GAAG,KAAKA,KAAL,CAAW8C,+BAAX,CAA4CJ,SAA5C,CAAZ;;AACA,UAAIzC,GAAG,GAAG,KAAKA,GAAL,CAAS6C,+BAAT,CAA0CJ,SAA1C,CAAV;;AAEA,UAAK1C,KAAK,CAACsE,IAAN,IAAcrE,GAAG,CAACqE,IAAvB,EAA8B;AAC7B;AACA;AACA;AACArE,QAAAA,GAAG,GAAG,KAAKA,GAAL,CAASmC,YAAT,CAAuB,CAAC,CAAxB,CAAN;AACA;;AAED,UAAKpC,KAAK,CAACU,OAAN,CAAeT,GAAf,CAAL,EAA4B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,YAAKyC,SAAS,CAACwB,cAAV,CAAyBvD,QAAzB,CAAmC+B,SAAS,CAACyB,cAA7C,CAAL,EAAqE;AACpE;AACAnE,UAAAA,KAAK,GAAGL,QAAQ,CAACO,SAAT,CAAoBD,GAApB,CAAR;AACAD,UAAAA,KAAK,CAACmC,MAAN,GAAe,CAAf;AACA,SAJD,MAIO;AACN,cAAK,CAACO,SAAS,CAAC6B,gBAAV,CAA2BvD,OAA3B,CAAoChB,KAApC,CAAN,EAAoD;AACnD;AACAC,YAAAA,GAAG,GAAGyC,SAAS,CAAC6B,gBAAhB;AACA,WAJK,CAMN;;;AACAvE,UAAAA,KAAK,GAAG0C,SAAS,CAACyB,cAAlB;AACA;;AAED,eAAO,IAAIpE,KAAJ,CAAWC,KAAX,EAAkBC,GAAlB,CAAP;AACA;;AAED,aAAO,IAAIF,KAAJ,CAAWC,KAAX,EAAkBC,GAAlB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CA8B4BuE,c,EAAgBvC,O,EAA0B;AAAA,UAAjB+B,MAAiB,uEAAR,KAAQ;;AACrE,UAAKA,MAAM,IAAI,KAAKjD,gBAAL,CAAuByD,cAAvB,CAAf,EAAyD;AACxD;AACA;AACA;AAEA,eAAO,CACN,IAAIzE,KAAJ,CAAW,KAAKC,KAAhB,EAAuBwE,cAAvB,CADM,EAEN,IAAIzE,KAAJ,CACCyE,cAAc,CAACpC,YAAf,CAA6BH,OAA7B,CADD,EAEC,KAAKhC,GAAL,CAASgE,0BAAT,CAAqCO,cAArC,EAAqDvC,OAArD,CAFD,CAFM,CAAP;AAOA,OAZD,MAYO;AACN,YAAMmB,KAAK,GAAG,IAAIrD,KAAJ,CAAW,KAAKC,KAAhB,EAAuB,KAAKC,GAA5B,CAAd;AAEAmD,QAAAA,KAAK,CAACpD,KAAN,GAAcoD,KAAK,CAACpD,KAAN,CAAYiE,0BAAZ,CAAwCO,cAAxC,EAAwDvC,OAAxD,CAAd;AACAmB,QAAAA,KAAK,CAACnD,GAAN,GAAYmD,KAAK,CAACnD,GAAN,CAAUgE,0BAAV,CAAsCO,cAAtC,EAAsDvC,OAAtD,CAAZ;AAEA,eAAO,CAAEmB,KAAF,CAAP;AACA;AACD;AAED;;;;;;;;;;;;;;0CAWuBc,c,EAAgBC,c,EAAgBlC,O,EAA0B;AAAA,UAAjB+B,MAAiB,uEAAR,KAAQ;;AAChF;AACA,UAAK,KAAK5D,WAAV,EAAwB;AACvB,YAAMqE,MAAM,GAAG,KAAKzE,KAAL,CAAWoE,qBAAX,CAAkCF,cAAlC,EAAkDC,cAAlD,EAAkElC,OAAlE,CAAf;;AAEA,eAAO,CAAE,IAAIlC,KAAJ,CAAW0E,MAAX,CAAF,CAAP;AACA,OAN+E,CAQhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMC,SAAS,GAAG3E,KAAK,CAAC4E,2BAAN,CAAmCT,cAAnC,EAAmDjC,OAAnD,CAAlB;;AACA,UAAMuC,cAAc,GAAGL,cAAc,CAACS,yBAAf,CAA0CV,cAA1C,EAA0DjC,OAA1D,CAAvB;;AAEA,UAAK,KAAKlB,gBAAL,CAAuBoD,cAAvB,KAA2C,CAACH,MAAjD,EAA0D;AACzD,YAAKU,SAAS,CAAC3D,gBAAV,CAA4B,KAAKf,KAAjC,KAA4C0E,SAAS,CAAC3D,gBAAV,CAA4B,KAAKd,GAAjC,CAAjD,EAA0F;AACzF,cAAMD,KAAK,GAAG,KAAKA,KAAL,CAAWoE,qBAAX,CAAkCF,cAAlC,EAAkDC,cAAlD,EAAkElC,OAAlE,CAAd;;AACA,cAAMhC,GAAG,GAAG,KAAKA,GAAL,CAASmE,qBAAT,CAAgCF,cAAhC,EAAgDC,cAAhD,EAAgElC,OAAhE,CAAZ;;AAEA,iBAAO,CAAE,IAAIlC,KAAJ,CAAWC,KAAX,EAAkBC,GAAlB,CAAF,CAAP;AACA;AACD,OA9B+E,CAgChF;;;AACA,UAAIgD,MAAJ;AAEA,UAAM4B,aAAa,GAAG,KAAKC,aAAL,CAAoBJ,SAApB,CAAtB;AACA,UAAIK,UAAU,GAAG,IAAjB;AAEA,UAAMC,MAAM,GAAG,KAAKC,eAAL,CAAsBP,SAAtB,CAAf;;AAEA,UAAKG,aAAa,CAAChD,MAAd,IAAwB,CAA7B,EAAiC;AAChC;AACAkD,QAAAA,UAAU,GAAG,IAAIhF,KAAJ,CACZ8E,aAAa,CAAE,CAAF,CAAb,CAAmB7E,KAAnB,CAAyB4E,yBAAzB,CAAoDV,cAApD,EAAoEjC,OAApE,CADY,EAEZ4C,aAAa,CAAE,CAAF,CAAb,CAAmB5E,GAAnB,CAAuB2E,yBAAvB,CAAkDV,cAAlD,EAAkEjC,OAAlE,CAFY,CAAb;AAIA,OAND,MAMO,IAAK4C,aAAa,CAAChD,MAAd,IAAwB,CAA7B,EAAiC;AACvC;AACAkD,QAAAA,UAAU,GAAG,IAAIhF,KAAJ,CACZ,KAAKC,KADO,EAEZ,KAAKC,GAAL,CAAS2E,yBAAT,CAAoCV,cAApC,EAAoDjC,OAApD,CAFY,CAAb;AAIA,OApD+E,CAoD9E;;;AAEF,UAAK8C,UAAL,EAAkB;AACjB9B,QAAAA,MAAM,GAAG8B,UAAU,CAACd,0BAAX,CAAuCO,cAAvC,EAAuDvC,OAAvD,EAAgE+C,MAAM,KAAK,IAAX,IAAmBhB,MAAnF,CAAT;AACA,OAFD,MAEO;AACNf,QAAAA,MAAM,GAAG,EAAT;AACA;;AAED,UAAK+B,MAAL,EAAc;AACb,YAAME,iBAAiB,GAAG,IAAInF,KAAJ,CACzBiF,MAAM,CAAChF,KAAP,CAAamF,YAAb,CAA2BT,SAAS,CAAC1E,KAArC,EAA4CwE,cAA5C,CADyB,EAEzBQ,MAAM,CAAC/E,GAAP,CAAWkF,YAAX,CAAyBT,SAAS,CAAC1E,KAAnC,EAA0CwE,cAA1C,CAFyB,CAA1B;;AAKA,YAAKvB,MAAM,CAACpB,MAAP,IAAiB,CAAtB,EAA0B;AACzBoB,UAAAA,MAAM,CAACE,MAAP,CAAe,CAAf,EAAkB,CAAlB,EAAqB+B,iBAArB;AACA,SAFD,MAEO;AACNjC,UAAAA,MAAM,CAACzB,IAAP,CAAa0D,iBAAb;AACA;AACD;;AAED,aAAOjC,MAAP;AACA;AAED;;;;;;;;;;;;;;;8CAY2BmC,c,EAAgBnD,O,EAAU;AACpD,UAAIoD,QAAQ,GAAG,KAAKrF,KAAL,CAAW4E,yBAAX,CAAsCQ,cAAtC,EAAsDnD,OAAtD,CAAf;;AACA,UAAIqD,MAAM,GAAG,KAAKrF,GAAL,CAAS2E,yBAAT,CAAoCQ,cAApC,EAAoDnD,OAApD,CAAb;;AAEA,UAAKoD,QAAQ,IAAI,IAAZ,IAAoBC,MAAM,IAAI,IAAnC,EAA0C;AACzC,eAAO,IAAP;AACA;;AAED,UAAKD,QAAQ,IAAI,IAAjB,EAAwB;AACvBA,QAAAA,QAAQ,GAAGD,cAAX;AACA;;AAED,UAAKE,MAAM,IAAI,IAAf,EAAsB;AACrBA,QAAAA,MAAM,GAAGF,cAAT;AACA;;AAED,aAAO,IAAIrF,KAAJ,CAAWsF,QAAX,EAAqBC,MAArB,CAAP;AACA;AAED;;;;;;;;;;;;wBA3wBkB;AACjB,aAAO,KAAKtF,KAAL,CAAWgB,OAAX,CAAoB,KAAKf,GAAzB,CAAP;AACA;AAED;;;;;;;;;wBAMa;AACZ,UAAMsF,eAAe,GAAG,KAAKvF,KAAL,CAAWwF,aAAX,EAAxB;AACA,UAAMC,aAAa,GAAG,KAAKxF,GAAL,CAASuF,aAAT,EAAtB;AAEA,aAAO1F,aAAa,CAAEyF,eAAF,EAAmBE,aAAnB,CAAb,IAAmD,MAA1D;AACA;AAED;;;;;;;;wBAKW;AACV,aAAO,KAAKzF,KAAL,CAAWsE,IAAlB;AACA;;;gDA4vBmC7D,Q,EAAUiF,K,EAAQ;AACrD,UAAM1F,KAAK,GAAGS,QAAd;AACA,UAAMR,GAAG,GAAGQ,QAAQ,CAAC2B,YAAT,CAAuBsD,KAAvB,CAAZ;AAEA,aAAOA,KAAK,GAAG,CAAR,GAAY,IAAI,IAAJ,CAAU1F,KAAV,EAAiBC,GAAjB,CAAZ,GAAqC,IAAI,IAAJ,CAAUA,GAAV,EAAeD,KAAf,CAA5C;AACA;AAED;;;;;;;;;;;8BAQkB2F,O,EAAU;AAC3B,aAAO,IAAI,IAAJ,CAAUhG,QAAQ,CAACO,SAAT,CAAoByF,OAApB,EAA6B,CAA7B,CAAV,EAA4ChG,QAAQ,CAACO,SAAT,CAAoByF,OAApB,EAA6BA,OAAO,CAACzD,SAArC,CAA5C,CAAP;AACA;AAED;;;;;;;;;;8BAOkBhB,I,EAAO;AACxB,aAAO,KAAKyD,2BAAL,CAAkChF,QAAQ,CAACyB,aAAT,CAAwBF,IAAxB,CAAlC,EAAkEA,IAAI,CAAC0E,UAAvE,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;sCAe0BtE,M,EAAS;AAClC,UAAKA,MAAM,CAACO,MAAP,KAAkB,CAAvB,EAA2B;AAC1B;;;;;;AAMA,cAAM,IAAIhC,aAAJ,CACL,4EADK,EAEL,IAFK,CAAN;AAIA,OAXD,MAWO,IAAKyB,MAAM,CAACO,MAAP,IAAiB,CAAtB,EAA0B;AAChC,eAAOP,MAAM,CAAE,CAAF,CAAN,CAAYuE,KAAZ,EAAP;AACA,OAdiC,CAgBlC;AACA;AACA;;;AACA,UAAMC,GAAG,GAAGxE,MAAM,CAAE,CAAF,CAAlB,CAnBkC,CAqBlC;;AACAA,MAAAA,MAAM,CAACyE,IAAP,CAAa,UAAEC,CAAF,EAAKC,CAAL,EAAY;AACxB,eAAOD,CAAC,CAAChG,KAAF,CAAQU,OAAR,CAAiBuF,CAAC,CAACjG,KAAnB,IAA6B,CAA7B,GAAiC,CAAC,CAAzC;AACA,OAFD,EAtBkC,CA0BlC;;AACA,UAAMkG,QAAQ,GAAG5E,MAAM,CAAC6E,OAAP,CAAgBL,GAAhB,CAAjB,CA3BkC,CA6BlC;AACA;AACA;;AACA,UAAM7C,MAAM,GAAG,IAAI,IAAJ,CAAU6C,GAAG,CAAC9F,KAAd,EAAqB8F,GAAG,CAAC7F,GAAzB,CAAf,CAhCkC,CAkClC;AACA;;AACA,UAAKiG,QAAQ,GAAG,CAAhB,EAAoB;AACnB,aAAM,IAAIlD,CAAC,GAAGkD,QAAQ,GAAG,CAAzB,EAA4B,IAA5B,EAAkClD,CAAC,EAAnC,EAAwC;AACvC,cAAK1B,MAAM,CAAE0B,CAAF,CAAN,CAAY/C,GAAZ,CAAgBe,OAAhB,CAAyBiC,MAAM,CAACjD,KAAhC,CAAL,EAA+C;AAC9CiD,YAAAA,MAAM,CAACjD,KAAP,GAAeL,QAAQ,CAACO,SAAT,CAAoBoB,MAAM,CAAE0B,CAAF,CAAN,CAAYhD,KAAhC,CAAf;AACA,WAFD,MAEO;AACN;AACA;AACA;AACD;AACD,OA7CiC,CA+ClC;AACA;;;AACA,WAAM,IAAIgD,GAAC,GAAGkD,QAAQ,GAAG,CAAzB,EAA4BlD,GAAC,GAAG1B,MAAM,CAACO,MAAvC,EAA+CmB,GAAC,EAAhD,EAAqD;AACpD,YAAK1B,MAAM,CAAE0B,GAAF,CAAN,CAAYhD,KAAZ,CAAkBgB,OAAlB,CAA2BiC,MAAM,CAAChD,GAAlC,CAAL,EAA+C;AAC9CgD,UAAAA,MAAM,CAAChD,GAAP,GAAaN,QAAQ,CAACO,SAAT,CAAoBoB,MAAM,CAAE0B,GAAF,CAAN,CAAY/C,GAAhC,CAAb;AACA,SAFD,MAEO;AACN;AACA;AACA;AACD;;AAED,aAAOgD,MAAP;AACA;AAED;;;;;;;;;;6BAOiBmD,I,EAAMC,G,EAAM;AAC5B,aAAO,IAAI,IAAJ,CAAU1G,QAAQ,CAAC2G,QAAT,CAAmBF,IAAI,CAACpG,KAAxB,EAA+BqG,GAA/B,CAAV,EAAgD1G,QAAQ,CAAC2G,QAAT,CAAmBF,IAAI,CAACnG,GAAxB,EAA6BoG,GAA7B,CAAhD,CAAP;AACA,K,CAED;AACA;AACA;AAEA;AACA;AACA;;;;;;;SAr8BoBtG,K","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.start = Position._createAt( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.end = end ? Position._createAt( end ) : Position._createAt( start );\n\n\t\t// If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n\t\t// In other case, make the boundaries stick to the \"inside\" of the range.\n\t\tthis.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n\t\tthis.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/model/position~Position positions},\n\t * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n\t * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n\t *\n\t * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n\t * and `ignoreElementEnd` option set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is if {@link #start} and\n\t * {@link #end} positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link #start} position and\n\t * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\tconst startParentPath = this.start.getParentPath();\n\t\tconst endParentPath = this.end.getParentPath();\n\n\t\treturn compareArrays( startParentPath, endParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n\t * in this range,`false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link ~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n\t *\n\t * @param {module:engine/model/item~Item} item Model item to check.\n\t */\n\tcontainsItem( item ) {\n\t\tconst pos = Position._createBefore( item );\n\n\t\treturn this.containsPosition( pos ) || this.start.isEqual( pos );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'model:range' ); // -> true\n\t *\n\t *\t\trange.is( 'view:range' ); // -> false\n\t *\t\trange.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'range' || type == 'model:range';\n\t}\n\n\t/**\n\t * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n\t * Returned array contains zero, one or two {@link ~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( new Range( this.start, this.end ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n\t *\n\t * See an example of a model structure (`[` and `]` are range boundaries):\n\t *\n\t *\t\troot                                                            root\n\t *\t\t |- element DIV                         DIV             P2              P3             DIV\n\t *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n\t *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n\t *\t\t |   |- element P1\n\t *\t\t |   |   |- \"lorem\"                                              ||\n\t *\t\t |- element P2                                                   ||\n\t *\t\t |   |- \"foo\"                                                    VV\n\t *\t\t |- element P3\n\t *\t\t |   |- \"bar\"                                                   root\n\t *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n\t *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n\t *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n\t *\t\t |   |- element P4\n\t *\t\t |   |   |- \"ipsum\"\n\t *\n\t * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n\t * We are looking for minimal set of flat ranges that contains the same nodes.\n\t *\n\t * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n\t *\n\t *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n\t *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n\t *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n\t *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n\t *\n\t * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n\t * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n\t * were omitted. Only their parts that were wholly in the range were returned.\n\t *\n\t * **Note:** this method is not returning flat ranges that contain no nodes.\n\t *\n\t * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n\t */\n\tgetMinimalFlatRanges() {\n\t\tconst ranges = [];\n\t\tconst diffAt = this.start.getCommonPath( this.end ).length;\n\n\t\tconst pos = Position._createAt( this.start );\n\t\tlet posParent = pos.parent;\n\n\t\t// Go up.\n\t\twhile ( pos.path.length > diffAt + 1 ) {\n\t\t\tconst howMany = posParent.maxOffset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.path = pos.path.slice( 0, -1 );\n\t\t\tpos.offset++;\n\t\t\tposParent = posParent.parent;\n\t\t}\n\n\t\t// Go down.\n\t\twhile ( pos.path.length <= this.end.path.length ) {\n\t\t\tconst offset = this.end.path[ pos.path.length - 1 ];\n\t\t\tconst howMany = offset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.offset = offset;\n\t\t\tpos.path.push( 0 );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * For example, to iterate over all items in the entire document root:\n\t *\n\t *\t\t// Create a range spanning over the entire root content:\n\t *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n\t *\n\t *\t\t// Iterate over all items in this range:\n\t *\t\tfor ( const value of range.getWalker() ) {\n\t *\t\t\tconsole.log( value.item );\n\t *\t\t}\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @param {module:engine/model/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n\t * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by given `operation`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\treturn this._getTransformedByInsertOperation( operation );\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\treturn this._getTransformedByMoveOperation( operation );\n\t\t\tcase 'split':\n\t\t\t\treturn [ this._getTransformedBySplitOperation( operation ) ];\n\t\t\tcase 'merge':\n\t\t\t\treturn [ this._getTransformedByMergeOperation( operation ) ];\n\t\t}\n\n\t\treturn [ new Range( this.start, this.end ) ];\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by multiple `operations`.\n\t *\n\t * @see ~Range#getTransformedByOperation\n\t * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperations( operations ) {\n\t\tconst ranges = [ new Range( this.start, this.end ) ];\n\n\t\tfor ( const operation of operations ) {\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\tconst result = ranges[ i ].getTransformedByOperation( operation );\n\n\t\t\t\tranges.splice( i, 1, ...result );\n\t\t\t\ti += result.length - 1;\n\t\t\t}\n\t\t}\n\n\t\t// It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n\t\t// \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n\t\t// because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n\t\t// are inside other ranges and we simply remove them.\n\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\tconst range = ranges[ i ];\n\n\t\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t\tconst next = ranges[ j ];\n\n\t\t\t\tif ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {\n\t\t\t\t\tranges.splice( j, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of the range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element Element} contained by the range.\n\t * The element will be returned when it is the **only** node within the range and **fullycontained**\n\t * at the same time.\n\t *\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\tgetContainedElement() {\n\t\tif ( this.isCollapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst nodeAfterStart = this.start.nodeAfter;\n\t\tconst nodeBeforeEnd = this.end.nodeBefore;\n\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'element' ) && nodeAfterStart === nodeBeforeEnd ) {\n\t\t\treturn nodeAfterStart;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts `Range` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tstart: this.start.toJSON(),\n\t\t\tend: this.end.toJSON()\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new range that is equal to current range.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by insert operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByInsertOperation( operation, spread = false ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by move operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByMoveOperation( operation, spread = false ) {\n\t\tconst sourcePosition = operation.sourcePosition;\n\t\tconst howMany = operation.howMany;\n\t\tconst targetPosition = operation.targetPosition;\n\n\t\treturn this._getTransformedByMove( sourcePosition, targetPosition, howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by split operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst start = this.start._getTransformedBySplitOperation( operation );\n\t\tlet end = this.end._getTransformedBySplitOperation( operation );\n\n\t\tif ( this.end.isEqual( operation.insertionPosition ) ) {\n\t\t\tend = this.end.getShiftedBy( 1 );\n\t\t}\n\n\t\t// Below may happen when range contains graveyard element used by split operation.\n\t\tif ( start.root != end.root ) {\n\t\t\t// End position was next to the moved graveyard element and was moved with it.\n\t\t\t// Fix it by using old `end` which has proper `root`.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by merge operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\t// Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n\t\t// transformations, especially when a content of a few block elements were removed. For example:\n\t\t//\n\t\t// {} is the transformed range, [] is the removed range.\n\t\t// <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n\t\t//\n\t\t// <p>Fo{o</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p>}<p>z</p>\n\t\t// <p>F{}z</p>\n\t\t//\n\t\tif ( this.start.isEqual( operation.targetPosition ) && this.end.isEqual( operation.deletionPosition ) ) {\n\t\t\treturn new Range( this.start );\n\t\t}\n\n\t\tlet start = this.start._getTransformedByMergeOperation( operation );\n\t\tlet end = this.end._getTransformedByMergeOperation( operation );\n\n\t\tif ( start.root != end.root ) {\n\t\t\t// This happens when the end position was next to the merged (deleted) element.\n\t\t\t// Then, the end position was moved to the graveyard root. In this case we need to fix\n\t\t\t// the range cause its boundaries would be in different roots.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\tif ( start.isAfter( end ) ) {\n\t\t\t// This happens in three following cases:\n\t\t\t//\n\t\t\t// Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n\t\t\t//         This means that start can be moved before the end of the range.\n\t\t\t//\n\t\t\t// Before: <p>a{a</p><p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>b}b</p><p>cca{a</p>\n\t\t\t// Fix:    <p>{b}b</p><p>ccaa</p>\n\t\t\t//\n\t\t\t// Case 2: Range start is before merged node but not directly.\n\t\t\t//         Result should include all nodes that were in the original range.\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{bb</p><p>cc</p>}\n\t\t\t//\n\t\t\t//         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n\t\t\t//\n\t\t\t// Case 3: Range start is directly before merged node.\n\t\t\t//         Resulting range should include only nodes from the merged element:\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{b}b</p><p>cc</p>\n\t\t\t//\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Case 1.\n\t\t\t\tstart = Position._createAt( end );\n\t\t\t\tstart.offset = 0;\n\t\t\t} else {\n\t\t\t\tif ( !operation.deletionPosition.isEqual( start ) ) {\n\t\t\t\t\t// Case 2.\n\t\t\t\t\tend = operation.deletionPosition;\n\t\t\t\t}\n\n\t\t\t\t// In both case 2 and 3 start is at the end of the merge-to element.\n\t\t\t\tstart = operation.targetPosition;\n\t\t\t}\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n\t * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n\t *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n\t *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n\t *\t\t// transformed array has one range, which is equal to original range\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n\t * was inside the range. Defaults to `false`.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, spread = false ) {\n\t\tif ( spread && this.containsPosition( insertPosition ) ) {\n\t\t\t// Range has to be spread. The first part is from original start to the spread point.\n\t\t\t// The other part is from spread point to the original end, but transformed by\n\t\t\t// insertion to reflect insertion changes.\n\n\t\t\treturn [\n\t\t\t\tnew Range( this.start, insertPosition ),\n\t\t\t\tnew Range(\n\t\t\t\t\tinsertPosition.getShiftedBy( howMany ),\n\t\t\t\t\tthis.end._getTransformedByInsertion( insertPosition, howMany )\n\t\t\t\t)\n\t\t\t];\n\t\t} else {\n\t\t\tconst range = new Range( this.start, this.end );\n\n\t\t\trange.start = range.start._getTransformedByInsertion( insertPosition, howMany );\n\t\t\trange.end = range.end._getTransformedByInsertion( insertPosition, howMany );\n\n\t\t\treturn [ range ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n\t * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n\t * @param {Number} howMany How many nodes are moved.\n\t * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany, spread = false ) {\n\t\t// Special case for transforming a collapsed range. Just transform it like a position.\n\t\tif ( this.isCollapsed ) {\n\t\t\tconst newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\treturn [ new Range( newPos ) ];\n\t\t}\n\n\t\t// Special case for transformation when a part of the range is moved towards the range.\n\t\t//\n\t\t// Examples:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n\t\t// <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n\t\t//\n\t\t// Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n\t\t//\n\t\t// This special case is applied only if the range is to be kept together (not spread).\n\t\tconst moveRange = Range._createFromPositionAndShift( sourcePosition, howMany );\n\t\tconst insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( this.containsPosition( targetPosition ) && !spread ) {\n\t\t\tif ( moveRange.containsPosition( this.start ) || moveRange.containsPosition( this.end ) ) {\n\t\t\t\tconst start = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\t\t\t\tconst end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\t\t}\n\n\t\t// Default algorithm.\n\t\tlet result;\n\n\t\tconst differenceSet = this.getDifference( moveRange );\n\t\tlet difference = null;\n\n\t\tconst common = this.getIntersection( moveRange );\n\n\t\tif ( differenceSet.length == 1 ) {\n\t\t\t// `moveRange` and this range may intersect but may be separate.\n\t\t\tdifference = new Range(\n\t\t\t\tdifferenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),\n\t\t\t\tdifferenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} else if ( differenceSet.length == 2 ) {\n\t\t\t// `moveRange` is inside this range.\n\t\t\tdifference = new Range(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} // else, `moveRange` contains this range.\n\n\t\tif ( difference ) {\n\t\t\tresult = difference._getTransformedByInsertion( insertPosition, howMany, common !== null || spread );\n\t\t} else {\n\t\t\tresult = [];\n\t\t}\n\n\t\tif ( common ) {\n\t\t\tconst transformedCommon = new Range(\n\t\t\t\tcommon.start._getCombined( moveRange.start, insertPosition ),\n\t\t\t\tcommon.end._getCombined( moveRange.start, insertPosition )\n\t\t\t);\n\n\t\t\tif ( result.length == 2 ) {\n\t\t\t\tresult.splice( 1, 0, transformedCommon );\n\t\t\t} else {\n\t\t\t\tresult.push( transformedCommon );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n\t *\n\t * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n\t *\n\t * If the deleted range contains transformed range, `null` will be returned.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/range~Range|null} Result of the transformation.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tlet newStart = this.start._getTransformedByDeletion( deletePosition, howMany );\n\t\tlet newEnd = this.end._getTransformedByDeletion( deletePosition, howMany );\n\n\t\tif ( newStart == null && newEnd == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( newStart == null ) {\n\t\t\tnewStart = deletePosition;\n\t\t}\n\n\t\tif ( newEnd == null ) {\n\t\t\tnewEnd = deletePosition;\n\t\t}\n\n\t\treturn new Range( newStart, newEnd );\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn new this( Position._createAt( element, 0 ), Position._createAt( element, element.maxOffset ) );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), item.offsetSize );\n\t}\n\n\t/**\n\t * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n\t * Passed ranges must not have common parts.\n\t *\n\t * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n\t * the reference range, they get combined into one range.\n\t *\n\t *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n\t *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n\t *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n\t *\t                                           [  ]  // The result of the function if the last range was a reference range.\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n\t * @returns {module:engine/model/range~Range} Combined range.\n\t */\n\tstatic _createFromRanges( ranges ) {\n\t\tif ( ranges.length === 0 ) {\n\t\t\t/**\n\t\t\t * At least one range has to be passed to\n\t\t\t * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n\t\t\t *\n\t\t\t * @error range-create-from-ranges-empty-array\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'range-create-from-ranges-empty-array: At least one range has to be passed.',\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if ( ranges.length == 1 ) {\n\t\t\treturn ranges[ 0 ].clone();\n\t\t}\n\n\t\t// 1. Set the first range in `ranges` array as a reference range.\n\t\t// If we are going to return just a one range, one of the ranges need to be the reference one.\n\t\t// Other ranges will be stuck to that range, if possible.\n\t\tconst ref = ranges[ 0 ];\n\n\t\t// 2. Sort all the ranges so it's easier to process them.\n\t\tranges.sort( ( a, b ) => {\n\t\t\treturn a.start.isAfter( b.start ) ? 1 : -1;\n\t\t} );\n\n\t\t// 3. Check at which index the reference range is now.\n\t\tconst refIndex = ranges.indexOf( ref );\n\n\t\t// 4. At this moment we don't need the original range.\n\t\t// We are going to modify the result and we need to return a new instance of Range.\n\t\t// We have to create a copy of the reference range.\n\t\tconst result = new this( ref.start, ref.end );\n\n\t\t// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tif ( refIndex > 0 ) {\n\t\t\tfor ( let i = refIndex - 1; true; i++ ) {\n\t\t\t\tif ( ranges[ i ].end.isEqual( result.start ) ) {\n\t\t\t\t\tresult.start = Position._createAt( ranges[ i ].start );\n\t\t\t\t} else {\n\t\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex + 1; i < ranges.length; i++ ) {\n\t\t\tif ( ranges[ i ].start.isEqual( result.end ) ) {\n\t\t\t\tresult.end = Position._createAt( ranges[ i ].end );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Range`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n\t * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\treturn new this( Position.fromJSON( json.start, doc ), Position.fromJSON( json.end, doc ) );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]}]}