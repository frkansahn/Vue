{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\document.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\document.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL21vZGVsL2RvY3VtZW50CiAqLwppbXBvcnQgRGlmZmVyIGZyb20gJy4vZGlmZmVyJzsKaW1wb3J0IFJvb3RFbGVtZW50IGZyb20gJy4vcm9vdGVsZW1lbnQnOwppbXBvcnQgSGlzdG9yeSBmcm9tICcuL2hpc3RvcnknOwppbXBvcnQgRG9jdW1lbnRTZWxlY3Rpb24gZnJvbSAnLi9kb2N1bWVudHNlbGVjdGlvbic7CmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbGxlY3Rpb24nOwppbXBvcnQgRW1pdHRlck1peGluIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2VtaXR0ZXJtaXhpbic7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCB7IGlzSW5zaWRlU3Vycm9nYXRlUGFpciwgaXNJbnNpZGVDb21iaW5lZFN5bWJvbCB9IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL3VuaWNvZGUnOwppbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2xvZGFzaC1lcyc7IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY29uc3QgeyBsb2dEb2N1bWVudCB9ID0gcmVxdWlyZSggJy4uL2Rldi11dGlscy91dGlscycgKTsKCnZhciBncmF2ZXlhcmROYW1lID0gJyRncmF2ZXlhcmQnOwovKioKICogRGF0YSBtb2RlbCdzIGRvY3VtZW50LiBJdCBjb250YWlucyB0aGUgbW9kZWwncyBzdHJ1Y3R1cmUsIGl0cyBzZWxlY3Rpb24gYW5kIHRoZSBoaXN0b3J5IG9mIGNoYW5nZXMuCiAqCiAqIFJlYWQgbW9yZSBhYm91dCB3b3JraW5nIHdpdGggdGhlIG1vZGVsIGluCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjbW9kZWwgaW50cm9kdWN0aW9uIHRvIHRoZSB0aGUgZWRpdGluZyBlbmdpbmUncyBhcmNoaXRlY3R1cmV9LgogKgogKiBVc3VhbGx5LCB0aGUgZG9jdW1lbnQgY29udGFpbnMganVzdCBvbmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjcm9vdHMgcm9vdCBlbGVtZW50fSwgc28KICogeW91IGNhbiByZXRyaWV2ZSBpdCBieSBqdXN0IGNhbGxpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZ2V0Um9vdH0gd2l0aG91dCBzcGVjaWZ5aW5nIGl0cyBuYW1lOgogKgogKgkJbW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpOyAvLyAtPiByZXR1cm5zIHRoZSBtYWluIHJvb3QKICoKICogSG93ZXZlciwgdGhlIGRvY3VtZW50IG1heSBjb250YWluIG11bHRpcGxlIHJvb3RzIOKAkyBlLmcuIHdoZW4gdGhlIGVkaXRvciBoYXMgbXVsdGlwbGUgZWRpdGFibGUgYXJlYXMKICogKGUuZy4gYSB0aXRsZSBhbmQgYSBib2R5IG9mIGEgbWVzc2FnZSkuCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJNaXhpbgogKi8KCnZhciBEb2N1bWVudCA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYW4gZW1wdHkgZG9jdW1lbnQgaW5zdGFuY2Ugd2l0aCBubyB7QGxpbmsgI3Jvb3RzfSAob3RoZXIgdGhhbgogICAqIHRoZSB7QGxpbmsgI2dyYXZleWFyZCBncmF2ZXlhcmQgcm9vdH0pLgogICAqLwogIGZ1bmN0aW9uIERvY3VtZW50KG1vZGVsKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N1bWVudCk7CgogICAgLyoqCiAgICAgKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwgbW9kZWx9IHRoYXQgdGhlIGRvY3VtZW50IGlzIGEgcGFydCBvZi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfQogICAgICovCiAgICB0aGlzLm1vZGVsID0gbW9kZWw7CiAgICAvKioKICAgICAqIFRoZSBkb2N1bWVudCB2ZXJzaW9uLiBJdCBzdGFydHMgZnJvbSBgMGAgYW5kIGV2ZXJ5IG9wZXJhdGlvbiBpbmNyZWFzZXMgdGhlIHZlcnNpb24gbnVtYmVyLiBJdCBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0CiAgICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIG9uIGEgcHJvcGVyIGRvY3VtZW50IHZlcnNpb24uCiAgICAgKgogICAgICogSWYgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uI2Jhc2VWZXJzaW9uIGJhc2UgdmVyc2lvbn0gZG9lcyBub3QgbWF0Y2ggdGhlIGRvY3VtZW50IHZlcnNpb24sCiAgICAgKiBhIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIG1vZGVsLWRvY3VtZW50LWFwcGx5T3BlcmF0aW9uLXdyb25nLXZlcnNpb259IGVycm9yIGlzIHRocm93bi4KICAgICAqCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogICAgdGhpcy52ZXJzaW9uID0gMDsKICAgIC8qKgogICAgICogVGhlIGRvY3VtZW50J3MgaGlzdG9yeS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL2hpc3Rvcnl+SGlzdG9yeX0KICAgICAqLwoKICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMpOwogICAgLyoqCiAgICAgKiBUaGUgc2VsZWN0aW9uIGluIHRoaXMgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0KICAgICAqLwoKICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IERvY3VtZW50U2VsZWN0aW9uKHRoaXMpOwogICAgLyoqCiAgICAgKiBBIGxpc3Qgb2Ygcm9vdHMgdGhhdCBhcmUgb3duZWQgYW5kIG1hbmFnZWQgYnkgdGhpcyBkb2N1bWVudC4gVXNlIHtAbGluayAjY3JlYXRlUm9vdH0gYW5kCiAgICAgKiB7QGxpbmsgI2dldFJvb3R9IHRvIG1hbmlwdWxhdGUgaXQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOnV0aWxzL2NvbGxlY3Rpb25+Q29sbGVjdGlvbn0KICAgICAqLwoKICAgIHRoaXMucm9vdHMgPSBuZXcgQ29sbGVjdGlvbih7CiAgICAgIGlkUHJvcGVydHk6ICdyb290TmFtZScKICAgIH0pOwogICAgLyoqCiAgICAgKiBUaGUgbW9kZWwgZGlmZmVyIG9iamVjdC4gSXRzIHJvbGUgaXMgdG8gYnVmZmVyIGNoYW5nZXMgZG9uZSBvbiB0aGUgbW9kZWwgZG9jdW1lbnQgYW5kIHRoZW4gY2FsY3VsYXRlIGEgZGlmZiBvZiB0aG9zZSBjaGFuZ2VzLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZGlmZmVyfkRpZmZlcn0KICAgICAqLwoKICAgIHRoaXMuZGlmZmVyID0gbmV3IERpZmZlcihtb2RlbC5tYXJrZXJzKTsKICAgIC8qKgogICAgICogUG9zdC1maXhlciBjYWxsYmFja3MgcmVnaXN0ZXJlZCB0byB0aGUgbW9kZWwgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtTZXQuPEZ1bmN0aW9uPn0KICAgICAqLwoKICAgIHRoaXMuX3Bvc3RGaXhlcnMgPSBuZXcgU2V0KCk7CiAgICAvKioKICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIHVudGlsCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtCb29sZWFufQogICAgICovCgogICAgdGhpcy5faGFzU2VsZWN0aW9uQ2hhbmdlZEZyb21UaGVMYXN0Q2hhbmdlQmxvY2sgPSBmYWxzZTsgLy8gR3JhdmV5YXJkIHRyZWUgcm9vdC4gRG9jdW1lbnQgYWx3YXlzIGhhdmUgYSBncmF2ZXlhcmQgcm9vdCwgd2hpY2ggc3RvcmVzIHJlbW92ZWQgbm9kZXMuCgogICAgdGhpcy5jcmVhdGVSb290KCckcm9vdCcsIGdyYXZleWFyZE5hbWUpOyAvLyBGaXJzdCwgaWYgdGhlIG9wZXJhdGlvbiBpcyBhIGRvY3VtZW50IG9wZXJhdGlvbiBjaGVjayBpZiBpdCdzIGJhc2UgdmVyc2lvbiBpcyBjb3JyZWN0LgoKICAgIHRoaXMubGlzdGVuVG8obW9kZWwsICdhcHBseU9wZXJhdGlvbicsIGZ1bmN0aW9uIChldnQsIGFyZ3MpIHsKICAgICAgdmFyIG9wZXJhdGlvbiA9IGFyZ3NbMF07CgogICAgICBpZiAob3BlcmF0aW9uLmlzRG9jdW1lbnRPcGVyYXRpb24gJiYgb3BlcmF0aW9uLmJhc2VWZXJzaW9uICE9PSBfdGhpcy52ZXJzaW9uKSB7CiAgICAgICAgLyoqCiAgICAgICAgICogT25seSBvcGVyYXRpb25zIHdpdGggbWF0Y2hpbmcgdmVyc2lvbnMgY2FuIGJlIGFwcGxpZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgZG9jdW1lbnQtYXBwbHlPcGVyYXRpb24td3JvbmctdmVyc2lvbgogICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLWRvY3VtZW50LWFwcGx5T3BlcmF0aW9uLXdyb25nLXZlcnNpb246IE9ubHkgb3BlcmF0aW9ucyB3aXRoIG1hdGNoaW5nIHZlcnNpb25zIGNhbiBiZSBhcHBsaWVkLicsIF90aGlzLCB7CiAgICAgICAgICBvcGVyYXRpb246IG9wZXJhdGlvbgogICAgICAgIH0pOwogICAgICB9CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaGVzdCcKICAgIH0pOyAvLyBUaGVuLCBzdGlsbCBiZWZvcmUgYW4gb3BlcmF0aW9uIGlzIGFwcGxpZWQgb24gbW9kZWwsIGJ1ZmZlciB0aGUgY2hhbmdlIGluIGRpZmZlci4KCiAgICB0aGlzLmxpc3RlblRvKG1vZGVsLCAnYXBwbHlPcGVyYXRpb24nLCBmdW5jdGlvbiAoZXZ0LCBhcmdzKSB7CiAgICAgIHZhciBvcGVyYXRpb24gPSBhcmdzWzBdOwoKICAgICAgaWYgKG9wZXJhdGlvbi5pc0RvY3VtZW50T3BlcmF0aW9uKSB7CiAgICAgICAgX3RoaXMuZGlmZmVyLmJ1ZmZlck9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgICB9CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaCcKICAgIH0pOyAvLyBBZnRlciB0aGUgb3BlcmF0aW9uIGlzIGFwcGxpZWQsIGJ1bXAgZG9jdW1lbnQncyB2ZXJzaW9uIGFuZCBhZGQgdGhlIG9wZXJhdGlvbiB0byB0aGUgaGlzdG9yeS4KCiAgICB0aGlzLmxpc3RlblRvKG1vZGVsLCAnYXBwbHlPcGVyYXRpb24nLCBmdW5jdGlvbiAoZXZ0LCBhcmdzKSB7CiAgICAgIHZhciBvcGVyYXRpb24gPSBhcmdzWzBdOwoKICAgICAgaWYgKG9wZXJhdGlvbi5pc0RvY3VtZW50T3BlcmF0aW9uKSB7CiAgICAgICAgX3RoaXMudmVyc2lvbisrOwoKICAgICAgICBfdGhpcy5oaXN0b3J5LmFkZE9wZXJhdGlvbihvcGVyYXRpb24pOwogICAgICB9CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93JwogICAgfSk7IC8vIExpc3RlbiB0byBzZWxlY3Rpb24gY2hhbmdlcy4gSWYgc2VsZWN0aW9uIGNoYW5nZWQsIG1hcmsgaXQuCgogICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnNlbGVjdGlvbiwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHsKICAgICAgX3RoaXMuX2hhc1NlbGVjdGlvbkNoYW5nZWRGcm9tVGhlTGFzdENoYW5nZUJsb2NrID0gdHJ1ZTsKICAgIH0pOyAvLyBCdWZmZXIgbWFya2VyIGNoYW5nZXMuCiAgICAvLyBUaGlzIGlzIG5vdCBjb3ZlcmVkIGluIGJ1ZmZlcmluZyBvcGVyYXRpb25zIGJlY2F1c2UgbWFya2VycyBtYXkgY2hhbmdlIG91dHNpZGUgb2YgdGhlbSAod2hlbiB0aGV5CiAgICAvLyBhcmUgbW9kaWZpZWQgdXNpbmcgYG1vZGVsLm1hcmtlcnNgIGNvbGxlY3Rpb24sIG5vdCB0aHJvdWdoIGBNYXJrZXJPcGVyYXRpb25gKS4KCiAgICB0aGlzLmxpc3RlblRvKG1vZGVsLm1hcmtlcnMsICd1cGRhdGUnLCBmdW5jdGlvbiAoZXZ0LCBtYXJrZXIsIG9sZFJhbmdlLCBuZXdSYW5nZSkgewogICAgICAvLyBXaGVuZXZlciBtYXJrZXIgaXMgdXBkYXRlZCwgYnVmZmVyIHRoYXQgY2hhbmdlLgogICAgICBfdGhpcy5kaWZmZXIuYnVmZmVyTWFya2VyQ2hhbmdlKG1hcmtlci5uYW1lLCBvbGRSYW5nZSwgbmV3UmFuZ2UsIG1hcmtlci5hZmZlY3RzRGF0YSk7CgogICAgICBpZiAob2xkUmFuZ2UgPT09IG51bGwpIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbmV3IG1hcmtlciwgYWRkIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJ1ZmZlciBjaGFuZ2Ugd2hlbmV2ZXIgbWFya2VyIGNoYW5nZXMuCiAgICAgICAgbWFya2VyLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoZXZ0LCBvbGRSYW5nZSkgewogICAgICAgICAgX3RoaXMuZGlmZmVyLmJ1ZmZlck1hcmtlckNoYW5nZShtYXJrZXIubmFtZSwgb2xkUmFuZ2UsIG1hcmtlci5nZXRSYW5nZSgpLCBtYXJrZXIuYWZmZWN0c0RhdGEpOwogICAgICAgIH0pOwogICAgICB9CiAgICB9KTsKICB9CiAgLyoqCiAgICogVGhlIGdyYXZleWFyZCB0cmVlIHJvb3QuIEEgZG9jdW1lbnQgYWx3YXlzIGhhcyBhIGdyYXZleWFyZCByb290IHRoYXQgc3RvcmVzIHJlbW92ZWQgbm9kZXMuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3Jvb3RlbGVtZW50flJvb3RFbGVtZW50fQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKERvY3VtZW50LCBbewogICAga2V5OiAiY3JlYXRlUm9vdCIsCgogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgbmV3IHJvb3QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IFtlbGVtZW50TmFtZT0nJHJvb3QnXSBUaGUgZWxlbWVudCBuYW1lLiBEZWZhdWx0cyB0byBgJyRyb290J2Agd2hpY2ggYWxzbyBoYXMgc29tZSBiYXNpYyBzY2hlbWEgZGVmaW5lZAogICAgICogKGAkYmxvY2tgcyBhcmUgYWxsb3dlZCBpbnNpZGUgdGhlIGAkcm9vdGApLiBNYWtlIHN1cmUgdG8gZGVmaW5lIGEgcHJvcGVyIHNjaGVtYSBpZiB5b3UgdXNlIGEgZGlmZmVyZW50IG5hbWUuCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Jvb3ROYW1lPSdtYWluJ10gQSB1bmlxdWUgcm9vdCBuYW1lLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcm9vdGVsZW1lbnR+Um9vdEVsZW1lbnR9IFRoZSBjcmVhdGVkIHJvb3QuCiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSb290KCkgewogICAgICB2YXIgZWxlbWVudE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICckcm9vdCc7CiAgICAgIHZhciByb290TmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ21haW4nOwoKICAgICAgaWYgKHRoaXMucm9vdHMuZ2V0KHJvb3ROYW1lKSkgewogICAgICAgIC8qKgogICAgICAgICAqIEEgcm9vdCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhbHJlYWR5IGV4aXN0cy4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBtb2RlbC1kb2N1bWVudC1jcmVhdGVSb290LW5hbWUtZXhpc3RzCiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fSBkb2MKICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogICAgICAgICAqLwogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1kb2N1bWVudC1jcmVhdGVSb290LW5hbWUtZXhpc3RzOiBSb290IHdpdGggc3BlY2lmaWVkIG5hbWUgYWxyZWFkeSBleGlzdHMuJywgdGhpcywgewogICAgICAgICAgbmFtZTogcm9vdE5hbWUKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgdmFyIHJvb3QgPSBuZXcgUm9vdEVsZW1lbnQodGhpcywgZWxlbWVudE5hbWUsIHJvb3ROYW1lKTsKICAgICAgdGhpcy5yb290cy5hZGQocm9vdCk7CiAgICAgIHJldHVybiByb290OwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMgc2V0IGJ5IHRoZSBkb2N1bWVudCBpbnN0YW5jZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkZXN0cm95IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkgewogICAgICB0aGlzLnNlbGVjdGlvbi5kZXN0cm95KCk7CiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIGEgcm9vdCBieSBpdHMgbmFtZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J21haW4nXSBBIHVuaXF1ZSByb290IG5hbWUuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yb290ZWxlbWVudH5Sb290RWxlbWVudHxudWxsfSBUaGUgcm9vdCByZWdpc3RlcmVkIHVuZGVyIGEgZ2l2ZW4gbmFtZSBvciBgbnVsbGAgd2hlbgogICAgICogdGhlcmUgaXMgbm8gcm9vdCB3aXRoIHRoZSBnaXZlbiBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFJvb3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvb3QoKSB7CiAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnbWFpbic7CiAgICAgIHJldHVybiB0aGlzLnJvb3RzLmdldChuYW1lKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIG5hbWVzIG9mIGFsbCByb290cyAod2l0aG91dCB0aGUge0BsaW5rICNncmF2ZXlhcmR9KSBhZGRlZCB0byB0aGUgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxTdHJpbmc+fSBSb290cyBuYW1lcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRSb290TmFtZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvb3ROYW1lcygpIHsKICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yb290cywgZnVuY3Rpb24gKHJvb3QpIHsKICAgICAgICByZXR1cm4gcm9vdC5yb290TmFtZTsKICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgICAgcmV0dXJuIG5hbWUgIT0gZ3JhdmV5YXJkTmFtZTsKICAgICAgfSk7CiAgICB9CiAgICAvKioKICAgICAqIFVzZWQgdG8gcmVnaXN0ZXIgYSBwb3N0LWZpeGVyIGNhbGxiYWNrLiBBIHBvc3QtZml4ZXIgbWVjaGFuaXNtIGd1YXJhbnRlZXMgdGhhdCB0aGUgZmVhdHVyZXMKICAgICAqIHdpbGwgb3BlcmF0ZSBvbiBhIGNvcnJlY3QgbW9kZWwgc3RhdGUuCiAgICAgKgogICAgICogQW4gZXhlY3V0aW9uIG9mIGEgZmVhdHVyZSBtYXkgbGVhZCB0byBhbiBpbmNvcnJlY3QgZG9jdW1lbnQgdHJlZSBzdGF0ZS4gVGhlIGNhbGxiYWNrcyBhcmUgdXNlZCB0byBmaXggdGhlIGRvY3VtZW50IHRyZWUgYWZ0ZXIKICAgICAqIGl0IGhhcyBjaGFuZ2VkLiBQb3N0LWZpeGVycyBhcmUgZmlyZWQganVzdCBhZnRlciBhbGwgY2hhbmdlcyBmcm9tIHRoZSBvdXRlcm1vc3QgY2hhbmdlIGJsb2NrIHdlcmUgYXBwbGllZCBidXQKICAgICAqIGJlZm9yZSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlIGNoYW5nZSBldmVudH0gaXMgZmlyZWQuIElmIGEgcG9zdC1maXhlciBjYWxsYmFjayBtYWRlCiAgICAgKiBhIGNoYW5nZSwgaXQgc2hvdWxkIHJldHVybiBgdHJ1ZWAuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgcG9zdC1maXhlcnMgYXJlIGZpcmVkIGFnYWluIHRvIGNoZWNrIGlmIHNvbWV0aGluZyBlbHNlIHNob3VsZAogICAgICogbm90IGJlIGZpeGVkIGluIHRoZSBuZXcgZG9jdW1lbnQgdHJlZSBzdGF0ZS4KICAgICAqCiAgICAgKiBBcyBhIHBhcmFtZXRlciwgYSBwb3N0LWZpeGVyIGNhbGxiYWNrIHJlY2VpdmVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciB3cml0ZXJ9IGluc3RhbmNlIGNvbm5lY3RlZCB3aXRoIHRoZQogICAgICogZXhlY3V0ZWQgY2hhbmdlcyBibG9jay4gVGhhbmtzIHRvIHRoYXQsIGFsbCBjaGFuZ2VzIGRvbmUgYnkgdGhlIGNhbGxiYWNrIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNhbWUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNoIGJhdGNofSAoYW5kIHVuZG8gc3RlcCkgYXMgdGhlIG9yaWdpbmFsIGNoYW5nZXMuIFRoaXMgbWFrZXMgcG9zdC1maXhlciBjaGFuZ2VzIHRyYW5zcGFyZW50CiAgICAgKiBmb3IgdGhlIHVzZXIuCiAgICAgKgogICAgICogQW4gZXhhbXBsZSBvZiBhIHBvc3QtZml4ZXIgaXMgYSBjYWxsYmFjayB0aGF0IGNoZWNrcyBpZiBhbGwgdGhlIGRhdGEgd2VyZSByZW1vdmVkIGZyb20gdGhlIGVkaXRvci4gSWYgc28sIHRoZQogICAgICogY2FsbGJhY2sgc2hvdWxkIGFkZCBhbiBlbXB0eSBwYXJhZ3JhcGggc28gdGhhdCB0aGUgZWRpdG9yIGlzIG5ldmVyIGVtcHR5OgogICAgICoKICAgICAqCQlkb2N1bWVudC5yZWdpc3RlclBvc3RGaXhlciggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc3QgY2hhbmdlcyA9IGRvY3VtZW50LmRpZmZlci5nZXRDaGFuZ2VzKCk7CiAgICAgKgogICAgICoJCQkvLyBDaGVjayBpZiB0aGUgY2hhbmdlcyBsZWFkIHRvIGFuIGVtcHR5IHJvb3QgaW4gdGhlIGVkaXRvci4KICAgICAqCQkJZm9yICggY29uc3QgZW50cnkgb2YgY2hhbmdlcyApIHsKICAgICAqCQkJCWlmICggZW50cnkudHlwZSA9PSAncmVtb3ZlJyAmJiBlbnRyeS5wb3NpdGlvbi5yb290LmlzRW1wdHkgKSB7CiAgICAgKgkJCQkJd3JpdGVyLmluc2VydEVsZW1lbnQoICdwYXJhZ3JhcGgnLCBlbnRyeS5wb3NpdGlvbi5yb290LCAwICk7CiAgICAgKgogICAgICoJCQkJCS8vIEl0IGlzIGZpbmUgdG8gcmV0dXJuIGVhcmx5LCBldmVuIGlmIG11bHRpcGxlIHJvb3RzIHdvdWxkIG5lZWQgdG8gYmUgZml4ZWQuCiAgICAgKgkJCQkJLy8gQWxsIHBvc3QtZml4ZXJzIHdpbGwgYmUgZmlyZWQgYWdhaW4sIHNvIGlmIHRoZXJlIGFyZSBtb3JlIGVtcHR5IHJvb3RzLCB0aG9zZSB3aWxsIGJlIGZpeGVkLCB0b28uCiAgICAgKgkJCQkJcmV0dXJuIHRydWU7CiAgICAgKgkJCQl9CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcG9zdEZpeGVyCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAicmVnaXN0ZXJQb3N0Rml4ZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyUG9zdEZpeGVyKHBvc3RGaXhlcikgewogICAgICB0aGlzLl9wb3N0Rml4ZXJzLmFkZChwb3N0Rml4ZXIpOwogICAgfQogICAgLyoqCiAgICAgKiBBIGN1c3RvbSBgdG9KU09OKClgIG1ldGhvZCB0byBzb2x2ZSBjaGlsZC1wYXJlbnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgY2xvbmUgb2YgdGhpcyBvYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgcHJvcGVydHkgY2hhbmdlZCB0byBhIHN0cmluZy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b0pTT04iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHsKICAgICAgdmFyIGpzb24gPSBjbG9uZSh0aGlzKTsgLy8gRHVlIHRvIGNpcmN1bGFyIHJlZmVyZW5jZXMgd2UgbmVlZCB0byByZW1vdmUgcGFyZW50IHJlZmVyZW5jZS4KCiAgICAgIGpzb24uc2VsZWN0aW9uID0gJ1tlbmdpbmUubW9kZWwuRG9jdW1lbnRTZWxlY3Rpb25dJzsKICAgICAganNvbi5tb2RlbCA9ICdbZW5naW5lLm1vZGVsLk1vZGVsXSc7CiAgICAgIHJldHVybiBqc29uOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVjayBpZiB0aGVyZSB3ZXJlIGFueSBjaGFuZ2VzIGRvbmUgb24gZG9jdW1lbnQsIGFuZCBpZiBzbywgY2FsbCBwb3N0LWZpeGVycywKICAgICAqIGZpcmUgYGNoYW5nZWAgZXZlbnQgZm9yIGZlYXR1cmVzIGFuZCBjb252ZXJzaW9uIGFuZCB0aGVuIHJlc2V0IHRoZSBkaWZmZXIuCiAgICAgKiBGaXJlIGBjaGFuZ2U6ZGF0YWAgZXZlbnQgd2hlbiBhdCBsZWFzdCBvbmUgb3BlcmF0aW9uIG9yIGJ1ZmZlcmVkIG1hcmtlciBjaGFuZ2VzIHRoZSBkYXRhLgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBmaXJlcyBjaGFuZ2UKICAgICAqIEBmaXJlcyBjaGFuZ2U6ZGF0YQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlciBUaGUgd3JpdGVyIG9uIHdoaWNoIHBvc3QtZml4ZXJzIHdpbGwgYmUgY2FsbGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9oYW5kbGVDaGFuZ2VCbG9jayIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNoYW5nZUJsb2NrKHdyaXRlcikgewogICAgICBpZiAodGhpcy5faGFzRG9jdW1lbnRDaGFuZ2VkRnJvbVRoZUxhc3RDaGFuZ2VCbG9jaygpKSB7CiAgICAgICAgdGhpcy5fY2FsbFBvc3RGaXhlcnMod3JpdGVyKTsgLy8gUmVmcmVzaCBzZWxlY3Rpb24gYXR0cmlidXRlcyBhY2NvcmRpbmcgdG8gdGhlIGZpbmFsIHBvc2l0aW9uIGluIHRoZSBtb2RlbCBhZnRlciB0aGUgY2hhbmdlLgoKCiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVmcmVzaCgpOwoKICAgICAgICBpZiAodGhpcy5kaWZmZXIuaGFzRGF0YUNoYW5nZXMoKSkgewogICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2U6ZGF0YScsIHdyaXRlci5iYXRjaCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJywgd3JpdGVyLmJhdGNoKTsKICAgICAgICB9IC8vIFRoZW9yZXRpY2FsbHksIGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gcmVmcmVzaCBzZWxlY3Rpb24gYWZ0ZXIgY2hhbmdlIGV2ZW50IGJlY2F1c2UKICAgICAgICAvLyBwb3N0LWZpeGVycyBhcmUgdGhlIGxhc3Qgd2hvIHNob3VsZCBjaGFuZ2UgdGhlIG1vZGVsLCBidXQganVzdCBpbiBjYXNlLi4uCgoKICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZWZyZXNoKCk7CiAgICAgICAgdGhpcy5kaWZmZXIucmVzZXQoKTsKICAgICAgfQoKICAgICAgdGhpcy5faGFzU2VsZWN0aW9uQ2hhbmdlZEZyb21UaGVMYXN0Q2hhbmdlQmxvY2sgPSBmYWxzZTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgYnVmZmVyZWQgY2hhbmdlIG9yIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQgZnJvbSB0aGUgbGFzdAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZSBgZW5xdWV1ZUNoYW5nZSgpYCBibG9ja30KICAgICAqIG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZSBgY2hhbmdlKClgIGJsb2NrfS4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgZG9jdW1lbnQgaGFzIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBgY2hhbmdlKClgIG9yIGBlbnF1ZXVlQ2hhbmdlKClgIGJsb2NrLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9oYXNEb2N1bWVudENoYW5nZWRGcm9tVGhlTGFzdENoYW5nZUJsb2NrIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzRG9jdW1lbnRDaGFuZ2VkRnJvbVRoZUxhc3RDaGFuZ2VCbG9jaygpIHsKICAgICAgcmV0dXJuICF0aGlzLmRpZmZlci5pc0VtcHR5IHx8IHRoaXMuX2hhc1NlbGVjdGlvbkNoYW5nZWRGcm9tVGhlTGFzdENoYW5nZUJsb2NrOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHJvb3QgZm9yIHRoaXMgZG9jdW1lbnQgd2hpY2ggaXMgZWl0aGVyIHRoZSBmaXJzdCByb290IHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBkb2N1bWVudCB1c2luZwogICAgICoge0BsaW5rICNjcmVhdGVSb290fSBvciB0aGUge0BsaW5rICNncmF2ZXlhcmQgZ3JhdmV5YXJkIHJvb3R9IGlmIG5vIG90aGVyIHJvb3RzIHdlcmUgY3JlYXRlZC4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yb290ZWxlbWVudH5Sb290RWxlbWVudH0gVGhlIGRlZmF1bHQgcm9vdCBmb3IgdGhpcyBkb2N1bWVudC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfZ2V0RGVmYXVsdFJvb3QiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREZWZhdWx0Um9vdCgpIHsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLnJvb3RzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkgewogICAgICAgICAgdmFyIHJvb3QgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICBpZiAocm9vdCAhPT0gdGhpcy5ncmF2ZXlhcmQpIHsKICAgICAgICAgICAgcmV0dXJuIHJvb3Q7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5ncmF2ZXlhcmQ7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcmFuZ2UgZm9yIHRoaXMgc2VsZWN0aW9uLiBUaGUgZGVmYXVsdCByYW5nZSBpcyBhIGNvbGxhcHNlZCByYW5nZSB0aGF0IHN0YXJ0cyBhbmQgZW5kcwogICAgICogYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNlbGVjdGlvbidzIGRvY3VtZW50IHtAbGluayAjX2dldERlZmF1bHRSb290IGRlZmF1bHQgcm9vdH0uCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2dldERlZmF1bHRSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRSYW5nZSgpIHsKICAgICAgdmFyIGRlZmF1bHRSb290ID0gdGhpcy5fZ2V0RGVmYXVsdFJvb3QoKTsKCiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7CiAgICAgIHZhciBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7IC8vIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIHdoZXJlIHRoZSBzZWxlY3Rpb24gY2FuIGJlIHB1dC4KCiAgICAgIHZhciBwb3NpdGlvbiA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoZGVmYXVsdFJvb3QsIFswXSk7CiAgICAgIHZhciBuZWFyZXN0UmFuZ2UgPSBzY2hlbWEuZ2V0TmVhcmVzdFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uKTsgLy8gSWYgdmFsaWQgc2VsZWN0aW9uIHJhbmdlIGlzIG5vdCBmb3VuZCAtIHJldHVybiByYW5nZSBjb2xsYXBzZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcm9vdC4KCiAgICAgIHJldHVybiBuZWFyZXN0UmFuZ2UgfHwgbW9kZWwuY3JlYXRlUmFuZ2UocG9zaXRpb24pOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSBpcyBhIHZhbGlkIHJhbmdlIGZvcgogICAgICogdGhlIHtAbGluayAjc2VsZWN0aW9uIGRvY3VtZW50J3Mgc2VsZWN0aW9ufS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBBIHJhbmdlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBgcmFuZ2VgIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfdmFsaWRhdGVTZWxlY3Rpb25SYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlU2VsZWN0aW9uUmFuZ2UocmFuZ2UpIHsKICAgICAgcmV0dXJuIHZhbGlkYXRlVGV4dE5vZGVQb3NpdGlvbihyYW5nZS5zdGFydCkgJiYgdmFsaWRhdGVUZXh0Tm9kZVBvc2l0aW9uKHJhbmdlLmVuZCk7CiAgICB9CiAgICAvKioKICAgICAqIFBlcmZvcm1zIHBvc3QtZml4ZXIgbG9vcHMuIEV4ZWN1dGVzIHBvc3QtZml4ZXIgY2FsbGJhY2tzIGFzIGxvbmcgYXMgbm9uZSBvZiB0aGVtIGhhcyBkb25lIGFueSBjaGFuZ2VzIHRvIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlciBUaGUgd3JpdGVyIG9uIHdoaWNoIHBvc3QtZml4ZXIgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9jYWxsUG9zdEZpeGVycyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGxQb3N0Rml4ZXJzKHdyaXRlcikgewogICAgICB2YXIgd2FzRml4ZWQgPSBmYWxzZTsKCiAgICAgIGRvIHsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuX3Bvc3RGaXhlcnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgICAvLyBFbnN1cmUgc2VsZWN0aW9uIGF0dHJpYnV0ZXMgYXJlIHVwIHRvIGRhdGUgYmVmb3JlIGVhY2ggcG9zdC1maXhlci4KICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzE2NzMuCiAgICAgICAgICAgIC8vCiAgICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIGdvb2QgdG8gcmVmcmVzaCB0aGUgc2VsZWN0aW9uIGFmdGVyIGVhY2ggb3BlcmF0aW9uIGJ1dCBhdCB0aGUgbW9tZW50IGl0IGxlYWRzCiAgICAgICAgICAgIC8vIHRvIGxvc2luZyBhdHRyaWJ1dGVzIGZvciBjb21wb3NpdGlvbiBvciBhbmQgc3BlbGwgY2hlY2tpbmcKICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS10eXBpbmcvaXNzdWVzLzE4OAogICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZWZyZXNoKCk7CiAgICAgICAgICAgIHdhc0ZpeGVkID0gY2FsbGJhY2sod3JpdGVyKTsKCiAgICAgICAgICAgIGlmICh3YXNGaXhlZCkgewogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IHdoaWxlICh3YXNGaXhlZCk7CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIGFmdGVyIGVhY2gge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZSBgZW5xdWV1ZUNoYW5nZSgpYCBibG9ja30gb3IgdGhlIG91dGVybW9zdAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlIGBjaGFuZ2UoKWAgYmxvY2t9IHdhcyBleGVjdXRlZCBhbmQgdGhlIGRvY3VtZW50IHdhcyBjaGFuZ2VkCiAgICAgKiBkdXJpbmcgdGhhdCBibG9jaydzIGV4ZWN1dGlvbi4KICAgICAqCiAgICAgKiBUaGUgY2hhbmdlcyB3aGljaCB0aGlzIGV2ZW50IHdpbGwgY292ZXIgaW5jbHVkZToKICAgICAqCiAgICAgKiAqIGRvY3VtZW50IHN0cnVjdHVyZSBjaGFuZ2VzLAogICAgICogKiBzZWxlY3Rpb24gY2hhbmdlcywKICAgICAqICogbWFya2VyIGNoYW5nZXMuCiAgICAgKgogICAgICogSWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgYWxsIHRoZXNlIGNoYW5nZXMsIHRoZW4gc2ltcGx5IGxpc3RlbiB0byB0aGlzIGV2ZW50IGxpa2UgdGhpczoKICAgICAqCiAgICAgKgkJbW9kZWwuZG9jdW1lbnQub24oICdjaGFuZ2UnLCAoKSA9PiB7CiAgICAgKgkJCWNvbnNvbGUubG9nKCAnVGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkIScgKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogSWYsIGhvd2V2ZXIsIHlvdSBvbmx5IHdhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgdGhlIGRhdGEgY2hhbmdlcywgdGhlbiB1c2UgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2U6ZGF0YSBjaGFuZ2U6ZGF0YX0gZXZlbnQsCiAgICAgKiB3aGljaCBpcyBmaXJlZCBmb3IgZG9jdW1lbnQgc3RydWN0dXJlIGNoYW5nZXMgYW5kIG1hcmtlciBjaGFuZ2VzICh3aGljaCBhZmZlY3RzIHRoZSBkYXRhKS4KICAgICAqCiAgICAgKgkJbW9kZWwuZG9jdW1lbnQub24oICdjaGFuZ2U6ZGF0YScsICgpID0+IHsKICAgICAqCQkJY29uc29sZS5sb2coICdUaGUgZGF0YSBoYXMgY2hhbmdlZCEnICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBldmVudCBjaGFuZ2UKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gYmF0Y2ggVGhlIGJhdGNoIHRoYXQgd2FzIHVzZWQgaW4gdGhlIGV4ZWN1dGVkIGNoYW5nZXMgYmxvY2suCiAgICAgKi8KCiAgICAvKioKICAgICAqIEl0IGlzIGEgbmFycm93ZXIgdmVyc2lvbiBvZiB0aGUge0BsaW5rICNldmVudDpjaGFuZ2V9IGV2ZW50LiBJdCBpcyBmaXJlZCBmb3IgY2hhbmdlcyB3aGljaAogICAgICogYWZmZWN0IHRoZSBlZGl0b3IgZGF0YS4gVGhpcyBpczoKICAgICAqCiAgICAgKiAqIGRvY3VtZW50IHN0cnVjdHVyZSBjaGFuZ2VzLAogICAgICogKiBtYXJrZXIgY2hhbmdlcyAod2hpY2ggYWZmZWN0cyB0aGUgZGF0YSkuCiAgICAgKgogICAgICogSWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgYWJvdXQgdGhlIGRhdGEgY2hhbmdlcywgdGhlbiBsaXN0ZW4gdG8gdGhpcyBldmVudDoKICAgICAqCiAgICAgKgkJbW9kZWwuZG9jdW1lbnQub24oICdjaGFuZ2U6ZGF0YScsICgpID0+IHsKICAgICAqCQkJY29uc29sZS5sb2coICdUaGUgZGF0YSBoYXMgY2hhbmdlZCEnICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGxpc3RlbiB0byBhbGwgZG9jdW1lbnQgY2hhbmdlcywgdGhlbiBjaGVjayBvdXQgdGhlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2UgY2hhbmdlfSBldmVudC4KICAgICAqCiAgICAgKiBAZXZlbnQgY2hhbmdlOmRhdGEKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gYmF0Y2ggVGhlIGJhdGNoIHRoYXQgd2FzIHVzZWQgaW4gdGhlIGV4ZWN1dGVkIGNoYW5nZXMgYmxvY2suCiAgICAgKi8KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gbG9nKCB2ZXJzaW9uID0gbnVsbCApIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCXZlcnNpb24gPSB2ZXJzaW9uID09PSBudWxsID8gdGhpcy52ZXJzaW9uIDogdmVyc2lvbjsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWxvZ0RvY3VtZW50KCB0aGlzLCB2ZXJzaW9uICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0KCiAgfSwgewogICAga2V5OiAiZ3JhdmV5YXJkIiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICByZXR1cm4gdGhpcy5nZXRSb290KGdyYXZleWFyZE5hbWUpOwogICAgfQogIH1dKTsKCiAgcmV0dXJuIERvY3VtZW50Owp9KCk7CgpleHBvcnQgeyBEb2N1bWVudCBhcyBkZWZhdWx0IH07Cm1peChEb2N1bWVudCwgRW1pdHRlck1peGluKTsgLy8gQ2hlY2tzIHdoZXRoZXIgZ2l2ZW4gcmFuZ2UgYm91bmRhcnkgcG9zaXRpb24gaXMgdmFsaWQgZm9yIGRvY3VtZW50IHNlbGVjdGlvbiwgbWVhbmluZyB0aGF0IGlzIG5vdCBiZXR3ZWVuCi8vIHVuaWNvZGUgc3Vycm9nYXRlIHBhaXJzIG9yIGJhc2UgY2hhcmFjdGVyIGFuZCBjb21iaW5pbmcgbWFya3MuCgpmdW5jdGlvbiB2YWxpZGF0ZVRleHROb2RlUG9zaXRpb24ocmFuZ2VCb3VuZGFyeSkgewogIHZhciB0ZXh0Tm9kZSA9IHJhbmdlQm91bmRhcnkudGV4dE5vZGU7CgogIGlmICh0ZXh0Tm9kZSkgewogICAgdmFyIGRhdGEgPSB0ZXh0Tm9kZS5kYXRhOwogICAgdmFyIG9mZnNldCA9IHJhbmdlQm91bmRhcnkub2Zmc2V0IC0gdGV4dE5vZGUuc3RhcnRPZmZzZXQ7CiAgICByZXR1cm4gIWlzSW5zaWRlU3Vycm9nYXRlUGFpcihkYXRhLCBvZmZzZXQpICYmICFpc0luc2lkZUNvbWJpbmVkU3ltYm9sKGRhdGEsIG9mZnNldCk7CiAgfQoKICByZXR1cm4gdHJ1ZTsKfQ=="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/document.js"],"names":["Differ","RootElement","History","DocumentSelection","Collection","EmitterMixin","CKEditorError","mix","isInsideSurrogatePair","isInsideCombinedSymbol","clone","graveyardName","Document","model","version","history","selection","roots","idProperty","differ","markers","_postFixers","Set","_hasSelectionChangedFromTheLastChangeBlock","createRoot","listenTo","evt","args","operation","isDocumentOperation","baseVersion","priority","bufferOperation","addOperation","marker","oldRange","newRange","bufferMarkerChange","name","affectsData","on","getRange","elementName","rootName","get","root","add","destroy","stopListening","Array","from","filter","postFixer","json","writer","_hasDocumentChangedFromTheLastChangeBlock","_callPostFixers","refresh","hasDataChanges","fire","batch","reset","isEmpty","graveyard","defaultRoot","_getDefaultRoot","schema","position","createPositionFromPath","nearestRange","getNearestSelectionRange","createRange","range","validateTextNodePosition","start","end","wasFixed","callback","getRoot","rangeBoundary","textNode","data","offset","startOffset"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/document\n */\n\nimport Differ from './differ';\nimport RootElement from './rootelement';\nimport History from './history';\nimport DocumentSelection from './documentselection';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport { clone } from 'lodash-es';\n\n// @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );\n\nconst graveyardName = '$graveyard';\n\n/**\n * Data model's document. It contains the model's structure, its selection and the history of changes.\n *\n * Read more about working with the model in\n * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.\n *\n * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so\n * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:\n *\n *\t\tmodel.document.getRoot(); // -> returns the main root\n *\n * However, the document may contain multiple roots â€“ e.g. when the editor has multiple editable areas\n * (e.g. a title and a body of a message).\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class Document {\n\t/**\n\t * Creates an empty document instance with no {@link #roots} (other than\n\t * the {@link #graveyard graveyard root}).\n\t */\n\tconstructor( model ) {\n\t\t/**\n\t\t * The {@link module:engine/model/model~Model model} that the document is a part of.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that\n\t\t * operations are applied on a proper document version.\n\t\t *\n\t\t * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,\n\t\t * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.\n\t\t *\n\t\t * @type {Number}\n\t\t */\n\t\tthis.version = 0;\n\n\t\t/**\n\t\t * The document's history.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/history~History}\n\t\t */\n\t\tthis.history = new History( this );\n\n\t\t/**\n\t\t * The selection in this document.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = new DocumentSelection( this );\n\n\t\t/**\n\t\t * A list of roots that are owned and managed by this document. Use {@link #createRoot} and\n\t\t * {@link #getRoot} to manipulate it.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.roots = new Collection( { idProperty: 'rootName' } );\n\n\t\t/**\n\t\t * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:engine/model/differ~Differ}\n\t\t */\n\t\tthis.differ = new Differ( model.markers );\n\n\t\t/**\n\t\t * Post-fixer callbacks registered to the model document.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<Function>}\n\t\t */\n\t\tthis._postFixers = new Set();\n\n\t\t/**\n\t\t * A boolean indicates whether the selection has changed until\n\t\t *\n\t\t * @private\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\n\t\t// Graveyard tree root. Document always have a graveyard root, which stores removed nodes.\n\t\tthis.createRoot( '$root', graveyardName );\n\n\t\t// First, if the operation is a document operation check if it's base version is correct.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation && operation.baseVersion !== this.version ) {\n\t\t\t\t/**\n\t\t\t\t * Only operations with matching versions can be applied.\n\t\t\t\t *\n\t\t\t\t * @error document-applyOperation-wrong-version\n\t\t\t\t * @param {module:engine/model/operation/operation~Operation} operation\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.',\n\t\t\t\t\tthis,\n\t\t\t\t\t{ operation }\n\t\t\t\t);\n\t\t\t}\n\t\t}, { priority: 'highest' } );\n\n\t\t// Then, still before an operation is applied on model, buffer the change in differ.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.differ.bufferOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\n\t\t// After the operation is applied, bump document's version and add the operation to the history.\n\t\tthis.listenTo( model, 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\tif ( operation.isDocumentOperation ) {\n\t\t\t\tthis.version++;\n\t\t\t\tthis.history.addOperation( operation );\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// Listen to selection changes. If selection changed, mark it.\n\t\tthis.listenTo( this.selection, 'change', () => {\n\t\t\tthis._hasSelectionChangedFromTheLastChangeBlock = true;\n\t\t} );\n\n\t\t// Buffer marker changes.\n\t\t// This is not covered in buffering operations because markers may change outside of them (when they\n\t\t// are modified using `model.markers` collection, not through `MarkerOperation`).\n\t\tthis.listenTo( model.markers, 'update', ( evt, marker, oldRange, newRange ) => {\n\t\t\t// Whenever marker is updated, buffer that change.\n\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, newRange, marker.affectsData );\n\n\t\t\tif ( oldRange === null ) {\n\t\t\t\t// If this is a new marker, add a listener that will buffer change whenever marker changes.\n\t\t\t\tmarker.on( 'change', ( evt, oldRange ) => {\n\t\t\t\t\tthis.differ.bufferMarkerChange( marker.name, oldRange, marker.getRange(), marker.affectsData );\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * The graveyard tree root. A document always has a graveyard root that stores removed nodes.\n\t *\n\t * @readonly\n\t * @member {module:engine/model/rootelement~RootElement}\n\t */\n\tget graveyard() {\n\t\treturn this.getRoot( graveyardName );\n\t}\n\n\t/**\n\t * Creates a new root.\n\t *\n\t * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined\n\t * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.\n\t * @param {String} [rootName='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement} The created root.\n\t */\n\tcreateRoot( elementName = '$root', rootName = 'main' ) {\n\t\tif ( this.roots.get( rootName ) ) {\n\t\t\t/**\n\t\t\t * A root with the specified name already exists.\n\t\t\t *\n\t\t\t * @error model-document-createRoot-name-exists\n\t\t\t * @param {module:engine/model/document~Document} doc\n\t\t\t * @param {String} name\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-document-createRoot-name-exists: Root with specified name already exists.',\n\t\t\t\tthis,\n\t\t\t\t{ name: rootName }\n\t\t\t);\n\t\t}\n\n\t\tconst root = new RootElement( this, elementName, rootName );\n\t\tthis.roots.add( root );\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Removes all event listeners set by the document instance.\n\t */\n\tdestroy() {\n\t\tthis.selection.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Returns a root by its name.\n\t *\n\t * @param {String} [name='main'] A unique root name.\n\t * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when\n\t * there is no root with the given name.\n\t */\n\tgetRoot( name = 'main' ) {\n\t\treturn this.roots.get( name );\n\t}\n\n\t/**\n\t * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.\n\t *\n\t * @returns {Array.<String>} Roots names.\n\t */\n\tgetRootNames() {\n\t\treturn Array.from( this.roots, root => root.rootName ).filter( name => name != graveyardName );\n\t}\n\n\t/**\n\t * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features\n\t * will operate on a correct model state.\n\t *\n\t * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after\n\t * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but\n\t * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made\n\t * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should\n\t * not be fixed in the new document tree state.\n\t *\n\t * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the\n\t * executed changes block. Thanks to that, all changes done by the callback will be added to the same\n\t * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent\n\t * for the user.\n\t *\n\t * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the\n\t * callback should add an empty paragraph so that the editor is never empty:\n\t *\n\t *\t\tdocument.registerPostFixer( writer => {\n\t *\t\t\tconst changes = document.differ.getChanges();\n\t *\n\t *\t\t\t// Check if the changes lead to an empty root in the editor.\n\t *\t\t\tfor ( const entry of changes ) {\n\t *\t\t\t\tif ( entry.type == 'remove' && entry.position.root.isEmpty ) {\n\t *\t\t\t\t\twriter.insertElement( 'paragraph', entry.position.root, 0 );\n\t *\n\t *\t\t\t\t\t// It is fine to return early, even if multiple roots would need to be fixed.\n\t *\t\t\t\t\t// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.\n\t *\t\t\t\t\treturn true;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {Function} postFixer\n\t */\n\tregisterPostFixer( postFixer ) {\n\t\tthis._postFixers.add( postFixer );\n\t}\n\n\t/**\n\t * A custom `toJSON()` method to solve child-parent circular dependencies.\n\t *\n\t * @returns {Object} A clone of this object with the document property changed to a string.\n\t */\n\ttoJSON() {\n\t\tconst json = clone( this );\n\n\t\t// Due to circular references we need to remove parent reference.\n\t\tjson.selection = '[engine.model.DocumentSelection]';\n\t\tjson.model = '[engine.model.Model]';\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Check if there were any changes done on document, and if so, call post-fixers,\n\t * fire `change` event for features and conversion and then reset the differ.\n\t * Fire `change:data` event when at least one operation or buffered marker changes the data.\n\t *\n\t * @protected\n\t * @fires change\n\t * @fires change:data\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.\n\t */\n\t_handleChangeBlock( writer ) {\n\t\tif ( this._hasDocumentChangedFromTheLastChangeBlock() ) {\n\t\t\tthis._callPostFixers( writer );\n\n\t\t\t// Refresh selection attributes according to the final position in the model after the change.\n\t\t\tthis.selection.refresh();\n\n\t\t\tif ( this.differ.hasDataChanges() ) {\n\t\t\t\tthis.fire( 'change:data', writer.batch );\n\t\t\t} else {\n\t\t\t\tthis.fire( 'change', writer.batch );\n\t\t\t}\n\n\t\t\t// Theoretically, it is not necessary to refresh selection after change event because\n\t\t\t// post-fixers are the last who should change the model, but just in case...\n\t\t\tthis.selection.refresh();\n\n\t\t\tthis.differ.reset();\n\t\t}\n\n\t\tthis._hasSelectionChangedFromTheLastChangeBlock = false;\n\t}\n\n\t/**\n\t * Returns whether there is a buffered change or if the selection has changed from the last\n\t * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}\n\t * or {@link module:engine/model/model~Model#change `change()` block}.\n\t *\n\t * @protected\n\t * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.\n\t */\n\t_hasDocumentChangedFromTheLastChangeBlock() {\n\t\treturn !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;\n\t}\n\n\t/**\n\t * Returns the default root for this document which is either the first root that was added to the document using\n\t * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/rootelement~RootElement} The default root for this document.\n\t */\n\t_getDefaultRoot() {\n\t\tfor ( const root of this.roots ) {\n\t\t\tif ( root !== this.graveyard ) {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t}\n\n\t\treturn this.graveyard;\n\t}\n\n\t/**\n\t * Returns the default range for this selection. The default range is a collapsed range that starts and ends\n\t * at the beginning of this selection's document {@link #_getDefaultRoot default root}.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getDefaultRange() {\n\t\tconst defaultRoot = this._getDefaultRoot();\n\t\tconst model = this.model;\n\t\tconst schema = model.schema;\n\n\t\t// Find the first position where the selection can be put.\n\t\tconst position = model.createPositionFromPath( defaultRoot, [ 0 ] );\n\t\tconst nearestRange = schema.getNearestSelectionRange( position );\n\n\t\t// If valid selection range is not found - return range collapsed at the beginning of the root.\n\t\treturn nearestRange || model.createRange( position );\n\t}\n\n\t/**\n\t * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for\n\t * the {@link #selection document's selection}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range A range to check.\n\t * @returns {Boolean} `true` if `range` is valid, `false` otherwise.\n\t */\n\t_validateSelectionRange( range ) {\n\t\treturn validateTextNodePosition( range.start ) && validateTextNodePosition( range.end );\n\t}\n\n\t/**\n\t * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.\n\t */\n\t_callPostFixers( writer ) {\n\t\tlet wasFixed = false;\n\n\t\tdo {\n\t\t\tfor ( const callback of this._postFixers ) {\n\t\t\t\t// Ensure selection attributes are up to date before each post-fixer.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1673.\n\t\t\t\t//\n\t\t\t\t// It might be good to refresh the selection after each operation but at the moment it leads\n\t\t\t\t// to losing attributes for composition or and spell checking\n\t\t\t\t// https://github.com/ckeditor/ckeditor5-typing/issues/188\n\t\t\t\tthis.selection.refresh();\n\n\t\t\t\twasFixed = callback( writer );\n\n\t\t\t\tif ( wasFixed ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( wasFixed );\n\t}\n\n\t/**\n\t * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost\n\t * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed\n\t * during that block's execution.\n\t *\n\t * The changes which this event will cover include:\n\t *\n\t * * document structure changes,\n\t * * selection changes,\n\t * * marker changes.\n\t *\n\t * If you want to be notified about all these changes, then simply listen to this event like this:\n\t *\n\t *\t\tmodel.document.on( 'change', () => {\n\t *\t\t\tconsole.log( 'The document has changed!' );\n\t *\t\t} );\n\t *\n\t * If, however, you only want to be notified about the data changes, then use the\n\t * {@link module:engine/model/document~Document#event:change:data change:data} event,\n\t * which is fired for document structure changes and marker changes (which affects the data).\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * @event change\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t/**\n\t * It is a narrower version of the {@link #event:change} event. It is fired for changes which\n\t * affect the editor data. This is:\n\t *\n\t * * document structure changes,\n\t * * marker changes (which affects the data).\n\t *\n\t * If you want to be notified about the data changes, then listen to this event:\n\t *\n\t *\t\tmodel.document.on( 'change:data', () => {\n\t *\t\t\tconsole.log( 'The data has changed!' );\n\t *\t\t} );\n\t *\n\t * If you would like to listen to all document changes, then check out the\n\t * {@link module:engine/model/document~Document#event:change change} event.\n\t *\n\t * @event change:data\n\t * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.\n\t */\n\n\t// @if CK_DEBUG_ENGINE // log( version = null ) {\n\t// @if CK_DEBUG_ENGINE // \tversion = version === null ? this.version : version;\n\t// @if CK_DEBUG_ENGINE // \tlogDocument( this, version );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\nmix( Document, EmitterMixin );\n\n// Checks whether given range boundary position is valid for document selection, meaning that is not between\n// unicode surrogate pairs or base character and combining marks.\nfunction validateTextNodePosition( rangeBoundary ) {\n\tconst textNode = rangeBoundary.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tconst offset = rangeBoundary.offset - textNode.startOffset;\n\n\t\treturn !isInsideSurrogatePair( data, offset ) && !isInsideCombinedSymbol( data, offset );\n\t}\n\n\treturn true;\n}\n"]}]}