{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\upcastdispatcher.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\upcastdispatcher.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnNldCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXIKICovCmltcG9ydCBWaWV3Q29uc3VtYWJsZSBmcm9tICcuL3ZpZXdjb25zdW1hYmxlJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwppbXBvcnQgTW9kZWxQb3NpdGlvbiBmcm9tICcuLi9tb2RlbC9wb3NpdGlvbic7CmltcG9ydCB7IFNjaGVtYUNvbnRleHQgfSBmcm9tICcuLi9tb2RlbC9zY2hlbWEnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7Ci8qKgogKiBgVXBjYXN0RGlzcGF0Y2hlcmAgaXMgYSBjZW50cmFsIHBvaW50IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlldyB2aWV3fSBjb252ZXJzaW9uLCB3aGljaCBpcyBhIHByb2Nlc3Mgb2YKICogY29udmVydGluZyBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gaW50byBhbm90aGVyIHN0cnVjdHVyZS4KICogSW4gZGVmYXVsdCBhcHBsaWNhdGlvbiwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3IHZpZXd9IGlzIGNvbnZlcnRlZCB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH0uCiAqCiAqIER1cmluZyBjb252ZXJzaW9uIHByb2Nlc3MsIGZvciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2Rlc30gZnJvbSB0aGUgY29udmVydGVkIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQsCiAqIGBVcGNhc3REaXNwYXRjaGVyYCBmaXJlcyBjb3JyZXNwb25kaW5nIGV2ZW50cy4gU3BlY2lhbCBjYWxsYmFja3MgY2FsbGVkICJjb252ZXJ0ZXJzIiBzaG91bGQgbGlzdGVuIHRvCiAqIGBVcGNhc3REaXNwYXRjaGVyYCBmb3IgdGhvc2UgZXZlbnRzLgogKgogKiBFYWNoIGNhbGxiYWNrLCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpcyBwYXNzZWQgYSBzcGVjaWFsIG9iamVjdCBgZGF0YWAgdGhhdCBoYXMgYHZpZXdJdGVtYCwgYG1vZGVsQ3Vyc29yYCBhbmQKICogYG1vZGVsUmFuZ2VgIHByb3BlcnRpZXMuIGB2aWV3SXRlbWAgcHJvcGVydHkgY29udGFpbnMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2RlfSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fQogKiB0aGF0IGlzIGNvbnZlcnRlZCBhdCB0aGUgbW9tZW50IGFuZCBtaWdodCBiZSBoYW5kbGVkIGJ5IHRoZSBjYWxsYmFjay4gYG1vZGVsUmFuZ2VgIHByb3BlcnR5IHNob3VsZCBiZSB1c2VkIHRvIHNhdmUgdGhlIHJlc3VsdAogKiBvZiBjb252ZXJzaW9uIGFuZCBpcyBhbHdheXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gd2hlbiBjb252ZXJzaW9uIHJlc3VsdCBpcyBjb3JyZWN0LgogKiBgbW9kZWxDdXJzb3JgIHByb3BlcnR5IGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259IG9uIHdoaWNoIGNvbnZlcnNpb24gcmVzdWx0IHdpbGwgYmUgaW5zZXJ0ZWQKICogYW5kIGlzIGEgY29udGV4dCBhY2NvcmRpbmcgdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IHdpbGwgYmUgY2hlY2tlZCBiZWZvcmUgdGhlIGNvbnZlcnNpb24uCiAqIFNlZSBhbHNvIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlciNjb252ZXJ0fS4gSXQgaXMgYWxzbyBzaGFyZWQgYnkgcmVmZXJlbmNlIGJ5IGFsbCBjYWxsYmFja3MgbGlzdGVuaW5nIHRvIGdpdmVuIGV2ZW50LgogKgogKiBUaGUgdGhpcmQgcGFyYW1ldGVyIHBhc3NlZCB0byBhIGNhbGxiYWNrIGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlcn0KICogd2hpY2ggcHJvdmlkZXMgYWRkaXRpb25hbCB0b29scyBmb3IgY29udmVydGVycy4KICoKICogRXhhbXBsZXMgb2YgcHJvdmlkaW5nIGNhbGxiYWNrcyBmb3IgYFVwY2FzdERpc3BhdGNoZXJgOgogKgogKgkJLy8gQ29udmVydGVyIGZvciBsaW5rcyAoPGE+KS4KICoJCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50OmEnLCAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICoJCQlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IHRydWUsIGF0dHJpYnV0ZXM6IFsgJ2hyZWYnIF0gfSApICkgewogKgkJCQkvLyA8YT4gZWxlbWVudCBpcyBpbmxpbmUgYW5kIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGF0dHJpYnV0ZSBpbiB0aGUgbW9kZWwuCiAqCQkJCS8vIFRoaXMgaXMgd2h5IHdlIG5lZWQgdG8gY29udmVydCBvbmx5IGNoaWxkcmVuLgogKgkJCQljb25zdCB7IG1vZGVsUmFuZ2UgfSA9IGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yICk7CiAqCiAqCQkJCWZvciAoIGxldCBpdGVtIG9mIG1vZGVsUmFuZ2UuZ2V0SXRlbXMoKSApIHsKICoJCQkJCWlmICggY29udmVyc2lvbkFwaS5zY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIGl0ZW0sICdsaW5rSHJlZicgKSApIHsKICoJCQkJCQljb252ZXJzaW9uQXBpLndyaXRlci5zZXRBdHRyaWJ1dGUoICdsaW5rSHJlZicsIGRhdGEudmlld0l0ZW0uZ2V0QXR0cmlidXRlKCAnaHJlZicgKSwgaXRlbSApOwogKgkJCQkJfQogKgkJCQl9CiAqCQkJfQogKgkJfSApOwogKgogKgkJLy8gQ29udmVydCA8cD4ncyBmb250LXNpemUgc3R5bGUuCiAqCQkvLyBOb3RlOiBZb3Ugc2hvdWxkIHVzZSBhIGxvdy1wcmlvcml0eSBvYnNlcnZlciBpbiBvcmRlciB0byBlbnN1cmUgdGhhdAogKgkJLy8gaXQncyBleGVjdXRlZCBhZnRlciB0aGUgZWxlbWVudC10by1lbGVtZW50IGNvbnZlcnRlci4KICoJCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50OnAnLCAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICoJCQljb25zdCB7IGNvbnN1bWFibGUsIHNjaGVtYSwgd3JpdGVyIH0gPSBjb252ZXJzaW9uQXBpOwogKgogKgkJCWlmICggIWNvbnN1bWFibGUuY29uc3VtZSggZGF0YS52aWV3SXRlbSwgeyBzdHlsZTogJ2ZvbnQtc2l6ZScgfSApICkgewogKgkJCQlyZXR1cm47CiAqCQkJfQogKgogKgkJCWNvbnN0IGZvbnRTaXplID0gZGF0YS52aWV3SXRlbS5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICoKICoJCQkvLyBEb24ndCBnbyBmb3IgdGhlIG1vZGVsIGVsZW1lbnQgYWZ0ZXIgZGF0YS5tb2RlbEN1cnNvciBiZWNhdXNlIGl0IG1pZ2h0IGhhcHBlbgogKgkJCS8vIHRoYXQgYSBzaW5nbGUgdmlldyBlbGVtZW50IHdhcyBjb252ZXJ0ZWQgdG8gbXVsdGlwbGUgbW9kZWwgZWxlbWVudHMuIEdldCBhbGwgb2YgdGhlbS4KICoJCQlmb3IgKCBjb25zdCBpdGVtIG9mIGRhdGEubW9kZWxSYW5nZS5nZXRJdGVtcyggeyBzaGFsbG93OiB0cnVlIH0gKSApIHsKICoJCQkJaWYgKCBzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIGl0ZW0sICdmb250U2l6ZScgKSApIHsKICoJCQkJCXdyaXRlci5zZXRBdHRyaWJ1dGUoICdmb250U2l6ZScsIGZvbnRTaXplLCBpdGVtICk7CiAqCQkJCX0KICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnbG93JyB9ICk7CiAqCiAqCQkvLyBDb252ZXJ0IGFsbCBlbGVtZW50cyB3aGljaCBoYXZlIG5vIGN1c3RvbSBjb252ZXJ0ZXIgaW50byBwYXJhZ3JhcGggKGF1dG9wYXJhZ3JhcGhpbmcpLgogKiAgCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50JywgKCBldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAqICAJIAkvLyBXaGVuIGVsZW1lbnQgaXMgYWxyZWFkeSBjb25zdW1lZCBieSBoaWdoZXIgcHJpb3JpdHkgY29udmVydGVycyB0aGVuIGRvIG5vdGhpbmcuCiAqICAJIAlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS50ZXN0KCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IGRhdGEudmlld0l0ZW0ubmFtZSB9ICkgKSB7CiAqICAJIAkJCWNvbnN0IHBhcmFncmFwaCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAqCiAqICAJIAkJCS8vIEZpbmQgYWxsb3dlZCBwYXJlbnQgZm9yIHBhcmFncmFwaCB0aGF0IHdlIGFyZSBnb2luZyB0byBpbnNlcnQuIElmIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGFsbG93CiAqICAJIAkJCS8vIHRvIGluc2VydCBwYXJhZ3JhcGggYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIGRvZXMgdGhlbiBzcGxpdCBub2RlcyB0byBhbGxvd2VkIHBhcmVudC4KICogIAkgCQkJY29uc3Qgc3BsaXRSZXN1bHQgPSBjb252ZXJzaW9uQXBpLnNwbGl0VG9BbGxvd2VkUGFyZW50KCBwYXJhZ3JhcGgsIGRhdGEubW9kZWxDdXJzb3IgKTsKICoKICogIAkgCQkJLy8gV2hlbiB0aGVyZSBpcyBubyBzcGxpdCByZXN1bHQgaXQgbWVhbnMgdGhhdCB3ZSBjYW4ndCBpbnNlcnQgcGFyYWdyYXBoIGluIHRoaXMgcG9zaXRpb24uCiAqICAJIAkJCWlmICggc3BsaXRSZXN1bHQgKSB7CiAqICAJIAkJCQkvLyBJbnNlcnQgcGFyYWdyYXBoIGluIGFsbG93ZWQgcG9zaXRpb24uCiAqICAJIAkJCQljb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQoIHBhcmFncmFwaCwgc3BsaXRSZXN1bHQucG9zaXRpb24gKTsKICoKICogIAkgCQkJCS8vIENvbnZlcnQgY2hpbGRyZW4gdG8gcGFyYWdyYXBoLgogKiAgCSAJCQkJY29uc3QgeyBtb2RlbFJhbmdlIH0gPSBjb252ZXJzaW9uQXBpLmNvbnZlcnRDaGlsZHJlbigKICogIAkgCQkJCQlkYXRhLnZpZXdJdGVtLAogKiAgCSAJCQkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoIHBhcmFncmFwaCwgMCApCiAqICAJIAkJCQkpOwogKgogKiAJCQkJCQkvLyBTZXQgYXMgY29udmVyc2lvbiByZXN1bHQsIGF0dHJpYnV0ZSBjb252ZXJ0ZXJzIG1heSB1c2UgdGhpcyBwcm9wZXJ0eS4KICogIAkgCQkJCWRhdGEubW9kZWxSYW5nZSA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVJhbmdlKAogKiAgCSAJCQkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKCBwYXJhZ3JhcGggKSwKICogIAkgCQkJCQltb2RlbFJhbmdlLmVuZAogKiAgCSAJCQkJKTsKICoKICogIAkgCQkJCS8vIENvbnRpbnVlIGNvbnZlcnNpb24gaW5zaWRlIHBhcmFncmFwaC4KICogIAkgCQkJCWRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogKiAgCSAJCQl9CiAqICAJIAkJfQogKiAgCSAJfQogKiAgCSB9LCB7IHByaW9yaXR5OiAnbG93JyB9ICk7CiAqCiAqIEJlZm9yZSBlYWNoIGNvbnZlcnNpb24gcHJvY2VzcywgYFVwY2FzdERpc3BhdGNoZXJgIGZpcmVzIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlciNldmVudDp2aWV3Q2xlYW51cH0KICogZXZlbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcHJlcGFyZSB0cmVlIHZpZXcgZm9yIGNvbnZlcnNpb24uCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJNaXhpbgogKiBAZmlyZXMgdmlld0NsZWFudXAKICogQGZpcmVzIGVsZW1lbnQKICogQGZpcmVzIHRleHQKICogQGZpcmVzIGRvY3VtZW50RnJhZ21lbnQKICovCgp2YXIgVXBjYXN0RGlzcGF0Y2hlciA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgYSBgVXBjYXN0RGlzcGF0Y2hlcmAgdGhhdCBvcGVyYXRlcyB1c2luZyBwYXNzZWQgQVBJLgogICAqCiAgICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpCiAgICogQHBhcmFtIHtPYmplY3R9IFtjb252ZXJzaW9uQXBpXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIGludGVyZmFjZSB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGV2ZW50cyBmaXJlZAogICAqIGJ5IGBVcGNhc3REaXNwYXRjaGVyYC4KICAgKi8KICBmdW5jdGlvbiBVcGNhc3REaXNwYXRjaGVyKCkgewogICAgdmFyIGNvbnZlcnNpb25BcGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9OwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVcGNhc3REaXNwYXRjaGVyKTsKCiAgICAvKioKICAgICAqIExpc3Qgb2YgdGhlIGVsZW1lbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyBzcGxpdHRpbmcuCiAgICAgKgogICAgICogQWZ0ZXIgY29udmVyc2lvbiBwcm9jZXNzIHRoZSBsaXN0IGlzIGNsZWFyZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXAuPG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50LEFycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD4+fQogICAgICovCiAgICB0aGlzLl9zcGxpdFBhcnRzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBQb3NpdGlvbiBpbiB0aGUgdGVtcG9yYXJ5IHN0cnVjdHVyZSB3aGVyZSB0aGUgY29udmVydGVkIGNvbnRlbnQgaXMgaW5zZXJ0ZWQuIFRoZSBzdHJ1Y3R1cmUgcmVmbGVjdCB0aGUgY29udGV4dCBvZgogICAgICogdGhlIHRhcmdldCBwb3NpdGlvbiB3aGVyZSB0aGUgY29udGVudCB3aWxsIGJlIGluc2VydGVkLiBUaGlzIHByb3BlcnR5IGlzIGJ1aWxkIGJhc2VkIG9uIHRoZSBjb250ZXh0IHBhcmFtZXRlciBvZiB0aGUKICAgICAqIGNvbnZlcnQgbWV0aG9kLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxudWxsfQogICAgICovCgogICAgdGhpcy5fbW9kZWxDdXJzb3IgPSBudWxsOwogICAgLyoqCiAgICAgKiBJbnRlcmZhY2UgcGFzc2VkIGJ5IGRpc3BhdGNoZXIgdG8gdGhlIGV2ZW50cyBjYWxsYmFja3MuCiAgICAgKgogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0KICAgICAqLwoKICAgIHRoaXMuY29udmVyc2lvbkFwaSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnZlcnNpb25BcGkpOyAvLyBgY29udmVydEl0ZW1gLCBgY29udmVydENoaWxkcmVuYCBhbmQgYHNwbGl0VG9BbGxvd2VkUGFyZW50YCBhcmUgYm91bmQgdG8gdGhpcyBgVXBjYXN0RGlzcGF0Y2hlcmAKICAgIC8vIGluc3RhbmNlIGFuZCBzZXQgb24gYGNvbnZlcnNpb25BcGlgLiBUaGlzIHdheSBvbmx5IGEgcGFydCBvZiBgVXBjYXN0RGlzcGF0Y2hlcmAgQVBJIGlzIGV4cG9zZWQuCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLmNvbnZlcnRJdGVtID0gdGhpcy5fY29udmVydEl0ZW0uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4gPSB0aGlzLl9jb252ZXJ0Q2hpbGRyZW4uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5zcGxpdFRvQWxsb3dlZFBhcmVudCA9IHRoaXMuX3NwbGl0VG9BbGxvd2VkUGFyZW50LmJpbmQodGhpcyk7CiAgICB0aGlzLmNvbnZlcnNpb25BcGkuZ2V0U3BsaXRQYXJ0cyA9IHRoaXMuX2dldFNwbGl0UGFydHMuYmluZCh0aGlzKTsKICB9CiAgLyoqCiAgICogU3RhcnRzIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuIFRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIGNvbnZlcnNpb24uCiAgICoKICAgKiBAZmlyZXMgZWxlbWVudAogICAqIEBmaXJlcyB0ZXh0CiAgICogQGZpcmVzIGRvY3VtZW50RnJhZ21lbnQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld0l0ZW0KICAgKiBQYXJ0IG9mIHRoZSB2aWV3IHRvIGJlIGNvbnZlcnRlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyIEluc3RhbmNlIG9mIG1vZGVsIHdyaXRlci4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBbY29udGV4dD1bJyRyb290J11dIEVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIGFjY29yZGluZyB0byB0aGlzIGNvbnRleHQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBNb2RlbCBkYXRhIHRoYXQgaXMgYSByZXN1bHQgb2YgdGhlIGNvbnZlcnNpb24gcHJvY2VzcwogICAqIHdyYXBwZWQgaW4gYERvY3VtZW50RnJhZ21lbnRgLiBDb252ZXJ0ZWQgbWFya2VyIGVsZW1lbnRzIHdpbGwgYmUgc2V0IGFzIHRoYXQgZG9jdW1lbnQgZnJhZ21lbnQncwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCNtYXJrZXJzIHN0YXRpYyBtYXJrZXJzIG1hcH0uCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoVXBjYXN0RGlzcGF0Y2hlciwgW3sKICAgIGtleTogImNvbnZlcnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnQodmlld0l0ZW0sIHdyaXRlcikgewogICAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogWyckcm9vdCddOwogICAgICB0aGlzLmZpcmUoJ3ZpZXdDbGVhbnVwJywgdmlld0l0ZW0pOyAvLyBDcmVhdGUgY29udGV4dCB0cmVlIGFuZCBzZXQgcG9zaXRpb24gaW4gdGhlIHRvcCBlbGVtZW50LgogICAgICAvLyBJdGVtcyB3aWxsIGJlIGNvbnZlcnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBwb3NpdGlvbi4KCiAgICAgIHRoaXMuX21vZGVsQ3Vyc29yID0gY3JlYXRlQ29udGV4dFRyZWUoY29udGV4dCwgd3JpdGVyKTsgLy8gU3RvcmUgd3JpdGVyIGluIGNvbnZlcnNpb24gYXMgYSBjb252ZXJzaW9uIEFQSQogICAgICAvLyB0byBiZSBzdXJlIHRoYXQgY29udmVyc2lvbiBwcm9jZXNzIHdpbGwgdXNlIHRoZSBzYW1lIGJhdGNoLgoKICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlciA9IHdyaXRlcjsgLy8gQ3JlYXRlIGNvbnN1bWFibGUgdmFsdWVzIGxpc3QgZm9yIGNvbnZlcnNpb24gcHJvY2Vzcy4KCiAgICAgIHRoaXMuY29udmVyc2lvbkFwaS5jb25zdW1hYmxlID0gVmlld0NvbnN1bWFibGUuY3JlYXRlRnJvbSh2aWV3SXRlbSk7IC8vIEN1c3RvbSBkYXRhIHN0b3JlZCBieSBjb252ZXJ0ZXIgZm9yIGNvbnZlcnNpb24gcHJvY2Vzcy4KCiAgICAgIHRoaXMuY29udmVyc2lvbkFwaS5zdG9yZSA9IHt9OyAvLyBEbyB0aGUgY29udmVyc2lvbi4KCiAgICAgIHZhciBfdGhpcyRfY29udmVydEl0ZW0gPSB0aGlzLl9jb252ZXJ0SXRlbSh2aWV3SXRlbSwgdGhpcy5fbW9kZWxDdXJzb3IpLAogICAgICAgICAgbW9kZWxSYW5nZSA9IF90aGlzJF9jb252ZXJ0SXRlbS5tb2RlbFJhbmdlOyAvLyBDb252ZXJzaW9uIHJlc3VsdCBpcyBhbHdheXMgYSBkb2N1bWVudCBmcmFnbWVudCBzbyBsZXQncyBjcmVhdGUgaXQuCgoKICAgICAgdmFyIGRvY3VtZW50RnJhZ21lbnQgPSB3cml0ZXIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOyAvLyBXaGVuIHRoZXJlIGlzIGEgY29udmVyc2lvbiByZXN1bHQuCgogICAgICBpZiAobW9kZWxSYW5nZSkgewogICAgICAgIC8vIFJlbW92ZSBhbGwgZW1wdHkgZWxlbWVudHMgdGhhdCB3ZXJlIGNyZWF0ZSB3aGlsZSBzcGxpdHRpbmcuCiAgICAgICAgdGhpcy5fcmVtb3ZlRW1wdHlFbGVtZW50cygpOyAvLyBNb3ZlIGFsbCBpdGVtcyB0aGF0IHdlcmUgY29udmVydGVkIGluIGNvbnRleHQgdHJlZSB0byB0aGUgZG9jdW1lbnQgZnJhZ21lbnQuCgoKICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9BcnJheSRmcm9tID0gQXJyYXkuZnJvbSh0aGlzLl9tb2RlbEN1cnNvci5wYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7IF9pIDwgX0FycmF5JGZyb20ubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICB2YXIgaXRlbSA9IF9BcnJheSRmcm9tW19pXTsKICAgICAgICAgIHdyaXRlci5hcHBlbmQoaXRlbSwgZG9jdW1lbnRGcmFnbWVudCk7CiAgICAgICAgfSAvLyBFeHRyYWN0IHRlbXBvcmFyeSBtYXJrZXJzIGVsZW1lbnRzIGZyb20gbW9kZWwgYW5kIHNldCBhcyBzdGF0aWMgbWFya2VycyBjb2xsZWN0aW9uLgoKCiAgICAgICAgZG9jdW1lbnRGcmFnbWVudC5tYXJrZXJzID0gZXh0cmFjdE1hcmtlcnNGcm9tTW9kZWxGcmFnbWVudChkb2N1bWVudEZyYWdtZW50LCB3cml0ZXIpOwogICAgICB9IC8vIENsZWFyIGNvbnRleHQgcG9zaXRpb24uCgoKICAgICAgdGhpcy5fbW9kZWxDdXJzb3IgPSBudWxsOyAvLyBDbGVhciBzcGxpdCBlbGVtZW50cyBsaXN0cy4KCiAgICAgIHRoaXMuX3NwbGl0UGFydHMuY2xlYXIoKTsgLy8gQ2xlYXIgY29udmVyc2lvbiBBUEkuCgoKICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlciA9IG51bGw7CiAgICAgIHRoaXMuY29udmVyc2lvbkFwaS5zdG9yZSA9IG51bGw7IC8vIFJldHVybiBmcmFnbWVudCBhcyBjb252ZXJzaW9uIHJlc3VsdC4KCiAgICAgIHJldHVybiBkb2N1bWVudEZyYWdtZW50OwogICAgfQogICAgLyoqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpI2NvbnZlcnRJdGVtCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NvbnZlcnRJdGVtIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydEl0ZW0odmlld0l0ZW0sIG1vZGVsQ3Vyc29yKSB7CiAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7CiAgICAgICAgdmlld0l0ZW06IHZpZXdJdGVtLAogICAgICAgIG1vZGVsQ3Vyc29yOiBtb2RlbEN1cnNvciwKICAgICAgICBtb2RlbFJhbmdlOiBudWxsCiAgICAgIH0pOwoKICAgICAgaWYgKHZpZXdJdGVtLmlzKCdlbGVtZW50JykpIHsKICAgICAgICB0aGlzLmZpcmUoJ2VsZW1lbnQ6JyArIHZpZXdJdGVtLm5hbWUsIGRhdGEsIHRoaXMuY29udmVyc2lvbkFwaSk7CiAgICAgIH0gZWxzZSBpZiAodmlld0l0ZW0uaXMoJ3RleHQnKSkgewogICAgICAgIHRoaXMuZmlyZSgndGV4dCcsIGRhdGEsIHRoaXMuY29udmVyc2lvbkFwaSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5maXJlKCdkb2N1bWVudEZyYWdtZW50JywgZGF0YSwgdGhpcy5jb252ZXJzaW9uQXBpKTsKICAgICAgfSAvLyBIYW5kbGUgaW5jb3JyZWN0IGNvbnZlcnNpb24gcmVzdWx0LgoKCiAgICAgIGlmIChkYXRhLm1vZGVsUmFuZ2UgJiYgIShkYXRhLm1vZGVsUmFuZ2UgaW5zdGFuY2VvZiBNb2RlbFJhbmdlKSkgewogICAgICAgIC8qKgogICAgICAgICAqIEluY29ycmVjdCBjb252ZXJzaW9uIHJlc3VsdCB3YXMgZHJvcHBlZC4KICAgICAgICAgKgogICAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIE1vZGVsIHJhbmdlfSBzaG91bGQgYmUgYSBjb252ZXJzaW9uIHJlc3VsdC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciB2aWV3LWNvbnZlcnNpb24tZGlzcGF0Y2hlci1pbmNvcnJlY3QtcmVzdWx0CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctY29udmVyc2lvbi1kaXNwYXRjaGVyLWluY29ycmVjdC1yZXN1bHQ6IEluY29ycmVjdCBjb252ZXJzaW9uIHJlc3VsdCB3YXMgZHJvcHBlZC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBtb2RlbFJhbmdlOiBkYXRhLm1vZGVsUmFuZ2UsCiAgICAgICAgbW9kZWxDdXJzb3I6IGRhdGEubW9kZWxDdXJzb3IKICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNjb252ZXJ0Q2hpbGRyZW4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfY29udmVydENoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydENoaWxkcmVuKHZpZXdJdGVtLCBtb2RlbEN1cnNvcikgewogICAgICB2YXIgbW9kZWxSYW5nZSA9IG5ldyBNb2RlbFJhbmdlKG1vZGVsQ3Vyc29yKTsKICAgICAgdmFyIG5leHRNb2RlbEN1cnNvciA9IG1vZGVsQ3Vyc29yOwoKICAgICAgZm9yICh2YXIgX2kyID0gMCwgX0FycmF5JGZyb20yID0gQXJyYXkuZnJvbSh2aWV3SXRlbS5nZXRDaGlsZHJlbigpKTsgX2kyIDwgX0FycmF5JGZyb20yLmxlbmd0aDsgX2kyKyspIHsKICAgICAgICB2YXIgdmlld0NoaWxkID0gX0FycmF5JGZyb20yW19pMl07CgogICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jb252ZXJ0SXRlbSh2aWV3Q2hpbGQsIG5leHRNb2RlbEN1cnNvcik7CgogICAgICAgIGlmIChyZXN1bHQubW9kZWxSYW5nZSBpbnN0YW5jZW9mIE1vZGVsUmFuZ2UpIHsKICAgICAgICAgIG1vZGVsUmFuZ2UuZW5kID0gcmVzdWx0Lm1vZGVsUmFuZ2UuZW5kOwogICAgICAgICAgbmV4dE1vZGVsQ3Vyc29yID0gcmVzdWx0Lm1vZGVsQ3Vyc29yOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBtb2RlbFJhbmdlOiBtb2RlbFJhbmdlLAogICAgICAgIG1vZGVsQ3Vyc29yOiBuZXh0TW9kZWxDdXJzb3IKICAgICAgfTsKICAgIH0KICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNzcGxpdFRvQWxsb3dlZFBhcmVudAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zcGxpdFRvQWxsb3dlZFBhcmVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3NwbGl0VG9BbGxvd2VkUGFyZW50KG5vZGUsIG1vZGVsQ3Vyc29yKSB7CiAgICAgIC8vIFRyeSB0byBmaW5kIGFsbG93ZWQgcGFyZW50LgogICAgICB2YXIgYWxsb3dlZFBhcmVudCA9IHRoaXMuY29udmVyc2lvbkFwaS5zY2hlbWEuZmluZEFsbG93ZWRQYXJlbnQobW9kZWxDdXJzb3IsIG5vZGUpOyAvLyBXaGVuIHRoZXJlIGlzIG5vIHBhcmVudCB0aGF0IGFsbG93cyB0byBpbnNlcnQgbm9kZSB0aGVuIHJldHVybiBgbnVsbGAuCgogICAgICBpZiAoIWFsbG93ZWRQYXJlbnQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfSAvLyBXaGVuIGN1cnJlbnQgcG9zaXRpb24gcGFyZW50IGFsbG93cyB0byBpbnNlcnQgbm9kZSB0aGVuIHJldHVybiB0aGlzIHBvc2l0aW9uLgoKCiAgICAgIGlmIChhbGxvd2VkUGFyZW50ID09PSBtb2RlbEN1cnNvci5wYXJlbnQpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgcG9zaXRpb246IG1vZGVsQ3Vyc29yCiAgICAgICAgfTsKICAgICAgfSAvLyBXaGVuIGFsbG93ZWQgcGFyZW50IGlzIGluIGNvbnRleHQgdHJlZS4KCgogICAgICBpZiAodGhpcy5fbW9kZWxDdXJzb3IucGFyZW50LmdldEFuY2VzdG9ycygpLmluY2x1ZGVzKGFsbG93ZWRQYXJlbnQpKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0gLy8gU3BsaXQgZWxlbWVudCB0byBhbGxvd2VkIHBhcmVudC4KCgogICAgICB2YXIgc3BsaXRSZXN1bHQgPSB0aGlzLmNvbnZlcnNpb25BcGkud3JpdGVyLnNwbGl0KG1vZGVsQ3Vyc29yLCBhbGxvd2VkUGFyZW50KTsgLy8gVXNpbmcgdGhlIHJhbmdlIHJldHVybmVkIGJ5IGBtb2RlbC5Xcml0ZXIjc3BsaXRgLCB3ZSB3aWxsIHBhaXIgb3JpZ2luYWwgZWxlbWVudHMgd2l0aCB0aGVpciBzcGxpdCBwYXJ0cy4KICAgICAgLy8KICAgICAgLy8gVGhlIHJhbmdlIHJldHVybmVkIGZyb20gdGhlIHdyaXRlciBzcGFucyAib3ZlciB0aGUgc3BsaXQiIG9yLCBwcmVjaXNlbHkgc2F5aW5nLCBmcm9tIHRoZSBlbmQgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgKHRoZSBvbmUKICAgICAgLy8gdGhhdCBnb3Qgc3BsaXQpIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIHBhcnQgb2YgdGhhdCBlbGVtZW50OgogICAgICAvLwogICAgICAvLyA8bGltaXQ+PGE+PGI+PGM+WFtdWTwvYz48L2I+PGE+PC9saW1pdD4gLT4KICAgICAgLy8gPGxpbWl0PjxhPjxiPjxjPlhbPC9jPjwvYj48L2E+PGE+PGI+PGM+XVk8L2M+PC9iPjwvYT4KICAgICAgLy8KICAgICAgLy8gQWZ0ZXIgdGhlIHNwbGl0IHRoZXJlIGNhbm5vdCBiZSBhbnkgZnVsbCBub2RlIGJldHdlZW4gdGhlIHBvc2l0aW9ucyBpbiBgc3BsaXRSYW5nZWAuIFRoZSBwb3NpdGlvbnMgYXJlIHRvdWNoaW5nLgogICAgICAvLyBBbHNvLCBiZWNhdXNlIG9mIGhvdyBzcGxpdHRpbmcgd29ya3MsIGl0IGlzIGVhc3kgdG8gbm90aWNlLCB0aGF0ICJjbG9zaW5nIHRhZ3MiIGFyZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGFuICJvcGVuaW5nIHRhZ3MiLgogICAgICAvLyBBbHNvLCBzaW5jZSB3ZSBzcGxpdCBhbGwgdGhvc2UgZWxlbWVudHMsIGVhY2ggb2YgdGhlbSBoYXMgdG8gaGF2ZSB0aGUgb3RoZXIgcGFydC4KICAgICAgLy8KICAgICAgLy8gV2l0aCB0aG9zZSBvYnNlcnZhdGlvbnMgaW4gbWluZCwgd2Ugd2lsbCBwYWlyIHRoZSBvcmlnaW5hbCBlbGVtZW50cyB3aXRoIHRoZWlyIHNwbGl0IHBhcnRzIGJ5IHNhdmluZyAiY2xvc2luZyB0YWdzIiBhbmQgbWF0Y2hpbmcKICAgICAgLy8gdGhlbSB3aXRoICJvcGVuaW5nIHRhZ3MiIGluIHRoZSByZXZlcnNlIG9yZGVyLiBGb3IgdGhhdCB3ZSBjYW4gdXNlIGEgc3RhY2suCgogICAgICB2YXIgc3RhY2sgPSBbXTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBzcGxpdFJlc3VsdC5yYW5nZS5nZXRXYWxrZXIoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciB0cmVlV2Fsa2VyVmFsdWUgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICBpZiAodHJlZVdhbGtlclZhbHVlLnR5cGUgPT0gJ2VsZW1lbnRFbmQnKSB7CiAgICAgICAgICAgIHN0YWNrLnB1c2godHJlZVdhbGtlclZhbHVlLml0ZW0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG5vdCBiZSBhbnkgdGV4dCBub2RlcyBhZnRlciB0aGUgZWxlbWVudCBpcyBzcGxpdCwgc28gdGhlIG9ubHkgb3RoZXIgdmFsdWUgaXMgYGVsZW1lbnRTdGFydGAuCiAgICAgICAgICAgIHZhciBvcmlnaW5hbFBhcnQgPSBzdGFjay5wb3AoKTsKICAgICAgICAgICAgdmFyIHNwbGl0UGFydCA9IHRyZWVXYWxrZXJWYWx1ZS5pdGVtOwoKICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJTcGxpdFBhaXIob3JpZ2luYWxQYXJ0LCBzcGxpdFBhcnQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBwb3NpdGlvbjogc3BsaXRSZXN1bHQucG9zaXRpb24sCiAgICAgICAgY3Vyc29yUGFyZW50OiBzcGxpdFJlc3VsdC5yYW5nZS5lbmQucGFyZW50CiAgICAgIH07CiAgICB9CiAgICAvKioKICAgICAqIFJlZ2lzdGVycyB0aGF0IGBzcGxpdFBhcnRgIGVsZW1lbnQgaXMgYSBzcGxpdCBwYXJ0IG9mIHRoZSBgb3JpZ2luYWxQYXJ0YCBlbGVtZW50LgogICAgICoKICAgICAqIERhdGEgc2V0IGJ5IHRoaXMgbWV0aG9kIGlzIHVzZWQgYnkge0BsaW5rICNfZ2V0U3BsaXRQYXJ0c30gYW5kIHtAbGluayAjX3JlbW92ZUVtcHR5RWxlbWVudHN9LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBvcmlnaW5hbFBhcnQKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHNwbGl0UGFydAogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZWdpc3RlclNwbGl0UGFpciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyU3BsaXRQYWlyKG9yaWdpbmFsUGFydCwgc3BsaXRQYXJ0KSB7CiAgICAgIGlmICghdGhpcy5fc3BsaXRQYXJ0cy5oYXMob3JpZ2luYWxQYXJ0KSkgewogICAgICAgIHRoaXMuX3NwbGl0UGFydHMuc2V0KG9yaWdpbmFsUGFydCwgW29yaWdpbmFsUGFydF0pOwogICAgICB9CgogICAgICB2YXIgbGlzdCA9IHRoaXMuX3NwbGl0UGFydHMuZ2V0KG9yaWdpbmFsUGFydCk7CgogICAgICB0aGlzLl9zcGxpdFBhcnRzLnNldChzcGxpdFBhcnQsIGxpc3QpOwoKICAgICAgbGlzdC5wdXNoKHNwbGl0UGFydCk7CiAgICB9CiAgICAvKioKICAgICAqIEBwcml2YXRlCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkjZ2V0U3BsaXRQYXJ0cwogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRTcGxpdFBhcnRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3BsaXRQYXJ0cyhlbGVtZW50KSB7CiAgICAgIHZhciBwYXJ0czsKCiAgICAgIGlmICghdGhpcy5fc3BsaXRQYXJ0cy5oYXMoZWxlbWVudCkpIHsKICAgICAgICBwYXJ0cyA9IFtlbGVtZW50XTsKICAgICAgfSBlbHNlIHsKICAgICAgICBwYXJ0cyA9IHRoaXMuX3NwbGl0UGFydHMuZ2V0KGVsZW1lbnQpOwogICAgICB9CgogICAgICByZXR1cm4gcGFydHM7CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IGVtcHR5IGVsZW1lbnRzIGNyZWF0ZWQgd2hpbGUgc3BsaXR0aW5nIGFuZCByZW1vdmVzIHRoZW0uCiAgICAgKgogICAgICogVGhpcyBtZXRob2Qgd29ya3MgcmVjdXJzaXZlbHkgdG8gcmUtY2hlY2sgZW1wdHkgZWxlbWVudHMgYWdhaW4gYWZ0ZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgd2FzIHJlbW92ZWQgaW4gdGhlIGluaXRpYWwgY2FsbCwKICAgICAqIGFzIHNvbWUgZWxlbWVudHMgbWlnaHQgaGF2ZSBiZWNvbWUgZW1wdHkgYWZ0ZXIgb3RoZXIgZW1wdHkgZWxlbWVudHMgd2VyZSByZW1vdmVkIGZyb20gdGhlbS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9yZW1vdmVFbXB0eUVsZW1lbnRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRW1wdHlFbGVtZW50cygpIHsKICAgICAgdmFyIGFueVJlbW92ZWQgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdGhpcy5fc3BsaXRQYXJ0cy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgIHZhciBlbGVtZW50ID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgIGlmIChlbGVtZW50LmlzRW1wdHkpIHsKICAgICAgICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlci5yZW1vdmUoZWxlbWVudCk7CgogICAgICAgICAgICB0aGlzLl9zcGxpdFBhcnRzLmRlbGV0ZShlbGVtZW50KTsKCiAgICAgICAgICAgIGFueVJlbW92ZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChhbnlSZW1vdmVkKSB7CiAgICAgICAgdGhpcy5fcmVtb3ZlRW1wdHlFbGVtZW50cygpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIGJlZm9yZSB0aGUgZmlyc3QgY29udmVyc2lvbiBldmVudCwgYXQgdGhlIGJlZ2lubmluZyBvZiB1cGNhc3QgKHZpZXcgdG8gbW9kZWwgY29udmVyc2lvbikgcHJvY2Vzcy4KICAgICAqCiAgICAgKiBAZXZlbnQgdmlld0NsZWFudXAKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fQogICAgICogdmlld0l0ZW0gUGFydCBvZiB0aGUgdmlldyB0byBiZSBjb252ZXJ0ZWQuCiAgICAgKi8KCiAgICAvKioKICAgICAqIEZpcmVkIHdoZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGlzIGNvbnZlcnRlZC4KICAgICAqCiAgICAgKiBgZWxlbWVudGAgaXMgYSBuYW1lc3BhY2UgZXZlbnQgZm9yIGEgY2xhc3Mgb2YgZXZlbnRzLiBOYW1lcyBvZiBhY3R1YWxseSBjYWxsZWQgZXZlbnRzIGZvbGxvdyB0aGlzIHBhdHRlcm46CiAgICAgKiBgZWxlbWVudDo8ZWxlbWVudE5hbWU+YCB3aGVyZSBgZWxlbWVudE5hbWVgIGlzIHRoZSBuYW1lIG9mIGNvbnZlcnRlZCBlbGVtZW50LiBUaGlzIHdheSBsaXN0ZW5lcnMgbWF5IGxpc3RlbiB0bwogICAgICogYWxsIGVsZW1lbnRzIGNvbnZlcnNpb24gb3IgdG8gY29udmVyc2lvbiBvZiBzcGVjaWZpYyBlbGVtZW50cy4KICAgICAqCiAgICAgKiBAZXZlbnQgZWxlbWVudAogICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQ29udmVyc2lvbiBkYXRhLiBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIG9iamVjdCBpcyBzaGFyZWQgYnkgcmVmZXJlbmNlIGJldHdlZW4gYWxsCiAgICAgKiBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGNhbGxlZC4gVGhpcyBtZWFucyB0aGF0IGNhbGxiYWNrcyBjYW4gb3ZlcnJpZGUgdmFsdWVzIGlmIG5lZWRlZCwgYW5kIHRob3NlIHZhbHVlcyB3aWxsCiAgICAgKiBiZSBhdmFpbGFibGUgaW4gb3RoZXIgY2FsbGJhY2tzLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfSBkYXRhLnZpZXdJdGVtIENvbnZlcnRlZCBpdGVtLgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBkYXRhLm1vZGVsQ3Vyc29yIFBvc2l0aW9uIHdoZXJlIGEgY29udmVydGVyIHNob3VsZCBzdGFydCBjaGFuZ2VzLgogICAgICogQ2hhbmdlIHRoaXMgdmFsdWUgZm9yIHRoZSBuZXh0IGNvbnZlcnRlciB0byB0ZWxsIHdoZXJlIHRoZSBjb252ZXJzaW9uIHNob3VsZCBjb250aW51ZS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gZGF0YS5tb2RlbFJhbmdlIFRoZSBjdXJyZW50IHN0YXRlIG9mIGNvbnZlcnNpb24gcmVzdWx0LiBFdmVyeSBjaGFuZ2UgdG8KICAgICAqIGNvbnZlcnRlZCBlbGVtZW50IHNob3VsZCBiZSByZWZsZWN0ZWQgYnkgc2V0dGluZyBvciBtb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIHV0aWxpdGllcyB0byBiZSB1c2VkIGJ5IGNhbGxiYWNrLgogICAgICovCgogICAgLyoqCiAgICAgKiBGaXJlZCB3aGVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBpcyBjb252ZXJ0ZWQuCiAgICAgKgogICAgICogQGV2ZW50IHRleHQKICAgICAqIEBzZWUgI2V2ZW50OmVsZW1lbnQKICAgICAqLwoKICAgIC8qKgogICAgICogRmlyZWQgd2hlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gaXMgY29udmVydGVkLgogICAgICoKICAgICAqIEBldmVudCBkb2N1bWVudEZyYWdtZW50CiAgICAgKiBAc2VlICNldmVudDplbGVtZW50CiAgICAgKi8KCiAgfV0pOwoKICByZXR1cm4gVXBjYXN0RGlzcGF0Y2hlcjsKfSgpOwoKZXhwb3J0IHsgVXBjYXN0RGlzcGF0Y2hlciBhcyBkZWZhdWx0IH07Cm1peChVcGNhc3REaXNwYXRjaGVyLCBFbWl0dGVyTWl4aW4pOyAvLyBUcmF2ZXJzZXMgZ2l2ZW4gbW9kZWwgaXRlbSBhbmQgc2VhcmNoZXMgZWxlbWVudHMgd2hpY2ggbWFya3MgbWFya2VyIHJhbmdlLiBGb3VuZCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbQovLyBEb2N1bWVudEZyYWdtZW50IGJ1dCBwYXRoIG9mIHRoaXMgZWxlbWVudCBpcyBzdG9yZWQgaW4gYSBNYXAgd2hpY2ggaXMgdGhlbiByZXR1cm5lZC4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV9IG1vZGVsSXRlbSBGcmFnbWVudCBvZiBtb2RlbC4KLy8gQHJldHVybnMge01hcDxTdHJpbmcsIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBMaXN0IG9mIHN0YXRpYyBtYXJrZXJzLgoKZnVuY3Rpb24gZXh0cmFjdE1hcmtlcnNGcm9tTW9kZWxGcmFnbWVudChtb2RlbEl0ZW0sIHdyaXRlcikgewogIHZhciBtYXJrZXJFbGVtZW50cyA9IG5ldyBTZXQoKTsKICB2YXIgbWFya2VycyA9IG5ldyBNYXAoKTsgLy8gQ3JlYXRlIE1vZGVsVHJlZVdhbGtlci4KCiAgdmFyIHJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4obW9kZWxJdGVtKS5nZXRJdGVtcygpOyAvLyBXYWxrIHRocm91Z2ggRG9jdW1lbnRGcmFnbWVudCBhbmQgY29sbGVjdCBtYXJrZXIgZWxlbWVudHMuCgoKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IHJhbmdlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7CiAgICAgIHZhciBpdGVtID0gX3N0ZXAzLnZhbHVlOwoKICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBlbGVtZW50IGlzIGEgbWFya2VyLgogICAgICBpZiAoaXRlbS5uYW1lID09ICckbWFya2VyJykgewogICAgICAgIG1hcmtlckVsZW1lbnRzLmFkZChpdGVtKTsKICAgICAgfQogICAgfSAvLyBXYWxrIHRocm91Z2ggY29sbGVjdGVkIG1hcmtlciBlbGVtZW50cyBzdG9yZSBpdHMgcGF0aCBhbmQgcmVtb3ZlIGl0cyBmcm9tIHRoZSBEb2N1bWVudEZyYWdtZW50LgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7CiAgICAgIH0KICAgIH0KICB9CgogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjQgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gbWFya2VyRWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgdmFyIG1hcmtlckVsZW1lbnQgPSBfc3RlcDQudmFsdWU7CiAgICAgIHZhciBtYXJrZXJOYW1lID0gbWFya2VyRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScpOwogICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKG1hcmtlckVsZW1lbnQpOyAvLyBXaGVuIG1hcmtlciBvZiBnaXZlbiBuYW1lIGlzIG5vdCBzdG9yZWQgaXQgbWVhbnMgdGhhdCB3ZSBoYXZlIGZvdW5kIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlLgoKICAgICAgaWYgKCFtYXJrZXJzLmhhcyhtYXJrZXJOYW1lKSkgewogICAgICAgIG1hcmtlcnMuc2V0KG1hcmtlck5hbWUsIG5ldyBNb2RlbFJhbmdlKGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpKSk7IC8vIE90aGVyd2lzZSBpcyBtZWFucyB0aGF0IHdlIGhhdmUgZm91bmQgZW5kIG9mIHRoZSBtYXJrZXIgcmFuZ2UuCiAgICAgIH0gZWxzZSB7CiAgICAgICAgbWFya2Vycy5nZXQobWFya2VyTmFtZSkuZW5kID0gY3VycmVudFBvc2l0aW9uLmNsb25lKCk7CiAgICAgIH0gLy8gUmVtb3ZlIG1hcmtlciBlbGVtZW50IGZyb20gRG9jdW1lbnRGcmFnbWVudC4KCgogICAgICB3cml0ZXIucmVtb3ZlKG1hcmtlckVsZW1lbnQpOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTsKICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIG1hcmtlcnM7Cn0gLy8gQ3JlYXRlcyBtb2RlbCBmcmFnbWVudCBhY2NvcmRpbmcgdG8gZ2l2ZW4gY29udGV4dCBhbmQgcmV0dXJucyBwb3NpdGlvbiBpbiB0aGUgYm90dG9tICh0aGUgZGVlcGVzdCkgZWxlbWVudC4KCgpmdW5jdGlvbiBjcmVhdGVDb250ZXh0VHJlZShjb250ZXh0RGVmaW5pdGlvbiwgd3JpdGVyKSB7CiAgdmFyIHBvc2l0aW9uOwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlOwogIHZhciBfaXRlcmF0b3JFcnJvcjUgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3I1ID0gbmV3IFNjaGVtYUNvbnRleHQoY29udGV4dERlZmluaXRpb24pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgIHZhciBpdGVtID0gX3N0ZXA1LnZhbHVlOwogICAgICB2YXIgYXR0cmlidXRlcyA9IHt9OwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjYgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBpdGVtLmdldEF0dHJpYnV0ZUtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IChfc3RlcDYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZSkgewogICAgICAgICAgdmFyIGtleSA9IF9zdGVwNi52YWx1ZTsKICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGl0ZW0uZ2V0QXR0cmlidXRlKGtleSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjYucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjYpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I2OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIGN1cnJlbnQgPSB3cml0ZXIuY3JlYXRlRWxlbWVudChpdGVtLm5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgICAgaWYgKHBvc2l0aW9uKSB7CiAgICAgICAgd3JpdGVyLmFwcGVuZChjdXJyZW50LCBwb3NpdGlvbik7CiAgICAgIH0KCiAgICAgIHBvc2l0aW9uID0gTW9kZWxQb3NpdGlvbi5fY3JlYXRlQXQoY3VycmVudCwgMCk7CiAgICB9CiAgfSBjYXRjaCAoZXJyKSB7CiAgICBfZGlkSXRlcmF0b3JFcnJvcjUgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyOwogIH0gZmluYWxseSB7CiAgICB0cnkgewogICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3I1LnJldHVybigpOwogICAgICB9CiAgICB9IGZpbmFsbHkgewogICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I1KSB7CiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1OwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gcG9zaXRpb247Cn0KLyoqCiAqIENvbnZlcnNpb24gaW50ZXJmYWNlIHRoYXQgaXMgcmVnaXN0ZXJlZCBmb3IgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ9CiAqIGFuZCBpcyBwYXNzZWQgYXMgb25lIG9mIHBhcmFtZXRlcnMgd2hlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciBkaXNwYXRjaGVyfQogKiBmaXJlcyBpdCdzIGV2ZW50cy4KICoKICogQGludGVyZmFjZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3RDb252ZXJzaW9uQXBpCiAqLwoKLyoqCiAqIFN0YXJ0cyBjb252ZXJzaW9uIG9mIGdpdmVuIGl0ZW0gYnkgZmlyaW5nIGFuIGFwcHJvcHJpYXRlIGV2ZW50LgogKgogKiBFdmVyeSBmaXJlZCBldmVudCBpcyBwYXNzZWQgKGFzIGZpcnN0IHBhcmFtZXRlcikgYW4gb2JqZWN0IHdpdGggYG1vZGVsUmFuZ2VgIHByb3BlcnR5LiBFdmVyeSBldmVudCBtYXkgc2V0IGFuZC9vcgogKiBtb2RpZnkgdGhhdCBwcm9wZXJ0eS4gV2hlbiBhbGwgY2FsbGJhY2tzIGFyZSBkb25lLCB0aGUgZmluYWwgdmFsdWUgb2YgYG1vZGVsUmFuZ2VgIHByb3BlcnR5IGlzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLgogKiBUaGUgYG1vZGVsUmFuZ2VgIG11c3QgYmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgbW9kZWwgcmFuZ2V9IG9yIGBudWxsYCAoYXMgc2V0IGJ5IGRlZmF1bHQpLgogKgogKiBAbWV0aG9kICNjb252ZXJ0SXRlbQogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OnRleHQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZG9jdW1lbnRGcmFnbWVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHZpZXdJdGVtIEl0ZW0gdG8gY29udmVydC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2RlbEN1cnNvciBQb3NpdGlvbiBvZiBjb252ZXJzaW9uLgogKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgQ29udmVyc2lvbiByZXN1bHQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IHJlc3VsdC5tb2RlbFJhbmdlIE1vZGVsIHJhbmdlIGNvbnRhaW5pbmcgcmVzdWx0IG9mIGl0ZW0gY29udmVyc2lvbiwKICogY3JlYXRlZCBhbmQgbW9kaWZpZWQgYnkgY2FsbGJhY2tzIGF0dGFjaGVkIHRvIGZpcmVkIGV2ZW50LCBvciBgbnVsbGAgaWYgdGhlIGNvbnZlcnNpb24gcmVzdWx0IHdhcyBpbmNvcnJlY3QuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSByZXN1bHQubW9kZWxDdXJzb3IgUG9zaXRpb24gd2hlcmUgY29udmVyc2lvbiBzaG91bGQgYmUgY29udGludWVkLgogKi8KCi8qKgogKiBTdGFydHMgY29udmVyc2lvbiBvZiBhbGwgY2hpbGRyZW4gb2YgZ2l2ZW4gaXRlbSBieSBmaXJpbmcgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBhbGwgdGhvc2UgY2hpbGRyZW4uCiAqCiAqIEBtZXRob2QgI2NvbnZlcnRDaGlsZHJlbgogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OnRleHQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZG9jdW1lbnRGcmFnbWVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHZpZXdJdGVtIEVsZW1lbnQgd2hpY2ggY2hpbGRyZW4gc2hvdWxkIGJlIGNvbnZlcnRlZC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2RlbEN1cnNvciBQb3NpdGlvbiBvZiBjb252ZXJzaW9uLgogKiBAcmV0dXJucyB7T2JqZWN0fSByZXN1bHQgQ29udmVyc2lvbiByZXN1bHQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByZXN1bHQubW9kZWxSYW5nZSBNb2RlbCByYW5nZSBjb250YWluaW5nIHJlc3VsdHMgb2YgY29udmVyc2lvbiBvZiBhbGwgY2hpbGRyZW4gb2YgZ2l2ZW4gaXRlbS4KICogV2hlbiBubyBjaGlsZHJlbiB3YXMgY29udmVydGVkIHRoZW4gcmFuZ2UgaXMgY29sbGFwc2VkLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcmVzdWx0Lm1vZGVsQ3Vyc29yIFBvc2l0aW9uIHdoZXJlIGNvbnZlcnNpb24gc2hvdWxkIGJlIGNvbnRpbnVlZC4KICovCgovKioKICogQ2hlY2tzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSB0byBmaW5kIGFsbG93ZWQgcGFyZW50IGZvciBlbGVtZW50IHRoYXQgd2UgYXJlIGdvaW5nIHRvIGluc2VydAogKiBzdGFydGluZyBmcm9tIGdpdmVuIHBvc2l0aW9uLiBJZiBjdXJyZW50IHBhcmVudCBkb2VzIG5vdCBhbGxvdyB0byBpbnNlcnQgZWxlbWVudCBidXQgb25lIG9mIHRoZSBhbmNlc3RvcnMgZG9lcyB0aGVuCiAqIHNwbGl0IG5vZGVzIHRvIGFsbG93ZWQgcGFyZW50LgogKgogKiBJZiBzY2hlbWEgYWxsb3dzIHRvIGluc2VydCBub2RlIGluIGdpdmVuIHBvc2l0aW9uLCBub3RoaW5nIGlzIHNwbGl0IGFuZCBvYmplY3Qgd2l0aCB0aGF0IHBvc2l0aW9uIGlzIHJldHVybmVkLgogKgogKiBJZiBpdCB3YXMgbm90IHBvc3NpYmxlIHRvIGZpbmQgYWxsb3dlZCBwYXJlbnQsIGBudWxsYCBpcyByZXR1cm5lZCwgbm90aGluZyBpcyBzcGxpdC4KICoKICogT3RoZXJ3aXNlLCBhbmNlc3RvcnMgYXJlIHNwbGl0IGFuZCBvYmplY3Qgd2l0aCBwb3NpdGlvbiBhbmQgdGhlIGNvcHkgb2YgdGhlIHNwbGl0IGVsZW1lbnQgaXMgcmV0dXJuZWQuCiAqCiAqIEZvciBpbnN0YW5jZSwgaWYgYDxpbWFnZT5gIGlzIG5vdCBhbGxvd2VkIGluIGA8cGFyYWdyYXBoPmAgYnV0IGlzIGFsbG93ZWQgaW4gYCRyb290YDoKICoKICoJCTxwYXJhZ3JhcGg+Zm9vW11iYXI8L3BhcmFncmFwaD4KICoKICogIAktPiBzcGxpdCBmb3IgYDxpbWFnZT5gIC0+CiAqCiAqICAJPHBhcmFncmFwaD5mb288L3BhcmFncmFwaD5bXTxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAqCiAqIEluIHRoZSBzYW1wbGUgYWJvdmUgcG9zaXRpb24gYmV0d2VlbiBgPHBhcmFncmFwaD5gIGVsZW1lbnRzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYHBvc2l0aW9uYCBhbmQgdGhlIHNlY29uZCBgcGFyYWdyYXBoYAogKiBhcyBgY3Vyc29yUGFyZW50YC4KICoKICogQG1ldGhvZCAjc3BsaXRUb0FsbG93ZWRQYXJlbnQKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBvbiB3aGljaCBlbGVtZW50IGlzIGdvaW5nIHRvIGJlIGluc2VydGVkLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIE5vZGUgdG8gaW5zZXJ0LgogKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFNwbGl0IHJlc3VsdC4gSWYgaXQgd2FzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGFsbG93ZWQgcG9zaXRpb24gYG51bGxgIGlzIHJldHVybmVkLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gYmV0d2VlbiBzcGxpdCBlbGVtZW50cy4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBbY3Vyc29yUGFyZW50XSBFbGVtZW50IGluc2lkZSB3aGljaCBjdXJzb3Igc2hvdWxkIGJlIHBsYWNlZCB0bwogKiBjb250aW51ZSBjb252ZXJzaW9uLiBXaGVuIGVsZW1lbnQgaXMgbm90IGRlZmluZWQgaXQgbWVhbnMgdGhhdCB0aGVyZSB3YXMgbm8gc3BsaXQuCiAqLwoKLyoqCiAqIFJldHVybnMgYWxsIHRoZSBzcGxpdCBwYXJ0cyBvZiBnaXZlbiBgZWxlbWVudGAgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHVwY2FzdGluZyB0aHJvdWdoIHVzaW5nIHtAbGluayAjc3BsaXRUb0FsbG93ZWRQYXJlbnR9LgogKiBJdCBlbmFibGVzIHlvdSB0byBlYXNpbHkgdHJhY2sgdGhvc2UgZWxlbWVudHMgYW5kIGNvbnRpbnVlIHByb2Nlc3NpbmcgdGhlbSBhZnRlciB0aGV5IGFyZSBzcGxpdCBkdXJpbmcgdGhlaXIgY2hpbGRyZW4gY29udmVyc2lvbi4KICoKICoJCTxwYXJhZ3JhcGg+Rm9vPGltYWdlIC8+YmFyPGltYWdlIC8+YmF6PC9wYXJhZ3JhcGg+IC0+CiAqCQk8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPjxpbWFnZSAvPjxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+PGltYWdlIC8+PHBhcmFncmFwaD5iYXo8L3BhcmFncmFwaD4KICoKICogRm9yIGEgcmVmZXJlbmNlIHRvIGFueSBvZiBhYm92ZSBwYXJhZ3JhcGhzLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYWxsIHRocmVlIHBhcmFncmFwaHMgKHRoZSBvcmlnaW5hbCBlbGVtZW50IGluY2x1ZGVkKSwKICogc29ydGVkIGluIHRoZSBvcmRlciBvZiB0aGVpciBjcmVhdGlvbiAodGhlIG9yaWdpbmFsIGVsZW1lbnQgaXMgdGhlIGZpcnN0IG9uZSkuCiAqCiAqIElmIGdpdmVuIGBlbGVtZW50YCB3YXMgbm90IHNwbGl0LCBhbiBhcnJheSB3aXRoIHNpbmdsZSBlbGVtZW50IGlzIHJldHVybmVkLgogKgogKiBFeGFtcGxlIG9mIGEgdXNhZ2UgaW4gYSBjb252ZXJ0ZXIgY29kZToKICoKICoJCWNvbnN0IG15RWxlbWVudCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdteUVsZW1lbnQnICk7CiAqCiAqCQkvLyBDaGlsZHJlbiBjb252ZXJzaW9uIG1heSBzcGxpdCBgbXlFbGVtZW50YC4KICoJCWNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBteUVsZW1lbnQsIG1vZGVsQ3Vyc29yICk7CiAqCiAqCQljb25zdCBzcGxpdFBhcnRzID0gY29udmVyc2lvbkFwaS5nZXRTcGxpdFBhcnRzKCBteUVsZW1lbnQgKTsKICoJCWNvbnN0IGxhc3RTcGxpdFBhcnQgPSBzcGxpdFBhcnRzWyBzcGxpdFBhcnRzLmxlbmd0aCAtIDEgXTsKICoKICoJCS8vIFNldHRpbmcgYGRhdGEubW9kZWxSYW5nZWAgYmFzaW5nIG9uIHNwbGl0IHBhcnRzOgogKgkJZGF0YS5tb2RlbFJhbmdlID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUmFuZ2UoCiAqCQkJY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25CZWZvcmUoIG15RWxlbWVudCApLAogKgkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIoIGxhc3RTcGxpdFBhcnQgKQogKgkJKTsKICoKICoJCS8vIFNldHRpbmcgYGRhdGEubW9kZWxDdXJzb3JgIHRvIGNvbnRpbnVlIGFmdGVyIHRoZSBsYXN0IHNwbGl0IGVsZW1lbnQ6CiAqCQlkYXRhLm1vZGVsQ3Vyc29yID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlciggbGFzdFNwbGl0UGFydCApOwogKgogKiAqKlRpcDoqKiBpZiB5b3UgYXJlIHVuYWJsZSB0byBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGVsZW1lbnQgKGZvciBleGFtcGxlIGJlY2F1c2UgdGhlIGNvZGUgaXMgc3BsaXQgaW50byBtdWx0aXBsZSBjb252ZXJ0ZXJzCiAqIG9yIGV2ZW4gY2xhc3NlcykgYnV0IGl0IHdhcyBhbHJlYWR5IGNvbnZlcnRlZCwgeW91IG1pZ2h0IHdhbnQgdG8gY2hlY2sgZmlyc3QgZWxlbWVudCBpbiBgZGF0YS5tb2RlbFJhbmdlYC4gVGhpcyBpcyBhIGNvbW1vbiBzaXR1YXRpb24KICogaWYgYW4gYXR0cmlidXRlIGNvbnZlcnRlciBpcyBzZXBhcmF0ZWQgZnJvbSBhbiBlbGVtZW50IGNvbnZlcnRlci4KICoKICogQG1ldGhvZCAjZ2V0U3BsaXRQYXJ0cwogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQ+fQogKi8KCi8qKgogKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBwYXJ0cyBvZiBwcm9jZXNzZWQgdmlldyBpdGVtIGFyZSBzdGlsbCB3YWl0aW5nIHRvIGJlIGhhbmRsZWQuIEFmdGVyIGEgcGllY2Ugb2YgdmlldyBpdGVtCiAqIHdhcyBjb252ZXJ0ZWQsIGFwcHJvcHJpYXRlIGNvbnN1bWFibGUgdmFsdWUgc2hvdWxkIGJlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGUjY29uc3VtZSBjb25zdW1lZH0uCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZX0gI2NvbnN1bWFibGUKICovCgovKioKICogQ3VzdG9tIGRhdGEgc3RvcmVkIGJ5IGNvbnZlcnRlcnMgZm9yIGNvbnZlcnNpb24gcHJvY2Vzcy4gQ3VzdG9tIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3QgY2FuIGJlIGRlZmluZWQgYW5kIHVzZSB0bwogKiBwYXNzIHBhcmFtZXRlcnMgYmV0d2VlbiBjb252ZXJ0ZXJzLgogKgogKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgcHJvcGVydHkgYW5kIGBkYXRhYCBwYXJhbWV0ZXIgb2YKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6ZWxlbWVudH0gaXMgdGhhdCBgZGF0YWAgcGFyYW1ldGVycyBhbGxvd3MgeW91CiAqIHRvIHBhc3MgcGFyYW1ldGVycyB3aXRoaW4gYSBzaW5nbGUgZXZlbnQgYW5kIGBzdG9yZWAgd2l0aGluIHRoZSB3aG9sZSBjb252ZXJzaW9uLgogKgogKiBAbWVtYmVyIHtPYmplY3R9ICNzdG9yZQogKi8KCi8qKgogKiBUaGUgbW9kZWwncyBzY2hlbWEgaW5zdGFuY2UuCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYX0gI3NjaGVtYQogKi8KCi8qKgogKiBUaGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gaW5zdGFuY2UgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgZHVyaW5nIGNvbnZlcnNpb24uCiAqCiAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gI3dyaXRlcgogKi8="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","CKEditorError","EmitterMixin","mix","UpcastDispatcher","conversionApi","_splitParts","Map","_modelCursor","Object","assign","convertItem","_convertItem","bind","convertChildren","_convertChildren","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","viewItem","writer","context","fire","createContextTree","consumable","createFrom","store","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","Array","from","parent","getChildren","item","append","markers","extractMarkersFromModelFragment","clear","modelCursor","data","is","name","nextModelCursor","viewChild","result","end","node","allowedParent","schema","findAllowedParent","position","getAncestors","includes","splitResult","split","stack","range","getWalker","treeWalkerValue","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","has","set","list","get","element","parts","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","Set","_createIn","getItems","add","markerElement","markerName","getAttribute","currentPosition","createPositionBefore","clone","contextDefinition","attributes","getAttributeKeys","key","current","createElement","_createAt"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p>'s font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it's executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Don't go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren(\n *  \t \t\t\t\t\tdata.viewItem,\n *  \t \t\t\t\t\tconversionApi.writer.createPositionAt( paragraph, 0 )\n *  \t \t\t\t\t);\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = conversionApi.writer.createRange(\n *  \t \t\t\t\t\tconversionApi.writer.createPositionBefore( paragraph ),\n *  \t \t\t\t\t\tmodelRange.end\n *  \t \t\t\t\t);\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates a `UpcastDispatcher` that operates using passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n\t * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n\t * by `UpcastDispatcher`.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * List of the elements that were created during splitting.\n\t\t *\n\t\t * After conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._splitParts = new Map();\n\n\t\t/**\n\t\t * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n\t\t * the target position where the content will be inserted. This property is build based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n\t\t// instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t\tthis.conversionApi.getSplitParts = this._getSplitParts.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * Part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create it.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that were create while splitting.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that were converted in context tree to the document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements lists.\n\t\tthis._splitParts.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( 'text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', this );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, modelCursor ) {\n\t\tconst modelRange = new ModelRange( modelCursor );\n\t\tlet nextModelCursor = modelCursor;\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\t// Try to find allowed parent.\n\t\tconst allowedParent = this.conversionApi.schema.findAllowedParent( modelCursor, node );\n\n\t\t// When there is no parent that allows to insert node then return `null`.\n\t\tif ( !allowedParent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When current position parent allows to insert node then return this position.\n\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\treturn { position: modelCursor };\n\t\t}\n\n\t\t// When allowed parent is in context tree.\n\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n\t\t//\n\t\t// The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n\t\t// that got split) to the beginning of the other part of that element:\n\t\t//\n\t\t// <limit><a><b><c>X[]Y</c></b><a></limit> ->\n\t\t// <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n\t\t//\n\t\t// After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n\t\t// Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n\t\t// Also, since we split all those elements, each of them has to have the other part.\n\t\t//\n\t\t// With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n\t\t// them with \"opening tags\" in the reverse order. For that we can use a stack.\n\t\tconst stack = [];\n\n\t\tfor ( const treeWalkerValue of splitResult.range.getWalker() ) {\n\t\t\tif ( treeWalkerValue.type == 'elementEnd' ) {\n\t\t\t\tstack.push( treeWalkerValue.item );\n\t\t\t} else {\n\t\t\t\t// There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n\t\t\t\tconst originalPart = stack.pop();\n\t\t\t\tconst splitPart = treeWalkerValue.item;\n\n\t\t\t\tthis._registerSplitPair( originalPart, splitPart );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent: splitResult.range.end.parent\n\t\t};\n\t}\n\n\t/**\n\t * Registers that `splitPart` element is a split part of the `originalPart` element.\n\t *\n\t * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} originalPart\n\t * @param {module:engine/model/element~Element} splitPart\n\t */\n\t_registerSplitPair( originalPart, splitPart ) {\n\t\tif ( !this._splitParts.has( originalPart ) ) {\n\t\t\tthis._splitParts.set( originalPart, [ originalPart ] );\n\t\t}\n\n\t\tconst list = this._splitParts.get( originalPart );\n\n\t\tthis._splitParts.set( splitPart, list );\n\t\tlist.push( splitPart );\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n\t */\n\t_getSplitParts( element ) {\n\t\tlet parts;\n\n\t\tif ( !this._splitParts.has( element ) ) {\n\t\t\tparts = [ element ];\n\t\t} else {\n\t\t\tparts = this._splitParts.get( element );\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Checks if there are any empty elements created while splitting and removes them.\n\t *\n\t * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n\t * as some elements might have become empty after other empty elements were removed from them.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet anyRemoved = false;\n\n\t\tfor ( const element of this._splitParts.keys() ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._splitParts.delete( element );\n\n\t\t\t\tanyRemoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( anyRemoved ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem Part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n\t * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n\t * all elements conversion or to conversion of specific elements.\n\t *\n\t * @event element\n\t * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n\t * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n\t * be available in other callbacks.\n\t * @param {module:engine/view/item~Item} data.viewItem Converted item.\n\t * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n\t * Change this value for the next converter to tell where the conversion should continue.\n\t * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n\t * converted element should be reflected by setting or modifying this property.\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange._createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = writer.createPositionBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( currentPosition.clone() ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = currentPosition.clone();\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition._createAt( current, 0 );\n\t}\n\n\treturn position;\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Element which children should be converted.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track those elements and continue processing them after they are split during their children conversion.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If given `element` was not split, an array with single element is returned.\n *\n * Example of a usage in a converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( myElement, modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation\n * if an attribute converter is separated from an element converter.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n"]}]}