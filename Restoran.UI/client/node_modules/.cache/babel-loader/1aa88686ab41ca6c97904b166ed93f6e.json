{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\stylesmap.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\view\\stylesmap.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmVudHJpZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheSI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwoKLyoqCiAqIEBtb2R1bGUgZW5naW5lL3ZpZXcvc3R5bGVzbWFwCiAqLwppbXBvcnQgeyBnZXQsIGlzT2JqZWN0LCBtZXJnZSwgc2V0LCB1bnNldCB9IGZyb20gJ2xvZGFzaC1lcyc7Ci8qKgogKiBTdHlsZXMgbWFwLiBBbGxvd3MgaGFuZGxpbmcgKGFkZGluZywgcmVtb3ZpbmcsIHJldHJpZXZpbmcpIGEgc2V0IG9mIHN0eWxlIHJ1bGVzICh1c3VhbGx5LCBvZiBhbiBlbGVtZW50KS4KICoKICogVGhlIHN0eWxlcyBtYXAgaXMgY2FwYWJsZSBvZiBub3JtYWxpemluZyBzdHlsZSBuYW1lcyBzbyBlLmcuIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9ucyBhcmUgcG9zc2libGU6CiAqLwoKdmFyIFN0eWxlc01hcCA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8qKgogICAqIENyZWF0ZXMgU3R5bGVzIGluc3RhbmNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc3R5bGVzbWFwflN0eWxlc1Byb2Nlc3Nvcn0gc3R5bGVQcm9jZXNzb3IKICAgKi8KICBmdW5jdGlvbiBTdHlsZXNNYXAoc3R5bGVQcm9jZXNzb3IpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZXNNYXApOwoKICAgIC8qKgogICAgICogS2VlcHMgYW4gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2Ygc3R5bGVzIG1hcC4gTm9ybWFsaXplZCBzdHlsZXMgYXJlIGtlcHQgYXMgb2JqZWN0IHRyZWUgdG8gYWxsb3cgdW5pZmllZCBtb2RpZmljYXRpb24gYW5kCiAgICAgKiB2YWx1ZSBhY2Nlc3MgbW9kZWwgdXNpbmcgbG9kYXNoJ3MgZ2V0LCBzZXQsIHVuc2V0LCBldGMgbWV0aG9kcy4KICAgICAqCiAgICAgKiBXaGVuIG5vIHN0eWxlIHByb2Nlc3NvciBydWxlcyBhcmUgZGVmaW5lZCB0aGUgaXQgYWN0cyBhcyBzaW1wbGUga2V5LXZhbHVlIHN0b3JhZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtPYmplY3R9CiAgICAgKi8KICAgIHRoaXMuX3N0eWxlcyA9IHt9OwogICAgLyoqCiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+U3R5bGVzUHJvY2Vzc29yfS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5TdHlsZXNQcm9jZXNzb3J9CiAgICAgKi8KCiAgICB0aGlzLl9zdHlsZVByb2Nlc3NvciA9IHN0eWxlUHJvY2Vzc29yOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRydWUgaWYgc3R5bGUgbWFwIGhhcyBubyBzdHlsZXMgc2V0LgogICAqCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoU3R5bGVzTWFwLCBbewogICAga2V5OiAic2V0VG8iLAoKICAgIC8qKgogICAgICogU2V0IHN0eWxlcyBtYXAgdG8gYSBuZXcgdmFsdWUuCiAgICAgKgogICAgICoJCXN0eWxlcy5zZXRUbyggJ2JvcmRlcjoxcHggc29saWQgYmx1ZTttYXJnaW4tdG9wOjFweDsnICk7CiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGlubGluZVN0eWxlCiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUbyhpbmxpbmVTdHlsZSkgewogICAgICB0aGlzLmNsZWFyKCk7CiAgICAgIHZhciBwYXJzZWRTdHlsZXMgPSBBcnJheS5mcm9tKHBhcnNlSW5saW5lU3R5bGVzKGlubGluZVN0eWxlKS5lbnRyaWVzKCkpOwoKICAgICAgZm9yICh2YXIgX2kgPSAwLCBfcGFyc2VkU3R5bGVzID0gcGFyc2VkU3R5bGVzOyBfaSA8IF9wYXJzZWRTdHlsZXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgdmFyIF9wYXJzZWRTdHlsZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfcGFyc2VkU3R5bGVzW19pXSwgMiksCiAgICAgICAgICAgIGtleSA9IF9wYXJzZWRTdHlsZXMkX2lbMF0sCiAgICAgICAgICAgIHZhbHVlID0gX3BhcnNlZFN0eWxlcyRfaVsxXTsKCiAgICAgICAgdGhpcy5fc3R5bGVQcm9jZXNzb3IudG9Ob3JtYWxpemVkRm9ybShrZXksIHZhbHVlLCB0aGlzLl9zdHlsZXMpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHN0eWxlIGlzIHNldC4KICAgICAqCiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luLWxlZnQ6MXB4OycgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbi1sZWZ0JyApOyAgICAvLyAtPiB0cnVlCiAgICAgKgkJc3R5bGVzLmhhcyggJ3BhZGRpbmcnICk7ICAgICAgICAvLyAtPiBmYWxzZQogICAgICoKICAgICAqICoqTm90ZSoqOiBUaGlzIGNoZWNrIHN1cHBvcnRzIG5vcm1hbGl6ZWQgc3R5bGUgbmFtZXMuCiAgICAgKgogICAgICoJCS8vIEVuYWJsZSAnbWFyZ2luJyBzaG9ydGhhbmQgcHJvY2Vzc2luZzoKICAgICAqCQllZGl0b3IuZGF0YS5hZGRTdHlsZVByb2Nlc3NvclJ1bGVzKCBhZGRNYXJnaW5SdWxlcyApOwogICAgICoKICAgICAqCQlzdHlsZXMuc2V0VG8oICdtYXJnaW46MnB4OycgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbicgKTsgICAgICAgICAvLyAtPiB0cnVlCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbi10b3AnICk7ICAgICAvLyAtPiB0cnVlCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbi1sZWZ0JyApOyAgICAvLyAtPiB0cnVlCiAgICAgKgogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tdG9wJyApOwogICAgICoKICAgICAqCQlzdHlsZXMuaGFzKCAnbWFyZ2luJyApOyAgICAgICAgIC8vIC0+IGZhbHNlCiAgICAgKgkJc3R5bGVzLmhhcyggJ21hcmdpbi10b3AnICk7ICAgICAvLyAtPiBmYWxzZQogICAgICoJCXN0eWxlcy5oYXMoICdtYXJnaW4tbGVmdCcgKTsgICAgLy8gLT4gdHJ1ZQogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFN0eWxlIG5hbWUuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJoYXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhuYW1lKSB7CiAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBzdHlsZXMgPSB0aGlzLl9zdHlsZVByb2Nlc3Nvci5nZXRSZWR1Y2VkRm9ybShuYW1lLCB0aGlzLl9zdHlsZXMpOwoKICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IHN0eWxlcy5maW5kKGZ1bmN0aW9uIChfcmVmKSB7CiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksCiAgICAgICAgICAgIHByb3BlcnR5ID0gX3JlZjJbMF07CgogICAgICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gbmFtZTsKICAgICAgfSk7IC8vIE9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgaXQgaXMgc2V0OwoKICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXNjcmlwdG9yKTsKICAgIH0KICAgIC8qKgogICAgICogU2V0cyBhIGdpdmVuIHN0eWxlLgogICAgICoKICAgICAqIENhbiBpbnNlcnQgb25lIGJ5IG9uZToKICAgICAqCiAgICAgKgkJc3R5bGVzLnNldCggJ2NvbG9yJywgJ2JsdWUnICk7CiAgICAgKgkJc3R5bGVzLnNldCggJ21hcmdpbi1yaWdodCcsICcxZW0nICk7CiAgICAgKgogICAgICogb3IgbWFueSBzdHlsZXMgYXQgb25jZToKICAgICAqCiAgICAgKgkJc3R5bGVzLnNldCggewogICAgICoJCQljb2xvcjogJ2JsdWUnLAogICAgICoJCQknbWFyZ2luLXJpZ2h0JzogJzFlbScKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogKioqTm90ZSoqOiogVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyfkRhdGFDb250cm9sbGVyI2FkZFN0eWxlUHJvY2Vzc29yUnVsZXMKICAgICAqIGVuYWJsZWQgc3R5bGUgcHJvY2Vzc29yIHJ1bGVzfSB0byBub3JtYWxpemUgcGFzc2VkIHZhbHVlcy4KICAgICAqCiAgICAgKgkJLy8gRW5hYmxlICdtYXJnaW4nIHNob3J0aGFuZCBwcm9jZXNzaW5nOgogICAgICoJCWVkaXRvci5kYXRhLmFkZFN0eWxlUHJvY2Vzc29yUnVsZXMoIGFkZE1hcmdpblJ1bGVzICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5zZXQoICdtYXJnaW4nLCAnMnB4JyApOwogICAgICoKICAgICAqIFRoZSBhYm92ZSBjb2RlIHdpbGwgc2V0IG1hcmdpbiB0bzoKICAgICAqCiAgICAgKgkJc3R5bGVzLmdldE5vcm1hbGl6ZWQoICdtYXJnaW4nICk7CiAgICAgKgkJLy8gLT4geyB0b3A6ICcycHgnLCByaWdodDogJzJweCcsIGJvdHRvbTogJzJweCcsIGxlZnQ6ICcycHgnIH0KICAgICAqCiAgICAgKiBXaGljaCBtYWtlcyBpdCBwb3NzaWJsZSB0byByZXRyaWV2ZSBhICJzdWItdmFsdWUiOgogICAgICoKICAgICAqCQlzdHlsZXMuZ2V0KCAnbWFyZ2luLWxlZnQnICk7ICAgICAgIC8vIC0+ICcycHgnCiAgICAgKgogICAgICogT3IgbW9kaWZ5IGl0OgogICAgICoKICAgICAqCQlzdHlsZXMucmVtb3ZlKCAnbWFyZ2luLWxlZnQnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXROb3JtYWxpemVkKCAnbWFyZ2luJyApOyAgLy8gLT4geyB0b3A6ICcxcHgnLCBib3R0b206ICcxcHgnLCByaWdodDogJzFweCcgfQogICAgICoJCXN0eWxlcy50b1N0cmluZygpOyAgICAgICAgICAgICAgICAgLy8gLT4gJ21hcmdpbi1ib3R0b206MXB4O21hcmdpbi1yaWdodDoxcHg7bWFyZ2luLXRvcDoxcHg7JwogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGFsc28gYWxsb3dzIHRvIHNldCBub3JtYWxpemVkIHZhbHVlcyBkaXJlY3RseSAoaWYgYSBwYXJ0aWN1bGFyIHN0eWxlcyBwcm9jZXNzb3IgcnVsZSB3YXMgZW5hYmxlZCk6CiAgICAgKgogICAgICoJCXN0eWxlcy5zZXQoICdib3JkZXItY29sb3InLCB7IHRvcDogJ2JsdWUnIH0gKTsKICAgICAqCQlzdHlsZXMuc2V0KCAnbWFyZ2luJywgeyByaWdodDogJzJlbScgfSApOwogICAgICoKICAgICAqCQlzdHlsZXMudG9TdHJpbmcoKTsgICAgICAgICAgICAgICAgIC8vIC0+ICdib3JkZXItY29sb3ItdG9wOmJsdWU7bWFyZ2luLXJpZ2h0OjJlbTsnCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lT3JPYmplY3QgU3R5bGUgcHJvcGVydHkgbmFtZSBvciBvYmplY3Qgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzLgogICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZU9yT2JqZWN0IFZhbHVlIHRvIHNldC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lT3JPYmplY3QsIHZhbHVlT3JPYmplY3QpIHsKICAgICAgaWYgKGlzT2JqZWN0KG5hbWVPck9iamVjdCkpIHsKICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhuYW1lT3JPYmplY3QpOyBfaTIgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaTIrKykgewogICAgICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KF9PYmplY3QkZW50cmllc1tfaTJdLCAyKSwKICAgICAgICAgICAgICBrZXkgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sCiAgICAgICAgICAgICAgdmFsdWUgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07CgogICAgICAgICAgdGhpcy5fc3R5bGVQcm9jZXNzb3IudG9Ob3JtYWxpemVkRm9ybShrZXksIHZhbHVlLCB0aGlzLl9zdHlsZXMpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9zdHlsZVByb2Nlc3Nvci50b05vcm1hbGl6ZWRGb3JtKG5hbWVPck9iamVjdCwgdmFsdWVPck9iamVjdCwgdGhpcy5fc3R5bGVzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGdpdmVuIHN0eWxlLgogICAgICoKICAgICAqCQlzdHlsZXMuc2V0VG8oICdiYWNrZ3JvdW5kOiNmMDA7bWFyZ2luLXJpZ2h0OjJweDsnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5yZW1vdmUoICdiYWNrZ3JvdW5kJyApOwogICAgICoKICAgICAqCQlzdHlsZXMudG9TdHJpbmcoKTsgICAvLyAtPiAnbWFyZ2luLXJpZ2h0OjJweDsnCiAgICAgKgogICAgICogKioqTm90ZSoqOiogVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyfkRhdGFDb250cm9sbGVyI2FkZFN0eWxlUHJvY2Vzc29yUnVsZXMKICAgICAqIGVuYWJsZWQgc3R5bGUgcHJvY2Vzc29yIHJ1bGVzfSB0byBub3JtYWxpemUgcGFzc2VkIHZhbHVlcy4KICAgICAqCiAgICAgKgkJLy8gRW5hYmxlICdtYXJnaW4nIHNob3J0aGFuZCBwcm9jZXNzaW5nOgogICAgICoJCWVkaXRvci5kYXRhLmFkZFN0eWxlUHJvY2Vzc29yUnVsZXMoIGFkZE1hcmdpblJ1bGVzICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5zZXRUbyggJ21hcmdpbjoxcHgnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tdG9wJyApOwogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tcmlnaHQnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy50b1N0cmluZygpOyAvLyAtPiAnbWFyZ2luLWJvdHRvbToxcHg7bWFyZ2luLWxlZnQ6MXB4OycKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBTdHlsZSBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlbW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHsKICAgICAgdmFyIHBhdGggPSB0b1BhdGgobmFtZSk7CiAgICAgIHVuc2V0KHRoaXMuX3N0eWxlcywgcGF0aCk7CiAgICAgIGRlbGV0ZSB0aGlzLl9zdHlsZXNbbmFtZV07CgogICAgICB0aGlzLl9jbGVhbkVtcHR5T2JqZWN0c09uUGF0aChwYXRoKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgc3R5bGUgb2JqZWN0IG9yIGEgc2luZ2xlIHZhbHVlLgogICAgICoKICAgICAqCQkvLyBFbmFibGUgJ21hcmdpbicgc2hvcnRoYW5kIHByb2Nlc3Npbmc6CiAgICAgKgkJZWRpdG9yLmRhdGEuYWRkU3R5bGVQcm9jZXNzb3JSdWxlcyggYWRkTWFyZ2luUnVsZXMgKTsKICAgICAqCiAgICAgKgkJY29uc3Qgc3R5bGVzID0gbmV3IFN0eWxlcygpOwogICAgICoJCXN0eWxlcy5zZXRUbyggJ21hcmdpbjoxcHggMnB4IDNlbTsnICk7CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXROb3JtYWxpemVkKCAnbWFyZ2luJyApOwogICAgICoJCS8vIHdpbGwgbG9nOgogICAgICoJCS8vIHsKICAgICAqCQkvLyAgICAgdG9wOiAnMXB4JywKICAgICAqCQkvLyAgICAgcmlnaHQ6ICcycHgnLAogICAgICoJCS8vICAgICBib3R0b206ICczZW0nLAogICAgICoJCS8vICAgICBsZWZ0OiAnMnB4JyAgICAgLy8gbm9ybWFsaXplZCB2YWx1ZSBmcm9tIG1hcmdpbiBzaG9ydGhhbmQKICAgICAqCQkvLyB9CiAgICAgKgogICAgICoJCXN0eWxlcy5nZXROb3JtYWxpemVkKCAnbWFyZ2luLWxlZnQnICk7IC8vIC0+ICcycHgnCiAgICAgKgogICAgICogKipOb3RlKio6IFRoaXMgbWV0aG9kIHdpbGwgb25seSByZXR1cm4gbm9ybWFsaXplZCBzdHlsZXMgaWYgYSBzdHlsZSBwcm9jZXNzb3Igd2FzIGRlZmluZWQuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3R5bGUgbmFtZS4KICAgICAqIEByZXR1cm5zIHtPYmplY3R8U3RyaW5nfHVuZGVmaW5lZH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXROb3JtYWxpemVkIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb3JtYWxpemVkKG5hbWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlUHJvY2Vzc29yLmdldE5vcm1hbGl6ZWQobmFtZSwgdGhpcy5fc3R5bGVzKTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgc3R5bGUgc3RyaW5nLiBTdHlsZXMgYXJlIHNvcnRlZCBieSBuYW1lLgogICAgICoKICAgICAqCQlzdHlsZXMuc2V0KCAnbWFyZ2luJyAsICcxcHgnICk7CiAgICAgKgkJc3R5bGVzLnNldCggJ2JhY2tncm91bmQnLCAnI2YwMCcgKTsKICAgICAqCiAgICAgKgkJc3R5bGVzLnRvU3RyaW5nKCk7IC8vIC0+ICdiYWNrZ3JvdW5kOiNmMDA7bWFyZ2luOjFweDsnCiAgICAgKgogICAgICogKipOb3RlKio6IFRoaXMgbWV0aG9kIHN1cHBvcnRzIG5vcm1hbGl6ZWQgc3R5bGVzIGlmIGRlZmluZWQuCiAgICAgKgogICAgICoJCS8vIEVuYWJsZSAnbWFyZ2luJyBzaG9ydGhhbmQgcHJvY2Vzc2luZzoKICAgICAqCQllZGl0b3IuZGF0YS5hZGRTdHlsZVByb2Nlc3NvclJ1bGVzKCBhZGRNYXJnaW5SdWxlcyApOwogICAgICoKICAgICAqCQlzdHlsZXMuc2V0KCAnbWFyZ2luJyAsICcxcHgnICk7CiAgICAgKgkJc3R5bGVzLnNldCggJ2JhY2tncm91bmQnLCAnI2YwMCcgKTsKICAgICAqCQlzdHlsZXMucmVtb3ZlKCAnbWFyZ2luLXRvcCcgKTsKICAgICAqCQlzdHlsZXMucmVtb3ZlKCAnbWFyZ2luLXJpZ2h0JyApOwogICAgICoKICAgICAqCQlzdHlsZXMudG9TdHJpbmcoKTsgLy8gLT4gJ2JhY2tncm91bmQ6I2YwMDttYXJnaW4tYm90dG9tOjFweDttYXJnaW4tbGVmdDoxcHg7JwogICAgICoKICAgICAqIEByZXR1cm5zIHtTdHJpbmd9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9TdHJpbmciLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgICBpZiAodGhpcy5pc0VtcHR5KSB7CiAgICAgICAgcmV0dXJuICcnOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5fZ2V0U3R5bGVzRW50cmllcygpLm1hcChmdW5jdGlvbiAoYXJyKSB7CiAgICAgICAgcmV0dXJuIGFyci5qb2luKCc6Jyk7CiAgICAgIH0pLnNvcnQoKS5qb2luKCc7JykgKyAnOyc7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgcHJvcGVydHkgYXMgYSB2YWx1ZSBzdHJpbmcgb3IgdW5kZWZpbmVkIGlmIHByb3BlcnR5IGlzIG5vdCBzZXQuCiAgICAgKgogICAgICoJCS8vIEVuYWJsZSAnbWFyZ2luJyBzaG9ydGhhbmQgcHJvY2Vzc2luZzoKICAgICAqCQllZGl0b3IuZGF0YS5hZGRTdHlsZVByb2Nlc3NvclJ1bGVzKCBhZGRNYXJnaW5SdWxlcyApOwogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSBuZXcgU3R5bGVzKCk7CiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luOjFweDsnICk7CiAgICAgKgkJc3R5bGVzLnNldCggJ21hcmdpbi1ib3R0b20nLCAnM2VtJyApOwogICAgICoKICAgICAqCQlzdHlsZXMuZ2V0QXNTdHJpbmcoICdtYXJnaW4nICk7IC8vIC0+ICdtYXJnaW46IDFweCAxcHggM2VtOycKICAgICAqCiAgICAgKiBOb3RlLCBob3dldmVyLCB0aGF0IGFsbCBzdWItdmFsdWVzIG11c3QgYmUgc2V0IGZvciB0aGUgbG9uZ2hhbmQgcHJvcGVydHkgbmFtZSB0byByZXR1cm4gYSB2YWx1ZToKICAgICAqCiAgICAgKgkJY29uc3Qgc3R5bGVzID0gbmV3IFN0eWxlcygpOwogICAgICoJCXN0eWxlcy5zZXRUbyggJ21hcmdpbjoxcHg7JyApOwogICAgICoJCXN0eWxlcy5yZW1vdmUoICdtYXJnaW4tYm90dG9tJyApOwogICAgICoKICAgICAqCQlzdHlsZXMuZ2V0QXNTdHJpbmcoICdtYXJnaW4nICk7IC8vIC0+IHVuZGVmaW5lZAogICAgICoKICAgICAqIEluIHRoZSBhYm92ZSBzY2VuYXJpbywgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHJldHVybiBhIGBtYXJnaW5gIHZhbHVlLCBzbyBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4KICAgICAqIEluc3RlYWQsIHlvdSBzaG91bGQgdXNlOgogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSBuZXcgU3R5bGVzKCk7CiAgICAgKgkJc3R5bGVzLnNldFRvKCAnbWFyZ2luOjFweDsnICk7CiAgICAgKgkJc3R5bGVzLnJlbW92ZSggJ21hcmdpbi1ib3R0b20nICk7CiAgICAgKgogICAgICoJCWZvciAoIGNvbnN0IHN0eWxlTmFtZSBvZiBzdHlsZXMuZ2V0U3R5bGVOYW1lcygpICkgewogICAgICoJCQljb25zb2xlLmxvZyggc3R5bGVOYW1lLCBzdHlsZXMuZ2V0QXNTdHJpbmcoIHN0eWxlTmFtZSApICk7CiAgICAgKgkJfQogICAgICoJCS8vICdtYXJnaW4tdG9wJywgJzFweCcKICAgICAqCQkvLyAnbWFyZ2luLXJpZ2h0JywgJzFweCcKICAgICAqCQkvLyAnbWFyZ2luLWxlZnQnLCAnMXB4JwogICAgICoKICAgICAqIEluIGdlbmVyYWwsIGl0IGlzIHJlY29tbWVuZCB0byBpdGVyYXRlIG92ZXIgc3R5bGUgbmFtZXMgbGlrZSBpbiB0aGUgZXhhbXBsZSBhYm92ZS4gVGhpcyB3YXksIHlvdSB3aWxsIGFsd2F5cyBnZXQgYWxsCiAgICAgKiB0aGUgY3VycmVudGx5IHNldCBzdHlsZSB2YWx1ZXMuIFNvLCBpZiBhbGwgdGhlIDQgbWFyZ2luIHZhbHVlcyB3b3VsZCBiZSBzZXQKICAgICAqIHRoZSBmb3Itb2YgbG9vcCBhYm92ZSB3b3VsZCB5aWVsZCBvbmx5IGAnbWFyZ2luJ2AsIGAnMXB4J2A6CiAgICAgKgogICAgICoJCWNvbnN0IHN0eWxlcyA9IG5ldyBTdHlsZXMoKTsKICAgICAqCQlzdHlsZXMuc2V0VG8oICdtYXJnaW46MXB4OycgKTsKICAgICAqCiAgICAgKgkJZm9yICggY29uc3Qgc3R5bGVOYW1lIG9mIHN0eWxlcy5nZXRTdHlsZU5hbWVzKCkgKSB7CiAgICAgKgkJCWNvbnNvbGUubG9nKCBzdHlsZU5hbWUsIHN0eWxlcy5nZXRBc1N0cmluZyggc3R5bGVOYW1lICkgKTsKICAgICAqCQl9CiAgICAgKgkJLy8gJ21hcmdpbicsICcxcHgnCiAgICAgKgogICAgICogKipOb3RlKio6IFRvIGdldCBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiBhIGxvbmdoYW5kIHByb3BlcnR5IHVzZSB0aGUge0BsaW5rICNnZXROb3JtYWxpemVkIGAjZ2V0Tm9ybWFsaXplZCgpYH0gbWV0aG9kLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUKICAgICAqIEByZXR1cm5zIHtTdHJpbmd8dW5kZWZpbmVkfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEFzU3RyaW5nIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBc1N0cmluZyhwcm9wZXJ0eU5hbWUpIHsKICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuX3N0eWxlc1twcm9wZXJ0eU5hbWVdICYmICFpc09iamVjdCh0aGlzLl9zdHlsZXNbcHJvcGVydHlOYW1lXSkpIHsKICAgICAgICAvLyBUcnkgcmV0dXJuIHN0eWxlcyBzZXQgZGlyZWN0bHkgLSB2YWx1ZXMgdGhhdCBhcmUgbm90IHBhcnNlZC4KICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVzW3Byb3BlcnR5TmFtZV07CiAgICAgIH0KCiAgICAgIHZhciBzdHlsZXMgPSB0aGlzLl9zdHlsZVByb2Nlc3Nvci5nZXRSZWR1Y2VkRm9ybShwcm9wZXJ0eU5hbWUsIHRoaXMuX3N0eWxlcyk7CgogICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gc3R5bGVzLmZpbmQoZnVuY3Rpb24gKF9yZWYzKSB7CiAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLAogICAgICAgICAgICBwcm9wZXJ0eSA9IF9yZWY0WzBdOwoKICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHByb3BlcnR5TmFtZTsKICAgICAgfSk7IC8vIE9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgaXQgaXMgc2V0OwoKICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXNjcmlwdG9yKSkgewogICAgICAgIHJldHVybiBwcm9wZXJ0eURlc2NyaXB0b3JbMV07CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBzdHlsZSBwcm9wZXJ0eSBuYW1lcyBhcyB0aGV5IHdvdWxkIGFwcGVhciB3aGVuIHVzaW5nIHtAbGluayAjdG9TdHJpbmcgYCN0b1N0cmluZygpYH0uCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxTdHJpbmc+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFN0eWxlTmFtZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlTmFtZXMoKSB7CiAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KCiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fZ2V0U3R5bGVzRW50cmllcygpOwoKICAgICAgcmV0dXJuIGVudHJpZXMubWFwKGZ1bmN0aW9uIChfcmVmNSkgewogICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAxKSwKICAgICAgICAgICAga2V5ID0gX3JlZjZbMF07CgogICAgICAgIHJldHVybiBrZXk7CiAgICAgIH0pOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBzdHlsZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY2xlYXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgICB0aGlzLl9zdHlsZXMgPSB7fTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBub3JtYWxpemVkIHN0eWxlcyBlbnRyaWVzIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5Qcm9wZXJ0eURlc2NyaXB0b3I+fQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9nZXRTdHlsZXNFbnRyaWVzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3R5bGVzRW50cmllcygpIHsKICAgICAgdmFyIHBhcnNlZCA9IFtdOwogICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3N0eWxlcyk7CgogICAgICBmb3IgKHZhciBfaTMgPSAwLCBfa2V5cyA9IGtleXM7IF9pMyA8IF9rZXlzLmxlbmd0aDsgX2kzKyspIHsKICAgICAgICB2YXIga2V5ID0gX2tleXNbX2kzXTsKICAgICAgICBwYXJzZWQucHVzaC5hcHBseShwYXJzZWQsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdHlsZVByb2Nlc3Nvci5nZXRSZWR1Y2VkRm9ybShrZXksIHRoaXMuX3N0eWxlcykpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHBhcnNlZDsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBlbXB0eSBvYmplY3RzIHVwb24gcmVtb3ZpbmcgYW4gZW50cnkgZnJvbSBpbnRlcm5hbCBvYmplY3QuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGgKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NsZWFuRW1wdHlPYmplY3RzT25QYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW5FbXB0eU9iamVjdHNPblBhdGgocGF0aCkgewogICAgICB2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdCgnLicpOwogICAgICB2YXIgaXNDaGlsZFBhdGggPSBwYXRoUGFydHMubGVuZ3RoID4gMTsKCiAgICAgIGlmICghaXNDaGlsZFBhdGgpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBwYXJlbnRQYXRoID0gcGF0aFBhcnRzLnNwbGljZSgwLCBwYXRoUGFydHMubGVuZ3RoIC0gMSkuam9pbignLicpOwogICAgICB2YXIgcGFyZW50T2JqZWN0ID0gZ2V0KHRoaXMuX3N0eWxlcywgcGFyZW50UGF0aCk7CgogICAgICBpZiAoIXBhcmVudE9iamVjdCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGlzUGFyZW50RW1wdHkgPSAhQXJyYXkuZnJvbShPYmplY3Qua2V5cyhwYXJlbnRPYmplY3QpKS5sZW5ndGg7CgogICAgICBpZiAoaXNQYXJlbnRFbXB0eSkgewogICAgICAgIHRoaXMucmVtb3ZlKHBhcmVudFBhdGgpOwogICAgICB9CiAgICB9CiAgfSwgewogICAga2V5OiAiaXNFbXB0eSIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9zdHlsZXMpOwogICAgICB2YXIgZnJvbSA9IEFycmF5LmZyb20oZW50cmllcyk7CiAgICAgIHJldHVybiAhZnJvbS5sZW5ndGg7CiAgICB9CiAgICAvKioKICAgICAqIE51bWJlciBvZiBzdHlsZXMgZGVmaW5lZC4KICAgICAqCiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogInNpemUiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHsKICAgICAgICByZXR1cm4gMDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVOYW1lcygpLmxlbmd0aDsKICAgIH0KICB9XSk7CgogIHJldHVybiBTdHlsZXNNYXA7Cn0oKTsKLyoqCiAqIFN0eWxlIHByb2Nlc3NvciBpcyByZXNwb25zaWJsZSBmb3Igd3JpdGluZyBhbmQgcmVhZGluZyBhIG5vcm1hbGl6ZWQgc3R5bGVzIG9iamVjdC4KICovCgoKZXhwb3J0IHsgU3R5bGVzTWFwIGFzIGRlZmF1bHQgfTsKZXhwb3J0IHZhciBTdHlsZXNQcm9jZXNzb3IgPQovKiNfX1BVUkVfXyovCmZ1bmN0aW9uICgpIHsKICAvKioKICAgKiBDcmVhdGVzIFN0eWxlc1Byb2Nlc3NvciBpbnN0YW5jZS4KICAgKgogICAqIEBwcml2YXRlCiAgICovCiAgZnVuY3Rpb24gU3R5bGVzUHJvY2Vzc29yKCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlc1Byb2Nlc3Nvcik7CgogICAgdGhpcy5fbm9ybWFsaXplcnMgPSBuZXcgTWFwKCk7CiAgICB0aGlzLl9leHRyYWN0b3JzID0gbmV3IE1hcCgpOwogICAgdGhpcy5fcmVkdWNlcnMgPSBuZXcgTWFwKCk7CiAgICB0aGlzLl9jb25zdW1hYmxlcyA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogUGFyc2Ugc3R5bGUgc3RyaW5nIHZhbHVlIHRvIGEgbm9ybWFsaXplZCBvYmplY3QgYW5kIGFwcGVuZHMgaXQgdG8gc3R5bGVzIG9iamVjdC4KICAgKgogICAqCQljb25zdCBzdHlsZXMgPSB7fTsKICAgKgogICAqCQlzdHlsZXNQcm9jZXNzb3IudG9Ob3JtYWxpemVkRm9ybSggJ21hcmdpbicsICcxcHgnLCBzdHlsZXMgKTsKICAgKgogICAqCQkvLyBzdHlsZXMgd2lsbCBjb25zaXN0OiB7IG1hcmdpbjogeyB0b3A6ICcxcHgnLCByaWdodDogJzFweCcsIGJvdHRvbTogJzFweCcsIGxlZnQ6ICcxcHg7IH0gfQogICAqCiAgICogKipOb3RlKio6IFRvIGRlZmluZSBub3JtYWxpemVyIGNhbGxiYWNrcyB1c2Uge0BsaW5rICNzZXROb3JtYWxpemVyfS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2Ygc3R5bGUgcHJvcGVydHkuCiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5VmFsdWUgVmFsdWUgb2Ygc3R5bGUgcHJvcGVydHkuCiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBPYmplY3QgaG9sZGluZyBub3JtYWxpemVkIHN0eWxlcy4KICAgKi8KCgogIF9jcmVhdGVDbGFzcyhTdHlsZXNQcm9jZXNzb3IsIFt7CiAgICBrZXk6ICJ0b05vcm1hbGl6ZWRGb3JtIiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b05vcm1hbGl6ZWRGb3JtKG5hbWUsIHByb3BlcnR5VmFsdWUsIHN0eWxlcykgewogICAgICBpZiAoaXNPYmplY3QocHJvcGVydHlWYWx1ZSkpIHsKICAgICAgICBhcHBlbmRTdHlsZVZhbHVlKHN0eWxlcywgdG9QYXRoKG5hbWUpLCBwcm9wZXJ0eVZhbHVlKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLl9ub3JtYWxpemVycy5oYXMobmFtZSkpIHsKICAgICAgICB2YXIgbm9ybWFsaXplciA9IHRoaXMuX25vcm1hbGl6ZXJzLmdldChuYW1lKTsKCiAgICAgICAgdmFyIF9ub3JtYWxpemVyID0gbm9ybWFsaXplcihwcm9wZXJ0eVZhbHVlKSwKICAgICAgICAgICAgcGF0aCA9IF9ub3JtYWxpemVyLnBhdGgsCiAgICAgICAgICAgIHZhbHVlID0gX25vcm1hbGl6ZXIudmFsdWU7CgogICAgICAgIGFwcGVuZFN0eWxlVmFsdWUoc3R5bGVzLCBwYXRoLCB2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYXBwZW5kU3R5bGVWYWx1ZShzdHlsZXMsIG5hbWUsIHByb3BlcnR5VmFsdWUpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgYSBzdHlsZSBwcm9wZXJ0eS4KICAgICAqCQljb25zdCBzdHlsZXMgPSB7CiAgICAgKgkJCW1hcmdpbjogeyB0b3A6ICcxcHgnLCByaWdodDogJzFweCcsIGJvdHRvbTogJzFweCcsIGxlZnQ6ICcxcHg7IH0sCiAgICAgKgkJCWJhY2tncm91bmQ6IHsgY29sb3I6ICcjZjAwJyB9CiAgICAgKgkJfTsKICAgICAqCiAgICAgKgkJc3R5bGVzUHJvY2Vzc29yLmdldE5vcm1hbGl6ZWQoICdiYWNrZ3JvdW5kJyApOwogICAgICoJCS8vIHdpbGwgcmV0dXJuOiB7IGNvbG9yOiAnI2YwMCcgfQogICAgICoKICAgICAqCQlzdHlsZXNQcm9jZXNzb3IuZ2V0Tm9ybWFsaXplZCggJ21hcmdpbi10b3AnICk7CiAgICAgKgkJLy8gd2lsbCByZXR1cm46ICcxcHgnCiAgICAgKgogICAgICogKipOb3RlKio6IEluIHNvbWUgY2FzZXMgZXh0cmFjdGluZyBzaW5nbGUgdmFsdWUgcmVxdWlyZXMgZGVmaW5pbmcgYW4gZXh0cmFjdG9yIGNhbGxiYWNrIHtAbGluayAjc2V0RXh0cmFjdG9yfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHN0eWxlIHByb3BlcnR5LgogICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBPYmplY3QgaG9sZGluZyBub3JtYWxpemVkIHN0eWxlcy4KICAgICAqIEByZXR1cm5zIHsqfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE5vcm1hbGl6ZWQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWQobmFtZSwgc3R5bGVzKSB7CiAgICAgIGlmICghbmFtZSkgewogICAgICAgIHJldHVybiBtZXJnZSh7fSwgc3R5bGVzKTsKICAgICAgfSAvLyBNaWdodCBiZSBlbXB0eSBzdHJpbmcuCgoKICAgICAgaWYgKHN0eWxlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIHN0eWxlc1tuYW1lXTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuX2V4dHJhY3RvcnMuaGFzKG5hbWUpKSB7CiAgICAgICAgdmFyIGV4dHJhY3RvciA9IHRoaXMuX2V4dHJhY3RvcnMuZ2V0KG5hbWUpOwoKICAgICAgICBpZiAodHlwZW9mIGV4dHJhY3RvciA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIHJldHVybiBnZXQoc3R5bGVzLCBleHRyYWN0b3IpOwogICAgICAgIH0KCiAgICAgICAgdmFyIHZhbHVlID0gZXh0cmFjdG9yKG5hbWUsIHN0eWxlcyk7CgogICAgICAgIGlmICh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIGdldChzdHlsZXMsIHRvUGF0aChuYW1lKSk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgYSByZWR1Y2VkIGZvcm0gb2Ygc3R5bGUgcHJvcGVydHkgZm9ybSBub3JtYWxpemVkIG9iamVjdC4KICAgICAqCiAgICAgKiBGb3IgZGVmYXVsdCBtYXJnaW4gcmVkdWNlciwgdGhlIGJlbG93IGNvZGU6CiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5nZXRSZWR1Y2VkRm9ybSggJ21hcmdpbicsIHsKICAgICAqCQkJbWFyZ2luOiB7IHRvcDogJzFweCcsIHJpZ2h0OiAnMXB4JywgYm90dG9tOiAnMnB4JywgbGVmdDogJzFweDsgfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiB3aWxsIHJldHVybjoKICAgICAqCiAgICAgKgkJWwogICAgICoJCQlbICdtYXJnaW4nLCAnMXB4IDFweCAycHgnIF0KICAgICAqCQldCiAgICAgKgogICAgICogYmVjYXVzZSBpdCBtaWdodCBiZSByZXByZXNlbnRlZCBhcyBhIHNob3J0aGFuZCAnbWFyZ2luJyB2YWx1ZS4gSG93ZXZlciBpZiBvbmUgb2YgbWFyZ2luIGxvbmcgaGFuZCB2YWx1ZXMgaXMgbWlzc2luZyBpdCBzaG91bGQgcmV0dXJuOgogICAgICoKICAgICAqCQlbCiAgICAgKgkJCVsgJ21hcmdpbi10b3AnLCAnMXB4JyBdLAogICAgICoJCQlbICdtYXJnaW4tcmlnaHQnLCAnMXB4JyBdLAogICAgICoJCQlbICdtYXJnaW4tYm90dG9tJywgJzJweCcgXQogICAgICoJCQkvLyB0aGUgJ2xlZnQnIHZhbHVlIGlzIG1pc3NpbmcgLSBjYW5ub3QgdXNlICdtYXJnaW4nIHNob3J0aGFuZC4KICAgICAqCQldCiAgICAgKgogICAgICogKipOb3RlKio6IFRvIGRlZmluZSByZWR1Y2VyIGNhbGxiYWNrcyB1c2Uge0BsaW5rICNzZXRSZWR1Y2VyfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiBzdHlsZSBwcm9wZXJ0eS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXMgT2JqZWN0IGhvbGRpbmcgbm9ybWFsaXplZCBzdHlsZXMuCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+UHJvcGVydHlEZXNjcmlwdG9yPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRSZWR1Y2VkRm9ybSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVkdWNlZEZvcm0obmFtZSwgc3R5bGVzKSB7CiAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSB0aGlzLmdldE5vcm1hbGl6ZWQobmFtZSwgc3R5bGVzKTsgLy8gTWlnaHQgYmUgZW1wdHkgc3RyaW5nLgoKICAgICAgaWYgKG5vcm1hbGl6ZWRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICBpZiAodGhpcy5fcmVkdWNlcnMuaGFzKG5hbWUpKSB7CiAgICAgICAgdmFyIHJlZHVjZXIgPSB0aGlzLl9yZWR1Y2Vycy5nZXQobmFtZSk7CgogICAgICAgIHJldHVybiByZWR1Y2VyKG5vcm1hbGl6ZWRWYWx1ZSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBbW25hbWUsIG5vcm1hbGl6ZWRWYWx1ZV1dOwogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHJlbGF0ZWQgc3R5bGUgbmFtZXMuCiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5nZXRSZWxhdGVkU3R5bGVzKCAnbWFyZ2luJyApOwogICAgICoJCS8vIHdpbGwgcmV0dXJuOiBbICdtYXJnaW4tdG9wJywgJ21hcmdpbi1yaWdodCcsICdtYXJnaW4tYm90dG9tJywgJ21hcmdpbi1sZWZ0JyBdOwogICAgICoKICAgICAqCQlzdHlsZXNQcm9jZXNzb3IuZ2V0UmVsYXRlZFN0eWxlcyggJ21hcmdpbi10b3AnICk7CiAgICAgKgkJLy8gd2lsbCByZXR1cm46IFsgJ21hcmdpbicgXTsKICAgICAqCiAgICAgKiAqKk5vdGUqKjogVG8gZGVmaW5lIG5ldyBzdHlsZSByZWxhdGlvbnMgbG9hZCBhbiBleGlzdGluZyBzdHlsZSBwcm9jZXNzb3Igb3IgdXNlCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5TdHlsZXNQcm9jZXNzb3Ijc2V0U3R5bGVSZWxhdGlvbiBgU3R5bGVzUHJvY2Vzc29yLnNldFN0eWxlUmVsYXRpb24oKWB9LgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0UmVsYXRlZFN0eWxlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVsYXRlZFN0eWxlcyhuYW1lKSB7CiAgICAgIHJldHVybiB0aGlzLl9jb25zdW1hYmxlcy5nZXQobmFtZSkgfHwgW107CiAgICB9CiAgICAvKioKICAgICAqIEFkZHMgYSBub3JtYWxpemVyIG1ldGhvZCBmb3IgYSBzdHlsZSBwcm9wZXJ0eS4KICAgICAqCiAgICAgKiBBIG5vcm1hbGl6ZXIgcmV0dXJucyBkZXNjcmliaW5nIGhvdyB0aGUgdmFsdWUgc2hvdWxkIGJlIG5vcm1hbGl6ZWQuCiAgICAgKgogICAgICogRm9yIGluc3RhbmNlICdtYXJnaW4nIHN0eWxlIGlzIGEgc2hvcnRoYW5kIGZvciBmb3VyIG1hcmdpbiB2YWx1ZXM6CiAgICAgKgogICAgICogLSAnbWFyZ2luLXRvcCcKICAgICAqIC0gJ21hcmdpbi1yaWdodCcKICAgICAqIC0gJ21hcmdpbi1ib3R0b20nCiAgICAgKiAtICdtYXJnaW4tbGVmdCcKICAgICAqCiAgICAgKiBhbmQgY2FuIGJlIHdyaXR0ZW4gaW4gdmFyaW91cyB3YXlzIGlmIHNvbWUgdmFsdWVzIGFyZSBlcXVhbCB0byBvdGhlcnMuIEZvciBpbnN0YW5jZSBgJ21hcmdpbjogMXB4IDJlbTsnYCBpcyBhIHNob3J0aGFuZCBmb3IKICAgICAqIGAnbWFyZ2luLXRvcDogMXB4O21hcmdpbi1yaWdodDogMmVtO21hcmdpbi1ib3R0b206IDFweDttYXJnaW4tbGVmdDogMmVtJ2AuCiAgICAgKgogICAgICogQSBub3JtYWxpemVyIHNob3VsZCBwYXJzZSB2YXJpb3VzIG1hcmdpbiBub3RhdGlvbnMgYXMgYSBzaW5nbGUgb2JqZWN0OgogICAgICoKICAgICAqCQljb25zdCBzdHlsZXMgPSB7CiAgICAgKgkJCW1hcmdpbjogewogICAgICoJCQkJdG9wOiAnMXB4JywKICAgICAqCQkJCXJpZ2h0OiAnMmVtJywKICAgICAqCQkJCWJvdHRvbTogJzFweCcsCiAgICAgKgkJCQlsZWZ0OiAnMmVtJwogICAgICoJCQl9CiAgICAgKgkJfTsKICAgICAqCiAgICAgKiBUaHVzIGEgbm9ybWFsaXplciBmb3IgJ21hcmdpbicgc3R5bGUgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgZGVmaW5pbmcgc3R5bGUgcGF0aCBhbmQgdmFsdWUgdG8gc3RvcmU6CiAgICAgKgogICAgICoJCWNvbnN0IHJldHVyblZhbHVlID0gewogICAgICoJCQlwYXRoOiAnbWFyZ2luJywKICAgICAqCQkJdmFsdWU6IHsKICAgICAqCQkJCXRvcDogJzFweCcsCiAgICAgKgkJCQlyaWdodDogJzJlbScsCiAgICAgKgkJCQlib3R0b206ICcxcHgnLAogICAgICoJCQkJbGVmdDogJzJlbScKICAgICAqCQkJfQogICAgICoJCX07CiAgICAgKgogICAgICogQWRkaXRpb25hbGx5IHRvIGZ1bGx5IHN1cHBvcnQgYWxsIG1hcmdpbiBub3RhdGlvbnMgdGhlcmUgc2hvdWxkIGJlIGFsc28gZGVmaW5lZCA0IG5vcm1hbGl6ZXJzIGZvciBsb25naGFuZCBtYXJnaW4gbm90YXRpb25zLiBCZWxvdwogICAgICogaXMgYW4gZXhhbXBsZSBmb3IgJ21hcmdpbi10b3AnIHN0eWxlIHByb3BlcnR5IG5vcm1hbGl6ZXI6CiAgICAgKgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5zZXROb3JtYWxpemVyKCAnbWFyZ2luLXRvcCcsIHZhbHVlU3RyaW5nID0+IHsKICAgICAqCQkJcmV0dXJuIHsKICAgICAqCQkJCXBhdGg6ICdtYXJnaW4udG9wJywKICAgICAqCQkJCXZhbHVlOiB2YWx1ZVN0cmluZwogICAgICoJCQl9CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawogICAgICovCgogIH0sIHsKICAgIGtleTogInNldE5vcm1hbGl6ZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldE5vcm1hbGl6ZXIobmFtZSwgY2FsbGJhY2spIHsKICAgICAgdGhpcy5fbm9ybWFsaXplcnMuc2V0KG5hbWUsIGNhbGxiYWNrKTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBhIGV4dHJhY3RvciBjYWxsYmFjayBmb3IgYSBzdHlsZSBwcm9wZXJ0eS4KICAgICAqCiAgICAgKiBNb3N0IG5vcm1hbGl6ZWQgc3R5bGUgdmFsdWVzIGFyZSBzdG9yZWQgYXMgb25lIGxldmVsIG9iamVjdHMuIEl0IGlzIGFzc3VtZWQgdGhhdCBgJ21hcmdpbi10b3AnYCBzdHlsZSB3aWxsIGJlIHN0b3JlZCBhczoKICAgICAqCiAgICAgKgkJY29uc3Qgc3R5bGVzID0gewogICAgICoJCQltYXJnaW46IHsKICAgICAqCQkJCXRvcDogJ3ZhbHVlJwogICAgICoJCQl9CiAgICAgKgkJfQogICAgICoKICAgICAqIEhvd2V2ZXIsIHNvbWUgc3R5bGVzIGNhbiBoYXZlIGNvbmZsaWN0aW5nIG5vdGF0aW9ucyBhbmQgdGh1cyBpdCBtaWdodCBiZSBoYXJkZXIgdG8gZXh0cmFjdCBhIHN0eWxlIHZhbHVlIGZyb20gc2hvcnRoYW5kLiBGb3IgaW5zdGFuY2UKICAgICAqIHRoZSAnYm9yZGVyLXRvcC1zdHlsZScgY2FuIGJlIGRlZmluZWQgdXNpbmcgYCdib3JkZXItdG9wOnNvbGlkJ2AsIGAnYm9yZGVyLXN0eWxlOnNvbGlkIG5vbmUgbm9uZSBub25lJ2Agb3IgYnkgYCdib3JkZXI6c29saWQnYAogICAgICogc2hvcnRoYW5kcy4gVGhlIGRlZmF1bHQgYm9yZGVyIHN0eWxlcyBwcm9jZXNzb3JzIHN0b3JlcyBzdHlsZXMgYXM6CiAgICAgKgogICAgICoJCWNvbnN0IHN0eWxlcyA9IHsKICAgICAqCQkJYm9yZGVyOiB7CiAgICAgKgkJCQlzdHlsZTogewogICAgICoJCQkJCXRvcDogJ3NvbGlkJwogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgkJfQogICAgICoKICAgICAqIGFzIGl0IGlzIGJldHRlciB0byBtb2RpZnkgYm9yZGVyIHN0eWxlIGluZGVwZW5kZW50bHkgZnJvbSBvdGhlciB2YWx1ZXMuIE9uIHRoZSBvdGhlciBwYXJ0IHRoZSBvdXRwdXQgb2YgdGhlIGJvcmRlciBtaWdodCBiZQogICAgICogZGVzaXJlZCBhcyBgYm9yZGVyLXRvcGAsIGBib3JkZXItbGVmdGAsIGV0YyBub3RhdGlvbi4KICAgICAqCiAgICAgKiBJbiB0aGUgYWJvdmUgZXhhbXBsZSBhIHJlZHVjZXIgc2hvdWxkIHJldHVybiBhIHNpZGUgYm9yZGVyIHZhbHVlIHRoYXQgY29tYmluZXMgc3R5bGUsIGNvbG9yIGFuZCB3aWR0aDoKICAgICAqCiAgICAgKgkJc3R5bGVQcm9jZXNzb3Iuc2V0RXh0cmFjdG9yKCAnYm9yZGVyLXRvcCcsIHN0eWxlcyA9PiB7CiAgICAgKgkJCXJldHVybiB7CiAgICAgKgkJCQljb2xvcjogc3R5bGVzLmJvcmRlci5jb2xvci50b3AsCiAgICAgKgkJCQlzdHlsZTogc3R5bGVzLmJvcmRlci5zdHlsZS50b3AsCiAgICAgKgkJCQl3aWR0aDogc3R5bGVzLmJvcmRlci53aWR0aC50b3AKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrT3JQYXRoIENhbGxiYWNrIHRoYXQgcmV0dXJuIGEgcmVxdWVzdGVkIHZhbHVlIG9yIHBhdGggc3RyaW5nIGZvciBzaW5nbGUgdmFsdWVzLgogICAgICovCgogIH0sIHsKICAgIGtleTogInNldEV4dHJhY3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RXh0cmFjdG9yKG5hbWUsIGNhbGxiYWNrT3JQYXRoKSB7CiAgICAgIHRoaXMuX2V4dHJhY3RvcnMuc2V0KG5hbWUsIGNhbGxiYWNrT3JQYXRoKTsKICAgIH0KICAgIC8qKgogICAgICogQWRkcyBhIHJlZHVjZXIgY2FsbGJhY2sgZm9yIGEgc3R5bGUgcHJvcGVydHkuCiAgICAgKgogICAgICogUmVkdWNlciByZXR1cm5zIGEgbWluaW1hbCBub3RhdGlvbiBmb3IgZ2l2ZW4gc3R5bGUgbmFtZS4gRm9yIGxvbmdoYW5kIHByb3BlcnRpZXMgaXQgaXMgbm90IHJlcXVpcmVkIHRvIHdyaXRlIGEgcmVkdWNlciBhcwogICAgICogYnkgZGVmYXVsdCB0aGUgZGlyZWN0IHZhbHVlIGZyb20gc3R5bGUgcGF0aCBpcyB0YWtlbi4KICAgICAqCiAgICAgKiBGb3Igc2hvcnRoYW5kIHN0eWxlcyBhIHJlZHVjZXIgc2hvdWxkIHJldHVybiBtaW5pbWFsIHN0eWxlIG5vdGF0aW9uIGVpdGhlciBieSByZXR1cm5pbmcgc2luZ2xlIG5hbWUtdmFsdWUgdHVwbGUgb3IgbXVsdGlwbGUgdHVwbGVzCiAgICAgKiBpZiBhIHNob3J0aGFuZCBjYW5ub3QgYmUgdXNlZC4gRm9yIGluc3RhbmNlIGZvciBhIG1hcmdpbiBzaG9ydGhhbmQgYSByZWR1Y2VyIG1pZ2h0IHJldHVybjoKICAgICAqCiAgICAgKgkJY29uc3QgbWFyZ2luU2hvcnRIYW5kVHVwbGUgPSBbCiAgICAgKgkJCVsgJ21hcmdpbicsICcxcHggMXB4IDJweCcgXQogICAgICoJCV07CiAgICAgKgogICAgICogb3IgYSBsb25naGFuZCB0dXBsZXMgZm9yIGRlZmluZWQgdmFsdWVzOgogICAgICoKICAgICAqCQkvLyBDb25zaWRlcmluZyBtYXJnaW4uYm90dG9tIGFuZCBtYXJnaW4ubGVmdCBhcmUgdW5kZWZpbmVkLgogICAgICoJCWNvbnN0IG1hcmdpbkxvbmdoYW5kc1R1cGxlcyA9IFsKICAgICAqCQkJWyAnbWFyZ2luLXRvcCcsICcxcHgnIF0sCiAgICAgKgkJCVsgJ21hcmdpbi1yaWdodCcsICcxcHgnIF0KICAgICAqCQldOwogICAgICoKICAgICAqIEEgcmVkdWNlciBvYnRhaW5zIGEgbm9ybWFsaXplZCBzdHlsZSB2YWx1ZToKICAgICAqCiAgICAgKgkJLy8gU2ltcGxpZmllZCByZWR1Y2VyIHRoYXQgYWx3YXlzIG91dHB1dHMgNCB2YWx1ZXMgd2hpY2ggYXJlIGFsd2F5cyBwcmVzZW50OgogICAgICoJCXN0eWxlc1Byb2Nlc3Nvci5zZXRSZWR1Y2VyKCAnbWFyZ2luJywgbWFyZ2luID0+IHsKICAgICAqCQkJcmV0dXJuIFsKICAgICAqCQkJCVsgJ21hcmdpbicsIGAkeyBtYXJnaW4udG9wIH0gJHsgbWFyZ2luLnJpZ2h0IH0gJHsgbWFyZ2luLmJvdHRvbSB9ICR7IG1hcmdpbi5sZWZ0IH1gIF0KICAgICAqCQkJXQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRSZWR1Y2VyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZWR1Y2VyKG5hbWUsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMuX3JlZHVjZXJzLnNldChuYW1lLCBjYWxsYmFjayk7CiAgICB9CiAgICAvKioKICAgICAqIERlZmluZXMgYSBzdHlsZSBzaG9ydGhhbmQgcmVsYXRpb24gdG8gb3RoZXIgc3R5bGUgbm90YXRpb25zLgogICAgICoKICAgICAqCQlzdHlsZXNQcm9jZXNzb3Iuc2V0U3R5bGVSZWxhdGlvbiggJ21hcmdpbicsIFsKICAgICAqCQkJJ21hcmdpbi10b3AnLAogICAgICoJCQknbWFyZ2luLXJpZ2h0JywKICAgICAqCQkJJ21hcmdpbi1ib3R0b20nLAogICAgICoJCQknbWFyZ2luLWxlZnQnCiAgICAgKgkJXSApOwogICAgICoKICAgICAqIFRoaXMgZW5hYmxlcyBleHBhbmRpbmcgb2Ygc3R5bGUgbmFtZXMgZm9yIHNob3J0aGFuZHMuIEZvciBpbnN0YW5jZSwgaWYgZGVmaW5lZCwKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdmlld2NvbnN1bWFibGV+Vmlld0NvbnN1bWFibGUgdmlldyBjb25zdW1hYmxlfSBpdGVtcyBhcmUgYXV0b21hdGljYWxseSBjcmVhdGVkCiAgICAgKiBmb3IgbG9uZy1oYW5kIG1hcmdpbiBzdHlsZSBub3RhdGlvbiBhbG9uZ3NpZGUgdGhlIGAnbWFyZ2luJ2AgaXRlbS4KICAgICAqCiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgd2hlbiBhbiBlbGVtZW50IGJlaW5nIGNvbnZlcnRlZCBoYXMgYSBzdHlsZSBgbWFyZ2luYCwgYSBjb252ZXJ0ZXIgZm9yIGBtYXJnaW4tbGVmdGAgd2lsbCB3b3JrIGp1c3QKICAgICAqIGZpbmUgc2luY2UgdGhlIHZpZXcgY29uc3VtYWJsZSB3aWxsIGNvbnRhaW4gYSBjb25zdW1hYmxlIGBtYXJnaW4tbGVmdGAgaXRlbSAodGhhbmtzIHRvIHRoZSByZWxhdGlvbikgYW5kCiAgICAgKiBgZWxlbWVudC5nZXRTdHlsZSggJ21hcmdpbi1sZWZ0JyApYCB3aWxsIHdvcmsgYXMgd2VsbCBhc3N1bWluZyB0aGF0IHRoZSBzdHlsZSBwcm9jZXNzb3Igd2FzIGNvcnJlY3RseSBjb25maWd1cmVkLgogICAgICogSG93ZXZlciwgb25jZSBgbWFyZ2luLWxlZnRgIGlzIGNvbnN1bWVkLCBgbWFyZ2luYCB3aWxsIG5vdCBiZSBjb25zdW1hYmxlIGFueW1vcmUuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IHNob3J0aGFuZE5hbWUKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHN0eWxlTmFtZXMKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZXRTdHlsZVJlbGF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHlsZVJlbGF0aW9uKHNob3J0aGFuZE5hbWUsIHN0eWxlTmFtZXMpIHsKICAgICAgdGhpcy5fbWFwU3R5bGVOYW1lcyhzaG9ydGhhbmROYW1lLCBzdHlsZU5hbWVzKTsKCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gc3R5bGVOYW1lc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBhbHNvTmFtZSA9IF9zdGVwLnZhbHVlOwoKICAgICAgICAgIHRoaXMuX21hcFN0eWxlTmFtZXMoYWxzb05hbWUsIFtzaG9ydGhhbmROYW1lXSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFNldCB0d28td2F5IGJpbmRpbmcgb2Ygc3R5bGUgbmFtZXMuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUKICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IHN0eWxlTmFtZXMKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX21hcFN0eWxlTmFtZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXBTdHlsZU5hbWVzKG5hbWUsIHN0eWxlTmFtZXMpIHsKICAgICAgdmFyIF90aGlzJF9jb25zdW1hYmxlcyRnZTsKCiAgICAgIGlmICghdGhpcy5fY29uc3VtYWJsZXMuaGFzKG5hbWUpKSB7CiAgICAgICAgdGhpcy5fY29uc3VtYWJsZXMuc2V0KG5hbWUsIFtdKTsKICAgICAgfQoKICAgICAgKF90aGlzJF9jb25zdW1hYmxlcyRnZSA9IHRoaXMuX2NvbnN1bWFibGVzLmdldChuYW1lKSkucHVzaC5hcHBseShfdGhpcyRfY29uc3VtYWJsZXMkZ2UsIF90b0NvbnN1bWFibGVBcnJheShzdHlsZU5hbWVzKSk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gU3R5bGVzUHJvY2Vzc29yOwp9KCk7IC8vIFBhcnNlcyBpbmxpbmUgc3R5bGVzIGFuZCBwdXRzIHByb3BlcnR5IC0gdmFsdWUgcGFpcnMgaW50byBzdHlsZXMgbWFwLgovLwovLyBAcGFyYW0ge1N0cmluZ30gc3R5bGVzU3RyaW5nIFN0eWxlcyB0byBwYXJzZS4KLy8gQHJldHVybnMge01hcC48U3RyaW5nLCBTdHJpbmc+fSBzdHlsZXNNYXAgTWFwIG9mIHBhcnNlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuCgpmdW5jdGlvbiBwYXJzZUlubGluZVN0eWxlcyhzdHlsZXNTdHJpbmcpIHsKICAvLyBgbnVsbGAgaWYgbm8gcXVvdGUgd2FzIGZvdW5kIGluIGlucHV0IHN0cmluZyBvciBsYXN0IGZvdW5kIHF1b3RlIHdhcyBhIGNsb3NpbmcgcXVvdGUuIFNlZSBiZWxvdy4KICB2YXIgcXVvdGVUeXBlID0gbnVsbDsKICB2YXIgcHJvcGVydHlOYW1lU3RhcnQgPSAwOwogIHZhciBwcm9wZXJ0eVZhbHVlU3RhcnQgPSAwOwogIHZhciBwcm9wZXJ0eU5hbWUgPSBudWxsOwogIHZhciBzdHlsZXNNYXAgPSBuZXcgTWFwKCk7IC8vIERvIG5vdCBzZXQgYW55dGhpbmcgaWYgaW5wdXQgc3RyaW5nIGlzIGVtcHR5LgoKICBpZiAoc3R5bGVzU3RyaW5nID09PSAnJykgewogICAgcmV0dXJuIHN0eWxlc01hcDsKICB9IC8vIEZpeCBpbmxpbmUgc3R5bGVzIHRoYXQgZG8gbm90IGVuZCB3aXRoIGA7YCBzbyB0aGV5IGFyZSBjb21wYXRpYmxlIHdpdGggYWxnb3JpdGhtIGJlbG93LgoKCiAgaWYgKHN0eWxlc1N0cmluZy5jaGFyQXQoc3R5bGVzU3RyaW5nLmxlbmd0aCAtIDEpICE9ICc7JykgewogICAgc3R5bGVzU3RyaW5nID0gc3R5bGVzU3RyaW5nICsgJzsnOwogIH0gLy8gU2VlayB0aGUgd2hvbGUgc3RyaW5nIGZvciAic3BlY2lhbCBjaGFyYWN0ZXJzIi4KCgogIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzU3RyaW5nLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgY2hhciA9IHN0eWxlc1N0cmluZy5jaGFyQXQoaSk7CgogICAgaWYgKHF1b3RlVHlwZSA9PT0gbnVsbCkgewogICAgICAvLyBObyBxdW90ZSBmb3VuZCB5ZXQgb3IgbGFzdCBmb3VuZCBxdW90ZSB3YXMgYSBjbG9zaW5nIHF1b3RlLgogICAgICBzd2l0Y2ggKGNoYXIpIHsKICAgICAgICBjYXNlICc6JzoKICAgICAgICAgIC8vIE1vc3Qgb2YgdGltZSBjb2xvbiBtZWFucyB0aGF0IHByb3BlcnR5IG5hbWUganVzdCBlbmRlZC4KICAgICAgICAgIC8vIFNvbWV0aW1lcyBob3dldmVyIGA6YCBpcyBmb3VuZCBpbnNpZGUgcHJvcGVydHkgdmFsdWUgKGZvciBleGFtcGxlIGluIGJhY2tncm91bmQgaW1hZ2UgdXJsKS4KICAgICAgICAgIGlmICghcHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgIC8vIFRyZWF0IHRoaXMgYXMgZW5kIG9mIHByb3BlcnR5IG9ubHkgaWYgcHJvcGVydHkgbmFtZSBpcyBub3QgYWxyZWFkeSBzYXZlZC4KICAgICAgICAgICAgLy8gU2F2ZSBwcm9wZXJ0eSBuYW1lLgogICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBzdHlsZXNTdHJpbmcuc3Vic3RyKHByb3BlcnR5TmFtZVN0YXJ0LCBpIC0gcHJvcGVydHlOYW1lU3RhcnQpOyAvLyBTYXZlIHRoaXMgcG9pbnQgYXMgdGhlIHN0YXJ0IG9mIHByb3BlcnR5IHZhbHVlLgoKICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVN0YXJ0ID0gaSArIDE7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CgogICAgICAgIGNhc2UgJyInOgogICAgICAgIGNhc2UgJ1wnJzoKICAgICAgICAgIC8vIE9wZW5pbmcgcXVvdGUgZm91bmQgKHRoaXMgaXMgYW4gb3BlbmluZyBxdW90ZSwgYmVjYXVzZSBgcXVvdGVUeXBlYCBpcyBgbnVsbGApLgogICAgICAgICAgcXVvdGVUeXBlID0gY2hhcjsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICBjYXNlICc7JzoKICAgICAgICAgIHsKICAgICAgICAgICAgLy8gUHJvcGVydHkgdmFsdWUganVzdCBlbmRlZC4KICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHkgc3RvcmVkIHByb3BlcnR5IHZhbHVlIHN0YXJ0IHRvIG9idGFpbiBwcm9wZXJ0eSB2YWx1ZS4KICAgICAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBzdHlsZXNTdHJpbmcuc3Vic3RyKHByb3BlcnR5VmFsdWVTdGFydCwgaSAtIHByb3BlcnR5VmFsdWVTdGFydCk7CgogICAgICAgICAgICBpZiAocHJvcGVydHlOYW1lKSB7CiAgICAgICAgICAgICAgLy8gU2F2ZSBwYXJzZWQgcGFydC4KICAgICAgICAgICAgICBzdHlsZXNNYXAuc2V0KHByb3BlcnR5TmFtZS50cmltKCksIHByb3BlcnR5VmFsdWUudHJpbSgpKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gbnVsbDsgLy8gU2F2ZSB0aGlzIHBvaW50IGFzIHByb3BlcnR5IG5hbWUgc3RhcnQuIFByb3BlcnR5IG5hbWUgc3RhcnRzIGltbWVkaWF0ZWx5IGFmdGVyIHByZXZpb3VzIHByb3BlcnR5IHZhbHVlIGVuZHMuCgogICAgICAgICAgICBwcm9wZXJ0eU5hbWVTdGFydCA9IGkgKyAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChjaGFyID09PSBxdW90ZVR5cGUpIHsKICAgICAgLy8gSWYgYSBxdW90ZSBjaGFyIGlzIGZvdW5kIGFuZCBpdCBpcyBhIGNsb3NpbmcgcXVvdGUsIG1hcmsgdGhpcyBmYWN0IGJ5IGBudWxsYC1pbmcgYHF1b3RlVHlwZWAuCiAgICAgIHF1b3RlVHlwZSA9IG51bGw7CiAgICB9CiAgfQoKICByZXR1cm4gc3R5bGVzTWFwOwp9IC8vIFJldHVybiBsb2Rhc2ggY29tcGF0aWJsZSBwYXRoIGZyb20gc3R5bGUgbmFtZS4KCgpmdW5jdGlvbiB0b1BhdGgobmFtZSkgewogIHJldHVybiBuYW1lLnJlcGxhY2UoJy0nLCAnLicpOwp9IC8vIEFwcGVuZHMgc3R5bGUgZGVmaW5pdGlvbiB0byB0aGUgc3R5bGVzIG9iamVjdC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IG5hbWVPclBhdGgKLy8gQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZU9yT2JqZWN0Ci8vIEBwcml2YXRlCgoKZnVuY3Rpb24gYXBwZW5kU3R5bGVWYWx1ZShzdHlsZXNPYmplY3QsIG5hbWVPclBhdGgsIHZhbHVlT3JPYmplY3QpIHsKICB2YXIgdmFsdWVUb1NldCA9IHZhbHVlT3JPYmplY3Q7CgogIGlmIChpc09iamVjdCh2YWx1ZU9yT2JqZWN0KSkgewogICAgdmFsdWVUb1NldCA9IG1lcmdlKHt9LCBnZXQoc3R5bGVzT2JqZWN0LCBuYW1lT3JQYXRoKSwgdmFsdWVPck9iamVjdCk7CiAgfQoKICBzZXQoc3R5bGVzT2JqZWN0LCBuYW1lT3JQYXRoLCB2YWx1ZVRvU2V0KTsKfQovKioKICogQSBDU1Mgc3R5bGUgcHJvcGVydHkgZGVzY3JpcHRvciB0aGF0IGNvbnRhaW5zIHR1cGxldCBvZiB0d28gc3RyaW5nczoKICoKICogLSBmaXJzdCBzdHJpbmcgZGVzY3JpYmVzIHByb3BlcnR5IG5hbWUKICogLSBzZWNvbmQgc3RyaW5nIGRlc2NyaWJlcyBwcm9wZXJ0eSB2YWx1ZQogKgogKgkJY29uc3QgbWFyZ2luRGVzY3JpcHRvciA9IFsgJ21hcmdpbicsICcycHggM2VtJyBdOwogKgkJY29uc3QgbWFyZ2luVG9wRGVzY3JpcHRvciA9IFsgJ21hcmdpbi10b3AnLCAnMnB4JyBdOwogKgogKiBAdHlwZWRlZiB7QXJyYXkuPFN0cmluZywgU3RyaW5nPn0gbW9kdWxlOmVuZ2luZS92aWV3L3N0eWxlc21hcH5Qcm9wZXJ0eURlc2NyaXB0b3IKICovCgovKioKICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lkZXMgb2YgYSBib3gsIGZvciBpbnN0YW5jZSBtYXJnaW5zLCBwYWRkaW5ncywKICogYm9yZGVyIHdpZHRocywgYm9yZGVyIGNvbG9ycywgZXRjLgogKgogKgkJY29uc3QgbWFyZ2luID0gewogKgkJCXRvcDogJzFweCcsCiAqCQkJcmlnaHQ6ICczcHgnLAogKgkJCWJvdHRvbTogJzNweCcsCiAqCQkJbGVmdDogJzdweCcKICoJCX07CiAqCiAqCQljb25zdCBib3JkZXJDb2xvciA9IHsKICoJCQl0b3A6ICdyZWQnLAogKgkJCXJpZ2h0OiAnYmx1ZScsCiAqCQkJYm90dG9tOiAnYmx1ZScsCiAqCQkJbGVmdDogJ3JlZCcKICoJCX07CiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvdmlldy9zdHlsZXNtYXB+Qm94U2lkZXMKICoKICogQHByb3BlcnR5IHtTdHJpbmd9IHRvcCBUb3Agc2lkZSB2YWx1ZS4KICogQHByb3BlcnR5IHtTdHJpbmd9IHJpZ2h0IFJpZ2h0IHNpZGUgdmFsdWUuCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBib3R0b20gQm90dG9tIHNpZGUgdmFsdWUuCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsZWZ0IExlZnQgc2lkZSB2YWx1ZS4KICov"},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js"],"names":["get","isObject","merge","set","unset","StylesMap","styleProcessor","_styles","_styleProcessor","inlineStyle","clear","parsedStyles","Array","from","parseInlineStyles","entries","key","value","toNormalizedForm","name","isEmpty","styles","getReducedForm","propertyDescriptor","find","property","isArray","nameOrObject","valueOrObject","Object","path","toPath","_cleanEmptyObjectsOnPath","getNormalized","_getStylesEntries","map","arr","join","sort","propertyName","parsed","keys","push","pathParts","split","isChildPath","length","parentPath","splice","parentObject","isParentEmpty","remove","getStyleNames","StylesProcessor","_normalizers","Map","_extractors","_reducers","_consumables","propertyValue","appendStyleValue","has","normalizer","undefined","extractor","normalizedValue","reducer","callback","callbackOrPath","shorthandName","styleNames","_mapStyleNames","alsoName","stylesString","quoteType","propertyNameStart","propertyValueStart","stylesMap","charAt","i","char","substr","trim","replace","stylesObject","nameOrPath","valueToSet"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/stylesmap\n */\n\nimport { get, isObject, merge, set, unset } from 'lodash-es';\n\n/**\n * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).\n *\n * The styles map is capable of normalizing style names so e.g. the following operations are possible:\n */\nexport default class StylesMap {\n\t/**\n\t * Creates Styles instance.\n\t *\n\t * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor\n\t */\n\tconstructor( styleProcessor ) {\n\t\t/**\n\t\t * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and\n\t\t * value access model using lodash's get, set, unset, etc methods.\n\t\t *\n\t\t * When no style processor rules are defined the it acts as simple key-value storage.\n\t\t *\n\t\t * @private\n\t\t * @type {Object}\n\t\t */\n\t\tthis._styles = {};\n\n\t\t/**\n\t\t * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/view/stylesmap~StylesProcessor}\n\t\t */\n\t\tthis._styleProcessor = styleProcessor;\n\t}\n\n\t/**\n\t * Returns true if style map has no styles set.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget isEmpty() {\n\t\tconst entries = Object.entries( this._styles );\n\t\tconst from = Array.from( entries );\n\n\t\treturn !from.length;\n\t}\n\n\t/**\n\t * Number of styles defined.\n\t *\n\t * @type {Number}\n\t */\n\tget size() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.getStyleNames().length;\n\t}\n\n\t/**\n\t * Set styles map to a new value.\n\t *\n\t *\t\tstyles.setTo( 'border:1px solid blue;margin-top:1px;' );\n\t *\n\t * @param {String} inlineStyle\n\t */\n\tsetTo( inlineStyle ) {\n\t\tthis.clear();\n\n\t\tconst parsedStyles = Array.from( parseInlineStyles( inlineStyle ).entries() );\n\n\t\tfor ( const [ key, value ] of parsedStyles ) {\n\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Checks if a given style is set.\n\t *\n\t *\t\tstyles.setTo( 'margin-left:1px;' );\n\t *\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\t\tstyles.has( 'padding' );        // -> false\n\t *\n\t * **Note**: This check supports normalized style names.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:2px;' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> true\n\t *\t\tstyles.has( 'margin-top' );     // -> true\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\n\t *\t\tstyles.has( 'margin' );         // -> false\n\t *\t\tstyles.has( 'margin-top' );     // -> false\n\t *\t\tstyles.has( 'margin-left' );    // -> true\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Boolean}\n\t */\n\thas( name ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( name, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === name );\n\n\t\t// Only return a value if it is set;\n\t\treturn Array.isArray( propertyDescriptor );\n\t}\n\n\t/**\n\t * Sets a given style.\n\t *\n\t * Can insert one by one:\n\t *\n\t *\t\tstyles.set( 'color', 'blue' );\n\t *\t\tstyles.set( 'margin-right', '1em' );\n\t *\n\t * or many styles at once:\n\t *\n\t *\t\tstyles.set( {\n\t *\t\t\tcolor: 'blue',\n\t *\t\t\t'margin-right': '1em'\n\t *\t\t} );\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin', '2px' );\n\t *\n\t * The above code will set margin to:\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }\n\t *\n\t * Which makes it possible to retrieve a \"sub-value\":\n\t *\n\t *\t\tstyles.get( 'margin-left' );       // -> '2px'\n\t *\n\t * Or modify it:\n\t *\n\t *\t\tstyles.remove( 'margin-left' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }\n\t *\t\tstyles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'\n\t *\n\t * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):\n\t *\n\t *\t\tstyles.set( 'border-color', { top: 'blue' } );\n\t *\t\tstyles.set( 'margin', { right: '2em' } );\n\t *\n\t *\t\tstyles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'\n\t *\n\t * @param {String|Object} nameOrObject Style property name or object with multiple properties.\n\t * @param {String|Object} valueOrObject Value to set.\n\t */\n\tset( nameOrObject, valueOrObject ) {\n\t\tif ( isObject( nameOrObject ) ) {\n\t\t\tfor ( const [ key, value ] of Object.entries( nameOrObject ) ) {\n\t\t\t\tthis._styleProcessor.toNormalizedForm( key, value, this._styles );\n\t\t\t}\n\t\t} else {\n\t\t\tthis._styleProcessor.toNormalizedForm( nameOrObject, valueOrObject, this._styles );\n\t\t}\n\t}\n\n\t/**\n\t * Removes given style.\n\t *\n\t *\t\tstyles.setTo( 'background:#f00;margin-right:2px;' );\n\t *\n\t *\t\tstyles.remove( 'background' );\n\t *\n\t *\t\tstyles.toString();   // -> 'margin-right:2px;'\n\t *\n\t * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules\n\t * enabled style processor rules} to normalize passed values.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.setTo( 'margin:1px' );\n\t *\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @param {String} name Style name.\n\t */\n\tremove( name ) {\n\t\tconst path = toPath( name );\n\n\t\tunset( this._styles, path );\n\t\tdelete this._styles[ name ];\n\n\t\tthis._cleanEmptyObjectsOnPath( path );\n\t}\n\n\t/**\n\t * Returns a normalized style object or a single value.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px 2px 3em;' );\n\t *\n\t *\t\tstyles.getNormalized( 'margin' );\n\t *\t\t// will log:\n\t *\t\t// {\n\t *\t\t//     top: '1px',\n\t *\t\t//     right: '2px',\n\t *\t\t//     bottom: '3em',\n\t *\t\t//     left: '2px'     // normalized value from margin shorthand\n\t *\t\t// }\n\t *\n\t *\t\tstyles.getNormalized( 'margin-left' ); // -> '2px'\n\t *\n\t * **Note**: This method will only return normalized styles if a style processor was defined.\n\t *\n\t * @param {String} name Style name.\n\t * @returns {Object|String|undefined}\n\t */\n\tgetNormalized( name ) {\n\t\treturn this._styleProcessor.getNormalized( name, this._styles );\n\t}\n\n\t/**\n\t * Returns a normalized style string. Styles are sorted by name.\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin:1px;'\n\t *\n\t * **Note**: This method supports normalized styles if defined.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tstyles.set( 'margin' , '1px' );\n\t *\t\tstyles.set( 'background', '#f00' );\n\t *\t\tstyles.remove( 'margin-top' );\n\t *\t\tstyles.remove( 'margin-right' );\n\t *\n\t *\t\tstyles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'\n\t *\n\t * @returns {String}\n\t */\n\ttoString() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this._getStylesEntries()\n\t\t\t.map( arr => arr.join( ':' ) )\n\t\t\t.sort()\n\t\t\t.join( ';' ) + ';';\n\t}\n\n\t/**\n\t * Returns property as a value string or undefined if property is not set.\n\t *\n\t *\t\t// Enable 'margin' shorthand processing:\n\t *\t\teditor.data.addStyleProcessorRules( addMarginRules );\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.set( 'margin-bottom', '3em' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'\n\t *\n\t * Note, however, that all sub-values must be set for the longhand property name to return a value:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tstyles.getAsString( 'margin' ); // -> undefined\n\t *\n\t * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.\n\t * Instead, you should use:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\t\tstyles.remove( 'margin-bottom' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin-top', '1px'\n\t *\t\t// 'margin-right', '1px'\n\t *\t\t// 'margin-left', '1px'\n\t *\n\t * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all\n\t * the currently set style values. So, if all the 4 margin values would be set\n\t * the for-of loop above would yield only `'margin'`, `'1px'`:\n\t *\n\t *\t\tconst styles = new Styles();\n\t *\t\tstyles.setTo( 'margin:1px;' );\n\t *\n\t *\t\tfor ( const styleName of styles.getStyleNames() ) {\n\t *\t\t\tconsole.log( styleName, styles.getAsString( styleName ) );\n\t *\t\t}\n\t *\t\t// 'margin', '1px'\n\t *\n\t * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.\n\t *\n\t * @param {String} propertyName\n\t * @returns {String|undefined}\n\t */\n\tgetAsString( propertyName ) {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._styles[ propertyName ] && !isObject( this._styles[ propertyName ] ) ) {\n\t\t\t// Try return styles set directly - values that are not parsed.\n\t\t\treturn this._styles[ propertyName ];\n\t\t}\n\n\t\tconst styles = this._styleProcessor.getReducedForm( propertyName, this._styles );\n\n\t\tconst propertyDescriptor = styles.find( ( [ property ] ) => property === propertyName );\n\n\t\t// Only return a value if it is set;\n\t\tif ( Array.isArray( propertyDescriptor ) ) {\n\t\t\treturn propertyDescriptor[ 1 ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns style property names as they would appear when using {@link #toString `#toString()`}.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tgetStyleNames() {\n\t\tif ( this.isEmpty ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst entries = this._getStylesEntries();\n\n\t\treturn entries.map( ( [ key ] ) => key );\n\t}\n\n\t/**\n\t * Removes all styles.\n\t */\n\tclear() {\n\t\tthis._styles = {};\n\t}\n\n\t/**\n\t * Returns normalized styles entries for further processing.\n\t *\n\t * @private\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\t_getStylesEntries() {\n\t\tconst parsed = [];\n\n\t\tconst keys = Object.keys( this._styles );\n\n\t\tfor ( const key of keys ) {\n\t\t\tparsed.push( ...this._styleProcessor.getReducedForm( key, this._styles ) );\n\t\t}\n\n\t\treturn parsed;\n\t}\n\n\t/**\n\t * Removes empty objects upon removing an entry from internal object.\n\t *\n\t * @param {String} path\n\t * @private\n\t */\n\t_cleanEmptyObjectsOnPath( path ) {\n\t\tconst pathParts = path.split( '.' );\n\t\tconst isChildPath = pathParts.length > 1;\n\n\t\tif ( !isChildPath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst parentPath = pathParts.splice( 0, pathParts.length - 1 ).join( '.' );\n\n\t\tconst parentObject = get( this._styles, parentPath );\n\n\t\tif ( !parentObject ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst isParentEmpty = !Array.from( Object.keys( parentObject ) ).length;\n\n\t\tif ( isParentEmpty ) {\n\t\t\tthis.remove( parentPath );\n\t\t}\n\t}\n}\n\n/**\n * Style processor is responsible for writing and reading a normalized styles object.\n */\nexport class StylesProcessor {\n\t/**\n\t * Creates StylesProcessor instance.\n\t *\n\t * @private\n\t */\n\tconstructor() {\n\t\tthis._normalizers = new Map();\n\t\tthis._extractors = new Map();\n\t\tthis._reducers = new Map();\n\t\tthis._consumables = new Map();\n\t}\n\n\t/**\n\t * Parse style string value to a normalized object and appends it to styles object.\n\t *\n\t *\t\tconst styles = {};\n\t *\n\t *\t\tstylesProcessor.toNormalizedForm( 'margin', '1px', styles );\n\t *\n\t *\t\t// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }\n\t *\n\t * **Note**: To define normalizer callbacks use {@link #setNormalizer}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {String} propertyValue Value of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t */\n\ttoNormalizedForm( name, propertyValue, styles ) {\n\t\tif ( isObject( propertyValue ) ) {\n\t\t\tappendStyleValue( styles, toPath( name ), propertyValue );\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._normalizers.has( name ) ) {\n\t\t\tconst normalizer = this._normalizers.get( name );\n\n\t\t\tconst { path, value } = normalizer( propertyValue );\n\n\t\t\tappendStyleValue( styles, path, value );\n\t\t} else {\n\t\t\tappendStyleValue( styles, name, propertyValue );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a normalized version of a style property.\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },\n\t *\t\t\tbackground: { color: '#f00' }\n\t *\t\t};\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'background' );\n\t *\t\t// will return: { color: '#f00' }\n\t *\n\t *\t\tstylesProcessor.getNormalized( 'margin-top' );\n\t *\t\t// will return: '1px'\n\t *\n\t * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.\n\t *\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {*}\n\t */\n\tgetNormalized( name, styles ) {\n\t\tif ( !name ) {\n\t\t\treturn merge( {}, styles );\n\t\t}\n\n\t\t// Might be empty string.\n\t\tif ( styles[ name ] !== undefined ) {\n\t\t\treturn styles[ name ];\n\t\t}\n\n\t\tif ( this._extractors.has( name ) ) {\n\t\t\tconst extractor = this._extractors.get( name );\n\n\t\t\tif ( typeof extractor === 'string' ) {\n\t\t\t\treturn get( styles, extractor );\n\t\t\t}\n\n\t\t\tconst value = extractor( name, styles );\n\n\t\t\tif ( value ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\treturn get( styles, toPath( name ) );\n\t}\n\n\t/**\n\t * Returns a reduced form of style property form normalized object.\n\t *\n\t * For default margin reducer, the below code:\n\t *\n\t *\t\tstylesProcessor.getReducedForm( 'margin', {\n\t *\t\t\tmargin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }\n\t *\t\t} );\n\t *\n\t * will return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t]\n\t *\n\t * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:\n\t *\n\t *\t\t[\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ],\n\t *\t\t\t[ 'margin-bottom', '2px' ]\n\t *\t\t\t// the 'left' value is missing - cannot use 'margin' shorthand.\n\t *\t\t]\n\t *\n\t * **Note**: To define reducer callbacks use {@link #setReducer}.\n\t *\n\t * @param {String} name\n\t * @param {String} name Name of style property.\n\t * @param {Object} styles Object holding normalized styles.\n\t * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}\n\t */\n\tgetReducedForm( name, styles ) {\n\t\tconst normalizedValue = this.getNormalized( name, styles );\n\n\t\t// Might be empty string.\n\t\tif ( normalizedValue === undefined ) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( this._reducers.has( name ) ) {\n\t\t\tconst reducer = this._reducers.get( name );\n\n\t\t\treturn reducer( normalizedValue );\n\t\t}\n\n\t\treturn [ [ name, normalizedValue ] ];\n\t}\n\n\t/**\n\t * Returns related style names.\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin' );\n\t *\t\t// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];\n\t *\n\t *\t\tstylesProcessor.getRelatedStyles( 'margin-top' );\n\t *\t\t// will return: [ 'margin' ];\n\t *\n\t * **Note**: To define new style relations load an existing style processor or use\n\t * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.\n\t *\n\t * @param {String} name\n\t * @returns {Array.<String>}\n\t */\n\tgetRelatedStyles( name ) {\n\t\treturn this._consumables.get( name ) || [];\n\t}\n\n\t/**\n\t * Adds a normalizer method for a style property.\n\t *\n\t * A normalizer returns describing how the value should be normalized.\n\t *\n\t * For instance 'margin' style is a shorthand for four margin values:\n\t *\n\t * - 'margin-top'\n\t * - 'margin-right'\n\t * - 'margin-bottom'\n\t * - 'margin-left'\n\t *\n\t * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for\n\t * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.\n\t *\n\t * A normalizer should parse various margin notations as a single object:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Thus a normalizer for 'margin' style should return an object defining style path and value to store:\n\t *\n\t *\t\tconst returnValue = {\n\t *\t\t\tpath: 'margin',\n\t *\t\t\tvalue: {\n\t *\t\t\t\ttop: '1px',\n\t *\t\t\t\tright: '2em',\n\t *\t\t\t\tbottom: '1px',\n\t *\t\t\t\tleft: '2em'\n\t *\t\t\t}\n\t *\t\t};\n\t *\n\t * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below\n\t * is an example for 'margin-top' style property normalizer:\n\t *\n\t *\t\tstylesProcessor.setNormalizer( 'margin-top', valueString => {\n\t *\t\t\treturn {\n\t *\t\t\t\tpath: 'margin.top',\n\t *\t\t\t\tvalue: valueString\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetNormalizer( name, callback ) {\n\t\tthis._normalizers.set( name, callback );\n\t}\n\n\t/**\n\t * Adds a extractor callback for a style property.\n\t *\n\t * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tmargin: {\n\t *\t\t\t\ttop: 'value'\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance\n\t * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`\n\t * shorthands. The default border styles processors stores styles as:\n\t *\n\t *\t\tconst styles = {\n\t *\t\t\tborder: {\n\t *\t\t\t\tstyle: {\n\t *\t\t\t\t\ttop: 'solid'\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t}\n\t *\n\t * as it is better to modify border style independently from other values. On the other part the output of the border might be\n\t * desired as `border-top`, `border-left`, etc notation.\n\t *\n\t * In the above example a reducer should return a side border value that combines style, color and width:\n\t *\n\t *\t\tstyleProcessor.setExtractor( 'border-top', styles => {\n\t *\t\t\treturn {\n\t *\t\t\t\tcolor: styles.border.color.top,\n\t *\t\t\t\tstyle: styles.border.style.top,\n\t *\t\t\t\twidth: styles.border.width.top\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.\n\t */\n\tsetExtractor( name, callbackOrPath ) {\n\t\tthis._extractors.set( name, callbackOrPath );\n\t}\n\n\t/**\n\t * Adds a reducer callback for a style property.\n\t *\n\t * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as\n\t * by default the direct value from style path is taken.\n\t *\n\t * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples\n\t * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:\n\t *\n\t *\t\tconst marginShortHandTuple = [\n\t *\t\t\t[ 'margin', '1px 1px 2px' ]\n\t *\t\t];\n\t *\n\t * or a longhand tuples for defined values:\n\t *\n\t *\t\t// Considering margin.bottom and margin.left are undefined.\n\t *\t\tconst marginLonghandsTuples = [\n\t *\t\t\t[ 'margin-top', '1px' ],\n\t *\t\t\t[ 'margin-right', '1px' ]\n\t *\t\t];\n\t *\n\t * A reducer obtains a normalized style value:\n\t *\n\t *\t\t// Simplified reducer that always outputs 4 values which are always present:\n\t *\t\tstylesProcessor.setReducer( 'margin', margin => {\n\t *\t\t\treturn [\n\t *\t\t\t\t[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t * @param {String} name\n\t * @param {Function} callback\n\t */\n\tsetReducer( name, callback ) {\n\t\tthis._reducers.set( name, callback );\n\t}\n\n\t/**\n\t * Defines a style shorthand relation to other style notations.\n\t *\n\t *\t\tstylesProcessor.setStyleRelation( 'margin', [\n\t *\t\t\t'margin-top',\n\t *\t\t\t'margin-right',\n\t *\t\t\t'margin-bottom',\n\t *\t\t\t'margin-left'\n\t *\t\t] );\n\t *\n\t * This enables expanding of style names for shorthands. For instance, if defined,\n\t * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created\n\t * for long-hand margin style notation alongside the `'margin'` item.\n\t *\n\t * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just\n\t * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and\n\t * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.\n\t * However, once `margin-left` is consumed, `margin` will not be consumable anymore.\n\t *\n\t * @param {String} shorthandName\n\t * @param {Array.<String>} styleNames\n\t */\n\tsetStyleRelation( shorthandName, styleNames ) {\n\t\tthis._mapStyleNames( shorthandName, styleNames );\n\n\t\tfor ( const alsoName of styleNames ) {\n\t\t\tthis._mapStyleNames( alsoName, [ shorthandName ] );\n\t\t}\n\t}\n\n\t/**\n\t * Set two-way binding of style names.\n\t *\n\t * @param {String} name\n\t * @param {Array.<String>} styleNames\n\t * @private\n\t */\n\t_mapStyleNames( name, styleNames ) {\n\t\tif ( !this._consumables.has( name ) ) {\n\t\t\tthis._consumables.set( name, [] );\n\t\t}\n\n\t\tthis._consumables.get( name ).push( ...styleNames );\n\t}\n}\n\n// Parses inline styles and puts property - value pairs into styles map.\n//\n// @param {String} stylesString Styles to parse.\n// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.\nfunction parseInlineStyles( stylesString ) {\n\t// `null` if no quote was found in input string or last found quote was a closing quote. See below.\n\tlet quoteType = null;\n\tlet propertyNameStart = 0;\n\tlet propertyValueStart = 0;\n\tlet propertyName = null;\n\n\tconst stylesMap = new Map();\n\n\t// Do not set anything if input string is empty.\n\tif ( stylesString === '' ) {\n\t\treturn stylesMap;\n\t}\n\n\t// Fix inline styles that do not end with `;` so they are compatible with algorithm below.\n\tif ( stylesString.charAt( stylesString.length - 1 ) != ';' ) {\n\t\tstylesString = stylesString + ';';\n\t}\n\n\t// Seek the whole string for \"special characters\".\n\tfor ( let i = 0; i < stylesString.length; i++ ) {\n\t\tconst char = stylesString.charAt( i );\n\n\t\tif ( quoteType === null ) {\n\t\t\t// No quote found yet or last found quote was a closing quote.\n\t\t\tswitch ( char ) {\n\t\t\t\tcase ':':\n\t\t\t\t\t// Most of time colon means that property name just ended.\n\t\t\t\t\t// Sometimes however `:` is found inside property value (for example in background image url).\n\t\t\t\t\tif ( !propertyName ) {\n\t\t\t\t\t\t// Treat this as end of property only if property name is not already saved.\n\t\t\t\t\t\t// Save property name.\n\t\t\t\t\t\tpropertyName = stylesString.substr( propertyNameStart, i - propertyNameStart );\n\t\t\t\t\t\t// Save this point as the start of property value.\n\t\t\t\t\t\tpropertyValueStart = i + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\t// Opening quote found (this is an opening quote, because `quoteType` is `null`).\n\t\t\t\t\tquoteType = char;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ';': {\n\t\t\t\t\t// Property value just ended.\n\t\t\t\t\t// Use previously stored property value start to obtain property value.\n\t\t\t\t\tconst propertyValue = stylesString.substr( propertyValueStart, i - propertyValueStart );\n\n\t\t\t\t\tif ( propertyName ) {\n\t\t\t\t\t\t// Save parsed part.\n\t\t\t\t\t\tstylesMap.set( propertyName.trim(), propertyValue.trim() );\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyName = null;\n\n\t\t\t\t\t// Save this point as property name start. Property name starts immediately after previous property value ends.\n\t\t\t\t\tpropertyNameStart = i + 1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( char === quoteType ) {\n\t\t\t// If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.\n\t\t\tquoteType = null;\n\t\t}\n\t}\n\n\treturn stylesMap;\n}\n\n// Return lodash compatible path from style name.\nfunction toPath( name ) {\n\treturn name.replace( '-', '.' );\n}\n\n// Appends style definition to the styles object.\n//\n// @param {String} nameOrPath\n// @param {String|Object} valueOrObject\n// @private\nfunction appendStyleValue( stylesObject, nameOrPath, valueOrObject ) {\n\tlet valueToSet = valueOrObject;\n\n\tif ( isObject( valueOrObject ) ) {\n\t\tvalueToSet = merge( {}, get( stylesObject, nameOrPath ), valueOrObject );\n\t}\n\n\tset( stylesObject, nameOrPath, valueToSet );\n}\n\n/**\n * A CSS style property descriptor that contains tuplet of two strings:\n *\n * - first string describes property name\n * - second string describes property value\n *\n *\t\tconst marginDescriptor = [ 'margin', '2px 3em' ];\n *\t\tconst marginTopDescriptor = [ 'margin-top', '2px' ];\n *\n * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor\n */\n\n/**\n * An object describing values associated with the sides of a box, for instance margins, paddings,\n * border widths, border colors, etc.\n *\n *\t\tconst margin = {\n *\t\t\ttop: '1px',\n *\t\t\tright: '3px',\n *\t\t\tbottom: '3px',\n *\t\t\tleft: '7px'\n *\t\t};\n *\n *\t\tconst borderColor = {\n *\t\t\ttop: 'red',\n *\t\t\tright: 'blue',\n *\t\t\tbottom: 'blue',\n *\t\t\tleft: 'red'\n *\t\t};\n *\n * @typedef {Object} module:engine/view/stylesmap~BoxSides\n *\n * @property {String} top Top side value.\n * @property {String} right Right side value.\n * @property {String} bottom Bottom side value.\n * @property {String} left Left side value.\n */\n"]}]}