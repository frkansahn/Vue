{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\operation\\transform.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\operation\\transform.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zcGxpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLndlYWstbWFwIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvciI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjayI7CmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiQzpcXFVzZXJzXFxwY1xcRGVza3RvcFxcUmVzdG9yYW5cXFJlc3RvcmFuXFxSZXN0b3Jhbi5VSVxcY2xpZW50XFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CgovKioKICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjAsIENLU291cmNlIC0gRnJlZGVyaWNvIEtuYWJiZW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLW9zcy1saWNlbnNlCiAqLwppbXBvcnQgSW5zZXJ0T3BlcmF0aW9uIGZyb20gJy4vaW5zZXJ0b3BlcmF0aW9uJzsKaW1wb3J0IEF0dHJpYnV0ZU9wZXJhdGlvbiBmcm9tICcuL2F0dHJpYnV0ZW9wZXJhdGlvbic7CmltcG9ydCBSZW5hbWVPcGVyYXRpb24gZnJvbSAnLi9yZW5hbWVvcGVyYXRpb24nOwppbXBvcnQgTWFya2VyT3BlcmF0aW9uIGZyb20gJy4vbWFya2Vyb3BlcmF0aW9uJzsKaW1wb3J0IE1vdmVPcGVyYXRpb24gZnJvbSAnLi9tb3Zlb3BlcmF0aW9uJzsKaW1wb3J0IFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24gZnJvbSAnLi9yb290YXR0cmlidXRlb3BlcmF0aW9uJzsKaW1wb3J0IE1lcmdlT3BlcmF0aW9uIGZyb20gJy4vbWVyZ2VvcGVyYXRpb24nOwppbXBvcnQgU3BsaXRPcGVyYXRpb24gZnJvbSAnLi9zcGxpdG9wZXJhdGlvbic7CmltcG9ydCBOb09wZXJhdGlvbiBmcm9tICcuL25vb3BlcmF0aW9uJzsKaW1wb3J0IFJhbmdlIGZyb20gJy4uL3JhbmdlJzsKaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4uL3Bvc2l0aW9uJzsKaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY29tcGFyZWFycmF5cyc7CnZhciB0cmFuc2Zvcm1hdGlvbnMgPSBuZXcgTWFwKCk7Ci8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtCiAqLwoKLyoqCiAqIFNldHMgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBiZSBiZSB1c2VkIHRvIHRyYW5zZm9ybSBpbnN0YW5jZXMgb2YgY2xhc3MgYE9wZXJhdGlvbkFgIGJ5IGluc3RhbmNlcyBvZiBjbGFzcyBgT3BlcmF0aW9uQmAuCiAqCiAqIFRoZSBgdHJhbnNmb3JtYXRpb25GdW5jdGlvbmAgaXMgcGFzc2VkIHRocmVlIHBhcmFtZXRlcnM6CiAqCiAqICogYGFgIC0gb3BlcmF0aW9uIHRvIGJlIHRyYW5zZm9ybWVkLCBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQWAsCiAqICogYGJgIC0gb3BlcmF0aW9uIHRvIGJlIHRyYW5zZm9ybWVkIGJ5LCBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQmAsCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5UcmFuc2Zvcm1hdGlvbkNvbnRleHQgYGNvbnRleHRgfSAtIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQKICogdHJhbnNmb3JtYXRpb24gY29udGV4dC4KICoKICogVGhlIGB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uYCBzaG91bGQgcmV0dXJuIHRyYW5zZm9ybWF0aW9uIHJlc3VsdCwgd2hpY2ggaXMgYW4gYXJyYXkgd2l0aCBvbmUgb3IgbXVsdGlwbGUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9ufSBpbnN0YW5jZXMuCiAqCiAqIEBwcm90ZWN0ZWQKICogQHBhcmFtIHtGdW5jdGlvbn0gT3BlcmF0aW9uQQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcGVyYXRpb25CCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybWF0aW9uRnVuY3Rpb24gRnVuY3Rpb24gdG8gdXNlIGZvciB0cmFuc2Zvcm1pbmcuCiAqLwoKZnVuY3Rpb24gc2V0VHJhbnNmb3JtYXRpb24oT3BlcmF0aW9uQSwgT3BlcmF0aW9uQiwgdHJhbnNmb3JtYXRpb25GdW5jdGlvbikgewogIHZhciBhR3JvdXAgPSB0cmFuc2Zvcm1hdGlvbnMuZ2V0KE9wZXJhdGlvbkEpOwoKICBpZiAoIWFHcm91cCkgewogICAgYUdyb3VwID0gbmV3IE1hcCgpOwogICAgdHJhbnNmb3JtYXRpb25zLnNldChPcGVyYXRpb25BLCBhR3JvdXApOwogIH0KCiAgYUdyb3VwLnNldChPcGVyYXRpb25CLCB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uKTsKfQovKioKICogUmV0dXJucyBhIHByZXZpb3VzbHkgc2V0IHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIGZvciB0cmFuc2Zvcm1pbmcgYW4gaW5zdGFuY2Ugb2YgYE9wZXJhdGlvbkFgIGJ5IGFuIGluc3RhbmNlIG9mIGBPcGVyYXRpb25CYC4KICoKICogSWYgbm8gdHJhbnNmb3JtYXRpb24gd2FzIHNldCBmb3IgZ2l2ZW4gcGFpciBvZiBvcGVyYXRpb25zLCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3Jtfm5vVXBkYXRlVHJhbnNmb3JtYXRpb259CiAqIGlzIHJldHVybmVkLiBUaGlzIG1lYW5zIHRoYXQgaWYgbm8gdHJhbnNmb3JtYXRpb24gd2FzIHNldCwgdGhlIGBPcGVyYXRpb25BYCBpbnN0YW5jZSB3aWxsIG5vdCBjaGFuZ2Ugd2hlbiB0cmFuc2Zvcm1lZAogKiBieSB0aGUgYE9wZXJhdGlvbkJgIGluc3RhbmNlLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcGVyYXRpb25BCiAqIEBwYXJhbSB7RnVuY3Rpb259IE9wZXJhdGlvbkIKICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiBzZXQgdG8gdHJhbnNmb3JtIGFuIGluc3RhbmNlIG9mIGBPcGVyYXRpb25BYCBieSBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQmAuCiAqLwoKCmZ1bmN0aW9uIGdldFRyYW5zZm9ybWF0aW9uKE9wZXJhdGlvbkEsIE9wZXJhdGlvbkIpIHsKICB2YXIgYUdyb3VwID0gdHJhbnNmb3JtYXRpb25zLmdldChPcGVyYXRpb25BKTsKCiAgaWYgKGFHcm91cCAmJiBhR3JvdXAuaGFzKE9wZXJhdGlvbkIpKSB7CiAgICByZXR1cm4gYUdyb3VwLmdldChPcGVyYXRpb25CKTsKICB9CgogIHJldHVybiBub1VwZGF0ZVRyYW5zZm9ybWF0aW9uOwp9Ci8qKgogKiBBIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgb25seSBjbG9uZXMgb3BlcmF0aW9uIHRvIHRyYW5zZm9ybSwgd2l0aG91dCBjaGFuZ2luZyBpdC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBhIE9wZXJhdGlvbiB0byB0cmFuc2Zvcm0uCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59CiAqLwoKCmZ1bmN0aW9uIG5vVXBkYXRlVHJhbnNmb3JtYXRpb24oYSkgewogIHJldHVybiBbYV07Cn0KLyoqCiAqIFRyYW5zZm9ybXMgb3BlcmF0aW9uIGBhYCBieSBvcGVyYXRpb24gYGJgLgogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IGEgT3BlcmF0aW9uIHRvIGJlIHRyYW5zZm9ybWVkLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IGIgT3BlcmF0aW9uIHRvIHRyYW5zZm9ybSBieS4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi90cmFuc2Zvcm1+VHJhbnNmb3JtYXRpb25Db250ZXh0fSBjb250ZXh0IFRyYW5zZm9ybWF0aW9uIGNvbnRleHQgZm9yIHRoaXMgdHJhbnNmb3JtYXRpb24uCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IFRyYW5zZm9ybWF0aW9uIHJlc3VsdC4KICovCgoKZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShhLCBiKSB7CiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9OwogIHZhciB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uID0gZ2V0VHJhbnNmb3JtYXRpb24oYS5jb25zdHJ1Y3RvciwgYi5jb25zdHJ1Y3Rvcik7CgogIHRyeSB7CiAgICBhID0gYS5jbG9uZSgpOwogICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uRnVuY3Rpb24oYSwgYiwgY29udGV4dCk7CiAgfSBjYXRjaCAoZSkgewogICAgLy8gQGlmIENLX0RFQlVHIC8vIGNvbnNvbGUud2FybiggJ0Vycm9yIGR1cmluZyBvcGVyYXRpb24gdHJhbnNmb3JtYXRpb24hJywgZS5tZXNzYWdlICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnVHJhbnNmb3JtZWQgb3BlcmF0aW9uJywgYSApOwogICAgLy8gQGlmIENLX0RFQlVHIC8vIGNvbnNvbGUud2FybiggJ09wZXJhdGlvbiB0cmFuc2Zvcm1lZCBieScsIGIgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmFJc1N0cm9uZycsIGNvbnRleHQuYUlzU3Ryb25nICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnY29udGV4dC5hV2FzVW5kb25lJywgY29udGV4dC5hV2FzVW5kb25lICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnY29udGV4dC5iV2FzVW5kb25lJywgY29udGV4dC5iV2FzVW5kb25lICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnY29udGV4dC5hYlJlbGF0aW9uJywgY29udGV4dC5hYlJlbGF0aW9uICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnY29udGV4dC5iYVJlbGF0aW9uJywgY29udGV4dC5iYVJlbGF0aW9uICk7CiAgICB0aHJvdyBlOwogIH0KfQovKioKICogUGVyZm9ybXMgYSB0cmFuc2Zvcm1hdGlvbiBvZiB0d28gc2V0cyBvZiBvcGVyYXRpb25zIC0gYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYC4gVGhlIHRyYW5zZm9ybWF0aW9uIGlzIHR3by13YXkgLQogKiBib3RoIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQWAgYW5kIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQmAgYXJlIHJldHVybmVkLgogKgogKiBOb3RlLCB0aGF0IHRoZSBmaXJzdCBvcGVyYXRpb24gaW4gZWFjaCBzZXQgc2hvdWxkIGJhc2Ugb24gdGhlIHNhbWUgZG9jdW1lbnQgc3RhdGUgKAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCN2ZXJzaW9uIGRvY3VtZW50IHZlcnNpb259KS4KICoKICogSXQgaXMgYXNzdW1lZCB0aGF0IGBvcGVyYXRpb25zQWAgYXJlICJtb3JlIGltcG9ydGFudCIgZHVyaW5nIGNvbmZsaWN0IHJlc29sdXRpb24gYmV0d2VlbiB0d28gb3BlcmF0aW9ucy4KICoKICogTmV3IGNvcGllcyBvZiBib3RoIHBhc3NlZCBhcnJheXMgYW5kIG9wZXJhdGlvbnMgaW5zaWRlIHRoZW0gYXJlIHJldHVybmVkLiBQYXNzZWQgYXJndW1lbnRzIGFyZSBub3QgYWx0ZXJlZC4KICoKICogQmFzZSB2ZXJzaW9ucyBvZiB0aGUgdHJhbnNmb3JtZWQgb3BlcmF0aW9ucyBzZXRzIGFyZSB1cGRhdGVkIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgYXNzdW1lIHRoYXQgYmFzZSB2ZXJzaW9ucyBhcmUgYDRgCiAqIGFuZCB0aGVyZSBhcmUgYDNgIG9wZXJhdGlvbnMgaW4gYG9wZXJhdGlvbnNBYCBhbmQgYDVgIG9wZXJhdGlvbnMgaW4gYG9wZXJhdGlvbnNCYC4gVGhlbjoKICoKICogKiB0cmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0FgIHdpbGwgc3RhcnQgZnJvbSBiYXNlIHZlcnNpb24gYDlgIChgNGAgYmFzZSB2ZXJzaW9uICsgYDVgIG9wZXJhdGlvbnMgQiksCiAqICogdHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNCYCB3aWxsIHN0YXJ0IGZyb20gYmFzZSB2ZXJzaW9uIGA3YCAoYDRgIGJhc2UgdmVyc2lvbiArIGAzYCBvcGVyYXRpb25zIEEpLgogKgogKiBJZiBubyBvcGVyYXRpb24gd2FzIGJyb2tlbiBpbnRvIHR3byBkdXJpbmcgdHJhbnNmb3JtYXRpb24sIHRoZW4gYm90aCBzZXRzIHdpbGwgZW5kIHVwIHdpdGggYW4gb3BlcmF0aW9uIHRoYXQgYmFzZXMgb24gdmVyc2lvbiBgMTFgOgogKgogKiAqIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQWAgc3RhcnQgZnJvbSBgOWAgYW5kIHRoZXJlIGFyZSBgM2Agb2YgdGhlbSwgc28gdGhlIGxhc3Qgd2lsbCBoYXZlIGBiYXNlVmVyc2lvbmAgZXF1YWwgdG8gYDExYCwKICogKiB0cmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0JgIHN0YXJ0IGZyb20gYDdgIGFuZCB0aGVyZSBhcmUgYDVgIG9mIHRoZW0sIHNvIHRoZSBsYXN0IHdpbGwgaGF2ZSBgYmFzZVZlcnNpb25gIGVxdWFsIHRvIGAxMWAuCiAqCiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zQQogKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gb3BlcmF0aW9uc0IKICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBvcHRpb25zLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR8bnVsbH0gb3B0aW9ucy5kb2N1bWVudCBEb2N1bWVudCB3aGljaCB0aGUgb3BlcmF0aW9ucyBjaGFuZ2UuCiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlUmVsYXRpb25zPWZhbHNlXSBXaGV0aGVyIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiByZWxhdGlvbnMgc2hvdWxkIGJlIHVzZWQgKHVzZWQgZHVyaW5nIHVuZG8gZm9yCiAqIGJldHRlciBjb25mbGljdCByZXNvbHV0aW9uKS4KICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wYWRXaXRoTm9PcHM9ZmFsc2VdIFdoZXRoZXIgYWRkaXRpb25hbCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbm9vcGVyYXRpb25+Tm9PcGVyYXRpb259cwogKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHRyYW5zZm9ybWF0aW9uIHJlc3VsdHMgdG8gZm9yY2UgdGhlIHNhbWUgbGFzdCBiYXNlIHZlcnNpb24gZm9yIGJvdGggdHJhbnNmb3JtZWQgc2V0cyAoaW4gY2FzZQogKiBpZiBzb21lIG9wZXJhdGlvbnMgZ290IGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMgZHVyaW5nIHRyYW5zZm9ybWF0aW9uKS4KICogQHJldHVybnMge09iamVjdH0gVHJhbnNmb3JtYXRpb24gcmVzdWx0LgogKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSByZXR1cm4ub3BlcmF0aW9uc0EgVHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNBYC4KICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gcmV0dXJuLm9wZXJhdGlvbnNCIFRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQmAuCiAqIEByZXR1cm5zIHtNYXB9IHJldHVybi5vcmlnaW5hbE9wZXJhdGlvbnMgQSBtYXAgdGhhdCBsaW5rcyB0cmFuc2Zvcm1lZCBvcGVyYXRpb25zIHRvIG9yaWdpbmFsIG9wZXJhdGlvbnMuIFRoZSBrZXlzIGFyZSB0aGUgdHJhbnNmb3JtZWQKICogb3BlcmF0aW9ucyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbnMgZnJvbSB0aGUgaW5wdXQgKGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmApLgogKi8KCmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1TZXRzKG9wZXJhdGlvbnNBLCBvcGVyYXRpb25zQiwgb3B0aW9ucykgewogIC8vIENyZWF0ZSBuZXcgYXJyYXlzIHNvIHRoZSBvcmlnaW5hbGx5IHBhc3NlZCBhcmd1bWVudHMgYXJlIG5vdCBjaGFuZ2VkLgogIC8vIE5vIG5lZWQgdG8gY2xvbmUgb3BlcmF0aW9ucywgdGhleSBhcmUgY2xvbmVkIGFzIHRoZXkgYXJlIHRyYW5zZm9ybWVkLgogIG9wZXJhdGlvbnNBID0gb3BlcmF0aW9uc0Euc2xpY2UoKTsKICBvcGVyYXRpb25zQiA9IG9wZXJhdGlvbnNCLnNsaWNlKCk7CiAgdmFyIGNvbnRleHRGYWN0b3J5ID0gbmV3IENvbnRleHRGYWN0b3J5KG9wdGlvbnMuZG9jdW1lbnQsIG9wdGlvbnMudXNlUmVsYXRpb25zLCBvcHRpb25zLmZvcmNlV2Vha1JlbW92ZSk7CiAgY29udGV4dEZhY3Rvcnkuc2V0T3JpZ2luYWxPcGVyYXRpb25zKG9wZXJhdGlvbnNBKTsKICBjb250ZXh0RmFjdG9yeS5zZXRPcmlnaW5hbE9wZXJhdGlvbnMob3BlcmF0aW9uc0IpOwogIHZhciBvcmlnaW5hbE9wZXJhdGlvbnMgPSBjb250ZXh0RmFjdG9yeS5vcmlnaW5hbE9wZXJhdGlvbnM7IC8vIElmIG9uZSBvZiBzZXRzIGlzIGVtcHR5IHRoZXJlIGlzIHNpbXBseSBub3RoaW5nIHRvIHRyYW5zZm9ybSwgc28gcmV0dXJuIHNldHMgYXMgdGhleSBhcmUuCgogIGlmIChvcGVyYXRpb25zQS5sZW5ndGggPT0gMCB8fCBvcGVyYXRpb25zQi5sZW5ndGggPT0gMCkgewogICAgcmV0dXJuIHsKICAgICAgb3BlcmF0aW9uc0E6IG9wZXJhdGlvbnNBLAogICAgICBvcGVyYXRpb25zQjogb3BlcmF0aW9uc0IsCiAgICAgIG9yaWdpbmFsT3BlcmF0aW9uczogb3JpZ2luYWxPcGVyYXRpb25zCiAgICB9OwogIH0gLy8KICAvLyBGb2xsb3dpbmcgaXMgYSBkZXNjcmlwdGlvbiBvZiB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzOgogIC8vCiAgLy8gVGhlcmUgYXJlIGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmAgdG8gYmUgdHJhbnNmb3JtZWQsIGJvdGggYnkgYm90aC4KICAvLwogIC8vIFNvLCBzdXBwb3NlIHdlIGhhdmUgc2V0cyBvZiB0d28gb3BlcmF0aW9ucyBlYWNoOiBgb3BlcmF0aW9uc0FgID0gYFsgYTEsIGEyIF1gLCBgb3BlcmF0aW9uc0JgID0gYFsgYjEsIGIyIF1gLgogIC8vCiAgLy8gUmVtZW1iZXIsIHRoYXQgd2UgY2FuIG9ubHkgdHJhbnNmb3JtIG9wZXJhdGlvbnMgdGhhdCBiYXNlIG9uIHRoZSBzYW1lIGNvbnRleHQuIFdlIGFzc2VydCB0aGF0IGBhMWAgYW5kIGBiMWAgYmFzZSBvbgogIC8vIHRoZSBzYW1lIGNvbnRleHQgYW5kIHdlIHRyYW5zZm9ybSB0aGVtLiBUaGVuLCB3ZSBnZXQgYGExJ2AgYW5kIGBiMSdgLiBgYTJgIGJhc2VzIG9uIGEgY29udGV4dCB3aXRoIGBhMWAgLS0gYGEyYAogIC8vIGlzIGFuIG9wZXJhdGlvbiB0aGF0IGZvbGxvd2VkIGBhMWAuIFNpbWlsYXJseSwgYGIyYCBiYXNlcyBvbiBhIGNvbnRleHQgd2l0aCBgYjFgLgogIC8vCiAgLy8gSG93ZXZlciwgc2luY2UgYGExJ2AgaXMgYSByZXN1bHQgb2YgdHJhbnNmb3JtYXRpb24gYnkgYGIxYCwgYGExJ2Agbm93IGFsc28gaGFzIGEgY29udGV4dCB3aXRoIGBiMWAuIFRoaXMgbWVhbnMgdGhhdAogIC8vIHdlIGNhbiBzYWZlbHkgdHJhbnNmb3JtIGBhMSdgIGJ5IGBiMmAuIEFzIHdlIGZpbmlzaCB0cmFuc2Zvcm1pbmcgYGExYCwgd2UgYWxzbyB0cmFuc2Zvcm1lZCBhbGwgYG9wZXJhdGlvbnNCYC4KICAvLyBBbGwgYG9wZXJhdGlvbnNCYCBhbHNvIGhhdmUgY29udGV4dCBpbmNsdWRpbmcgYGExYC4gTm93LCB3ZSBjYW4gcHJvcGVybHkgdHJhbnNmb3JtIGBhMmAgYnkgdGhvc2Ugb3BlcmF0aW9ucy4KICAvLwogIC8vIFRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGNhbiBiZSB2aXN1YWxpemVkIG9uIGEgdHJhbnNmb3JtYXRpb24gZGlhZ3JhbSAoImRpYW1vbmQgZGlhZ3JhbSIpOgogIC8vCiAgLy8gICAgICAgICAgW3RoZSBpbml0aWFsIHN0YXRlXQogIC8vICAgICAgICAgW2NvbW1vbiBmb3IgYTEgYW5kIGIxXQogIC8vCiAgLy8gICAgICAgICAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgICAgICAgLyBcCiAgLy8gICAgICAgICAgICAgICAgIC8gICBcCiAgLy8gICAgICAgICAgICAgICBiMSAgICAgYTEKICAvLyAgICAgICAgICAgICAgIC8gICAgICAgXAogIC8vICAgICAgICAgICAgICAvICAgICAgICAgXAogIC8vICAgICAgICAgICAgICogICAgICAgICAgICoKICAvLyAgICAgICAgICAgIC8gXCAgICAgICAgIC8gXAogIC8vICAgICAgICAgICAvICAgXCAgICAgICAvICAgXAogIC8vICAgICAgICAgYjIgICAgYTEnICAgYjEnICAgIGEyCiAgLy8gICAgICAgICAvICAgICAgIFwgICAvICAgICAgIFwKICAvLyAgICAgICAgLyAgICAgICAgIFwgLyAgICAgICAgIFwKICAvLyAgICAgICAqICAgICAgICAgICAqICAgICAgICAgICAqCiAgLy8gICAgICAgIFwgICAgICAgICAvIFwgICAgICAgICAvCiAgLy8gICAgICAgICBcICAgICAgIC8gICBcICAgICAgIC8KICAvLyAgICAgICAgYTEnJyAgIGIyJyAgIGEyJyAgIGIxJycKICAvLyAgICAgICAgICAgXCAgIC8gICAgICAgXCAgIC8KICAvLyAgICAgICAgICAgIFwgLyAgICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICogICAgICAgICAgICoKICAvLyAgICAgICAgICAgICAgXCAgICAgICAgIC8KICAvLyAgICAgICAgICAgICAgIFwgICAgICAgLwogIC8vICAgICAgICAgICAgICBhMicnICAgYjInJwogIC8vICAgICAgICAgICAgICAgICBcICAgLwogIC8vICAgICAgICAgICAgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAgICAgKgogIC8vCiAgLy8gICAgICAgICAgIFt0aGUgZmluYWwgc3RhdGVdCiAgLy8KICAvLyBUaGUgZmluYWwgc3RhdGUgY2FuIGJlIHJlYWNoZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSBieSBhcHBseWluZyBgYTFgLCBgYTJgLCBgYjEnJ2AgYW5kIGBiMicnYCwgYXMgd2VsbCBhcyBieQogIC8vIGFwcGx5aW5nIGBiMWAsIGBiMmAsIGBhMScnYCwgYGEyJydgLiBOb3RlIGhvdyB0aGUgb3BlcmF0aW9ucyBnZXQgdG8gYSBwcm9wZXIgY29tbW9uIHN0YXRlIGJlZm9yZSBlYWNoIHBhaXIgaXMKICAvLyB0cmFuc2Zvcm1lZC4KICAvLwogIC8vIEFub3RoZXIgdGhpbmcgdG8gY29uc2lkZXIgaXMgdGhhdCBhbiBvcGVyYXRpb24gZHVyaW5nIHRyYW5zZm9ybWF0aW9uIGNhbiBiZSBicm9rZW4gaW50byBtdWx0aXBsZSBvcGVyYXRpb25zLgogIC8vIFN1cHBvc2UgdGhhdCBgYTFgICogYGIxYCA9IGBbIGExMScsIGExMicgXWAgKGluc3RlYWQgb2YgYGExJ2AgdGhhdCB3ZSBjb25zaWRlcmVkIHByZXZpb3VzbHkpLgogIC8vCiAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBsZWF2ZSBgYTEyJ2AgZm9yIGxhdGVyIGFuZCB3ZSBjb250aW51ZSB0cmFuc2Zvcm1pbmcgYGExMSdgIHVudGlsIGl0IGlzIHRyYW5zZm9ybWVkIGJ5IGFsbCBgb3BlcmF0aW9uc0JgCiAgLy8gKGluIG91ciBjYXNlIGl0IGlzIGp1c3QgYGIyYCkuIEF0IHRoaXMgcG9pbnQsIGBiMWAgaXMgdHJhbnNmb3JtZWQgYnkgIndob2xlIiBgYTFgLCB3aGlsZSBgYjJgIGlzIG9ubHkgdHJhbnNmb3JtZWQKICAvLyBieSBgYTExJ2AuIFNpbWlsYXJseSwgYGExMidgIGlzIG9ubHkgdHJhbnNmb3JtZWQgYnkgYGIxYC4gVGhpcyBsZWFkcyB0byBhIGNvbmNsdXNpb24gdGhhdCB3ZSBuZWVkIHRvIHN0YXJ0IHRyYW5zZm9ybWluZyBgYTEyJ2AKICAvLyBmcm9tIHRoZSBtb21lbnQganVzdCBhZnRlciBpdCB3YXMgYnJva2VuLiBTbywgYGExMidgIGlzIHRyYW5zZm9ybWVkIGJ5IGBiMmAuIE5vdywgInRoZSB3aG9sZSIgYGExYCBpcyB0cmFuc2Zvcm1lZAogIC8vIGJ5IGBvcGVyYXRpb25zQmAsIHdoaWxlIGFsbCBgb3BlcmF0aW9uc0JgIGFyZSB0cmFuc2Zvcm1lZCBieSAidGhlIHdob2xlIiBgYTFgLiBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGNvbnRpbnVlIHdpdGgKICAvLyBmb2xsb3dpbmcgYG9wZXJhdGlvbnNBYCAoaW4gb3VyIGNhc2UgaXQgaXMganVzdCBgYTJgKS4KICAvLwogIC8vIE9mIGNvdXJzZSwgYWxzbyBgb3BlcmF0aW9uc0JgIGNhbiBiZSBicm9rZW4uIEhvd2V2ZXIsIHNpbmNlIHdlIGZvY3VzIG9uIHRyYW5zZm9ybWluZyBvcGVyYXRpb24gYGFgIHRvIHRoZSBlbmQsCiAgLy8gdGhlIG9ubHkgdGhpbmcgdG8gZG8gaXMgdG8gc3RvcmUgYm90aCBwaWVjZXMgb2Ygb3BlcmF0aW9uIGBiYCwgc28gdGhhdCB0aGUgbmV4dCB0cmFuc2Zvcm1lZCBvcGVyYXRpb24gYGFgIHdpbGwKICAvLyBiZSB0cmFuc2Zvcm1lZCBieSBib3RoIG9mIHRoZW0uCiAgLy8KICAvLyAgICAgICAgICAgICAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgICAgICAgICAgIC8gXAogIC8vICAgICAgICAgICAgICAgICAgICAgLyAgIFwKICAvLyAgICAgICAgICAgICAgICAgICAgLyAgICAgXAogIC8vICAgICAgICAgICAgICAgICAgYjEgICAgICAgYTEKICAvLyAgICAgICAgICAgICAgICAgIC8gICAgICAgICBcCiAgLy8gICAgICAgICAgICAgICAgIC8gICAgICAgICAgIFwKICAvLyAgICAgICAgICAgICAgICAvICAgICAgICAgICAgIFwKICAvLyAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAqCiAgLy8gICAgICAgICAgICAgIC8gXCAgICAgICAgICAgICAvIFwKICAvLyAgICAgICAgICAgICAvICBhMTEnICAgICAgICAgLyAgIFwKICAvLyAgICAgICAgICAgIC8gICAgIFwgICAgICAgICAvICAgICBcCiAgLy8gICAgICAgICAgYjIgICAgICAgKiAgICAgIGIxJyAgICAgIGEyCiAgLy8gICAgICAgICAgLyAgICAgICAvIFwgICAgIC8gICAgICAgICBcCiAgLy8gICAgICAgICAvICAgICAgIC8gIGExMicgLyAgICAgICAgICAgXAogIC8vICAgICAgICAvICAgICAgIC8gICAgIFwgLyAgICAgICAgICAgICBcCiAgLy8gICAgICAgKiAgICAgICBiMicgICAgICogICAgICAgICAgICAgICAqCiAgLy8gICAgICAgIFwgICAgIC8gICAgICAgLyBcICAgICAgICAgICAgIC8KICAvLyAgICAgICBhMTEnJyAvICAgICBiMjEnJyBcICAgICAgICAgICAvCiAgLy8gICAgICAgICAgXCAvICAgICAgIC8gICAgIFwgICAgICAgICAvCiAgLy8gICAgICAgICAgICogICAgICAgKiAgICAgIGEyJyAgICAgYjEnJwogIC8vICAgICAgICAgICAgXCAgICAgLyBcICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICBhMTInJyBiMjInJ1wgICAgICAgXCAgIC8KICAvLyAgICAgICAgICAgICAgXCAvICAgICBcICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICAgKiAgICAgIGEyJycgICAgICoKICAvLyAgICAgICAgICAgICAgICBcICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICAgICAgICAgXCAgICAgICBcICBiMjEnJycKICAvLyAgICAgICAgICAgICAgICAgIFwgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAgYTInJycgICAgICAqCiAgLy8gICAgICAgICAgICAgICAgICAgIFwgICAgIC8KICAvLyAgICAgICAgICAgICAgICAgICAgIFwgIGIyMicnJwogIC8vICAgICAgICAgICAgICAgICAgICAgIFwgLwogIC8vICAgICAgICAgICAgICAgICAgICAgICAqCiAgLy8KICAvLyBOb3RlLCBob3cgYGExYCBpcyBicm9rZW4gYW5kIHRyYW5zZm9ybWVkIGludG8gYGExMSdgIGFuZCBgYTEyJ2AsIHdoaWxlIGBiMidgIGdvdCBicm9rZW4gYW5kIHRyYW5zZm9ybWVkIGludG8gYGIyMScnYCBhbmQgYGIyMicnYC4KICAvLwogIC8vIEhhdmluZyBhbGwgdGhhdCBvbiBtaW5kLCBoZXJlIGlzIGFuIG91dGxpbmUgZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGFsZ29yaXRobToKICAvLwogIC8vIDEuIFdlIGhhdmUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCBhcnJheSwgd2hpY2ggd2UgZHluYW1pY2FsbHkgdXBkYXRlIGFzIHRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGdvZXMuCiAgLy8KICAvLyAyLiBXZSB0YWtlIG5leHQgKG9yIGZpcnN0KSBvcGVyYXRpb24gZnJvbSBgb3BlcmF0aW9uc0FgIGFuZCBjaGVjayBmcm9tIHdoaWNoIG9wZXJhdGlvbiBgYmAgd2UgbmVlZCB0byBzdGFydCB0cmFuc2Zvcm1pbmcgaXQuCiAgLy8gQWxsIG9yaWdpbmFsIGBvcGVyYXRpb25zQWAgYXJlIHNldCB0byBiZSB0cmFuc2Zvcm1lZCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvcGVyYXRpb24gYGJgLgogIC8vCiAgLy8gMy4gV2UgdGFrZSBvcGVyYXRpb25zIGZyb20gYG9wZXJhdGlvbnNCYCwgb25lIGJ5IG9uZSwgc3RhcnRpbmcgZnJvbSB0aGUgY29ycmVjdCBvbmUsIGFuZCB0cmFuc2Zvcm0gb3BlcmF0aW9uIGBhYAogIC8vIGJ5IG9wZXJhdGlvbiBgYmAgKGFuZCB2aWNlIHZlcnNhKS4gV2UgdXBkYXRlIGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmAgYnkgcmVwbGFjaW5nIHRoZSBvcmlnaW5hbCBvcGVyYXRpb25zCiAgLy8gd2l0aCB0aGUgdHJhbnNmb3JtYXRpb24gcmVzdWx0cy4KICAvLwogIC8vIDQuIElmIG9wZXJhdGlvbiBpcyBicm9rZW4gaW50byBtdWx0aXBsZSBvcGVyYXRpb25zLCB3ZSBzYXZlIGFsbCB0aGUgbmV3IG9wZXJhdGlvbnMgaW4gdGhlIHBsYWNlIG9mIHRoZQogIC8vIG9yaWdpbmFsIG9wZXJhdGlvbi4KICAvLwogIC8vIDUuIEFkZGl0aW9uYWxseSwgaWYgb3BlcmF0aW9uIGBhYCB3YXMgYnJva2VuLCBmb3IgdGhlICJuZXciIG9wZXJhdGlvbiwgd2UgcmVtZW1iZXIgZnJvbSB3aGljaCBvcGVyYXRpb24gYGJgIGl0IHNob3VsZAogIC8vIGJlIHRyYW5zZm9ybWVkIGJ5LgogIC8vCiAgLy8gNi4gV2UgY29udGludWUgdHJhbnNmb3JtaW5nICJjdXJyZW50IiBvcGVyYXRpb24gYGFgIHVudGlsIGl0IGlzIHRyYW5zZm9ybWVkIGJ5IGFsbCBgb3BlcmF0aW9uc0JgLiBUaGVuLCBnbyB0byAyLgogIC8vIHVubGVzcyB0aGUgbGFzdCBvcGVyYXRpb24gYGFgIHdhcyB0cmFuc2Zvcm1lZC4KICAvLwogIC8vIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobSBpcyBzbGlnaHRseSBkaWZmZXJlbnQsIGFzIG9ubHkgb25lIGxvb3AgKHdoaWxlKSBpcyB1c2VkLgogIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgaGF2ZSAiY3VycmVudCIgYGFgIG9wZXJhdGlvbiB0byB0cmFuc2Zvcm0gYW5kIHdlIHN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBgYmAgb3BlcmF0aW9uCiAgLy8gdG8gdHJhbnNmb3JtIGJ5LiBFYWNoIGxvb3Agb3BlcmF0ZXMgb24gdHdvIGluZGV4ZXMgdGhlbjogaW5kZXggcG9pbnRpbmcgdG8gY3VycmVudGx5IHByb2Nlc3NlZCBgYWAgb3BlcmF0aW9uIGFuZAogIC8vIGluZGV4IHBvaW50aW5nIHRvIG5leHQgYGJgIG9wZXJhdGlvbi4gRWFjaCBsb29wIGlzIGp1c3Qgb25lIGBhICogYmAgKyBgYiAqIGFgIHRyYW5zZm9ybWF0aW9uLiBBZnRlciBlYWNoIGxvb3AKICAvLyBvcGVyYXRpb24gYGJgIGluZGV4IGlzIHVwZGF0ZWQuIElmIGFsbCBgYmAgb3BlcmF0aW9ucyB3ZXJlIHZpc2l0ZWQgZm9yIHRoZSBjdXJyZW50IGBhYCBvcGVyYXRpb24sIHdlIGNoYW5nZQogIC8vIGN1cnJlbnQgYGFgIG9wZXJhdGlvbiBpbmRleCB0byB0aGUgbmV4dCBvbmUuCiAgLy8KICAvLyBGb3IgZWFjaCBvcGVyYXRpb24gYGFgLCBrZWVwcyBpbmZvcm1hdGlvbiB3aGF0IGlzIHRoZSBpbmRleCBpbiBgb3BlcmF0aW9uc0JgIGZyb20gd2hpY2ggdGhlIHRyYW5zZm9ybWF0aW9uIHNob3VsZCBzdGFydC4KCgogIHZhciBuZXh0VHJhbnNmb3JtSW5kZXggPSBuZXcgV2Vha01hcCgpOyAvLyBGb3IgYWxsIHRoZSBvcmlnaW5hbCBgb3BlcmF0aW9uc0FgLCBzZXQgdGhhdCB0aGV5IHNob3VsZCBiZSB0cmFuc2Zvcm1lZCBzdGFydGluZyBmcm9tIHRoZSBmaXJzdCBvZiBgb3BlcmF0aW9uc0JgLgoKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7CiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb3BlcmF0aW9uc0FbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7CiAgICAgIHZhciBvcCA9IF9zdGVwLnZhbHVlOwogICAgICBuZXh0VHJhbnNmb3JtSW5kZXguc2V0KG9wLCAwKTsKICAgIH0gLy8gQWRkaXRpb25hbCBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29tZSBwb3N0cHJvY2Vzc2luZyBhZnRlciB0aGUgbWFpbiB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzIGlzIGRvbmUuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICB9CiAgICB9CiAgfQoKICB2YXIgZGF0YSA9IHsKICAgIG5leHRCYXNlVmVyc2lvbkE6IG9wZXJhdGlvbnNBW29wZXJhdGlvbnNBLmxlbmd0aCAtIDFdLmJhc2VWZXJzaW9uICsgMSwKICAgIG5leHRCYXNlVmVyc2lvbkI6IG9wZXJhdGlvbnNCW29wZXJhdGlvbnNCLmxlbmd0aCAtIDFdLmJhc2VWZXJzaW9uICsgMSwKICAgIG9yaWdpbmFsT3BlcmF0aW9uc0FDb3VudDogb3BlcmF0aW9uc0EubGVuZ3RoLAogICAgb3JpZ2luYWxPcGVyYXRpb25zQkNvdW50OiBvcGVyYXRpb25zQi5sZW5ndGgKICB9OyAvLyBJbmRleCBvZiBjdXJyZW50bHkgdHJhbnNmb3JtZWQgb3BlcmF0aW9uIGBhYC4KCiAgdmFyIGkgPSAwOyAvLyBXaGlsZSBub3QgYWxsIGBvcGVyYXRpb25zQWAgYXJlIHRyYW5zZm9ybWVkLi4uCgogIHdoaWxlIChpIDwgb3BlcmF0aW9uc0EubGVuZ3RoKSB7CiAgICB2YXIgX29wZXJhdGlvbnNBLCBfb3BlcmF0aW9uc0I7CgogICAgLy8gR2V0ICJjdXJyZW50IiBvcGVyYXRpb24gYGFgLgogICAgdmFyIG9wQSA9IG9wZXJhdGlvbnNBW2ldOyAvLyBGb3IgdGhlICJjdXJyZW50IiBvcGVyYXRpb24gYGFgLCBnZXQgdGhlIGluZGV4IG9mIHRoZSBuZXh0IG9wZXJhdGlvbiBgYmAgdG8gdHJhbnNmb3JtIGJ5LgoKICAgIHZhciBpbmRleEIgPSBuZXh0VHJhbnNmb3JtSW5kZXguZ2V0KG9wQSk7IC8vIElmIG9wZXJhdGlvbiBgYWAgd2FzIGFscmVhZHkgdHJhbnNmb3JtZWQgYnkgZXZlcnkgb3BlcmF0aW9uIGBiYCwgY2hhbmdlICJjdXJyZW50IiBvcGVyYXRpb24gYGFgIHRvIHRoZSBuZXh0IG9uZS4KCiAgICBpZiAoaW5kZXhCID09IG9wZXJhdGlvbnNCLmxlbmd0aCkgewogICAgICBpKys7CiAgICAgIGNvbnRpbnVlOwogICAgfQoKICAgIHZhciBvcEIgPSBvcGVyYXRpb25zQltpbmRleEJdOyAvLyBUcmFuc2Zvcm0gYGFgIGJ5IGBiYCBhbmQgYGJgIGJ5IGBhYC4KCiAgICB2YXIgbmV3T3BzQSA9IHRyYW5zZm9ybShvcEEsIG9wQiwgY29udGV4dEZhY3RvcnkuZ2V0Q29udGV4dChvcEEsIG9wQiwgdHJ1ZSkpOwogICAgdmFyIG5ld09wc0IgPSB0cmFuc2Zvcm0ob3BCLCBvcEEsIGNvbnRleHRGYWN0b3J5LmdldENvbnRleHQob3BCLCBvcEEsIGZhbHNlKSk7IC8vIEFzIGEgcmVzdWx0IHdlIGdldCBvbmUgb3IgbW9yZSBgbmV3T3BzQWAgYW5kIG9uZSBvciBtb3JlIGBuZXdPcHNCYCBvcGVyYXRpb25zLgogICAgLy8gVXBkYXRlIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgb3BlcmF0aW9ucy4KCiAgICBjb250ZXh0RmFjdG9yeS51cGRhdGVSZWxhdGlvbihvcEEsIG9wQik7CiAgICBjb250ZXh0RmFjdG9yeS5zZXRPcmlnaW5hbE9wZXJhdGlvbnMobmV3T3BzQSwgb3BBKTsKICAgIGNvbnRleHRGYWN0b3J5LnNldE9yaWdpbmFsT3BlcmF0aW9ucyhuZXdPcHNCLCBvcEIpOyAvLyBGb3IgbmV3IGBhYCBvcGVyYXRpb25zLCB1cGRhdGUgdGhlaXIgaW5kZXggb2YgdGhlIG5leHQgb3BlcmF0aW9uIGBiYCB0byB0cmFuc2Zvcm0gdGhlbSBieS4KICAgIC8vCiAgICAvLyBUaGlzIGlzIG5lZWRlZCBldmVuIGlmIHRoZXJlIHdhcyBvbmx5IG9uZSByZXN1bHQgKGBhYCB3YXMgbm90IGJyb2tlbikgYmVjYXVzZSB0aGF0IGluZm9ybWF0aW9uIGlzIHVzZWQKICAgIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBsb29wIGV2ZXJ5IHRpbWUuCgogICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTsKICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7CgogICAgdHJ5IHsKICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG5ld09wc0FbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICB2YXIgbmV3T3BBID0gX3N0ZXAyLnZhbHVlOwogICAgICAgIC8vIEFja25vd2xlZGdlLCB0aGF0IG9wZXJhdGlvbiBgYmAgYWxzbyBtaWdodCBiZSBicm9rZW4gaW50byBtdWx0aXBsZSBvcGVyYXRpb25zLgogICAgICAgIC8vCiAgICAgICAgLy8gVGhpcyBpcyB3aHkgd2UgcmFpc2UgYGluZGV4QmAgbm90IGp1c3QgYnkgMS4gSWYgYG5ld09wc0JgIGFyZSBtdWx0aXBsZSBvcGVyYXRpb25zLCB0aGV5IHdpbGwgYmUKICAgICAgICAvLyBzcGxpY2VkIGluIHRoZSBwbGFjZSBvZiBgb3BCYC4gU28gd2UgbmVlZCB0byBjaGFuZ2UgYHRyYW5zZm9ybUJ5YCBhY2NvcmRpbmdseSwgc28gdGhhdCBhbiBvcGVyYXRpb24gd29uJ3QKICAgICAgICAvLyBiZSB0cmFuc2Zvcm1lZCBieSB0aGUgc2FtZSBvcGVyYXRpb24gKHBhcnQgb2YgaXQpIGFnYWluLgogICAgICAgIG5leHRUcmFuc2Zvcm1JbmRleC5zZXQobmV3T3BBLCBpbmRleEIgKyBuZXdPcHNCLmxlbmd0aCk7CiAgICAgIH0gLy8gVXBkYXRlIGBvcGVyYXRpb25zQWAgYW5kIGBvcGVyYXRpb25zQmAgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmVyc2lvbnMuCgogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjsKICAgIH0gZmluYWxseSB7CiAgICAgIHRyeSB7CiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgIH0KICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgKF9vcGVyYXRpb25zQSA9IG9wZXJhdGlvbnNBKS5zcGxpY2UuYXBwbHkoX29wZXJhdGlvbnNBLCBbaSwgMV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuZXdPcHNBKSkpOwoKICAgIChfb3BlcmF0aW9uc0IgPSBvcGVyYXRpb25zQikuc3BsaWNlLmFwcGx5KF9vcGVyYXRpb25zQiwgW2luZGV4QiwgMV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuZXdPcHNCKSkpOwogIH0KCiAgaWYgKG9wdGlvbnMucGFkV2l0aE5vT3BzKSB7CiAgICAvLyBJZiBuby1vcGVyYXRpb25zIHBhZGRpbmcgaXMgZW5hYmxlZCwgY291bnQgaG93IG1hbnkgZXh0cmEgYGFgIGFuZCBgYmAgb3BlcmF0aW9ucyB3ZXJlIGdlbmVyYXRlZC4KICAgIHZhciBicm9rZW5PcGVyYXRpb25zQUNvdW50ID0gb3BlcmF0aW9uc0EubGVuZ3RoIC0gZGF0YS5vcmlnaW5hbE9wZXJhdGlvbnNBQ291bnQ7CiAgICB2YXIgYnJva2VuT3BlcmF0aW9uc0JDb3VudCA9IG9wZXJhdGlvbnNCLmxlbmd0aCAtIGRhdGEub3JpZ2luYWxPcGVyYXRpb25zQkNvdW50OyAvLyBUaGVuLCBpZiB0aGF0IG51bWJlciBpcyBub3QgdGhlIHNhbWUsIHBhZCBgb3BlcmF0aW9uc0FgIG9yIGBvcGVyYXRpb25zQmAgd2l0aCBjb3JyZWN0IG51bWJlciBvZiBuby1vcHMgc28KICAgIC8vIHRoYXQgdGhlIGJhc2UgdmVyc2lvbnMgYXJlIGVxdWFsbGVkLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCBvbmx5IG9uZSBhcnJheSB3aWxsIGJlIHVwZGF0ZWQsIGFzIG9ubHkgb25lIG9mIHRob3NlIHN1YnRyYWN0aW9ucyBjYW4gYmUgZ3JlYXRlciB0aGFuIHplcm8uCgogICAgcGFkV2l0aE5vT3BzKG9wZXJhdGlvbnNBLCBicm9rZW5PcGVyYXRpb25zQkNvdW50IC0gYnJva2VuT3BlcmF0aW9uc0FDb3VudCk7CiAgICBwYWRXaXRoTm9PcHMob3BlcmF0aW9uc0IsIGJyb2tlbk9wZXJhdGlvbnNBQ291bnQgLSBicm9rZW5PcGVyYXRpb25zQkNvdW50KTsKICB9IC8vIEZpbmFsbHksIHVwZGF0ZSBiYXNlIHZlcnNpb25zIG9mIHRyYW5zZm9ybWVkIG9wZXJhdGlvbnMuCgoKICB1cGRhdGVCYXNlVmVyc2lvbnMob3BlcmF0aW9uc0EsIGRhdGEubmV4dEJhc2VWZXJzaW9uQik7CiAgdXBkYXRlQmFzZVZlcnNpb25zKG9wZXJhdGlvbnNCLCBkYXRhLm5leHRCYXNlVmVyc2lvbkEpOwogIHJldHVybiB7CiAgICBvcGVyYXRpb25zQTogb3BlcmF0aW9uc0EsCiAgICBvcGVyYXRpb25zQjogb3BlcmF0aW9uc0IsCiAgICBvcmlnaW5hbE9wZXJhdGlvbnM6IG9yaWdpbmFsT3BlcmF0aW9ucwogIH07Cn0gLy8gR2F0aGVycyBhZGRpdGlvbmFsIGRhdGEgYWJvdXQgb3BlcmF0aW9ucyBwcm9jZXNzZWQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uLiBDYW4gYmUgdXNlZCB0byBvYnRhaW4gY29udGV4dHVhbCBpbmZvcm1hdGlvbgovLyBhYm91dCB0d28gb3BlcmF0aW9ucyB0aGF0IGFyZSBhYm91dCB0byBiZSB0cmFuc2Zvcm1lZC4gVGhpcyBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGNhbiBiZSB1c2VkIGZvciBiZXR0ZXIgY29uZmxpY3QgcmVzb2x1dGlvbi4KCnZhciBDb250ZXh0RmFjdG9yeSA9Ci8qI19fUFVSRV9fKi8KZnVuY3Rpb24gKCkgewogIC8vIENyZWF0ZXMgYENvbnRleHRGYWN0b3J5YCBpbnN0YW5jZS4KICAvLwogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gZG9jdW1lbnQgRG9jdW1lbnQgd2hpY2ggdGhlIG9wZXJhdGlvbnMgY2hhbmdlLgogIC8vIEBwYXJhbSB7Qm9vbGVhbn0gdXNlUmVsYXRpb25zIFdoZXRoZXIgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHJlbGF0aW9ucyBzaG91bGQgYmUgdXNlZCAodXNlZCBkdXJpbmcgdW5kbyBmb3IKICAvLyBiZXR0ZXIgY29uZmxpY3QgcmVzb2x1dGlvbikuCiAgLy8gQHBhcmFtIHtCb29sZWFufSBbZm9yY2VXZWFrUmVtb3ZlPWZhbHNlXSBJZiBzZXQgdG8gYGZhbHNlYCwgcmVtb3ZlIG9wZXJhdGlvbiB3aWxsIGJlIGFsd2F5cyBzdHJvbmdlciB0aGFuIG1vdmUgb3BlcmF0aW9uLAogIC8vIHNvIHRoZSByZW1vdmVkIG5vZGVzIHdvbid0IGVuZCB1cCBiYWNrIGluIHRoZSBkb2N1bWVudCByb290LiBXaGVuIHNldCB0byBgdHJ1ZWAsIGNvbnRleHQgZGF0YSB3aWxsIGJlIHVzZWQuCiAgZnVuY3Rpb24gQ29udGV4dEZhY3RvcnkoZG9jdW1lbnQsIHVzZVJlbGF0aW9ucykgewogICAgdmFyIGZvcmNlV2Vha1JlbW92ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRleHRGYWN0b3J5KTsKCiAgICAvLyBGb3IgZWFjaCBvcGVyYXRpb24gdGhhdCBpcyBjcmVhdGVkIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzLCB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24KICAgIC8vIHdoaWNoIGl0IGNvbWVzIGZyb20uIFRoZSBvcmlnaW5hbCBvcGVyYXRpb24gd29ya3MgYXMgYSBraW5kIG9mICJpZGVudGlmaWVyIi4gRXZlcnkgY29udGV4dHVhbCBpbmZvcm1hdGlvbgogICAgLy8gZ2F0aGVyZWQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgd2Ugd2FudCB0byBzYXZlIGZvciBnaXZlbiBvcGVyYXRpb24sIGlzIGFjdHVhbGx5IHNhdmVkIGZvciB0aGUgb3JpZ2luYWwgb3BlcmF0aW9uLgogICAgLy8gVGhpcyB3YXkgbm8gbWF0dGVyIGlmIG9wZXJhdGlvbiBgYWAgaXMgY2xvbmVkLCB0aGVuIHRyYW5zZm9ybWVkLCBldmVuIGJyZWFrcywgd2Ugc3RpbGwgaGF2ZSBhY2Nlc3MgdG8gdGhlIHByZXZpb3VzbHkKICAgIC8vIGdhdGhlcmVkIGRhdGEgdGhyb3VnaCBvcmlnaW5hbCBvcGVyYXRpb24gcmVmZXJlbmNlLgogICAgdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMgPSBuZXcgTWFwKCk7IC8vIGBtb2RlbC5IaXN0b3J5YCBpbnN0YW5jZSB3aGljaCBpbmZvcm1hdGlvbiBhYm91dCB1bmRvbmUgb3BlcmF0aW9ucyB3aWxsIGJlIHRha2VuIGZyb20uCgogICAgdGhpcy5faGlzdG9yeSA9IGRvY3VtZW50Lmhpc3Rvcnk7IC8vIFdoZXRoZXIgYWRkaXRpb25hbCBjb250ZXh0IHNob3VsZCBiZSB1c2VkLgoKICAgIHRoaXMuX3VzZVJlbGF0aW9ucyA9IHVzZVJlbGF0aW9uczsKICAgIHRoaXMuX2ZvcmNlV2Vha1JlbW92ZSA9ICEhZm9yY2VXZWFrUmVtb3ZlOyAvLyBSZWxhdGlvbnMgaXMgYSBkb3VibGUtbWFwIHN0cnVjdHVyZSAobWFwcyBpbiBtYXApIHdoZXJlIGZvciB0d28gb3BlcmF0aW9ucyB3ZSBzdG9yZSBob3cgdGhvc2Ugb3BlcmF0aW9ucyB3ZXJlIHJlbGF0ZWQKICAgIC8vIHRvIGVhY2ggb3RoZXIuIFRob3NlIHJlbGF0aW9ucyBhcmUgZXZhbHVhdGVkIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzLiBGb3IgZXZlcnkgdHJhbnNmb3JtYXRlZCBwYWlyIG9mIG9wZXJhdGlvbnMKICAgIC8vIHdlIGtlZXAgcmVsYXRpb25zIGJldHdlZW4gdGhlbS4KCiAgICB0aGlzLl9yZWxhdGlvbnMgPSBuZXcgTWFwKCk7CiAgfSAvLyBTZXRzICJvcmlnaW5hbCBvcGVyYXRpb24iIGZvciBnaXZlbiBvcGVyYXRpb25zLgogIC8vCiAgLy8gRHVyaW5nIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MsIG9wZXJhdGlvbnMgYXJlIGNsb25lZCwgdGhlbiBjaGFuZ2VkLCB0aGVuIHByb2Nlc3NlZCBhZ2Fpbiwgc29tZXRpbWVzIGJyb2tlbiBpbnRvIHR3bwogIC8vIG9yIG11bHRpcGxlIG9wZXJhdGlvbnMuIFdoZW4gZ2F0aGVyaW5nIGFkZGl0aW9uYWwgZGF0YSBpdCBpcyBpbXBvcnRhbnQgdGhhdCBhbGwgb3BlcmF0aW9ucyBjYW4gYmUgc29tZWhvdyBsaW5rZWQKICAvLyBzbyBhIGNsb25lZCBhbmQgdHJhbnNmb3JtZWQgInZlcnNpb24iIHN0aWxsIGtlcHQgdHJhY2sgb2YgdGhlIGRhdGEgYXNzaWduZWQgZWFybGllciB0byBpdC4KICAvLwogIC8vIFRoZSBvcmlnaW5hbCBvcGVyYXRpb24gb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBzdWNoIGFuIHVuaXZlcnNhbCBsaW5raW5nIGlkLiBUaHJvdWdob3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBwcm9jZXNzCiAgLy8gYWxsIGNsb25lZCBvcGVyYXRpb25zIHdpbGwgcmVmZXIgdG8gInRoZSBvcmlnaW5hbCBvcGVyYXRpb24iIHdoZW4gc3RvcmluZyBhbmQgcmVhZGluZyBhZGRpdGlvbmFsIGRhdGEuCiAgLy8KICAvLyBJZiBgdGFrZUZyb21gIGlzIG5vdCBzZXQsIGVhY2ggb3BlcmF0aW9uIGZyb20gYG9wZXJhdGlvbnNgIGFycmF5IHdpbGwgYmUgYXNzaWduZWQgaXRzZWxmIGFzICJ0aGUgb3JpZ2luYWwgb3BlcmF0aW9uIi4KICAvLyBUaGlzIHNob3VsZCBiZSB1c2VkIGFzIGFuIGluaXRpYWxpemF0aW9uIHN0ZXAuCiAgLy8KICAvLyBJZiBgdGFrZUZyb21gIGlzIHNldCwgZWFjaCBvcGVyYXRpb24gZnJvbSBgb3BlcmF0aW9uc2Agd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBvcmlnaW5hbCBvcGVyYXRpb24gYXMgYXNzaWduZWQKICAvLyBmb3IgYHRha2VGcm9tYCBvcGVyYXRpb24uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gdXBkYXRlIG9yaWdpbmFsIG9wZXJhdGlvbnMuIEl0IHNob3VsZCBiZSB1c2VkIGluIGEgd2F5IHRoYXQKICAvLyBgb3BlcmF0aW9uc2AgYXJlIHRoZSByZXN1bHQgb2YgYHRha2VGcm9tYCB0cmFuc2Zvcm1hdGlvbiB0byBlbnN1cmUgcHJvcGVyICJvcmlnaW5hbCBvcGVyYXRpb24gcHJvcGFnYXRpb24iLgogIC8vCiAgLy8gQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnMKICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb258bnVsbH0gW3Rha2VGcm9tPW51bGxdCgoKICBfY3JlYXRlQ2xhc3MoQ29udGV4dEZhY3RvcnksIFt7CiAgICBrZXk6ICJzZXRPcmlnaW5hbE9wZXJhdGlvbnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdpbmFsT3BlcmF0aW9ucyhvcGVyYXRpb25zKSB7CiAgICAgIHZhciB0YWtlRnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDsKICAgICAgdmFyIG9yaWdpbmFsT3BlcmF0aW9uID0gdGFrZUZyb20gPyB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQodGFrZUZyb20pIDogbnVsbDsKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTsKICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlOwogICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gb3BlcmF0aW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkgewogICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgIHRoaXMub3JpZ2luYWxPcGVyYXRpb25zLnNldChvcGVyYXRpb24sIG9yaWdpbmFsT3BlcmF0aW9uIHx8IG9wZXJhdGlvbik7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgICB9CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSAvLyBTYXZlcyBhIHJlbGF0aW9uIGJldHdlZW4gb3BlcmF0aW9ucyBgb3BBYCBhbmQgYG9wQmAuCiAgICAvLwogICAgLy8gUmVsYXRpb25zIGFyZSB0aGVuIGxhdGVyIHVzZWQgdG8gaGVscCBzb2x2ZSBjb25mbGljdHMgd2hlbiBvcGVyYXRpb25zIGFyZSB0cmFuc2Zvcm1lZC4KICAgIC8vCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKCiAgfSwgewogICAga2V5OiAidXBkYXRlUmVsYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJlbGF0aW9uKG9wQSwgb3BCKSB7CiAgICAgIC8vIFRoZSB1c2Ugb2YgcmVsYXRpb25zIGlzIGRlc2NyaWJlZCBpbiBhIGJpZ2dlciBkZXRhaWwgaW4gdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zLgogICAgICAvLwogICAgICAvLyBJbiBicmllZiwgdGhpcyBmdW5jdGlvbiwgZm9yIHNwZWNpZmllZCBwYWlycyBvZiBvcGVyYXRpb24gdHlwZXMsIGNoZWNrcyBob3cgcG9zaXRpb25zIGRlZmluZWQgaW4gdGhvc2Ugb3BlcmF0aW9ucyByZWxhdGUuCiAgICAgIC8vIFRoZW4gdGhvc2UgcmVsYXRpb25zIGFyZSBzYXZlZC4gRm9yIGV4YW1wbGUsIGZvciB0d28gbW92ZSBvcGVyYXRpb25zLCBpdCBpcyBzYXZlZCBpZiBvbmUgb2YgdGhvc2Ugb3BlcmF0aW9ucyB0YXJnZXQKICAgICAgLy8gcG9zaXRpb24gaXMgYmVmb3JlIHRoZSBvdGhlciBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uLiBUaGlzIGtpbmQgb2YgaW5mb3JtYXRpb24gZ2l2ZXMgY29udGV4dHVhbCBpbmZvcm1hdGlvbiB3aGVuCiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIGlzIHVzZWQgZHVyaW5nIHVuZG8uIFNpbWlsYXIgY2hlY2tzIGFyZSBkb25lIGZvciBvdGhlciBwYWlycyBvZiBvcGVyYXRpb25zLgogICAgICAvLwogICAgICBzd2l0Y2ggKG9wQS5jb25zdHJ1Y3RvcikgewogICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgIHsKICAgICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKSB8fCBvcEIubW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKG9wQS50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ2luc2VydEF0U291cmNlJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdpbnNlcnRCZXR3ZWVuJyk7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzQWZ0ZXIob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnbW92ZVRhcmdldEFmdGVyJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIE1vdmVPcGVyYXRpb246CiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgIGlmIChvcEEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pIHx8IG9wQS50YXJnZXRQb3NpdGlvbi5pc0JlZm9yZShvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdpbnNlcnRCZWZvcmUnKTsKICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ2luc2VydEFmdGVyJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgY2FzZSBTcGxpdE9wZXJhdGlvbjoKICAgICAgICAgIHsKICAgICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnNwbGl0UG9zaXRpb24uaXNCZWZvcmUob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnc3BsaXRCZWZvcmUnKTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgaWYgKG9wQS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKSB8fCBvcEEuc3BsaXRQb3NpdGlvbi5pc0JlZm9yZShvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdzcGxpdEJlZm9yZScpOwogICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgTWVyZ2VPcGVyYXRpb246CiAgICAgICAgICB7CiAgICAgICAgICAgIHN3aXRjaCAob3BCLmNvbnN0cnVjdG9yKSB7CiAgICAgICAgICAgICAgY2FzZSBNZXJnZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgaWYgKCFvcEEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVRhcmdldE5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChvcEEuc291cmNlUG9zaXRpb24uaXNFcXVhbChvcEIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNvdXJjZU5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGlmIChvcEEuc291cmNlUG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNhbWVFbGVtZW50Jyk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIFNwbGl0T3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICBpZiAob3BBLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwob3BCLnNwbGl0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdzcGxpdEF0U291cmNlJyk7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgIGNhc2UgTWFya2VyT3BlcmF0aW9uOgogICAgICAgICAgewogICAgICAgICAgICB2YXIgbWFya2VyUmFuZ2UgPSBvcEEubmV3UmFuZ2U7CgogICAgICAgICAgICBpZiAoIW1hcmtlclJhbmdlKSB7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CgogICAgICAgICAgICBzd2l0Y2ggKG9wQi5jb25zdHJ1Y3RvcikgewogICAgICAgICAgICAgIGNhc2UgTW92ZU9wZXJhdGlvbjoKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQob3BCLnNvdXJjZVBvc2l0aW9uLCBvcEIuaG93TWFueSk7CgogICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRMZWZ0ID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKG1hcmtlclJhbmdlLnN0YXJ0KSB8fCBtb3ZlZFJhbmdlLnN0YXJ0LmlzRXF1YWwobWFya2VyUmFuZ2Uuc3RhcnQpOwogICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRSaWdodCA9IG1vdmVkUmFuZ2UuY29udGFpbnNQb3NpdGlvbihtYXJrZXJSYW5nZS5lbmQpIHx8IG1vdmVkUmFuZ2UuZW5kLmlzRXF1YWwobWFya2VyUmFuZ2UuZW5kKTsKCiAgICAgICAgICAgICAgICAgIGlmICgoYWZmZWN0ZWRMZWZ0IHx8IGFmZmVjdGVkUmlnaHQpICYmICFtb3ZlZFJhbmdlLmNvbnRhaW5zUmFuZ2UobWFya2VyUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsIHsKICAgICAgICAgICAgICAgICAgICAgIHNpZGU6IGFmZmVjdGVkTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsCiAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBhZmZlY3RlZExlZnQgPyBtYXJrZXJSYW5nZS5zdGFydC5wYXRoLnNsaWNlKCkgOiBtYXJrZXJSYW5nZS5lbmQucGF0aC5zbGljZSgpCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBjYXNlIE1lcmdlT3BlcmF0aW9uOgogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICB2YXIgd2FzSW5MZWZ0RWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLnRhcmdldFBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgdmFyIHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pOwogICAgICAgICAgICAgICAgICB2YXIgd2FzRW5kQmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLmVuZC5pc0VxdWFsKG9wQi5kZWxldGlvblBvc2l0aW9uKTsKICAgICAgICAgICAgICAgICAgdmFyIHdhc0luUmlnaHRFbGVtZW50ID0gbWFya2VyUmFuZ2UuZW5kLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKTsKCiAgICAgICAgICAgICAgICAgIGlmICh3YXNJbkxlZnRFbGVtZW50IHx8IHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCB8fCB3YXNFbmRCZWZvcmVNZXJnZWRFbGVtZW50IHx8IHdhc0luUmlnaHRFbGVtZW50KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsIHsKICAgICAgICAgICAgICAgICAgICAgIHdhc0luTGVmdEVsZW1lbnQ6IHdhc0luTGVmdEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgICB3YXNTdGFydEJlZm9yZU1lcmdlZEVsZW1lbnQ6IHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCwKICAgICAgICAgICAgICAgICAgICAgIHdhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQ6IHdhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgICB3YXNJblJpZ2h0RWxlbWVudDogd2FzSW5SaWdodEVsZW1lbnQKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICB9CiAgICB9IC8vIEV2YWx1YXRlcyBhbmQgcmV0dXJucyBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IHR3byBnaXZlbiBvcGVyYXRpb25zIGBvcEFgIGFuZCBgb3BCYCB3aGljaCBhcmUgYWJvdXQgdG8gYmUgdHJhbnNmb3JtZWQuCiAgICAvLwogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEEKICAgIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BCCiAgICAvLyBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtflRyYW5zZm9ybWF0aW9uQ29udGV4dH0KCiAgfSwgewogICAga2V5OiAiZ2V0Q29udGV4dCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dChvcEEsIG9wQiwgYUlzU3Ryb25nKSB7CiAgICAgIHJldHVybiB7CiAgICAgICAgYUlzU3Ryb25nOiBhSXNTdHJvbmcsCiAgICAgICAgYVdhc1VuZG9uZTogdGhpcy5fd2FzVW5kb25lKG9wQSksCiAgICAgICAgYldhc1VuZG9uZTogdGhpcy5fd2FzVW5kb25lKG9wQiksCiAgICAgICAgYWJSZWxhdGlvbjogdGhpcy5fdXNlUmVsYXRpb25zID8gdGhpcy5fZ2V0UmVsYXRpb24ob3BBLCBvcEIpIDogbnVsbCwKICAgICAgICBiYVJlbGF0aW9uOiB0aGlzLl91c2VSZWxhdGlvbnMgPyB0aGlzLl9nZXRSZWxhdGlvbihvcEIsIG9wQSkgOiBudWxsLAogICAgICAgIGZvcmNlV2Vha1JlbW92ZTogdGhpcy5fZm9yY2VXZWFrUmVtb3ZlCiAgICAgIH07CiAgICB9IC8vIFJldHVybnMgd2hldGhlciBnaXZlbiBvcGVyYXRpb24gYG9wYCBoYXMgYWxyZWFkeSBiZWVuIHVuZG9uZS4KICAgIC8vCiAgICAvLyBJbmZvcm1hdGlvbiB3aGV0aGVyIGFuIG9wZXJhdGlvbiB3YXMgdW5kb25lIGdpdmVzIG1vcmUgY29udGV4dCB3aGVuIG1ha2luZyBhIGRlY2lzaW9uIHdoZW4gdHdvIG9wZXJhdGlvbnMgYXJlIGluIGNvbmZsaWN0LgogICAgLy8KICAgIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3AKICAgIC8vIEByZXR1cm5zIHtCb29sZWFufQoKICB9LCB7CiAgICBrZXk6ICJfd2FzVW5kb25lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfd2FzVW5kb25lKG9wKSB7CiAgICAgIC8vIEZvciBgb3BgLCBnZXQgaXRzIG9yaWdpbmFsIG9wZXJhdGlvbi4gQWZ0ZXIgYWxsLCBpZiBgb3BgIGlzIGEgY2xvbmUgKG9yIGV2ZW4gdHJhbnNmb3JtZWQgY2xvbmUpIG9mIGFub3RoZXIKICAgICAgLy8gb3BlcmF0aW9uLCBsaXRlcmFsbHkgYG9wYCBjb3VsZG4ndCBiZSB1bmRvbmUuIEl0IHdhcyBqdXN0IGdlbmVyYXRlZC4gSWYgYW55dGhpbmcsIGl0IHdhcyB0aGUgb3BlcmF0aW9uIGl0IG9yaWdpbnMKICAgICAgLy8gZnJvbSB3aGljaCB3YXMgdW5kb25lLiBTbyBnZXQgdGhhdCBvcmlnaW5hbCBvcGVyYXRpb24uCiAgICAgIHZhciBvcmlnaW5hbE9wID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wKTsgLy8gQW5kIGNoZWNrIHdpdGggdGhlIGRvY3VtZW50IGlmIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KCiAgICAgIHJldHVybiBvcmlnaW5hbE9wLndhc1VuZG9uZSB8fCB0aGlzLl9oaXN0b3J5LmlzVW5kb25lT3BlcmF0aW9uKG9yaWdpbmFsT3ApOwogICAgfSAvLyBSZXR1cm5zIGEgcmVsYXRpb24gYmV0d2VlbiBgb3BBYCBhbmQgYW4gb3BlcmF0aW9uIHdoaWNoIGlzIHVuZG9uZSBieSBgb3BCYC4gVGhpcyBjYW4gYmUgYFN0cmluZ2AgdmFsdWUgaWYgYSByZWxhdGlvbgogICAgLy8gd2FzIHNldCBlYXJsaWVyIG9yIGBudWxsYCBpZiB0aGVyZSB3YXMgbm8gcmVsYXRpb24gYmV0d2VlbiB0aG9zZSBvcGVyYXRpb25zLgogICAgLy8KICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgdHJpY2t5IHRvIHVuZGVyc3RhbmQsIHNvIGxldCdzIGNvbXBhcmUgaXQgdG8gYENvbnRleHRGYWN0b3J5I193YXNVbmRvbmVgLgogICAgLy8KICAgIC8vIFdoZW4gYHdhc1VuZG9uZSggb3BCIClgIGlzIHVzZWQsIHdlIGNoZWNrIGlmIHRoZSBgb3BCYCBoYXMgYWxyZWFkeSBiZWVuIHVuZG9uZS4gSXQgaXMgb2J2aW91cywgdGhhdCB0aGUKICAgIC8vIHVuZG9pbmcgb3BlcmF0aW9uIG11c3QgaGFwcGVuIGFmdGVyIHRoZSB1bmRvbmUgb3BlcmF0aW9uLiBTbywgZXNzZW50aWFsbHksIHdlIGhhdmUgYG9wQmAsIHdlIHRha2UgZG9jdW1lbnQgaGlzdG9yeSwKICAgIC8vIHdlIGxvb2sgZm9yd2FyZCBpbiB0aGUgZnV0dXJlIGFuZCBhc2sgaWYgaW4gdGhhdCBmdXR1cmUgYG9wQmAgd2FzIHVuZG9uZS4KICAgIC8vCiAgICAvLyBSZWxhdGlvbnMgaXMgYSBiYWNrd2FyZCBwcm9jZXNzIHRvIGB3YXNVbmRvbmUoKWAuCiAgICAvLwogICAgLy8gTG9uZyBzdG9yeSBzaG9ydCAtIHVzaW5nIHJlbGF0aW9ucyBpcyBhc2tpbmcgd2hhdCBoYXBwZW5lZCBpbiB0aGUgcGFzdC4gTG9va2luZyBiYWNrLiBUaGlzIHRpbWUgd2UgaGF2ZSBhbiB1bmRvaW5nCiAgICAvLyBvcGVyYXRpb24gYG9wQmAgd2hpY2ggaGFzIHVuZG9uZSBzb21lIG90aGVyIG9wZXJhdGlvbi4gV2hlbiB0aGVyZSBpcyBhIHRyYW5zZm9ybWF0aW9uIGBvcEFgIHggYG9wQmAgYW5kIHRoZXJlIGlzCiAgICAvLyBhIGNvbmZsaWN0IHRvIHNvbHZlIGFuZCBgb3BCYCBpcyBhbiB1bmRvaW5nIG9wZXJhdGlvbiwgd2UgY2FuIGxvb2sgYmFjayBpbiB0aGUgaGlzdG9yeSBhbmQgc2VlIHdoYXQgd2FzIGEgcmVsYXRpb24KICAgIC8vIGJldHdlZW4gYG9wQWAgYW5kIHRoZSBvcGVyYXRpb24gd2hpY2ggYG9wQmAgdW5kb25lLiBCYXNpbmcgb24gdGhhdCByZWxhdGlvbiBmcm9tIHRoZSBwYXN0LCB3ZSBjYW4gbm93IG1ha2UKICAgIC8vIGEgYmV0dGVyIGRlY2lzaW9uIHdoZW4gcmVzb2x2aW5nIGEgY29uZmxpY3QgYmV0d2VlbiB0d28gb3BlcmF0aW9ucywgYmVjYXVzZSB3ZSBrbm93IG1vcmUgYWJvdXQgdGhlIGNvbnRleHQgb2YKICAgIC8vIHRob3NlIHR3byBvcGVyYXRpb25zLgogICAgLy8KICAgIC8vIFRoaXMgaXMgd2h5IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgcmVsYXRpb24gZGlyZWN0bHkgYmV0d2VlbiBgb3BBYCBhbmQgYG9wQmAgYmVjYXVzZSB3ZSBuZWVkIHRvIGxvb2sKICAgIC8vIGJhY2sgdG8gc2VhcmNoIGZvciBhIG1lYW5pbmdmdWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbi4KICAgIC8vCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKICAgIC8vIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0KCiAgfSwgewogICAga2V5OiAiX2dldFJlbGF0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVsYXRpb24ob3BBLCBvcEIpIHsKICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBvcGVyYXRpb24uIFNpbWlsYXJseSBhcyBpbiBgd2FzVW5kb25lKClgIGl0IGlzIHVzZWQgYXMgYW4gdW5pdmVyc2FsIGlkZW50aWZpZXIgZm9yIHN0b3JlZCBkYXRhLgogICAgICB2YXIgb3JpZ0IgPSB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQob3BCKTsKCiAgICAgIHZhciB1bmRvbmVCID0gdGhpcy5faGlzdG9yeS5nZXRVbmRvbmVPcGVyYXRpb24ob3JpZ0IpOyAvLyBJZiBgb3BCYCBpcyBub3QgdW5kb2luZyBhbnkgb3BlcmF0aW9uLCB0aGVyZSBpcyBubyByZWxhdGlvbi4KCgogICAgICBpZiAoIXVuZG9uZUIpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIG9yaWdBID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wQSk7CgogICAgICB2YXIgcmVsYXRpb25zQSA9IHRoaXMuX3JlbGF0aW9ucy5nZXQob3JpZ0EpOyAvLyBHZXQgYWxsIHJlbGF0aW9ucyBmb3IgYG9wQWAsIGFuZCBjaGVjayBpZiB0aGVyZSBpcyBhIHJlbGF0aW9uIHdpdGggYG9wQmAtdW5kb25lLWNvdW50ZXJwYXJ0LiBJZiBzbywgcmV0dXJuIGl0LgoKCiAgICAgIGlmIChyZWxhdGlvbnNBKSB7CiAgICAgICAgcmV0dXJuIHJlbGF0aW9uc0EuZ2V0KHVuZG9uZUIpIHx8IG51bGw7CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBDb250ZXh0RmFjdG9yeSN1cGRhdGVSZWxhdGlvbnNgLgogICAgLy8KICAgIC8vIEBwcml2YXRlCiAgICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogICAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKICAgIC8vIEBwYXJhbSB7U3RyaW5nfSByZWxhdGlvbgoKICB9LCB7CiAgICBrZXk6ICJfc2V0UmVsYXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZWxhdGlvbihvcEEsIG9wQiwgcmVsYXRpb24pIHsKICAgICAgLy8gQXMgYWx3YXlzLCBzZXR0aW5nIGlzIGZvciBvcmlnaW5hbCBvcGVyYXRpb25zLCBub3QgdGhlIGNsb25lcy90cmFuc2Zvcm1lZCBvcGVyYXRpb25zLgogICAgICB2YXIgb3JpZ0EgPSB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQob3BBKTsKICAgICAgdmFyIG9yaWdCID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wQik7CgogICAgICB2YXIgcmVsYXRpb25zQSA9IHRoaXMuX3JlbGF0aW9ucy5nZXQob3JpZ0EpOwoKICAgICAgaWYgKCFyZWxhdGlvbnNBKSB7CiAgICAgICAgcmVsYXRpb25zQSA9IG5ldyBNYXAoKTsKCiAgICAgICAgdGhpcy5fcmVsYXRpb25zLnNldChvcmlnQSwgcmVsYXRpb25zQSk7CiAgICAgIH0KCiAgICAgIHJlbGF0aW9uc0Euc2V0KG9yaWdCLCByZWxhdGlvbik7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gQ29udGV4dEZhY3Rvcnk7Cn0oKTsKLyoqCiAqIEhvbGRzIGFkZGl0aW9uYWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCBhIHRyYW5zZm9ybWVkIHBhaXIgb2Ygb3BlcmF0aW9ucyAoYGFgIGFuZCBgYmApLiBUaG9zZSBpbmZvcm1hdGlvbgogKiBjYW4gYmUgdXNlZCBmb3IgYmV0dGVyIGNvbmZsaWN0IHJlc29sdmluZy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtflRyYW5zZm9ybWF0aW9uQ29udGV4dAogKgogKiBAcHJvcGVydHkge0Jvb2xlYW59IGFJc1N0cm9uZyBXaGV0aGVyIGBhYCBpcyBzdHJvbmcgb3BlcmF0aW9uIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIG9yIHdlYWsuCiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYVdhc1VuZG9uZSBXaGV0aGVyIGBhYCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KICogQHByb3BlcnR5IHtCb29sZWFufSBiV2FzVW5kb25lIFdoZXRoZXIgYGJgIG9wZXJhdGlvbiB3YXMgdW5kb25lLgogKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBhYlJlbGF0aW9uIFRoZSByZWxhdGlvbiBiZXR3ZWVuIGBhYCBvcGVyYXRpb24gYW5kIGFuIG9wZXJhdGlvbiB1bmRvbmUgYnkgYGJgIG9wZXJhdGlvbi4KICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gYmFSZWxhdGlvbiBUaGUgcmVsYXRpb24gYmV0d2VlbiBgYmAgb3BlcmF0aW9uIGFuZCBhbiBvcGVyYXRpb24gdW5kb25lIGJ5IGBhYCBvcGVyYXRpb24uCiAqLwoKLyoqCiAqIEFuIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uI2Jhc2VWZXJzaW9uIGJhc2UgdmVyc2lvbnN9CiAqIG9mIHBhc3NlZCBvcGVyYXRpb25zLgogKgogKiBUaGUgZnVuY3Rpb24gc2ltcGx5IHNldHMgYGJhc2VWZXJzaW9uYCBhcyBhIGJhc2UgdmVyc2lvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIG9wZXJhdGlvbiBhbmQgdGhlbiBpbmNyZW1lbnRzIGl0IGZvcgogKiBlYWNoIGZvbGxvd2luZyBvcGVyYXRpb24gaW4gYG9wZXJhdGlvbnNgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gb3BlcmF0aW9ucyBPcGVyYXRpb25zIHRvIHVwZGF0ZS4KICogQHBhcmFtIHtOdW1iZXJ9IGJhc2VWZXJzaW9uIEJhc2UgdmVyc2lvbiB0byBzZXQgZm9yIHRoZSBmaXJzdCBvcGVyYXRpb24gaW4gYG9wZXJhdGlvbnNgLgogKi8KCgpmdW5jdGlvbiB1cGRhdGVCYXNlVmVyc2lvbnMob3BlcmF0aW9ucywgYmFzZVZlcnNpb24pIHsKICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICB0cnkgewogICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IG9wZXJhdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgdmFyIG9wZXJhdGlvbiA9IF9zdGVwNC52YWx1ZTsKICAgICAgb3BlcmF0aW9uLmJhc2VWZXJzaW9uID0gYmFzZVZlcnNpb24rKzsKICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7CiAgICAgIH0KICAgIH0KICB9Cn0KLyoqCiAqIEFkZHMgYGhvd01hbnlgIGluc3RhbmNlcyBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbm9vcGVyYXRpb25+Tm9PcGVyYXRpb259IHRvIGBvcGVyYXRpb25zYCBzZXQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zCiAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55CiAqLwoKCmZ1bmN0aW9uIHBhZFdpdGhOb09wcyhvcGVyYXRpb25zLCBob3dNYW55KSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHsKICAgIG9wZXJhdGlvbnMucHVzaChuZXcgTm9PcGVyYXRpb24oMCkpOwogIH0KfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgQXR0cmlidXRlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChhLmtleSA9PT0gYi5rZXkpIHsKICAgIC8vIElmIG9wZXJhdGlvbnMgYXR0cmlidXRlcyBhcmUgaW4gY29uZmxpY3QsIGNoZWNrIGlmIHRoZWlyIHJhbmdlcyBpbnRlcnNlY3QgYW5kIG1hbmFnZSB0aGVtIHByb3Blcmx5LgogICAgLy8gRmlyc3QsIHdlIHdhbnQgdG8gYXBwbHkgY2hhbmdlIHRvIHRoZSBwYXJ0IG9mIGEgcmFuZ2UgdGhhdCBoYXMgbm90IGJlZW4gY2hhbmdlZCBieSB0aGUgb3RoZXIgb3BlcmF0aW9uLgogICAgdmFyIG9wZXJhdGlvbnMgPSBhLnJhbmdlLmdldERpZmZlcmVuY2UoYi5yYW5nZSkubWFwKGZ1bmN0aW9uIChyYW5nZSkgewogICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIDApOwogICAgfSk7IC8vIFRoZW4gd2UgdGFrZSBjYXJlIG9mIHRoZSBjb21tb24gcGFydCBvZiByYW5nZXMuCgogICAgdmFyIGNvbW1vbiA9IGEucmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKGIucmFuZ2UpOwoKICAgIGlmIChjb21tb24pIHsKICAgICAgLy8gSWYgdGhpcyBvcGVyYXRpb24gaXMgbW9yZSBpbXBvcnRhbnQsIHdlIGFsc28gd2FudCB0byBhcHBseSBjaGFuZ2UgdG8gdGhlIHBhcnQgb2YgdGhlCiAgICAgIC8vIG9yaWdpbmFsIHJhbmdlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjaGFuZ2VkIGJ5IHRoZSBvdGhlciBvcGVyYXRpb24uIFNpbmNlIHRoYXQgcmFuZ2UKICAgICAgLy8gZ290IGNoYW5nZWQgd2UgYWxzbyBoYXZlIHRvIHVwZGF0ZSBgb2xkVmFsdWVgLgogICAgICBpZiAoY29udGV4dC5hSXNTdHJvbmcpIHsKICAgICAgICBvcGVyYXRpb25zLnB1c2gobmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihjb21tb24sIGIua2V5LCBiLm5ld1ZhbHVlLCBhLm5ld1ZhbHVlLCAwKSk7CiAgICAgIH0KICAgIH0KCiAgICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPT0gMCkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9CgogICAgcmV0dXJuIG9wZXJhdGlvbnM7CiAgfSBlbHNlIHsKICAgIC8vIElmIG9wZXJhdGlvbnMgZG9uJ3QgY29uZmxpY3QsIHNpbXBseSByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBqdXN0IGEgY2xvbmUgb2YgdGhpcyBvcGVyYXRpb24uCiAgICByZXR1cm4gW2FdOwogIH0KfSk7CnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIC8vIENhc2UgMToKICAvLwogIC8vIFRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIHJhbmdlIGluY2x1ZGVzIHRoZSBwb3NpdGlvbiB3aGVyZSBub2RlcyB3ZXJlIGluc2VydGVkLgogIC8vIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2NlbmFyaW9zOiB0aGUgaW5zZXJ0ZWQgbm9kZXMgd2VyZSB0ZXh0IGFuZCB0aGV5IHNob3VsZCByZWNlaXZlIGF0dHJpYnV0ZXMgb3IKICAvLyB0aGUgaW5zZXJ0ZWQgbm9kZXMgd2VyZSBlbGVtZW50cyBhbmQgdGhleSBzaG91bGQgbm90IHJlY2VpdmUgYXR0cmlidXRlcy4KICAvLwogIGlmIChhLnJhbmdlLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyhiLnBvc2l0aW9uKSAmJiBhLnJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYi5wb3NpdGlvbikpIHsKICAgIC8vIElmIG5ldyBub2RlcyBzaG91bGQgbm90IHJlY2VpdmUgYXR0cmlidXRlcywgdHdvIHNlcGFyYXRlZCByYW5nZXMgd2lsbCBiZSByZXR1cm5lZC4KICAgIC8vIE90aGVyd2lzZSwgb25lIGV4cGFuZGVkIHJhbmdlIHdpbGwgYmUgcmV0dXJuZWQuCiAgICB2YXIgcmFuZ2UgPSBhLnJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGIucG9zaXRpb24sIGIuaG93TWFueSwgIWIuc2hvdWxkUmVjZWl2ZUF0dHJpYnV0ZXMpOwoKICAgIHZhciByZXN1bHQgPSByYW5nZS5tYXAoZnVuY3Rpb24gKHIpIHsKICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVPcGVyYXRpb24ociwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIGEuYmFzZVZlcnNpb24pOwogICAgfSk7CgogICAgaWYgKGIuc2hvdWxkUmVjZWl2ZUF0dHJpYnV0ZXMpIHsKICAgICAgLy8gYEF0dHJpYnV0ZU9wZXJhdGlvbiNyYW5nZWAgaW5jbHVkZXMgc29tZSBuZXdseSBpbnNlcnRlZCB0ZXh0LgogICAgICAvLyBUaGUgb3BlcmF0aW9uIHNob3VsZCBhbHNvIGNoYW5nZSB0aGUgYXR0cmlidXRlIG9mIHRoYXQgdGV4dC4gQW4gZXhhbXBsZToKICAgICAgLy8KICAgICAgLy8gQm9sZCBzaG91bGQgYmUgYXBwbGllZCBvbiB0aGUgZm9sbG93aW5nIHJhbmdlOgogICAgICAvLyA8cD5Gb1t6Yl1hcjwvcD4KICAgICAgLy8KICAgICAgLy8gSW4gbWVhbnRpbWUsIG5ldyB0ZXh0IGlzIHR5cGVkOgogICAgICAvLyA8cD5Gb3p4eGJhcjwvcD4KICAgICAgLy8KICAgICAgLy8gQm9sZCBzaG91bGQgYmUgYXBwbGllZCBhbHNvIG9uIHRoZSBuZXcgdGV4dDoKICAgICAgLy8gPHA+Rm9benh4Yl1hcjwvcD4KICAgICAgLy8gPHA+Rm88JHRleHQgYm9sZD0idHJ1ZSI+enh4YjwvJHRleHQ+YXI8L3A+CiAgICAgIC8vCiAgICAgIC8vIFRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRvIGNvbnNpZGVyIGhlcmUgdG8gY29uc2lkZXIuCiAgICAgIC8vCiAgICAgIC8vIENvbnNpZGVyIHNldHRpbmcgYW4gYXR0cmlidXRlIHdpdGggbXVsdGlwbGUgcG9zc2libGUgdmFsdWVzLCBmb3IgZXhhbXBsZSBgaGlnaGxpZ2h0YC4gVGhlIGluc2VydGVkIHRleHQgbWlnaHQKICAgICAgLy8gaGF2ZSBhbHJlYWR5IGFuIGF0dHJpYnV0ZSB2YWx1ZSBhcHBsaWVkIGFuZCB0aGUgYG9sZFZhbHVlYCBwcm9wZXJ0eSBvZiB0aGUgYXR0cmlidXRlIG9wZXJhdGlvbiBtaWdodCBiZSB3cm9uZzoKICAgICAgLy8KICAgICAgLy8gQXR0cmlidXRlIGBoaWdobGlnaHQ9InllbGxvdyJgIHNob3VsZCBiZSBhcHBsaWVkIG9uIHRoZSBmb2xsb3dpbmcgcmFuZ2U6CiAgICAgIC8vIDxwPkZvW3piXWFyPHA+CiAgICAgIC8vCiAgICAgIC8vIEluIG1lYW50aW1lLCBjaGFyYWN0ZXIgYHhgIHdpdGggYGhpZ2hsaWdodD0icmVkImAgaXMgdHlwZWQ6CiAgICAgIC8vIDxwPkZvW3o8JHRleHQgaGlnaGxpZ2h0PSJyZWQiPng8LyR0ZXh0PmJdYXI8L3A+CiAgICAgIC8vCiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBjYW5ub3Qgc2ltcGx5IGFwcGx5IG9wZXJhdGlvbiBjaGFuZ2luZyB0aGUgYXR0cmlidXRlIHZhbHVlIGZyb20gYG51bGxgIHRvIGAieWVsbG93ImAgZm9yIHRoZSB3aG9sZSByYW5nZQogICAgICAvLyBiZWNhdXNlIHRoYXQgd291bGQgbGVhZCB0byBhbiBleGNlcHRpb24gKGBvbGRWYWx1ZWAgaXMgaW5jb3JyZWN0IGZvciBgeGApLgogICAgICAvLwogICAgICAvLyBXZSBhbHNvIGNhbm5vdCBicmVhayB0aGUgb3JpZ2luYWwgcmFuZ2UgYXMgdGhpcyB3b3VsZCBtZXNzIHVwIGEgc2NlbmFyaW8gd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgZm9sbG93aW5nCiAgICAgIC8vIGluc2VydCBvcGVyYXRpb25zLCBiZWNhdXNlIHRoZW4gb25seSB0aGUgZmlyc3QgaW5zZXJ0ZWQgY2hhcmFjdGVyIGlzIGluY2x1ZGVkIGluIHRob3NlIHJhbmdlczoKICAgICAgLy8gPHA+Rm9bel1beF1bYl1hcjwvcD4gICAtLT4gICA8cD5Gb1t6XVt4XXhbYl1hcjwvcD4gICAtLT4gICA8cD5Gb1t6XVt4XXh4W2JdYXI8L3A+CiAgICAgIC8vCiAgICAgIC8vIFNvLCB0aGUgYXR0cmlidXRlIHJhbmdlIG5lZWRzIGJlIGV4cGFuZGVkLCBubyBtYXR0ZXIgd2hhdCBhdHRyaWJ1dGVzIGFyZSBzZXQgb24gdGhlIGluc2VydGVkIG5vZGVzOgogICAgICAvLwogICAgICAvLyA8cD5Gb1t6PCR0ZXh0IGhpZ2hsaWdodD0icmVkIj54PC8kdGV4dD5iXWFyPC9wPiAgICAgIDwtLS0gQ2hhbmdlIGZyb20gYG51bGxgIHRvIGB5ZWxsb3dgLCB0aHJvd2luZyBhbiBleGNlcHRpb24uCiAgICAgIC8vCiAgICAgIC8vIEJ1dCBiZWZvcmUgdGhhdCBvcGVyYXRpb24gd291bGQgYmUgYXBwbGllZCwgd2Ugd2lsbCBhZGQgYW4gYWRkaXRpb25hbCBhdHRyaWJ1dGUgb3BlcmF0aW9uIHRoYXQgd2lsbCBjaGFuZ2UKICAgICAgLy8gYXR0cmlidXRlcyBvbiB0aGUgaW5zZXJ0ZWQgbm9kZXMgaW4gYSB3YXkgd2hpY2ggd291bGQgbWFrZSB0aGUgb3JpZ2luYWwgb3BlcmF0aW9uIGNvcnJlY3Q6CiAgICAgIC8vCiAgICAgIC8vIDxwPkZvW3p7PCR0ZXh0IGhpZ2hsaWdodD0icmVkIj59eDwvJHRleHQ+Yl1hcjwvcD4gICAgPC0tLSBDaGFuZ2UgcmFuZ2UgYHt9YCBmcm9tIGByZWRgIHRvIGBudWxsYC4KICAgICAgLy8gPHA+Rm9benhiXWFyPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tIE5vdyBjaGFuZ2UgZnJvbSBgbnVsbGAgdG8gYHllbGxvd2AgaXMgY29tcGxldGVseSBmaW5lLgogICAgICAvLwogICAgICAvLyBHZW5lcmF0ZSBjb21wbGVtZW50YXJ5IGF0dHJpYnV0ZSBvcGVyYXRpb24uIEJlIHN1cmUgdG8gYWRkIGl0IGJlZm9yZSB0aGUgb3JpZ2luYWwgb3BlcmF0aW9uLgogICAgICB2YXIgb3AgPSBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoYiwgYS5rZXksIGEub2xkVmFsdWUpOwoKICAgICAgaWYgKG9wKSB7CiAgICAgICAgcmVzdWx0LnVuc2hpZnQob3ApOwogICAgICB9CiAgICB9IC8vIElmIG5vZGVzIHNob3VsZCBub3QgcmVjZWl2ZSBuZXcgYXR0cmlidXRlLCB3ZSBhcmUgZG9uZSBoZXJlLgoKCiAgICByZXR1cm4gcmVzdWx0OwogIH0gLy8gSWYgaW5zZXJ0IG9wZXJhdGlvbiBpcyBub3QgZXhwYW5kaW5nIHRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIHJhbmdlLCBzaW1wbHkgdHJhbnNmb3JtIHRoZSByYW5nZS4KCgogIGEucmFuZ2UgPSBhLnJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGIucG9zaXRpb24sIGIuaG93TWFueSwgZmFsc2UpWzBdOwogIHJldHVybiBbYV07Cn0pOwovKioKICogSGVscGVyIGZ1bmN0aW9uIGZvciBgQXR0cmlidXRlT3BlcmF0aW9uYCB4IGBJbnNlcnRPcGVyYXRpb25gIChhbmQgcmV2ZXJzZSkgdHJhbnNmb3JtYXRpb24uCiAqCiAqIEZvciBnaXZlbiBgaW5zZXJ0T3BlcmF0aW9uYCBpdCBjaGVja3MgdGhlIGluc2VydGVkIG5vZGUgaWYgaXQgaGFzIGFuIGF0dHJpYnV0ZSBga2V5YCBzZXQgdG8gYSB2YWx1ZSBkaWZmZXJlbnQKICogdGhhbiBgbmV3VmFsdWVgLiBJZiBzbywgaXQgZ2VuZXJhdGVzIGFuIGBBdHRyaWJ1dGVPcGVyYXRpb25gIHdoaWNoIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGBrZXlgIGF0dHJpYnV0ZSB0byBgbmV3VmFsdWVgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2luc2VydG9wZXJhdGlvbn5JbnNlcnRPcGVyYXRpb259IGluc2VydE9wZXJhdGlvbgogKiBAcGFyYW0ge1N0cmluZ30ga2V5CiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUKICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2F0dHJpYnV0ZW9wZXJhdGlvbn5BdHRyaWJ1dGVPcGVyYXRpb258bnVsbH0KICovCgpmdW5jdGlvbiBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoaW5zZXJ0T3BlcmF0aW9uLCBrZXksIG5ld1ZhbHVlKSB7CiAgdmFyIG5vZGVzID0gaW5zZXJ0T3BlcmF0aW9uLm5vZGVzOyAvLyBBdCB0aGUgYmVnaW5uaW5nIHdlIHN0b3JlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgbm9kZS4KCiAgdmFyIGluc2VydFZhbHVlID0gbm9kZXMuZ2V0Tm9kZSgwKS5nZXRBdHRyaWJ1dGUoa2V5KTsKCiAgaWYgKGluc2VydFZhbHVlID09IG5ld1ZhbHVlKSB7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIHZhciByYW5nZSA9IG5ldyBSYW5nZShpbnNlcnRPcGVyYXRpb24ucG9zaXRpb24sIGluc2VydE9wZXJhdGlvbi5wb3NpdGlvbi5nZXRTaGlmdGVkQnkoaW5zZXJ0T3BlcmF0aW9uLmhvd01hbnkpKTsKICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwga2V5LCBpbnNlcnRWYWx1ZSwgbmV3VmFsdWUsIDApOwp9CgpzZXRUcmFuc2Zvcm1hdGlvbihBdHRyaWJ1dGVPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIHZhciByYW5nZXMgPSBbXTsgLy8gQ2FzZSAxOgogIC8vCiAgLy8gQXR0cmlidXRlIGNoYW5nZSBvbiB0aGUgbWVyZ2VkIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgdGhlIG1lcmdlZCBlbGVtZW50IHdhcyBtb3ZlZCB0byB0aGUgZ3JhdmV5YXJkLgogIC8vIEFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIG9wZXJhdGlvbiB0aGF0IHdpbGwgY2hhbmdlIHRoZSAocmUpbW92ZWQgZWxlbWVudCBuZWVkcyB0byBiZSBnZW5lcmF0ZWQuCiAgLy8KCiAgaWYgKGEucmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIuZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgIGlmIChhLnJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYi5kZWxldGlvblBvc2l0aW9uKSB8fCBhLnJhbmdlLnN0YXJ0LmlzRXF1YWwoYi5kZWxldGlvblBvc2l0aW9uKSkgewogICAgICByYW5nZXMucHVzaChSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYi5ncmF2ZXlhcmRQb3NpdGlvbiwgMSkpOwogICAgfQogIH0KCiAgdmFyIHJhbmdlID0gYS5yYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOyAvLyBEbyBub3QgYWRkIGVtcHR5IChjb2xsYXBzZWQpIHJhbmdlcyB0byB0aGUgcmVzdWx0LiBgcmFuZ2VgIG1heSBiZSBjb2xsYXBzZWQgaWYgaXQgY29udGFpbmVkIG9ubHkgdGhlIG1lcmdlZCBlbGVtZW50LgoKCiAgaWYgKCFyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgcmFuZ2VzLnB1c2gocmFuZ2UpOwogIH0gLy8gQ3JlYXRlIGBBdHRyaWJ1dGVPcGVyYXRpb25gcyBvdXQgb2YgdGhlIHJhbmdlcy4KCgogIHJldHVybiByYW5nZXMubWFwKGZ1bmN0aW9uIChyYW5nZSkgewogICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVPcGVyYXRpb24ocmFuZ2UsIGEua2V5LCBhLm9sZFZhbHVlLCBhLm5ld1ZhbHVlLCBhLmJhc2VWZXJzaW9uKTsKICB9KTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgTW92ZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICB2YXIgcmFuZ2VzID0gX2JyZWFrUmFuZ2VCeU1vdmVPcGVyYXRpb24oYS5yYW5nZSwgYik7IC8vIENyZWF0ZSBgQXR0cmlidXRlT3BlcmF0aW9uYHMgb3V0IG9mIHRoZSByYW5nZXMuCgoKICByZXR1cm4gcmFuZ2VzLm1hcChmdW5jdGlvbiAocmFuZ2UpIHsKICAgIHJldHVybiBuZXcgQXR0cmlidXRlT3BlcmF0aW9uKHJhbmdlLCBhLmtleSwgYS5vbGRWYWx1ZSwgYS5uZXdWYWx1ZSwgYS5iYXNlVmVyc2lvbik7CiAgfSk7Cn0pOyAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBBdHRyaWJ1dGVPcGVyYXRpb25gIHggYE1vdmVPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uLgovLwovLyBUYWtlcyB0aGUgcGFzc2VkIGByYW5nZWAgYW5kIHRyYW5zZm9ybXMgaXQgYnkgbW92ZSBvcGVyYXRpb24gYG1vdmVPcGAgaW4gYSBzcGVjaWZpYyB3YXkuIE9ubHkgdG9wLWxldmVsIG5vZGVzIG9mIGByYW5nZWAKLy8gYXJlIGNvbnNpZGVyZWQgdG8gYmUgaW4gdGhlIHJhbmdlLiBJZiBtb3ZlIG9wZXJhdGlvbiBtb3ZlcyBub2RlcyBkZWVwIGZyb20gaW5zaWRlIG9mIHRoZSByYW5nZSwgdGhvc2Ugbm9kZXMgd29uJ3QKLy8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC4gSW4gb3RoZXIgd29yZHMsIHRvcC1sZXZlbCBub2RlcyBvZiB0aGUgcmFuZ2VzIGZyb20gdGhlIHJlc3VsdCBhcmUgZXhhY3RseSB0aGUgc2FtZSBhcwovLyB0b3AtbGV2ZWwgbm9kZXMgb2YgdGhlIG9yaWdpbmFsIGByYW5nZWAuCi8vCi8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBgQXR0cmlidXRlT3BlcmF0aW9uYCBiZWNhdXNlLCBmb3IgaXRzIHJhbmdlLCBpdCBjaGFuZ2VzIG9ubHkgdGhlIHRvcC1sZXZlbCBub2Rlcy4gU28gd2UgbmVlZCB0bwovLyB0cmFjayBvbmx5IGhvdyB0aG9zZSBub2RlcyBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgYE1vdmVPcGVyYXRpb25gLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbW92ZW9wZXJhdGlvbn5Nb3ZlT3BlcmF0aW9ufSBtb3ZlT3AKLy8gQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0KCmZ1bmN0aW9uIF9icmVha1JhbmdlQnlNb3ZlT3BlcmF0aW9uKHJhbmdlLCBtb3ZlT3ApIHsKICB2YXIgbW92ZVJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KG1vdmVPcC5zb3VyY2VQb3NpdGlvbiwgbW92ZU9wLmhvd01hbnkpOyAvLyBXZSBhcmUgdHJhbnNmb3JtaW5nIGByYW5nZWAgKG9yaWdpbmFsIHJhbmdlKSBieSBgbW92ZVJhbmdlYCAocmFuZ2UgbW92ZWQgYnkgbW92ZSBvcGVyYXRpb24pLiBBcyB1c3VhbCB3aGVuIGl0IGNvbWVzIHRvCiAgLy8gdHJhbnNmb3JtaW5nIGEgcmFuZ2VzLCB3ZSBtYXkgaGF2ZSBhIGNvbW1vbiBwYXJ0IG9mIHRoZSByYW5nZXMgYW5kIHdlIG1heSBoYXZlIGEgZGlmZmVyZW5jZSBwYXJ0ICh6ZXJvIHRvIHR3byByYW5nZXMpLgoKCiAgdmFyIGNvbW1vbiA9IG51bGw7CiAgdmFyIGRpZmZlcmVuY2UgPSBbXTsgLy8gTGV0J3MgY29tcGFyZSB0aGUgcmFuZ2VzLgoKICBpZiAobW92ZVJhbmdlLmNvbnRhaW5zUmFuZ2UocmFuZ2UsIHRydWUpKSB7CiAgICAvLyBJZiB0aGUgd2hvbGUgb3JpZ2luYWwgcmFuZ2UgaXMgbW92ZWQsIHRyZWF0IGl0IHdob2xlIGFzIGEgY29tbW9uIHBhcnQuIFRoZXJlJ3MgYWxzbyBubyBkaWZmZXJlbmNlIHBhcnQuCiAgICBjb21tb24gPSByYW5nZTsKICB9IGVsc2UgaWYgKHJhbmdlLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyhtb3ZlUmFuZ2Uuc3RhcnQpKSB7CiAgICAvLyBJZiB0aGUgcmFuZ2VzIGFyZSAib24gdGhlIHNhbWUgbGV2ZWwiIChpbiB0aGUgc2FtZSBwYXJlbnQpIHRoZW4gbW92ZSBvcGVyYXRpb24gbWF5IG1vdmUgZXhhY3RseSB0aG9zZSBub2RlcwogICAgLy8gdGhhdCBhcmUgY2hhbmdlZCBieSB0aGUgYXR0cmlidXRlIG9wZXJhdGlvbi4gSW4gdGhpcyBjYXNlIHdlIGdldCBjb21tb24gcGFydCBhbmQgZGlmZmVyZW5jZSBwYXJ0IGluIHRoZSB1c3VhbCB3YXkuCiAgICBkaWZmZXJlbmNlID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZShtb3ZlUmFuZ2UpOwogICAgY29tbW9uID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKG1vdmVSYW5nZSk7CiAgfSBlbHNlIHsKICAgIC8vIEluIGFueSBvdGhlciBzaXR1YXRpb24gd2UgYXNzdW1lIHRoYXQgb3JpZ2luYWwgcmFuZ2UgaXMgZGlmZmVyZW50IHRoYW4gbW92ZSByYW5nZSwgdGhhdCBpcyB0aGF0IG1vdmUgb3BlcmF0aW9uCiAgICAvLyBtb3ZlcyBvdGhlciBub2RlcyB0aGF0IGF0dHJpYnV0ZSBvcGVyYXRpb24gY2hhbmdlLiBFdmVuIGlmIHRoZSBtb3ZlZCByYW5nZSBpcyBkZWVwIGluc2lkZSBpbiB0aGUgb3JpZ2luYWwgcmFuZ2UuCiAgICAvLwogICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IHRoYW4gaW4gYC5nZXRJbnRlcnNlY3Rpb25gICh3ZSB3b3VsZCBnZXQgYSBjb21tb24gcGFydCBpbiB0aGF0IGNhc2UpIGFuZCBkaWZmZXJlbnQKICAgIC8vIHRoYW4gYC5nZXREaWZmZXJlbmNlYCAod2Ugd291bGQgZ2V0IHR3byByYW5nZXMpLgogICAgZGlmZmVyZW5jZSA9IFtyYW5nZV07CiAgfQoKICB2YXIgcmVzdWx0ID0gW107IC8vIFRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBgX2dldFRyYW5zZm9ybWVkQnlNb3ZlYCBtaWdodCBnZXQgd3JvbmcgcmVzdWx0cyBmb3IgZGlmZmVyZW5jZSBwYXJ0LCB0aG91Z2gsIHNvCiAgLy8gd2UgZG8gaXQgYnkgaGFuZC4KCiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yNSA9IHVuZGVmaW5lZDsKCiAgdHJ5IHsKICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBkaWZmZXJlbmNlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA1OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gKF9zdGVwNSA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSB0cnVlKSB7CiAgICAgIHZhciBkaWZmID0gX3N0ZXA1LnZhbHVlOwogICAgICAvLyBGaXJzdCwgdHJhbnNmb3JtIHRoZSByYW5nZSBieSByZW1vdmluZyBtb3ZlZCBub2Rlcy4gU2luY2UgdGhpcyBpcyBhIGRpZmZlcmVuY2UsIHRoaXMgaXMgc2FmZSwgYG51bGxgIHdvbid0IGJlIHJldHVybmVkCiAgICAgIC8vIGFzIHRoZSByYW5nZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgbW92ZWQgcmFuZ2UuCiAgICAgIGRpZmYgPSBkaWZmLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24obW92ZU9wLnNvdXJjZVBvc2l0aW9uLCBtb3ZlT3AuaG93TWFueSk7IC8vIFRyYW5zZm9ybSBhbHNvIGB0YXJnZXRQb3NpdGlvbmAuCgogICAgICB2YXIgdGFyZ2V0UG9zaXRpb24gPSBtb3ZlT3AuZ2V0TW92ZWRSYW5nZVN0YXJ0KCk7IC8vIFNwcmVhZCB0aGUgcmFuZ2Ugb25seSBpZiBtb3ZlZCBub2RlcyBhcmUgaW5zZXJ0ZWQgb25seSBiZXR3ZWVuIHRoZSB0b3AtbGV2ZWwgbm9kZXMgb2YgdGhlIGBkaWZmYCByYW5nZS4KCiAgICAgIHZhciBzcHJlYWQgPSBkaWZmLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyh0YXJnZXRQb3NpdGlvbik7IC8vIFRyYW5zZm9ybSBieSBpbnNlcnRpb24gb2YgbW92ZWQgbm9kZXMuCgogICAgICBkaWZmID0gZGlmZi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbih0YXJnZXRQb3NpdGlvbiwgbW92ZU9wLmhvd01hbnksIHNwcmVhZCk7CiAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KGRpZmYpKTsKICAgIH0gLy8gQ29tbW9uIHBhcnQgY2FuIGJlIHNpbXBseSB0cmFuc2Zvcm1lZCBieSB0aGUgbW92ZSBvcGVyYXRpb24uIFRoaXMgaXMgYmVjYXVzZSBtb3ZlIG9wZXJhdGlvbiB3aWxsIG5vdCB0YXJnZXQgdG8KICAgIC8vIHRoYXQgY29tbW9uIHBhcnQgKHRoZSBvcGVyYXRpb24gd291bGQgaGF2ZSB0byB0YXJnZXQgaW5zaWRlIGl0cyBvd24gbW92ZWQgcmFuZ2UpLgoKICB9IGNhdGNoIChlcnIpIHsKICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7CiAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHsKICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7CiAgICAgIH0KICAgIH0KICB9CgogIGlmIChjb21tb24pIHsKICAgIHJlc3VsdC5wdXNoKGNvbW1vbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUobW92ZU9wLnNvdXJjZVBvc2l0aW9uLCBtb3ZlT3AudGFyZ2V0UG9zaXRpb24sIG1vdmVPcC5ob3dNYW55LCBmYWxzZSlbMF0pOwogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfQoKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBTcGxpdCBub2RlIGlzIHRoZSBsYXN0IG5vZGUgaW4gYEF0dHJpYnV0ZU9wZXJhdGlvbiNyYW5nZWAuCiAgLy8gYEF0dHJpYnV0ZU9wZXJhdGlvbiNyYW5nZWAgbmVlZHMgdG8gYmUgZXhwYW5kZWQgdG8gaW5jbHVkZSB0aGUgbmV3IChzcGxpdCkgbm9kZS4KICAvLwogIC8vIEF0dHJpYnV0ZSBgdHlwZWAgdG8gYmUgY2hhbmdlZCB0byBgbnVtYmVyZWRgIGJ1dCB0aGUgYGxpc3RJdGVtYCBpcyBzcGxpdC4KICAvLyA8bGlzdEl0ZW0gdHlwZT0iYnVsbGV0ZWQiPmZvb2JhcjwvbGlzdEl0ZW0+CiAgLy8KICAvLyBBZnRlciBzcGxpdDoKICAvLyA8bGlzdEl0ZW0gdHlwZT0iYnVsbGV0ZWQiPmZvbzwvbGlzdEl0ZW0+PGxpc3RJdGVtIHR5cGU9ImJ1bGxldGVkIj5iYXI8L2xpc3RJdGVtPgogIC8vCiAgLy8gQWZ0ZXIgYXR0cmlidXRlIGNoYW5nZToKICAvLyA8bGlzdEl0ZW0gdHlwZT0ibnVtYmVyZWQiPmZvbzwvbGlzdEl0ZW0+PGxpc3RJdGVtIHR5cGU9Im51bWJlcmVkIj5mb288L2xpc3RJdGVtPgogIC8vCiAgaWYgKGEucmFuZ2UuZW5kLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikpIHsKICAgIGlmICghYi5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgICBhLnJhbmdlLmVuZC5vZmZzZXQrKzsKICAgIH0KCiAgICByZXR1cm4gW2FdOwogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gU3BsaXQgcG9zaXRpb24gaXMgaW5zaWRlIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgLCBhdCB0aGUgc2FtZSBsZXZlbCwgc28gdGhlIG5vZGVzIHRvIGNoYW5nZSBhcmUKICAvLyBub3QgZ29pbmcgdG8gbWFrZSBhIGZsYXQgcmFuZ2UuCiAgLy8KICAvLyBDb250ZW50IHdpdGggcmFuZ2UtdG8tY2hhbmdlIGFuZCBzcGxpdCBwb3NpdGlvbjoKICAvLyA8cD5Gb1t6Yl5hXXI8L3A+CiAgLy8KICAvLyBBZnRlciBzcGxpdDoKICAvLyA8cD5Gb3piPC9wPjxwPmFyPC9wPgogIC8vCiAgLy8gTWFrZSB0d28gc2VwYXJhdGUgcmFuZ2VzIGNvbnRhaW5pbmcgYWxsIG5vZGVzIHRvIGNoYW5nZToKICAvLyA8cD5Gb1t6Yl08L3A+PHA+W2FdcjwvcD4KICAvLwoKCiAgaWYgKGEucmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIuc3BsaXRQb3NpdGlvbikgJiYgYS5yYW5nZS5jb250YWluc1Bvc2l0aW9uKGIuc3BsaXRQb3NpdGlvbikpIHsKICAgIHZhciBzZWNvbmRQYXJ0ID0gYS5jbG9uZSgpOwogICAgc2Vjb25kUGFydC5yYW5nZSA9IG5ldyBSYW5nZShiLm1vdmVUYXJnZXRQb3NpdGlvbi5jbG9uZSgpLCBhLnJhbmdlLmVuZC5fZ2V0Q29tYmluZWQoYi5zcGxpdFBvc2l0aW9uLCBiLm1vdmVUYXJnZXRQb3NpdGlvbikpOwogICAgYS5yYW5nZS5lbmQgPSBiLnNwbGl0UG9zaXRpb24uY2xvbmUoKTsKICAgIGEucmFuZ2UuZW5kLnN0aWNraW5lc3MgPSAndG9QcmV2aW91cyc7CiAgICByZXR1cm4gW2EsIHNlY29uZFBhcnRdOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgYS5yYW5nZSA9IGEucmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBBdHRyaWJ1dGVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgdmFyIHJlc3VsdCA9IFthXTsgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24gcmFuZ2UgaW5jbHVkZXMgdGhlIHBvc2l0aW9uIHdoZXJlIG5vZGVzIHdlcmUgaW5zZXJ0ZWQuCiAgLy8gVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3M6IHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIHRleHQgYW5kIHRoZXkgc2hvdWxkIHJlY2VpdmUgYXR0cmlidXRlcyBvcgogIC8vIHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIGVsZW1lbnRzIGFuZCB0aGV5IHNob3VsZCBub3QgcmVjZWl2ZSBhdHRyaWJ1dGVzLgogIC8vCiAgLy8gVGhpcyBpcyBhIG1pcnJvciBzY2VuYXJpbyB0byB0aGUgb25lIGRlc2NyaWJlZCBpbiBgQXR0cmlidXRlT3BlcmF0aW9uYCB4IGBJbnNlcnRPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uLAogIC8vIGFsdGhvdWdoIHRoaXMgY2FzZSBpcyBhIGxpdHRsZSBsZXNzIGNvbXBsaWNhdGVkLiBJbiB0aGlzIGNhc2Ugd2Ugc2ltcGx5IG5lZWQgdG8gY2hhbmdlIGF0dHJpYnV0ZXMgb2YgdGhlCiAgLy8gaW5zZXJ0ZWQgbm9kZXMgYW5kIHRoYXQncyBpdC4KICAvLwoKICBpZiAoYS5zaG91bGRSZWNlaXZlQXR0cmlidXRlcyAmJiBhLnBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnJhbmdlLnN0YXJ0KSAmJiBiLnJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYS5wb3NpdGlvbikpIHsKICAgIHZhciBvcCA9IF9nZXRDb21wbGVtZW50YXJ5QXR0cmlidXRlT3BlcmF0aW9ucyhhLCBiLmtleSwgYi5uZXdWYWx1ZSk7CgogICAgaWYgKG9wKSB7CiAgICAgIHJlc3VsdC5wdXNoKG9wKTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UgaXM6IGRvIG5vdGhpbmcuCiAgLy8gYEF0dHJpYnV0ZU9wZXJhdGlvbmAgZG9lcyBub3QgY2hhbmdlIHRoZSBtb2RlbCB0cmVlIHN0cnVjdHVyZSBzbyBgSW5zZXJ0T3BlcmF0aW9uYCBkb2VzIG5vdCBuZWVkIHRvIGJlIGNoYW5nZWQuCiAgLy8KCgogIHJldHVybiByZXN1bHQ7Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihJbnNlcnRPcGVyYXRpb24sIEluc2VydE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBUd28gaW5zZXJ0IG9wZXJhdGlvbnMgaW5zZXJ0IG5vZGVzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLiBTaW5jZSB0aGV5IGFyZSB0aGUgc2FtZSwgaXQgbmVlZHMgdG8gYmUgZGVjaWRlZAogIC8vIHdoYXQgd2lsbCBiZSB0aGUgb3JkZXIgb2YgaW5zZXJ0ZWQgbm9kZXMuIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gaGVscCBpbiB0aGF0CiAgLy8gZGVjaXNpb24uIEFsc28sIHdoZW4gYGJgIHdpbGwgYmUgdHJhbnNmb3JtZWQgYnkgYGFgLCB0aGUgc2FtZSBvcmRlciBtdXN0IGJlIG1haW50YWluZWQuCiAgLy8KICAvLyBUbyBhY2hpZXZlIHRoYXQsIHdlIHdpbGwgY2hlY2sgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdHJvbmcuCiAgLy8gSWYgaXQgaXMsIGl0IHdvbid0IGdldCB0cmFuc2Zvcm1lZC4gSWYgaXQgaXMgbm90LCBpdCB3aWxsIGJlIG1vdmVkLgogIC8vCiAgaWYgKGEucG9zaXRpb24uaXNFcXVhbChiLnBvc2l0aW9uKSAmJiBjb250ZXh0LmFJc1N0cm9uZykgewogICAgcmV0dXJuIFthXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihJbnNlcnRPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIpIHsKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc2V0VHJhbnNmb3JtYXRpb24oTWFya2VyT3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgaWYgKGEub2xkUmFuZ2UpIHsKICAgIGEub2xkUmFuZ2UgPSBhLm9sZFJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpWzBdOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGEubmV3UmFuZ2UgPSBhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpWzBdOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1hcmtlck9wZXJhdGlvbiwgTWFya2VyT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChhLm5hbWUgPT0gYi5uYW1lKSB7CiAgICBpZiAoY29udGV4dC5hSXNTdHJvbmcpIHsKICAgICAgYS5vbGRSYW5nZSA9IGIubmV3UmFuZ2UgPyBiLm5ld1JhbmdlLmNsb25lKCkgOiBudWxsOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1hcmtlck9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgaWYgKGEub2xkUmFuZ2UpIHsKICAgIGEub2xkUmFuZ2UgPSBhLm9sZFJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICBpZiAoYS5uZXdSYW5nZSkgewogICAgYS5uZXdSYW5nZSA9IGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgaWYgKGEub2xkUmFuZ2UpIHsKICAgIGEub2xkUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVJhbmdlcyhhLm9sZFJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKSk7CiAgfQoKICBpZiAoYS5uZXdSYW5nZSkgewogICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbikgewogICAgICB2YXIgYU5ld1JhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMoYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYikpOwoKICAgICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbi5zaWRlID09ICdsZWZ0JyAmJiBiLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYS5uZXdSYW5nZS5zdGFydCkpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0LnBhdGggPSBjb250ZXh0LmFiUmVsYXRpb24ucGF0aDsKICAgICAgICBhLm5ld1JhbmdlLmVuZCA9IGFOZXdSYW5nZS5lbmQ7CiAgICAgICAgcmV0dXJuIFthXTsKICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmFiUmVsYXRpb24uc2lkZSA9PSAncmlnaHQnICYmIGIudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChhLm5ld1JhbmdlLmVuZCkpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0ID0gYU5ld1JhbmdlLnN0YXJ0OwogICAgICAgIGEubmV3UmFuZ2UuZW5kLnBhdGggPSBjb250ZXh0LmFiUmVsYXRpb24ucGF0aDsKICAgICAgICByZXR1cm4gW2FdOwogICAgICB9CiAgICB9CgogICAgYS5uZXdSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUmFuZ2VzKGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIFNwbGl0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24pIHsKICAgICAgdmFyIGFOZXdSYW5nZSA9IGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKCiAgICAgIGlmIChhLm5ld1JhbmdlLnN0YXJ0LmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24ud2FzU3RhcnRCZWZvcmVNZXJnZWRFbGVtZW50KSB7CiAgICAgICAgYS5uZXdSYW5nZS5zdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChiLmluc2VydGlvblBvc2l0aW9uKTsKICAgICAgfSBlbHNlIGlmIChhLm5ld1JhbmdlLnN0YXJ0LmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiAhY29udGV4dC5hYlJlbGF0aW9uLndhc0luTGVmdEVsZW1lbnQpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KGIubW92ZVRhcmdldFBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgaWYgKGEubmV3UmFuZ2UuZW5kLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24ud2FzSW5SaWdodEVsZW1lbnQpIHsKICAgICAgICBhLm5ld1JhbmdlLmVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBdChiLm1vdmVUYXJnZXRQb3NpdGlvbik7CiAgICAgIH0gZWxzZSBpZiAoYS5uZXdSYW5nZS5lbmQuaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pICYmIGNvbnRleHQuYWJSZWxhdGlvbi53YXNFbmRCZWZvcmVNZXJnZWRFbGVtZW50KSB7CiAgICAgICAgYS5uZXdSYW5nZS5lbmQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoYi5pbnNlcnRpb25Qb3NpdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYS5uZXdSYW5nZS5lbmQgPSBhTmV3UmFuZ2UuZW5kOwogICAgICB9CgogICAgICByZXR1cm4gW2FdOwogICAgfQoKICAgIGEubmV3UmFuZ2UgPSBhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKE1lcmdlT3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgaWYgKGEuc291cmNlUG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIucG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogIH0KCiAgYS5zb3VyY2VQb3NpdGlvbiA9IGEuc291cmNlUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24oYik7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1lcmdlT3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBTYW1lIG1lcmdlIG9wZXJhdGlvbnMuCiAgLy8KICAvLyBCb3RoIG9wZXJhdGlvbnMgaGF2ZSBzYW1lIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9ucy4gU28gdGhlIGVsZW1lbnQgYWxyZWFkeSBnb3QgbWVyZ2VkIGFuZCB0aGVyZSBpcwogIC8vIHRoZW9yZXRpY2FsbHkgbm90aGluZyB0byBkby4KICAvLwogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwoYi5zb3VyY2VQb3NpdGlvbikgJiYgYS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKGIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICAvLyBUaGVyZSBhcmUgdHdvIHdheXMgdGhhdCB3ZSBjYW4gcHJvdmlkZSBhIGRvLW5vdGhpbmcgb3BlcmF0aW9uLgogICAgLy8KICAgIC8vIEZpcnN0IGlzIHNpbXBseSBhIE5vT3BlcmF0aW9uIGluc3RhbmNlLiBXZSB3aWxsIHVzZSBpdCBpZiBgYmAgb3BlcmF0aW9uIHdhcyBub3QgdW5kb25lLgogICAgLy8KICAgIC8vIFNlY29uZCBpcyBhIG1lcmdlIG9wZXJhdGlvbiB0aGF0IGhhcyB0aGUgc291cmNlIG9wZXJhdGlvbiBpbiB0aGUgbWVyZ2VkIGVsZW1lbnQgLSBpbiB0aGUgZ3JhdmV5YXJkIC0KICAgIC8vIHNhbWUgdGFyZ2V0IHBvc2l0aW9uIGFuZCBgaG93TWFueWAgZXF1YWwgdG8gYDBgLiBTbyBpdCBpcyBiYXNpY2FsbHkgbWVyZ2luZyBhbiBlbXB0eSBlbGVtZW50IGZyb20gZ3JhdmV5YXJkCiAgICAvLyB3aGljaCBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgTm9PcGVyYXRpb24uCiAgICAvLwogICAgLy8gVGhpcyB3YXkgdGhlIG1lcmdlIG9wZXJhdGlvbiBjYW4gYmUgbGF0ZXIgdHJhbnNmb3JtZWQgYnkgc3BsaXQgb3BlcmF0aW9uCiAgICAvLyB0byBwcm92aWRlIGNvcnJlY3QgdW5kby4gVGhpcyB3aWxsIGJlIHVzZWQgaWYgYGJgIG9wZXJhdGlvbiB3YXMgdW5kb25lIChvbmx5IHRoZW4gaXQgaXMgY29ycmVjdCkuCiAgICAvLwogICAgaWYgKCFjb250ZXh0LmJXYXNVbmRvbmUpIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfSBlbHNlIHsKICAgICAgdmFyIHBhdGggPSBiLmdyYXZleWFyZFBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgICAgcGF0aC5wdXNoKDApOwogICAgICBhLnNvdXJjZVBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24ucm9vdCwgcGF0aCk7CiAgICAgIGEuaG93TWFueSA9IDA7CiAgICAgIHJldHVybiBbYV07CiAgICB9CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBTYW1lIG1lcmdlIHNvdXJjZSBwb3NpdGlvbiBidXQgZGlmZmVyZW50IHRhcmdldCBwb3NpdGlvbi4KICAvLwogIC8vIFRoaXMgY2FuIGhhcHBlbiBkdXJpbmcgY29sbGFib3JhdGlvbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBjbGllbnQgbWVyZ2VkIGEgcGFyYWdyYXBoIHRvIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGgKICAvLyBhbmQgdGhlIG90aGVyIHBlcnNvbiByZW1vdmVkIHRoYXQgcGFyYWdyYXBoIGFuZCBtZXJnZWQgdGhlIHNhbWUgcGFyYWdyYXBoIHRvIHNvbWV0aGluZyBiZWZvcmU6CiAgLy8KICAvLyBDbGllbnQgQToKICAvLyA8cD5Gb288L3A+PHA+QmFyPC9wPjxwPltdWHl6PC9wPgogIC8vIDxwPkZvbzwvcD48cD5CYXJYeXo8L3A+CiAgLy8KICAvLyBDbGllbnQgQjoKICAvLyA8cD5Gb288L3A+WzxwPkJhcjwvcD5dPHA+WHl6PC9wPgogIC8vIDxwPkZvbzwvcD48cD5bXVh5ejwvcD4KICAvLyA8cD5Gb29YeXo8L3A+CiAgLy8KICAvLyBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hlcmUgZmluYWxseSAiWHl6IiB3aWxsIGxhbmQ6CiAgLy8KICAvLyA8cD5Gb29YeXo8L3A+ICAgICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cD5CYXI8L3A+CiAgLy8gPHA+Rm9vPC9wPiAgICAgICAgICAgICAgICAgIGdyYXZleWFyZDogPHA+QmFyWHl6PC9wPgogIC8vCiAgLy8gTGV0J3MgbW92ZSBpdCBpbiBhIHdheSBzbyB0aGF0IGEgbWVyZ2Ugb3BlcmF0aW9uIHRoYXQgZG9lcyBub3QgdGFyZ2V0IHRvIGdyYXZleWFyZCBpcyBtb3JlIGltcG9ydGFudCBzbyB0aGF0CiAgLy8gbm9kZXMgZG9lcyBub3QgZW5kIHVwIGluIHRoZSBncmF2ZXlhcmQuIEl0IG1ha2VzIHNlbnNlLiBCb3RoIGZvciBDbGllbnQgQSBhbmQgZm9yIENsaWVudCBCICJYeXoiIGZpbmFsbHkgZGlkIG5vdAogIC8vIGVuZCB1cCBpbiB0aGUgZ3JhdmV5YXJkIChzZWUgYWJvdmUpLgogIC8vCiAgLy8gSWYgbmVpdGhlciBvciBib3RoIG9wZXJhdGlvbnMgcG9pbnQgdG8gZ3JhdmV5YXJkLCB0aGVuIGxldCBgYUlzU3Ryb25nYCBkZWNpZGUuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwoYi5zb3VyY2VQb3NpdGlvbikgJiYgIWEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKSAmJiAhY29udGV4dC5iV2FzVW5kb25lICYmIGNvbnRleHQuYWJSZWxhdGlvbiAhPSAnc3BsaXRBdFNvdXJjZScpIHsKICAgIHZhciBhVG9HcmF2ZXlhcmQgPSBhLnRhcmdldFBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPT0gJyRncmF2ZXlhcmQnOwogICAgdmFyIGJUb0dyYXZleWFyZCA9IGIudGFyZ2V0UG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7IC8vIElmIGBhSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBhYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBiYCBkb2Vzbid0LiBEb24ndCBtb3ZlIG5vZGVzIHRoZW4uCgogICAgdmFyIGFJc1dlYWsgPSBhVG9HcmF2ZXlhcmQgJiYgIWJUb0dyYXZleWFyZDsgLy8gSWYgYGJJc1dlYWtgIGl0IG1lYW5zIHRoYXQgYGJgIHBvaW50cyB0byBncmF2ZXlhcmQgd2hpbGUgYGFgIGRvZXNuJ3QuIEZvcmNlIG1vdmluZyBub2RlcyB0aGVuLgoKICAgIHZhciBiSXNXZWFrID0gYlRvR3JhdmV5YXJkICYmICFhVG9HcmF2ZXlhcmQ7IC8vIEZvcmNlIG1vdmUgaWYgYGJgIGlzIHdlYWsgb3IgbmVpdGhlciBvcGVyYXRpb24gaXMgd2VhayBidXQgYGFgIGlzIHN0cm9uZ2VyIHRocm91Z2ggYGNvbnRleHQuYUlzU3Ryb25nYC4KCiAgICB2YXIgZm9yY2VNb3ZlID0gYklzV2VhayB8fCAhYUlzV2VhayAmJiBjb250ZXh0LmFJc1N0cm9uZzsKCiAgICBpZiAoZm9yY2VNb3ZlKSB7CiAgICAgIHZhciBzb3VyY2VQb3NpdGlvbiA9IGIudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgICAgIHZhciB0YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgICAgIHJldHVybiBbbmV3IE1vdmVPcGVyYXRpb24oc291cmNlUG9zaXRpb24sIGEuaG93TWFueSwgdGFyZ2V0UG9zaXRpb24sIDApXTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnRhcmdldFBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICB9CgogIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsgLy8gSGFuZGxlIHBvc2l0aW9ucyBpbiBncmF2ZXlhcmQuCiAgLy8gSWYgZ3JhdmV5YXJkIHBvc2l0aW9ucyBhcmUgc2FtZSBhbmQgYGFgIG9wZXJhdGlvbiBpcyBzdHJvbmcgLSBkbyBub3QgdHJhbnNmb3JtLgoKICBpZiAoIWEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSB8fCAhY29udGV4dC5hSXNTdHJvbmcpIHsKICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWVyZ2VPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGVsZW1lbnQgdG8gbWVyZ2UgZ290IHJlbW92ZWQuCiAgLy8KICAvLyBNZXJnZSBvcGVyYXRpb24gZG9lcyBzdXBwb3J0IG1lcmdpbmcgZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBzaWJsaW5ncy4gU28gaXQgd291bGQgbm90IGJlIGEgcHJvYmxlbQogIC8vIGZyb20gdGVjaG5pY2FsIHBvaW50IG9mIHZpZXcuIEhvd2V2ZXIsIGlmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLCB0aGUgaW50ZW50aW9uIG9mIHRoZSB1c2VyIGRlbGV0aW5nIGl0CiAgLy8gd2FzIHRvIGhhdmUgaXQgYWxsIGRlbGV0ZWQsIHRvZ2V0aGVyIHdpdGggaXRzIGNoaWxkcmVuLiBGcm9tIHVzZXIgZXhwZXJpZW5jZSBwb2ludCBvZiB2aWV3LCBtb3ZpbmcgYmFjayB0aGUKICAvLyByZW1vdmVkIG5vZGVzIG1pZ2h0IGJlIHVuZXhwZWN0ZWQuIFRoaXMgbWVhbnMgdGhhdCBpbiB0aGlzIHNjZW5hcmlvIHdlIHdpbGwgYmxvY2sgdGhlIG1lcmdpbmcuCiAgLy8KICAvLyBUaGUgZXhjZXB0aW9uIG9mIHRoaXMgcnVsZSB3b3VsZCBiZSBpZiB0aGUgcmVtb3ZlIG9wZXJhdGlvbiB3YXMgbGF0ZXIgdW5kb25lLgogIC8vCiAgdmFyIHJlbW92ZWRSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOwoKICBpZiAoYi50eXBlID09ICdyZW1vdmUnICYmICFjb250ZXh0LmJXYXNVbmRvbmUgJiYgIWNvbnRleHQuZm9yY2VXZWFrUmVtb3ZlKSB7CiAgICBpZiAoYS5kZWxldGlvblBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNvdXJjZVBvc2l0aW9uKSAmJiByZW1vdmVkUmFuZ2UuY29udGFpbnNQb3NpdGlvbihhLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikpIHsKICAgIGEuaG93TWFueSAtPSBiLmhvd01hbnk7CiAgfQoKICBhLnNvdXJjZVBvc2l0aW9uID0gYS5zb3VyY2VQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOyAvLyBgTWVyZ2VPcGVyYXRpb25gIGdyYXZleWFyZCBwb3NpdGlvbiBpcyBsaWtlIGBNb3ZlT3BlcmF0aW9uYCB0YXJnZXQgcG9zaXRpb24uIEl0IGlzIGEgcG9zaXRpb24gd2hlcmUgZWxlbWVudChzKSB3aWxsCiAgLy8gYmUgbW92ZWQuIExpa2UgaW4gb3RoZXIgc2ltaWxhciBjYXNlcywgd2UgbmVlZCB0byBjb25zaWRlciB0aGUgc2NlbmFyaW8gd2hlbiB0aG9zZSBwb3NpdGlvbnMgYXJlIHNhbWUuCiAgLy8gSGVyZSwgd2Ugd2lsbCB0cmVhdCBgTWVyZ2VPcGVyYXRpb25gIGxpa2UgaXQgaXMgYWx3YXlzIHN0cm9uZyAoc2VlIGBJbnNlcnRPcGVyYXRpb25gIHggYEluc2VydE9wZXJhdGlvbmAgZm9yIGNvbXBhcmlzb24pLgogIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSB3b24ndCB0cmFuc2Zvcm0gZ3JhdmV5YXJkIHBvc2l0aW9uIGlmIGl0IGlzIGVxdWFsIHRvIG1vdmUgb3BlcmF0aW9uIHRhcmdldCBwb3NpdGlvbi4KCiAgaWYgKCFhLmdyYXZleWFyZFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNZXJnZU9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgaWYgKGIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIC8vIElmIGBiYCBvcGVyYXRpb24gZGVmaW5lcyBncmF2ZXlhcmQgcG9zaXRpb24sIGEgbm9kZSBmcm9tIGdyYXZleWFyZCB3aWxsIGJlIG1vdmVkLiBUaGlzIG1lYW5zIHRoYXQgd2UgbmVlZCB0bwogICAgLy8gdHJhbnNmb3JtIGBhLmdyYXZleWFyZFBvc2l0aW9uYCBhY2NvcmRpbmdseS4KICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5ncmF2ZXlhcmRQb3NpdGlvbiwgMSk7IC8vIFRoaXMgaXMgYSBzY2VuYXJpbyBmb3Jlc2VlbiBpbiBgTWVyZ2VPcGVyYXRpb25gIHggYE1lcmdlT3BlcmF0aW9uYCwgd2l0aCB0d28gaWRlbnRpY2FsIG1lcmdlIG9wZXJhdGlvbnMuCiAgICAvLwogICAgLy8gU28sIHRoZXJlIHdhcyBgTWVyZ2VPcGVyYXRpb25gIHggYE1lcmdlT3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbiBlYXJsaWVyLiBOb3csIGBhYCBpcyBhIG1lcmdlIG9wZXJhdGlvbiB3aGljaAogICAgLy8gc291cmNlIHBvc2l0aW9uIGlzIGluIGdyYXZleWFyZC4gSW50ZXJlc3RpbmdseSwgc3BsaXQgb3BlcmF0aW9uIHdhbnRzIHRvIHVzZSB0aGUgbm9kZSB0byBiZSBtZXJnZWQgYnkgYGFgLiBUaGlzCiAgICAvLyBtZWFucyB0aGF0IGBiYCBpcyB1bmRvaW5nIHRoYXQgbWVyZ2Ugb3BlcmF0aW9uIGZyb20gZWFybGllciwgd2hpY2ggY2F1c2VkIGBhYCB0byBiZSBpbiBncmF2ZXlhcmQuCiAgICAvLwogICAgLy8gSWYgdGhhdCdzIHRoZSBjYXNlLCBhdCB0aGlzIHBvaW50LCB3ZSB3aWxsIG9ubHkgImZpeCIgYGEuaG93TWFueWAuIEl0IHdhcyBlYXJsaWVyIHNldCB0byBgMGAgaW4KICAgIC8vIGBNZXJnZU9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uLiBMYXRlciB0cmFuc2Zvcm1hdGlvbnMgaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNoYW5nZSBvdGhlcgogICAgLy8gcHJvcGVydGllcy4KICAgIC8vCgogICAgaWYgKGEuZGVsZXRpb25Qb3NpdGlvbi5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pKSB7CiAgICAgIGEuaG93TWFueSA9IGIuaG93TWFueTsKICAgIH0KICB9IC8vIENhc2UgMToKICAvLwogIC8vIE1lcmdlIG9wZXJhdGlvbiBtb3ZlcyBub2RlcyB0byB0aGUgcGxhY2Ugd2hlcmUgc3BsaXQgaGFwcGVucy4KICAvLyBUaGlzIGlzIGEgY2xhc3NpYyBzaXR1YXRpb24gd2hlbiB0aGVyZSBhcmUgdHdvIHBhcmFncmFwaHMsIGFuZCB0aGVyZSBpcyBhIHNwbGl0IChlbnRlcikgYWZ0ZXIgdGhlIGZpcnN0CiAgLy8gcGFyYWdyYXBoIGFuZCB0aGVyZSBpcyBhIG1lcmdlIChkZWxldGUpIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBwYXJhZ3JhcGg6CiAgLy8KICAvLyA8cD5Gb297fTwvcD48cD5bXUJhcjwvcD4uCiAgLy8KICAvLyBTcGxpdCBpcyBhZnRlciBgRm9vYCwgd2hpbGUgbWVyZ2UgaXMgZnJvbSBgQmFyYCB0byB0aGUgZW5kIG9mIGBGb29gLgogIC8vCiAgLy8gU3RhdGUgYWZ0ZXIgc3BsaXQ6CiAgLy8gPHA+Rm9vPC9wPjxwPjwvcD48cD5CYXI8L3A+CiAgLy8KICAvLyBOb3csIGBCYXJgIHNob3VsZCBiZSBtZXJnZWQgdG8gdGhlIG5ldyBwYXJhZ3JhcGg6CiAgLy8gPHA+Rm9vPC9wPjxwPkJhcjwvcD4KICAvLwogIC8vIEluc3RlYWQgb2YgbWVyZ2luZyBpdCB0byB0aGUgb3JpZ2luYWwgcGFyYWdyYXBoOgogIC8vIDxwPkZvb0JhcjwvcD48cD48L3A+CiAgLy8KICAvLyBUaGlzIG1lYW5zIHRoYXQgYHRhcmdldFBvc2l0aW9uYCBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZC4gVGhpcyBpcyB0aGUgZGVmYXVsdCBjYXNlIHRob3VnaC4KICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlIHNwbGl0IHdvdWxkIGJlIGFmdGVyIGBGYCwgYHRhcmdldFBvc2l0aW9uYCBzaG91bGQgYWxzbyBiZSB0cmFuc2Zvcm1lZC4KICAvLwogIC8vIFRoZXJlIGFyZSB0aHJlZSBleGNlcHRpb25zLCB0aG91Z2gsIHdoZW4gd2Ugd2FudCB0byBrZWVwIGB0YXJnZXRQb3NpdGlvbmAgYXMgaXQgd2FzLgogIC8vCiAgLy8gRmlyc3QgZXhjZXB0aW9uIGlzIHdoZW4gdGhlIG1lcmdlIHRhcmdldCBwb3NpdGlvbiBpcyBpbnNpZGUgYW4gZWxlbWVudCAobm90IGF0IHRoZSBlbmQsIGFzIHVzdWFsKS4gVGhpcwogIC8vIGhhcHBlbnMgd2hlbiB0aGUgbWVyZ2Ugb3BlcmF0aW9uIGVhcmxpZXIgd2FzIHRyYW5zZm9ybWVkIGJ5ICJ0aGUgc2FtZSIgbWVyZ2Ugb3BlcmF0aW9uLiBJZiBtZXJnZSBvcGVyYXRpb24KICAvLyB0YXJnZXRzIGluc2lkZSB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIHRhcmdldCBwb3NpdGlvbiAoYW5kIG5vdCB0cmFuc2Zvcm0gaXQpIGJlY2F1c2UKICAvLyB3ZSBoYXZlIGFkZGl0aW9uYWwgY29udGV4dCB0ZWxsaW5nIHVzIHRoYXQgd2Ugd2FudCB0byBtZXJnZSB0byB0aGUgb3JpZ2luYWwgZWxlbWVudC4gV2UgY2FuIGNoZWNrIGlmIHRoZQogIC8vIG1lcmdlIG9wZXJhdGlvbiBwb2ludHMgaW5zaWRlIGVsZW1lbnQgYnkgY2hlY2tpbmcgd2hhdCBpcyBgU3BsaXRPcGVyYXRpb24jaG93TWFueWAuIFNpbmNlIG1lcmdlIHRhcmdldCBwb3NpdGlvbgogIC8vIGlzIHNhbWUgYXMgc3BsaXQgcG9zaXRpb24sIGlmIGBob3dNYW55YCBpcyBub24temVybywgaXQgbWVhbnMgdGhhdCB0aGUgbWVyZ2UgdGFyZ2V0IHBvc2l0aW9uIGlzIGluc2lkZSBhbiBlbGVtZW50LgogIC8vCiAgLy8gU2Vjb25kIGV4Y2VwdGlvbiBpcyB3aGVuIHRoZSBlbGVtZW50IHRvIG1lcmdlIGlzIGluIHRoZSBncmF2ZXlhcmQgYW5kIHNwbGl0IG9wZXJhdGlvbiB1c2VzIGl0LiBJbiB0aGF0IGNhc2UKICAvLyBpZiB0YXJnZXQgcG9zaXRpb24gd291bGQgYmUgdHJhbnNmb3JtZWQsIHRoZSBtZXJnZSBvcGVyYXRpb24gd291bGQgdGFyZ2V0IGF0IHRoZSBzb3VyY2UgcG9zaXRpb246CiAgLy8KICAvLyByb290OiA8cD5Gb288L3A+CQkJCWdyYXZleWFyZDogPHA+PC9wPgogIC8vCiAgLy8gU3BsaXRPcGVyYXRpb246IHJvb3QgWyAwLCAzIF0gdXNpbmcgZ3JhdmV5YXJkIFsgMCBdIChob3dNYW55ID0gMCkKICAvLyBNZXJnZU9wZXJhdGlvbjogZ3JhdmV5YXJkIFsgMCwgMCBdIC0+IHJvb3QgWyAwLCAzIF0gKGhvd01hbnkgPSAwKQogIC8vCiAgLy8gU2luY2Ugc3BsaXQgb3BlcmF0aW9uIG1vdmVzIHRoZSBncmF2ZXlhcmQgbm9kZSBiYWNrIHRvIHRoZSByb290LCB0aGUgbWVyZ2Ugb3BlcmF0aW9uIHNvdXJjZSBwb3NpdGlvbiBjaGFuZ2VzLgogIC8vIFdlIHdvdWxkIGxpa2UgdG8gbWVyZ2UgZnJvbSB0aGUgZW1wdHkgPHA+IHRvIHRoZSAiRm9vIiA8cD46CiAgLy8KICAvLyByb290OiA8cD5Gb288L3A+PHA+PC9wPgkJCWdyYXZleWFyZDoKICAvLwogIC8vIE1lcmdlT3BlcmF0aW9uI3NvdXJjZVBvc2l0aW9uID0gcm9vdCBbIDEsIDAgXQogIC8vCiAgLy8gSWYgYHRhcmdldFBvc2l0aW9uYCBpcyB0cmFuc2Zvcm1lZCwgaXQgd291bGQgYmVjb21lIHJvb3QgWyAxLCAwIF0gYXMgd2VsbC4gSXQgaGFzIHRvIGJlIGtlcHQgYXMgaXQgd2FzLgogIC8vCiAgLy8gVGhpcmQgZXhjZXB0aW9uIGlzIGNvbm5lY3RlZCB3aXRoIHJlbGF0aW9ucy4gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyB1bmRvIGFuZCB3ZSBoYXZlIGV4cGxpY2l0IGluZm9ybWF0aW9uCiAgLy8gdGhhdCB0YXJnZXQgcG9zaXRpb24gaGFzIG5vdCBiZWVuIGFmZmVjdGVkIGJ5IHRoZSBvcGVyYXRpb24gd2hpY2ggaXMgdW5kb25lIGJ5IHRoaXMgc3BsaXQgdGhlbiB0aGlzIHNwbGl0IHNob3VsZAogIC8vIG5vdCBtb3ZlIHRoZSB0YXJnZXQgcG9zaXRpb24gZWl0aGVyLgogIC8vCgoKICBpZiAoYS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikpIHsKICAgIHZhciBtZXJnZUluc2lkZSA9IGIuaG93TWFueSAhPSAwOwogICAgdmFyIG1lcmdlU3BsaXR0aW5nRWxlbWVudCA9IGIuZ3JhdmV5YXJkUG9zaXRpb24gJiYgYS5kZWxldGlvblBvc2l0aW9uLmlzRXF1YWwoYi5ncmF2ZXlhcmRQb3NpdGlvbik7CgogICAgaWYgKG1lcmdlSW5zaWRlIHx8IG1lcmdlU3BsaXR0aW5nRWxlbWVudCB8fCBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21lcmdlVGFyZ2V0Tm90TW92ZWQnKSB7CiAgICAgIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICAgIHJldHVybiBbYV07CiAgICB9CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBNZXJnZSBzb3VyY2UgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgc3BsaXQgcG9zaXRpb24uIFRoaXMgc29tZXRpbWVzIGhhcHBlbiwgbW9zdGx5IGR1cmluZyB1bmRvLgogIC8vIFRoZSBkZWNpc2lvbiBoZXJlIGlzIG1vc3RseSB0byBjaG9vc2Ugd2hldGhlciBtZXJnZSBzb3VyY2UgcG9zaXRpb24gc2hvdWxkIHN0YXkgd2hlcmUgaXQgaXMgKHNvIGl0IHdpbGwgYmUgYXQgdGhlIGVuZCBvZiB0aGUKICAvLyBzcGxpdCBlbGVtZW50KSBvciBzaG91bGQgYmUgbW92ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgZWxlbWVudC4KICAvLwoKCiAgaWYgKGEuc291cmNlUG9zaXRpb24uaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pKSB7CiAgICAvLyBVc2UgY29udGV4dCB0byBjaGVjayBpZiBgU3BsaXRPcGVyYXRpb25gIGlzIG5vdCB1bmRvaW5nIGEgbWVyZ2Ugb3BlcmF0aW9uLCB0aGF0IGRpZG4ndCBjaGFuZ2UgdGhlIGBhYCBvcGVyYXRpb24uCiAgICAvLyBUaGlzIHNjZW5hcmlvIGhhcHBlbnMgdGhlIHVuZG9uZSBtZXJnZSBvcGVyYXRpb24gbW92ZWQgbm9kZXMgYXQgdGhlIHNvdXJjZSBwb3NpdGlvbiBvZiBgYWAgb3BlcmF0aW9uLgogICAgLy8gSW4gdGhhdCBjYXNlIGBhYCBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uIHNob3VsZCBzdGF5IHdoZXJlIGl0IGlzLgogICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnbWVyZ2VTb3VyY2VOb3RNb3ZlZCcpIHsKICAgICAgYS5ob3dNYW55ID0gMDsKICAgICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICAgICAgcmV0dXJuIFthXTsKICAgIH0gLy8gVGhpcyBtZXJnZSBvcGVyYXRpb24gbWlnaHQgaGF2ZSBiZWVuIGVhcmxpZXIgdHJhbnNmb3JtZWQgYnkgYSBtZXJnZSBvcGVyYXRpb24gd2hpY2ggYm90aCBtZXJnZWQgdGhlIHNhbWUgZWxlbWVudC4KICAgIC8vIFNlZSB0aGF0IGNhc2UgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uIEluIHRoYXQgc2NlbmFyaW8sIGlmIHRoZSBtZXJnZSBvcGVyYXRpb24gaGFzIGJlZW4gdW5kb25lLAogICAgLy8gdGhlIHNwZWNpYWwgY2FzZSBpcyBub3QgYXBwbGllZC4KICAgIC8vCiAgICAvLyBOb3csIHRoZSBtZXJnZSBvcGVyYXRpb24gaXMgdHJhbnNmb3JtZWQgYnkgdGhlIHNwbGl0IHdoaWNoIGhhcyB1bmRvbmUgdGhhdCBwcmV2aW91cyBtZXJnZSBvcGVyYXRpb24uCiAgICAvLyBTbyBub3cgd2UgYXJlIGZpeGluZyBzaXR1YXRpb24gd2hpY2ggd2FzIHNraXBwZWQgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgY2FzZS4KICAgIC8vCgoKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21lcmdlU2FtZUVsZW1lbnQnIHx8IGEuc291cmNlUG9zaXRpb24ub2Zmc2V0ID4gMCkgewogICAgICBhLnNvdXJjZVBvc2l0aW9uID0gYi5tb3ZlVGFyZ2V0UG9zaXRpb24uY2xvbmUoKTsKICAgICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICAgICAgcmV0dXJuIFthXTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgPSBiLnNwbGl0UG9zaXRpb24ub2Zmc2V0OwogIH0KCiAgYS5zb3VyY2VQb3NpdGlvbiA9IGEuc291cmNlUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICBhLnRhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc2V0VHJhbnNmb3JtYXRpb24oTW92ZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIHZhciBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgdmFyIHRyYW5zZm9ybWVkID0gbW92ZVJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIsIGZhbHNlKVswXTsKCiAgYS5zb3VyY2VQb3NpdGlvbiA9IHRyYW5zZm9ybWVkLnN0YXJ0OwogIGEuaG93TWFueSA9IHRyYW5zZm9ybWVkLmVuZC5vZmZzZXQgLSB0cmFuc2Zvcm1lZC5zdGFydC5vZmZzZXQ7IC8vIFNlZSBgSW5zZXJ0T3BlcmF0aW9uYCB4IGBNb3ZlT3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbiBmb3IgZGV0YWlscyBvbiB0aGlzIGNhc2UuCiAgLy8KICAvLyBJbiBzdW1tYXJ5LCBib3RoIG9wZXJhdGlvbnMgcG9pbnQgdG8gdGhlIHNhbWUgcGxhY2UsIHNvIHRoZSBvcmRlciBvZiBub2RlcyBuZWVkcyB0byBiZSBkZWNpZGVkLgogIC8vIGBNb3ZlT3BlcmF0aW9uYCBpcyBjb25zaWRlcmVkIHdlYWtlciwgc28gaXQgaXMgYWx3YXlzIHRyYW5zZm9ybWVkLCB1bmxlc3MgdGhlcmUgd2FzIGEgY2VydGFpbiByZWxhdGlvbgogIC8vIGJldHdlZW4gb3BlcmF0aW9ucy4KICAvLwoKICBpZiAoIWEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLnBvc2l0aW9uKSkgewogICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTW92ZU9wZXJhdGlvbiwgTW92ZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICAvLwogIC8vIFNldHRpbmcgYW5kIGV2YWx1YXRpbmcgc29tZSB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gc3BlY2lhbCBjYXNlcyBhbmQgZGVmYXVsdCBhbGdvcml0aG0uCiAgLy8KICAvLyBDcmVhdGUgcmFuZ2VzIGZyb20gYE1vdmVPcGVyYXRpb25zYCBwcm9wZXJ0aWVzLgogIHZhciByYW5nZUEgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgdmFyIHJhbmdlQiA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOyAvLyBBc3NpZ24gYGNvbnRleHQuYUlzU3Ryb25nYCB0byBhIGRpZmZlcmVudCB2YXJpYWJsZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGNoYW5nZSBkdXJpbmcgZXhlY3V0aW9uIG9mCiAgLy8gdGhpcyBhbGdvcml0aG0gYW5kIHdlIGRvIG5vdCB3YW50IHRvIG92ZXJyaWRlIG9yaWdpbmFsIGBjb250ZXh0LmFJc1N0cm9uZ2AgdGhhdCB3aWxsIGJlIHVzZWQgaW4gbGF0ZXIgdHJhbnNmb3JtYXRpb25zLgoKCiAgdmFyIGFJc1N0cm9uZyA9IGNvbnRleHQuYUlzU3Ryb25nOyAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZWNpZGUgdGhlIG9yZGVyIG9mIG5vZGVzIGlmIGJvdGggb3BlcmF0aW9ucyB0YXJnZXQgYXQgdGhlIHNhbWUgcG9zaXRpb24uCiAgLy8gQnkgZGVmYXVsdCwgdXNlIHN0cm9uZy93ZWFrIG9wZXJhdGlvbiBtZWNoYW5pc20uCgogIHZhciBpbnNlcnRCZWZvcmUgPSAhY29udGV4dC5hSXNTdHJvbmc7IC8vIElmIHRoZSByZWxhdGlvbiBpcyBzZXQsIHRoZW4gdXNlIGl0IHRvIGRlY2lkZSBub2RlcyBvcmRlci4KCiAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnaW5zZXJ0QmVmb3JlJyB8fCBjb250ZXh0LmJhUmVsYXRpb24gPT0gJ2luc2VydEFmdGVyJykgewogICAgaW5zZXJ0QmVmb3JlID0gdHJ1ZTsKICB9IGVsc2UgaWYgKGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnaW5zZXJ0QWZ0ZXInIHx8IGNvbnRleHQuYmFSZWxhdGlvbiA9PSAnaW5zZXJ0QmVmb3JlJykgewogICAgaW5zZXJ0QmVmb3JlID0gZmFsc2U7CiAgfSAvLyBgYS50YXJnZXRQb3NpdGlvbmAgY291bGQgYmUgYWZmZWN0ZWQgYnkgdGhlIGBiYCBvcGVyYXRpb24uIFdlIHdpbGwgdHJhbnNmb3JtIGl0LgoKCiAgdmFyIG5ld1RhcmdldFBvc2l0aW9uOwoKICBpZiAoYS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKGIudGFyZ2V0UG9zaXRpb24pICYmIGluc2VydEJlZm9yZSkgewogICAgbmV3VGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsKICB9IGVsc2UgewogICAgbmV3VGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShiLnNvdXJjZVBvc2l0aW9uLCBiLnRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnkpOwogIH0gLy8KICAvLyBTcGVjaWFsIGNhc2UgIzEgKyBtaXJyb3IuCiAgLy8KICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBib3RoIG1vdmUgb3BlcmF0aW9ucycgdGFyZ2V0IHBvc2l0aW9ucyBhcmUgaW5zaWRlIG5vZGVzIHRoYXQgYXJlCiAgLy8gYmVpbmcgbW92ZWQgYnkgdGhlIG90aGVyIG1vdmUgb3BlcmF0aW9uLiBTbyBpbiBvdGhlciB3b3Jkcywgd2UgbW92ZSByYW5nZXMgaW50byBpbnNpZGUgb2YgZWFjaCBvdGhlci4KICAvLyBUaGlzIGNhc2UgY2FuJ3QgYmUgc29sdmVkIHJlYXNvbmFibHkgKG9uIHRoZSBvdGhlciBoYW5kLCBpdCBzaG91bGQgbm90IGhhcHBlbiBvZnRlbikuCgoKICBpZiAoX21vdmVUYXJnZXRJbnRvTW92ZWRSYW5nZShhLCBiKSAmJiBfbW92ZVRhcmdldEludG9Nb3ZlZFJhbmdlKGIsIGEpKSB7CiAgICAvLyBJbnN0ZWFkIG9mIHRyYW5zZm9ybWluZyBvcGVyYXRpb24sIHdlIHJldHVybiBhIHJldmVyc2Ugb2YgdGhlIG9wZXJhdGlvbiB0aGF0IHdlIHRyYW5zZm9ybSBieS4KICAgIC8vIFNvIHdoZW4gdGhlIHJlc3VsdHMgb2YgdGhpcyAidHJhbnNmb3JtYXRpb24iIHdpbGwgYmUgYXBwbGllZCwgYGJgIE1vdmVPcGVyYXRpb24gd2lsbCBnZXQgcmV2ZXJzZWQuCiAgICByZXR1cm4gW2IuZ2V0UmV2ZXJzZWQoKV07CiAgfSAvLwogIC8vIEVuZCBvZiBzcGVjaWFsIGNhc2UgIzEuCiAgLy8KICAvLwogIC8vIFNwZWNpYWwgY2FzZSAjMi4KICAvLwogIC8vIENoZWNrIGlmIGBiYCBvcGVyYXRpb24gdGFyZ2V0cyBpbnNpZGUgYHJhbmdlQWAuCgoKICB2YXIgYlRhcmdldHNUb0EgPSByYW5nZUEuY29udGFpbnNQb3NpdGlvbihiLnRhcmdldFBvc2l0aW9uKTsgLy8gSWYgYGJgIHRhcmdldHMgdG8gYHJhbmdlQWAgYW5kIGByYW5nZUFgIGNvbnRhaW5zIGByYW5nZUJgLCBgYmAgb3BlcmF0aW9uIGhhcyBubyBpbmZsdWVuY2Ugb24gYGFgIG9wZXJhdGlvbi4KICAvLyBZb3UgbWlnaHQgc2F5IHRoYXQgb3BlcmF0aW9uIGBiYCBpcyBjYXB0dXJlZCBpbnNpZGUgb3BlcmF0aW9uIGBhYC4KCiAgaWYgKGJUYXJnZXRzVG9BICYmIHJhbmdlQS5jb250YWluc1JhbmdlKHJhbmdlQiwgdHJ1ZSkpIHsKICAgIC8vIFRoZXJlIGlzIGEgbWluaS1zcGVjaWFsIGNhc2UgaGVyZSwgd2hlcmUgYHJhbmdlQmAgaXMgb24gb3RoZXIgbGV2ZWwgdGhhbiBgcmFuZ2VBYC4gVGhhdCdzIHdoeQogICAgLy8gd2UgbmVlZCB0byB0cmFuc2Zvcm0gYGFgIG9wZXJhdGlvbiBhbnl3YXkuCiAgICByYW5nZUEuc3RhcnQgPSByYW5nZUEuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByYW5nZUEuZW5kID0gcmFuZ2VBLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYi5zb3VyY2VQb3NpdGlvbiwgYi50YXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55KTsKICAgIHJldHVybiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhbcmFuZ2VBXSwgbmV3VGFyZ2V0UG9zaXRpb24pOwogIH0gLy8KICAvLyBTcGVjaWFsIGNhc2UgIzIgbWlycm9yLgogIC8vCgoKICB2YXIgYVRhcmdldHNUb0IgPSByYW5nZUIuY29udGFpbnNQb3NpdGlvbihhLnRhcmdldFBvc2l0aW9uKTsKCiAgaWYgKGFUYXJnZXRzVG9CICYmIHJhbmdlQi5jb250YWluc1JhbmdlKHJhbmdlQSwgdHJ1ZSkpIHsKICAgIC8vIGBhYCBvcGVyYXRpb24gaXMgIm1vdmVkIHRvZ2V0aGVyIiB3aXRoIGBiYCBvcGVyYXRpb24uCiAgICAvLyBIZXJlLCBqdXN0IG1vdmUgYHJhbmdlQWAgImluc2lkZSIgYHJhbmdlQmAuCiAgICByYW5nZUEuc3RhcnQgPSByYW5nZUEuc3RhcnQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgcmFuZ2VBLmVuZCA9IHJhbmdlQS5lbmQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgcmV0dXJuIF9tYWtlTW92ZU9wZXJhdGlvbnNGcm9tUmFuZ2VzKFtyYW5nZUFdLCBuZXdUYXJnZXRQb3NpdGlvbik7CiAgfSAvLwogIC8vIEVuZCBvZiBzcGVjaWFsIGNhc2UgIzIuCiAgLy8KICAvLwogIC8vIFNwZWNpYWwgY2FzZSAjMyArIG1pcnJvci4KICAvLwogIC8vIGByYW5nZUFgIGhhcyBhIG5vZGUgd2hpY2ggaXMgYW4gYW5jZXN0b3Igb2YgYHJhbmdlQmAuIEluIG90aGVyIHdvcmRzLCBgcmFuZ2VCYCBpcyBpbnNpZGUgYHJhbmdlQWAKICAvLyBidXQgbm90IG9uIHRoZSBzYW1lIHRyZWUgbGV2ZWwuIEluIHN1Y2ggY2FzZSByYW5nZXMgaGF2ZSBjb21tb24gcGFydCBidXQgd2UgaGF2ZSB0byB0cmVhdCBpdAogIC8vIGRpZmZlcmVudGx5LCBiZWNhdXNlIGluIHN1Y2ggY2FzZSB0aG9zZSByYW5nZXMgYXJlIG5vdCByZWFsbHkgY29uZmxpY3RpbmcgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGxpa2UKICAvLyB0d28gc2VwYXJhdGUgcmFuZ2VzLiBBbHNvIHdlIGhhdmUgdG8gZGlzY2FyZCB0d28gZGlmZmVyZW5jZSBwYXJ0cy4KCgogIHZhciBhQ29tcEIgPSBjb21wYXJlQXJyYXlzKGEuc291cmNlUG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpLCBiLnNvdXJjZVBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSk7CgogIGlmIChhQ29tcEIgPT0gJ3ByZWZpeCcgfHwgYUNvbXBCID09ICdleHRlbnNpb24nKSB7CiAgICAvLyBUcmFuc2Zvcm0gYHJhbmdlQWAgYnkgYGJgIG9wZXJhdGlvbiBhbmQgbWFrZSBvcGVyYXRpb24gb3V0IG9mIGl0LCBhbmQgdGhhdCdzIGFsbC4KICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGRlZmF1bHQgY2FzZSwgYnV0IGhlcmUgd2UgdHJlYXQgdGhlIGNvbW1vbiBwYXJ0ICh3aG9sZSBgcmFuZ2VBYCkKICAgIC8vIGxpa2UgYSBvbmUgZGlmZmVyZW5jZSBwYXJ0LgogICAgcmFuZ2VBLnN0YXJ0ID0gcmFuZ2VBLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShiLnNvdXJjZVBvc2l0aW9uLCBiLnRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnkpOwogICAgcmFuZ2VBLmVuZCA9IHJhbmdlQS5lbmQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMoW3JhbmdlQV0sIG5ld1RhcmdldFBvc2l0aW9uKTsKICB9IC8vCiAgLy8gRW5kIG9mIHNwZWNpYWwgY2FzZSAjMy4KICAvLwogIC8vCiAgLy8gRGVmYXVsdCBjYXNlIC0gcmFuZ2VzIGFyZSBvbiB0aGUgc2FtZSBsZXZlbCBvciBhcmUgbm90IGNvbm5lY3RlZCB3aXRoIGVhY2ggb3RoZXIuCiAgLy8KICAvLyBNb2RpZmllciBmb3IgZGVmYXVsdCBjYXNlLgogIC8vIE1vZGlmaWVzIGBhSXNTdHJvbmdgIGZsYWcgaW4gY2VydGFpbiBjb25kaXRpb25zLgogIC8vCiAgLy8gSWYgb25seSBvbmUgb2Ygb3BlcmF0aW9ucyBpcyBhIHJlbW92ZSBvcGVyYXRpb24sIHdlIGZvcmNlIHJlbW92ZSBvcGVyYXRpb24gdG8gYmUgdGhlICJzdHJvbmdlciIgb25lCiAgLy8gdG8gcHJvdmlkZSBtb3JlIGV4cGVjdGVkIHJlc3VsdHMuCgoKICBpZiAoYS50eXBlID09ICdyZW1vdmUnICYmIGIudHlwZSAhPSAncmVtb3ZlJyAmJiAhY29udGV4dC5hV2FzVW5kb25lICYmICFjb250ZXh0LmZvcmNlV2Vha1JlbW92ZSkgewogICAgYUlzU3Ryb25nID0gdHJ1ZTsKICB9IGVsc2UgaWYgKGEudHlwZSAhPSAncmVtb3ZlJyAmJiBiLnR5cGUgPT0gJ3JlbW92ZScgJiYgIWNvbnRleHQuYldhc1VuZG9uZSAmJiAhY29udGV4dC5mb3JjZVdlYWtSZW1vdmUpIHsKICAgIGFJc1N0cm9uZyA9IGZhbHNlOwogIH0gLy8gSGFuZGxlIG9wZXJhdGlvbidzIHNvdXJjZSByYW5nZXMgLSBjaGVjayBob3cgYHJhbmdlQWAgaXMgYWZmZWN0ZWQgYnkgYGJgIG9wZXJhdGlvbi4KICAvLyBUaGlzIHdpbGwgYWdncmVnYXRlIHRyYW5zZm9ybWVkIHJhbmdlcy4KCgogIHZhciByYW5nZXMgPSBbXTsgLy8gR2V0IHRoZSAiZGlmZmVyZW5jZSBwYXJ0IiBvZiBgYWAgb3BlcmF0aW9uIHNvdXJjZSByYW5nZS4KICAvLyBUaGlzIGlzIGFuIGFycmF5IHdpdGggb25lIG9yIHR3byByYW5nZXMuIFR3byByYW5nZXMgaWYgYHJhbmdlQmAgaXMgaW5zaWRlIGByYW5nZUFgLgoKICB2YXIgZGlmZmVyZW5jZSA9IHJhbmdlQS5nZXREaWZmZXJlbmNlKHJhbmdlQik7CiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gZmFsc2U7CiAgdmFyIF9pdGVyYXRvckVycm9yNiA9IHVuZGVmaW5lZDsKCiAgdHJ5IHsKICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSBkaWZmZXJlbmNlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA2OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gKF9zdGVwNiA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlKSB7CiAgICAgIHZhciByYW5nZSA9IF9zdGVwNi52YWx1ZTsKICAgICAgLy8gVHJhbnNmb3JtIHRob3NlIHJhbmdlcyBieSBgYmAgb3BlcmF0aW9uLiBGb3IgZXhhbXBsZSBpZiBgYmAgbW92ZWQgcmFuZ2UgZnJvbSBiZWZvcmUgdGhvc2UgcmFuZ2VzLCBmaXggdGhvc2UgcmFuZ2VzLgogICAgICByYW5nZS5zdGFydCA9IHJhbmdlLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsKICAgICAgcmFuZ2UuZW5kID0gcmFuZ2UuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsgLy8gSWYgYGJgIG9wZXJhdGlvbiB0YXJnZXRzIGludG8gYHJhbmdlQWAgb24gdGhlIHNhbWUgbGV2ZWwsIHNwcmVhZCBgcmFuZ2VBYCBpbnRvIHR3byByYW5nZXMuCgogICAgICB2YXIgc2hvdWxkU3ByZWFkID0gY29tcGFyZUFycmF5cyhyYW5nZS5zdGFydC5nZXRQYXJlbnRQYXRoKCksIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkuZ2V0UGFyZW50UGF0aCgpKSA9PSAnc2FtZSc7CgogICAgICB2YXIgbmV3UmFuZ2VzID0gcmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oYi5nZXRNb3ZlZFJhbmdlU3RhcnQoKSwgYi5ob3dNYW55LCBzaG91bGRTcHJlYWQpOwoKICAgICAgcmFuZ2VzLnB1c2guYXBwbHkocmFuZ2VzLCBfdG9Db25zdW1hYmxlQXJyYXkobmV3UmFuZ2VzKSk7CiAgICB9IC8vIFRoZW4sIHdlIGhhdmUgdG8gbWFuYWdlIHRoZSAiY29tbW9uIHBhcnQiIG9mIGJvdGggbW92ZSByYW5nZXMuCgogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTsKICAgIF9pdGVyYXRvckVycm9yNiA9IGVycjsKICB9IGZpbmFsbHkgewogICAgdHJ5IHsKICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiAmJiBfaXRlcmF0b3I2LnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTsKICAgICAgfQogICAgfSBmaW5hbGx5IHsKICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjsKICAgICAgfQogICAgfQogIH0KCiAgdmFyIGNvbW1vbiA9IHJhbmdlQS5nZXRJbnRlcnNlY3Rpb24ocmFuZ2VCKTsKCiAgaWYgKGNvbW1vbiAhPT0gbnVsbCAmJiBhSXNTdHJvbmcpIHsKICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoYXQgcGFydCBvZiBvcmlnaW5hbCByYW5nZS4KICAgIGNvbW1vbi5zdGFydCA9IGNvbW1vbi5zdGFydC5fZ2V0Q29tYmluZWQoYi5zb3VyY2VQb3NpdGlvbiwgYi5nZXRNb3ZlZFJhbmdlU3RhcnQoKSk7CiAgICBjb21tb24uZW5kID0gY29tbW9uLmVuZC5fZ2V0Q29tYmluZWQoYi5zb3VyY2VQb3NpdGlvbiwgYi5nZXRNb3ZlZFJhbmdlU3RhcnQoKSk7IC8vIFRha2UgY2FyZSBvZiBwcm9wZXIgcmFuZ2Ugb3JkZXIuCiAgICAvLwogICAgLy8gUHV0IGBjb21tb25gIGF0IGFwcHJvcHJpYXRlIHBsYWNlLiBLZWVwIGluIG1pbmQgdGhhdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBvcmlnaW5hbCBvcmRlci4KICAgIC8vIEJhc2ljYWxseSB0aGVyZSBhcmUgb25seSB0aHJlZSBjYXNlczogdGhlcmUgaXMgemVybywgb25lIG9yIHR3byBkaWZmZXJlbmNlIHJhbmdlcy4KICAgIC8vCiAgICAvLyBJZiB0aGVyZSBpcyB6ZXJvIGRpZmZlcmVuY2UgcmFuZ2VzLCBqdXN0IHB1c2ggYGNvbW1vbmAgaW4gdGhlIGFycmF5LgoKICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSB7CiAgICAgIHJhbmdlcy5wdXNoKGNvbW1vbik7CiAgICB9IC8vIElmIHRoZXJlIGlzIG9uZSBkaWZmZXJlbmNlIHJhbmdlLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgY29tbW9uIHBhcnQgd2FzIGJlZm9yZSBpdCBvciBhZnRlciBpdC4KICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPT0gMSkgewogICAgICAgIGlmIChyYW5nZUIuc3RhcnQuaXNCZWZvcmUocmFuZ2VBLnN0YXJ0KSB8fCByYW5nZUIuc3RhcnQuaXNFcXVhbChyYW5nZUEuc3RhcnQpKSB7CiAgICAgICAgICByYW5nZXMudW5zaGlmdChjb21tb24pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByYW5nZXMucHVzaChjb21tb24pOwogICAgICAgIH0KICAgICAgfSAvLyBJZiB0aGVyZSBhcmUgbW9yZSByYW5nZXMgKHdoaWNoIG1lYW5zIHR3byksIHB1dCBjb21tb24gcGFydCBiZXR3ZWVuIHRoZW0uIFRoaXMgaXMgdGhlIG9ubHkgc2NlbmFyaW8KICAgICAgLy8gd2hlcmUgdGhlcmUgY291bGQgYmUgdHdvIGRpZmZlcmVuY2UgcmFuZ2VzIHNvIHdlIGRvbid0IGhhdmUgdG8gbWFrZSBhbnkgY29tcGFyaXNvbnMuCiAgICAgIGVsc2UgewogICAgICAgICAgcmFuZ2VzLnNwbGljZSgxLCAwLCBjb21tb24pOwogICAgICAgIH0KICB9CgogIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSB7CiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gInNvdXJjZSByYW5nZXMiLCBub3RoaW5nIHNob3VsZCBiZSBjaGFuZ2VkLgogICAgLy8gTm90ZSB0aGF0IHRoaXMgY2FuIGhhcHBlbiBvbmx5IGlmIGBhSXNTdHJvbmcgPT0gZmFsc2VgIGFuZCBgcmFuZ2VBLmlzRXF1YWwoIHJhbmdlQiApYC4KICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKGEuYmFzZVZlcnNpb24pXTsKICB9CgogIHJldHVybiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhyYW5nZXMsIG5ld1RhcmdldFBvc2l0aW9uKTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1vdmVPcGVyYXRpb24sIFNwbGl0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIHZhciBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uY2xvbmUoKTsgLy8gRG8gbm90IHRyYW5zZm9ybSBpZiB0YXJnZXQgcG9zaXRpb24gaXMgc2FtZSBhcyBzcGxpdCBpbnNlcnRpb24gcG9zaXRpb24gYW5kIHRoaXMgc3BsaXQgY29tZXMgZnJvbSB1bmRvLgogIC8vIFRoaXMgc2hvdWxkIGJlIGRvbmUgb24gcmVsYXRpb25zIGJ1dCBpdCBpcyB0b28gbXVjaCB3b3JrIGZvciBub3cgYXMgaXQgd291bGQgcmVxdWlyZSByZWxhdGlvbnMgd29ya2luZyBpbiBjb2xsYWJvcmF0aW9uLgogIC8vIFdlIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhvdyB3ZSB3aWxsIHJlc29sdmUgc3VjaCBjb25mbGljdCBhbmQgdGhpcyBpcyBsZXNzIGhhcm1mdWwgd2F5LgoKICBpZiAoIWEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLmluc2VydGlvblBvc2l0aW9uKSB8fCAhYi5ncmF2ZXlhcmRQb3NpdGlvbiB8fCBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21vdmVUYXJnZXRBZnRlcicpIHsKICAgIG5ld1RhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0gLy8gQ2FzZSAxOgogIC8vCiAgLy8gTGFzdCBlbGVtZW50IGluIHRoZSBtb3ZlZCByYW5nZSBnb3Qgc3BsaXQuCiAgLy8KICAvLyBJbiB0aGlzIGNhc2UgdGhlIGRlZmF1bHQgcmFuZ2UgdHJhbnNmb3JtYXRpb24gd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgYXMgdGhlIGVsZW1lbnQgY3JlYXRlZCBieQogIC8vIHNwbGl0IG9wZXJhdGlvbiB3b3VsZCBiZSBvdXRzaWRlIHRoZSByYW5nZS4gVGhlIHJhbmdlIHRvIG1vdmUgbmVlZHMgdG8gYmUgZml4ZWQgbWFudWFsbHkuCiAgLy8KCgogIHZhciBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgaWYgKG1vdmVSYW5nZS5lbmQuaXNFcXVhbChiLmluc2VydGlvblBvc2l0aW9uKSkgewogICAgLy8gRG8gaXQgb25seSBpZiB0aGlzIGlzIGEgIm5hdHVyYWwiIHNwbGl0LCBub3QgYSBvbmUgdGhhdCBjb21lcyBmcm9tIHVuZG8uCiAgICAvLyBJZiB0aGlzIGlzIHVuZG8gc3BsaXQsIG9ubHkgYHRhcmdldFBvc2l0aW9uYCBuZWVkcyB0byBiZSBjaGFuZ2VkIChpZiB0aGUgbW92ZSBpcyBhIHJlbW92ZSkuCiAgICBpZiAoIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgYS5ob3dNYW55Kys7CiAgICB9CgogICAgYS50YXJnZXRQb3NpdGlvbiA9IG5ld1RhcmdldFBvc2l0aW9uOwogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMjoKICAvLwogIC8vIFNwbGl0IGhhcHBlbmVkIGJldHdlZW4gdGhlIG1vdmVkIG5vZGVzLiBJbiB0aGlzIGNhc2UgdHdvIHJhbmdlcyB0byBtb3ZlIG5lZWQgdG8gYmUgZ2VuZXJhdGVkLgogIC8vCiAgLy8gQ2hhcmFjdGVycyBgb3piYWAgYXJlIG1vdmVkIHRvIHRoZSBlbmQgb2YgcGFyYWdyYXBoIGBYeXpgIGJ1dCBzcGxpdCBoYXBwZW5lZC4KICAvLyA8cD5GW296fGJhXXI8L3A+PHA+WHl6PC9wPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHA+RltvejwvcD48cD5iYV1yPC9wPjxwPlh5ejwvcD4KICAvLwogIC8vIENvcnJlY3QgcmFuZ2VzOgogIC8vIDxwPkZbb3pdPC9wPjxwPltiYV1yPC9wPjxwPlh5ejwvcD4KICAvLwogIC8vIEFmdGVyIG1vdmU6CiAgLy8gPHA+RjwvcD48cD5yPC9wPjxwPlh5em96YmE8L3A+CiAgLy8KCgogIGlmIChtb3ZlUmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIuc3BsaXRQb3NpdGlvbikgJiYgbW92ZVJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYi5zcGxpdFBvc2l0aW9uKSkgewogICAgdmFyIHJpZ2h0UmFuZ2UgPSBuZXcgUmFuZ2UoYi5zcGxpdFBvc2l0aW9uLCBtb3ZlUmFuZ2UuZW5kKTsKICAgIHJpZ2h0UmFuZ2UgPSByaWdodFJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICB2YXIgX3JhbmdlcyA9IFtuZXcgUmFuZ2UobW92ZVJhbmdlLnN0YXJ0LCBiLnNwbGl0UG9zaXRpb24pLCByaWdodFJhbmdlXTsKICAgIHJldHVybiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhfcmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7CiAgfSAvLyBDYXNlIDM6CiAgLy8KICAvLyBNb3ZlIG9wZXJhdGlvbiB0YXJnZXRzIGF0IHRoZSBzcGxpdCBwb3NpdGlvbi4gV2UgbmVlZCB0byBkZWNpZGUgaWYgdGhlIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZAogIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHNwbGl0IGVsZW1lbnQgb3IgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGVsZW1lbnQuCiAgLy8KCgogIGlmIChhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEF0U291cmNlJykgewogICAgbmV3VGFyZ2V0UG9zaXRpb24gPSBiLm1vdmVUYXJnZXRQb3NpdGlvbjsKICB9IC8vIENhc2UgNDoKICAvLwogIC8vIE1vdmUgb3BlcmF0aW9uIHRhcmdldHMganVzdCBhZnRlciB0aGUgc3BsaXQgZWxlbWVudC4gV2UgbmVlZCB0byBkZWNpZGUgaWYgdGhlIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZAogIC8vIGJldHdlZW4gdHdvIHBhcnRzIG9mIHNwbGl0IGVsZW1lbnQsIG9yIGFmdGVyIHRoZSBuZXcgZWxlbWVudC4KICAvLwogIC8vIFNwbGl0IGF0IGB8YCwgd2hpbGUgbW92ZSBvcGVyYXRpb24gbW92ZXMgYDxwPlh5ejwvcD5gIGFuZCB0YXJnZXRzIGF0IGBeYDoKICAvLyA8cD5Gb298YmFyPC9wPl48cD5iYXo8L3A+CiAgLy8gPHA+Rm9vPC9wPl48cD5iYXI8L3A+PHA+YmF6PC9wPiBvciA8cD5Gb288L3A+PHA+YmFyPC9wPl48cD5iYXo8L3A+PwogIC8vCiAgLy8gSWYgdGhlcmUgaXMgbm8gY29udGV4dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIG9wZXJhdGlvbnMgKGZvciBleGFtcGxlLCB0aGV5IGNvbWUgZnJvbSBjb2xsYWJvcmF0aXZlCiAgLy8gZWRpdGluZyksIHdlIGRvbid0IHdhbnQgdG8gcHV0IHNvbWUgdW5yZWxhdGVkIGNvbnRlbnQgKG1vdmUpIGJldHdlZW4gcGFydHMgb2YgcmVsYXRlZCBjb250ZW50IChzcGxpdCBwYXJ0cykuCiAgLy8gSG93ZXZlciwgaWYgdGhlIHNwbGl0IGlzIGZyb20gdW5kbywgaW4gdGhlIHBhc3QsIHRoZSBtb3ZlZCBjb250ZW50IG1pZ2h0IGJlIHRhcmdldGluZyBiZXR3ZWVuIHRoZQogIC8vIHNwbGl0IHBhcnRzLCBtZWFuaW5nIHRoYXQgd2FzIGV4YWN0bHkgdXNlcidzIGludGVudGlvbjoKICAvLwogIC8vIDxwPkZvbzwvcD5ePHA+YmFyPC9wPgkJPC0tLSBvcmlnaW5hbCBzaXR1YXRpb24sIGluICJwYXN0Ii4KICAvLyA8cD5Gb29iYXI8L3A+XgkJCQk8LS0tIGFmdGVyIG1lcmdlIHRhcmdldCBwb3NpdGlvbiBpcyB0cmFuc2Zvcm1lZC4KICAvLyA8cD5Gb298YmFyPC9wPl4JCQkJPC0tLSB0aGVuIHRoZSBtZXJnZSBpcyB1bmRvbmUsIGFuZCBzcGxpdCBoYXBwZW5zLCB3aGljaCBsZWFkcyB1cyB0byBjdXJyZW50IHNpdHVhdGlvbi4KICAvLwogIC8vIEluIHRoaXMgY2FzZSBpdCBpcyBwcmV0dHkgY2xlYXIgdGhhdCB0aGUgaW50ZW50aW9uIHdhcyB0byBwdXQgbmV3IHBhcmFncmFwaCBiZXR3ZWVuIHRob3NlIG5vZGVzLAogIC8vIHNvIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGFjY29yZGluZ2x5LiBXZSBjYW4gZGV0ZWN0IHRoaXMgc2NlbmFyaW8gdGhhbmtzIHRvIHJlbGF0aW9ucy4KICAvLwoKCiAgaWYgKGEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLmluc2VydGlvblBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEJldHdlZW4nKSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb247CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICB2YXIgdHJhbnNmb3JtZWQgPSBtb3ZlUmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKCiAgdmFyIHJhbmdlcyA9IFt0cmFuc2Zvcm1lZF07IC8vIENhc2UgNToKICAvLwogIC8vIE1vdmVkIHJhbmdlIGNvbnRhaW5zIGdyYXZleWFyZCBlbGVtZW50IHVzZWQgYnkgc3BsaXQgb3BlcmF0aW9uLiBBZGQgZXh0cmEgbW92ZSBvcGVyYXRpb24gdG8gdGhlIHJlc3VsdC4KICAvLwoKICBpZiAoYi5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgdmFyIG1vdmVzR3JhdmV5YXJkRWxlbWVudCA9IG1vdmVSYW5nZS5zdGFydC5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pIHx8IG1vdmVSYW5nZS5jb250YWluc1Bvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24pOwoKICAgIGlmIChhLmhvd01hbnkgPiAxICYmIG1vdmVzR3JhdmV5YXJkRWxlbWVudCAmJiAhY29udGV4dC5hV2FzVW5kb25lKSB7CiAgICAgIHJhbmdlcy5wdXNoKFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLmluc2VydGlvblBvc2l0aW9uLCAxKSk7CiAgICB9CiAgfQoKICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNb3ZlT3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICB2YXIgbW92ZWRSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChhLnNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnkpOwoKICBpZiAoYi5kZWxldGlvblBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhhLnNvdXJjZVBvc2l0aW9uKSAmJiBtb3ZlZFJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYi5zb3VyY2VQb3NpdGlvbikpIHsKICAgIGlmIChhLnR5cGUgPT0gJ3JlbW92ZScgJiYgIWNvbnRleHQuZm9yY2VXZWFrUmVtb3ZlKSB7CiAgICAgIC8vIENhc2UgMToKICAgICAgLy8KICAgICAgLy8gVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIGdvdCBtZXJnZWQuCiAgICAgIC8vCiAgICAgIC8vIE1lcmdlIG9wZXJhdGlvbiBkb2VzIHN1cHBvcnQgbWVyZ2luZyBlbGVtZW50cyB3aGljaCBhcmUgbm90IHNpYmxpbmdzLiBTbyBpdCB3b3VsZCBub3QgYmUgYSBwcm9ibGVtCiAgICAgIC8vIGZyb20gdGVjaG5pY2FsIHBvaW50IG9mIHZpZXcuIEhvd2V2ZXIsIGlmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLCB0aGUgaW50ZW50aW9uIG9mIHRoZSB1c2VyCiAgICAgIC8vIGRlbGV0aW5nIGl0IHdhcyB0byBoYXZlIGl0IGFsbCBkZWxldGVkLiBGcm9tIHVzZXIgZXhwZXJpZW5jZSBwb2ludCBvZiB2aWV3LCBtb3ZpbmcgYmFjayB0aGUKICAgICAgLy8gcmVtb3ZlZCBub2RlcyBtaWdodCBiZSB1bmV4cGVjdGVkLiBUaGlzIG1lYW5zIHRoYXQgaW4gdGhpcyBzY2VuYXJpbyB3ZSB3aWxsIHJldmVyc2UgbWVyZ2luZyBhbmQgcmVtb3ZlIHRoZSBlbGVtZW50LgogICAgICAvLwogICAgICBpZiAoIWNvbnRleHQuYVdhc1VuZG9uZSkgewogICAgICAgIHZhciByZXN1bHRzID0gW107CiAgICAgICAgdmFyIGd5TW92ZVNvdXJjZSA9IGIuZ3JhdmV5YXJkUG9zaXRpb24uY2xvbmUoKTsKCiAgICAgICAgdmFyIHNwbGl0Tm9kZXNNb3ZlU291cmNlID0gYi50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwoKICAgICAgICBpZiAoYS5ob3dNYW55ID4gMSkgewogICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBNb3ZlT3BlcmF0aW9uKGEuc291cmNlUG9zaXRpb24sIGEuaG93TWFueSAtIDEsIGEudGFyZ2V0UG9zaXRpb24sIDApKTsKICAgICAgICAgIGd5TW92ZVNvdXJjZSA9IGd5TW92ZVNvdXJjZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYS5zb3VyY2VQb3NpdGlvbiwgYS50YXJnZXRQb3NpdGlvbiwgYS5ob3dNYW55IC0gMSk7CiAgICAgICAgICBzcGxpdE5vZGVzTW92ZVNvdXJjZSA9IHNwbGl0Tm9kZXNNb3ZlU291cmNlLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShhLnNvdXJjZVBvc2l0aW9uLCBhLnRhcmdldFBvc2l0aW9uLCBhLmhvd01hbnkgLSAxKTsKICAgICAgICB9CgogICAgICAgIHZhciBneU1vdmVUYXJnZXQgPSBiLmRlbGV0aW9uUG9zaXRpb24uX2dldENvbWJpbmVkKGEuc291cmNlUG9zaXRpb24sIGEudGFyZ2V0UG9zaXRpb24pOwoKICAgICAgICB2YXIgZ3lNb3ZlID0gbmV3IE1vdmVPcGVyYXRpb24oZ3lNb3ZlU291cmNlLCAxLCBneU1vdmVUYXJnZXQsIDApOwogICAgICAgIHZhciBzcGxpdE5vZGVzTW92ZVRhcmdldFBhdGggPSBneU1vdmUuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkucGF0aC5zbGljZSgpOwogICAgICAgIHNwbGl0Tm9kZXNNb3ZlVGFyZ2V0UGF0aC5wdXNoKDApOwogICAgICAgIHZhciBzcGxpdE5vZGVzTW92ZVRhcmdldCA9IG5ldyBQb3NpdGlvbihneU1vdmUudGFyZ2V0UG9zaXRpb24ucm9vdCwgc3BsaXROb2Rlc01vdmVUYXJnZXRQYXRoKTsKICAgICAgICBzcGxpdE5vZGVzTW92ZVNvdXJjZSA9IHNwbGl0Tm9kZXNNb3ZlU291cmNlLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShneU1vdmVTb3VyY2UsIGd5TW92ZVRhcmdldCwgMSk7CiAgICAgICAgdmFyIHNwbGl0Tm9kZXNNb3ZlID0gbmV3IE1vdmVPcGVyYXRpb24oc3BsaXROb2Rlc01vdmVTb3VyY2UsIGIuaG93TWFueSwgc3BsaXROb2Rlc01vdmVUYXJnZXQsIDApOwogICAgICAgIHJlc3VsdHMucHVzaChneU1vdmUpOwogICAgICAgIHJlc3VsdHMucHVzaChzcGxpdE5vZGVzTW92ZSk7CiAgICAgICAgcmV0dXJuIHJlc3VsdHM7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIC8vIENhc2UgMjoKICAgICAgLy8KICAgICAgLy8gVGhlIGVsZW1lbnQgdG8gbW92ZSBnb3QgbWVyZ2VkIGFuZCBpdCB3YXMgdGhlIG9ubHkgZWxlbWVudCB0byBtb3ZlLgogICAgICAvLyBJbiB0aGlzIGNhc2UganVzdCBkb24ndCBkbyBhbnl0aGluZywgbGVhdmUgdGhlIG5vZGUgaW4gdGhlIGdyYXZleWFyZC4gV2l0aG91dCBzcGVjaWFsIGNhc2UKICAgICAgLy8gaXQgd291bGQgYmUgYSBtb3ZlIG9wZXJhdGlvbiB0aGF0IG1vdmVzIDAgbm9kZXMsIHNvIG1heWJlIGl0IGlzIGJldHRlciBqdXN0IHRvIHJldHVybiBuby1vcC4KICAgICAgLy8KICAgICAgaWYgKGEuaG93TWFueSA9PSAxKSB7CiAgICAgICAgaWYgKCFjb250ZXh0LmJXYXNVbmRvbmUpIHsKICAgICAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYS5zb3VyY2VQb3NpdGlvbiA9IGIuZ3JhdmV5YXJkUG9zaXRpb24uY2xvbmUoKTsKICAgICAgICAgIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgICAgICAgICByZXR1cm4gW2FdOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgdmFyIG1vdmVSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChhLnNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnkpOwoKICB2YXIgdHJhbnNmb3JtZWQgPSBtb3ZlUmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgYS5zb3VyY2VQb3NpdGlvbiA9IHRyYW5zZm9ybWVkLnN0YXJ0OwogIGEuaG93TWFueSA9IHRyYW5zZm9ybWVkLmVuZC5vZmZzZXQgLSB0cmFuc2Zvcm1lZC5zdGFydC5vZmZzZXQ7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKFJlbmFtZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIC8vIENhc2UgMToKICAvLwogIC8vIEVsZW1lbnQgdG8gcmVuYW1lIGdvdCBtZXJnZWQsIHNvIGl0IHdhcyBtb3ZlZCB0byBgYi5ncmF2ZXlhcmRQb3NpdGlvbmAuCiAgLy8KICBpZiAoYS5wb3NpdGlvbi5pc0VxdWFsKGIuZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgIGEucG9zaXRpb24gPSBiLmdyYXZleWFyZFBvc2l0aW9uLmNsb25lKCk7CiAgICBhLnBvc2l0aW9uLnN0aWNraW5lc3MgPSAndG9OZXh0JzsKICAgIHJldHVybiBbYV07CiAgfQoKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIFJlbmFtZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICBpZiAoYS5wb3NpdGlvbi5pc0VxdWFsKGIucG9zaXRpb24pKSB7CiAgICBpZiAoY29udGV4dC5hSXNTdHJvbmcpIHsKICAgICAgYS5vbGROYW1lID0gYi5uZXdOYW1lOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFJlbmFtZU9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiKSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGVsZW1lbnQgdG8gcmVuYW1lIGhhcyBiZWVuIHNwbGl0LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZWxlbWVudCBzaG91bGQgYmUgYWxzbyByZW5hbWVkLgogIC8vCiAgLy8gVXNlciBkZWNpZGVzIHRvIGNoYW5nZSB0aGUgcGFyYWdyYXBoIHRvIGEgbGlzdCBpdGVtOgogIC8vIDxwYXJhZ3JhcGg+Rm9vYmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBIb3dldmVyLCBpbiBtZWFudGltZSwgc3BsaXQgaGFwcGVuczoKICAvLyA8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBBcyBhIHJlc3VsdCwgcmVuYW1lIGJvdGggZWxlbWVudHM6CiAgLy8gPGxpc3RJdGVtPkZvbzwvbGlzdEl0ZW0+PGxpc3RJdGVtPmJhcjwvbGlzdEl0ZW0+CiAgLy8KICB2YXIgcmVuYW1lUGF0aCA9IGEucG9zaXRpb24ucGF0aDsKICB2YXIgc3BsaXRQYXRoID0gYi5zcGxpdFBvc2l0aW9uLmdldFBhcmVudFBhdGgoKTsKCiAgaWYgKGNvbXBhcmVBcnJheXMocmVuYW1lUGF0aCwgc3BsaXRQYXRoKSA9PSAnc2FtZScgJiYgIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIHZhciBleHRyYVJlbmFtZSA9IG5ldyBSZW5hbWVPcGVyYXRpb24oYS5wb3NpdGlvbi5nZXRTaGlmdGVkQnkoMSksIGEub2xkTmFtZSwgYS5uZXdOYW1lLCAwKTsKICAgIHJldHVybiBbYSwgZXh0cmFSZW5hbWVdOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24sIFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgaWYgKGEucm9vdCA9PT0gYi5yb290ICYmIGEua2V5ID09PSBiLmtleSkgewogICAgaWYgKCFjb250ZXh0LmFJc1N0cm9uZyB8fCBhLm5ld1ZhbHVlID09PSBiLm5ld1ZhbHVlKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0gZWxzZSB7CiAgICAgIGEub2xkVmFsdWUgPSBiLm5ld1ZhbHVlOwogICAgfQogIH0KCiAgcmV0dXJuIFthXTsKfSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpzZXRUcmFuc2Zvcm1hdGlvbihTcGxpdE9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYikgewogIC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnBvc2l0aW9uKSAmJiBhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IDwgYi5wb3NpdGlvbi5vZmZzZXQpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFNwbGl0T3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgZnVuY3Rpb24gKGEsIGIsIGNvbnRleHQpIHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBTcGxpdCBlbGVtZW50IGdvdCBtZXJnZWQuIElmIHR3byBkaWZmZXJlbnQgZWxlbWVudHMgd2VyZSBtZXJnZWQsIGNsaWVudHMgd2lsbCBoYXZlIGRpZmZlcmVudCBjb250ZW50LgogIC8vCiAgLy8gRXhhbXBsZS4gTWVyZ2UgYXQgYHt9YCwgc3BsaXQgYXQgYFtdYDoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkJbXWFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBPbiBtZXJnZSBzaWRlIGl0IHdpbGwgbG9vayBsaWtlIHRoaXM6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48aGVhZGluZz5hcjwvaGVhZGluZz4KICAvLwogIC8vIE9uIHNwbGl0IHNpZGUgaXQgd2lsbCBsb29rIGxpa2UgdGhpczoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkI8L3BhcmFncmFwaD48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBDbGVhcmx5LCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgZGlmZmVyZW50IGZvciBib3RoIGNsaWVudHMuCiAgLy8KICAvLyBXZSBjb3VsZCB1c2UgdGhlIHJlbW92ZWQgbWVyZ2UgZWxlbWVudCBmcm9tIGdyYXZleWFyZCBhcyBhIHNwbGl0IGVsZW1lbnQgYnV0IHRoZW4gY2xpZW50cyB3b3VsZCBoYXZlIGEgZGlmZmVyZW50CiAgLy8gbW9kZWwgc3RhdGUgKGluIGdyYXZleWFyZCksIGJlY2F1c2UgdGhlIHNwbGl0IHNpZGUgY2xpZW50IHdvdWxkIHN0aWxsIGhhdmUgYW4gZWxlbWVudCBpbiBncmF2ZXlhcmQgKHJlbW92ZWQgYnkgbWVyZ2UpLgogIC8vCiAgLy8gVG8gb3ZlcmNvbWUgdGhpcywgaW4gYFNwbGl0T3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gd2Ugd2lsbCBhZGQgYWRkaXRpb25hbCBgU3BsaXRPcGVyYXRpb25gCiAgLy8gaW4gdGhlIGdyYXZleWFyZCwgd2hpY2ggd2lsbCBhY3R1YWxseSBjbG9uZSB0aGUgbWVyZ2VkLWFuZC1kZWxldGVkIGVsZW1lbnQuIFRoZW4sIHRoYXQgY2xvbmVkIGVsZW1lbnQgd2lsbCBiZQogIC8vIHVzZWQgZm9yIHNwbGl0dGluZy4gRXhhbXBsZSBiZWxvdy4KICAvLwogIC8vIE9yaWdpbmFsIHN0YXRlOgogIC8vIDxoZWFkaW5nPkZvbzwvaGVhZGluZz57fTxwYXJhZ3JhcGg+QltdYXI8L3BhcmFncmFwaD4KICAvLwogIC8vIE1lcmdlIHNpZGUgY2xpZW50OgogIC8vCiAgLy8gQWZ0ZXIgbWVyZ2U6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gRXh0cmEgc3BsaXQ6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBVc2UgdGhlICJjbG9uZWQiIGVsZW1lbnQgZnJvbSBncmF2ZXlhcmQ6CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+ICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gU3BsaXQgc2lkZSBjbGllbnQ6CiAgLy8KICAvLyBBZnRlciBzcGxpdDoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkI8L3BhcmFncmFwaD48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBBZnRlciBtZXJnZToKICAvLyA8aGVhZGluZz5Gb29CPC9oZWFkaW5nPjxwYXJhZ3JhcGg+YXI8L3BhcmFncmFwaD4gICAgICAgICAgICBncmF2ZXlhcmQ6IDxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBUaGlzIHNwZWNpYWwgY2FzZSBzY2VuYXJpbyBvbmx5IGFwcGxpZXMgaWYgdGhlIG9yaWdpbmFsIHNwbGl0IG9wZXJhdGlvbiBjbG9uZXMgdGhlIHNwbGl0IGVsZW1lbnQuCiAgLy8gSWYgdGhlIG9yaWdpbmFsIHNwbGl0IG9wZXJhdGlvbiBoYXMgYGdyYXZleWFyZFBvc2l0aW9uYCBzZXQsIGl0IGFsbCBkb2Vzbid0IGhhdmUgc2Vuc2UgYmVjYXVzZSBzcGxpdCBvcGVyYXRpb24KICAvLyBrbm93cyBleGFjdGx5IHdoaWNoIGVsZW1lbnQgaXQgc2hvdWxkIHVzZS4gU28gdGhlcmUgd291bGQgYmUgbm8gb3JpZ2luYWwgcHJvYmxlbSB3aXRoIGRpZmZlcmVudCBjb250ZW50cy4KICAvLwogIC8vIEFkZGl0aW9uYWxseSwgdGhlIHNwZWNpYWwgY2FzZSBhcHBsaWVzIG9ubHkgaWYgdGhlIG1lcmdlIHdhc24ndCBhbHJlYWR5IHVuZG9uZS4KICAvLwogIGlmICghYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiAhY29udGV4dC5iV2FzVW5kb25lICYmIGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikpIHsKICAgIHZhciBzcGxpdFBhdGggPSBiLmdyYXZleWFyZFBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgIHNwbGl0UGF0aC5wdXNoKDApOwogICAgdmFyIHNwbGl0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24oYi5ncmF2ZXlhcmRQb3NpdGlvbi5yb290LCBzcGxpdFBhdGgpOwogICAgdmFyIGluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24obmV3IFBvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24ucm9vdCwgc3BsaXRQYXRoKSk7CiAgICB2YXIgYWRkaXRpb25hbFNwbGl0ID0gbmV3IFNwbGl0T3BlcmF0aW9uKHNwbGl0UG9zaXRpb24sIDAsIG51bGwsIDApOwogICAgYWRkaXRpb25hbFNwbGl0Lmluc2VydGlvblBvc2l0aW9uID0gaW5zZXJ0aW9uUG9zaXRpb247CiAgICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbiA9IGFkZGl0aW9uYWxTcGxpdC5pbnNlcnRpb25Qb3NpdGlvbi5jbG9uZSgpOwogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTmV4dCc7CiAgICByZXR1cm4gW2FkZGl0aW9uYWxTcGxpdCwgYV07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLmRlbGV0aW9uUG9zaXRpb24pICYmICFhLnNwbGl0UG9zaXRpb24uaXNBZnRlcihiLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnktLTsKICB9CgogIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogIH0KCiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFNwbGl0T3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCBmdW5jdGlvbiAoYSwgYiwgY29udGV4dCkgewogIHZhciByYW5nZVRvTW92ZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOwoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgLy8gQ2FzZSAxOgogICAgLy8KICAgIC8vIFNwbGl0IG9wZXJhdGlvbiBncmF2ZXlhcmQgbm9kZSB3YXMgbW92ZWQuIEluIHRoaXMgY2FzZSBtb3ZlIG9wZXJhdGlvbiBpcyBzdHJvbmdlci4gU2luY2UgZ3JhdmV5YXJkIGVsZW1lbnQKICAgIC8vIGlzIGFscmVhZHkgbW92ZWQgdG8gdGhlIGNvcnJlY3QgcG9zaXRpb24sIHdlIG5lZWQgdG8gb25seSBtb3ZlIHRoZSBub2RlcyBhZnRlciB0aGUgc3BsaXQgcG9zaXRpb24uCiAgICAvLyBUaGlzIHdpbGwgYmUgZG9uZSBieSBgTW92ZU9wZXJhdGlvbmAgaW5zdGVhZCBvZiBgU3BsaXRPcGVyYXRpb25gLgogICAgLy8KICAgIHZhciBneUVsZW1lbnRNb3ZlZCA9IHJhbmdlVG9Nb3ZlLnN0YXJ0LmlzRXF1YWwoYS5ncmF2ZXlhcmRQb3NpdGlvbikgfHwgcmFuZ2VUb01vdmUuY29udGFpbnNQb3NpdGlvbihhLmdyYXZleWFyZFBvc2l0aW9uKTsKCiAgICBpZiAoIWNvbnRleHQuYldhc1VuZG9uZSAmJiBneUVsZW1lbnRNb3ZlZCkgewogICAgICB2YXIgc291cmNlUG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwoKICAgICAgdmFyIG5ld1BhcmVudFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CgogICAgICB2YXIgbmV3VGFyZ2V0UGF0aCA9IG5ld1BhcmVudFBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgICAgbmV3VGFyZ2V0UGF0aC5wdXNoKDApOwogICAgICB2YXIgbmV3VGFyZ2V0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24obmV3UGFyZW50UG9zaXRpb24ucm9vdCwgbmV3VGFyZ2V0UGF0aCk7CiAgICAgIHZhciBtb3ZlT3AgPSBuZXcgTW92ZU9wZXJhdGlvbihzb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55LCBuZXdUYXJnZXRQb3NpdGlvbiwgMCk7CiAgICAgIHJldHVybiBbbW92ZU9wXTsKICAgIH0KCiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBJZiB0aGUgc3BsaXQgcG9zaXRpb24gaXMgaW5zaWRlIHRoZSBtb3ZlZCByYW5nZSwgd2UgbmVlZCB0byBzaGlmdCB0aGUgc3BsaXQgcG9zaXRpb24gdG8gYSBwcm9wZXIgcGxhY2UuCiAgLy8gVGhlIHBvc2l0aW9uIGNhbm5vdCBiZSBtb3ZlZCB0b2dldGhlciB3aXRoIG1vdmVkIHJhbmdlIGJlY2F1c2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gc3BsaXR0aW5nIG9mIGFuIGluY29ycmVjdCBlbGVtZW50LgogIC8vCiAgLy8gQ2hhcmFjdGVycyBgYmNgIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgc2Vjb25kIHBhcmFncmFwaCB3aGlsZSBzcGxpdCBwb3NpdGlvbiBpcyBiZXR3ZWVuIHRoZW06CiAgLy8gPHBhcmFncmFwaD5BW2J8Y11kPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YeXo8L3BhcmFncmFwaD4KICAvLwogIC8vIEFmdGVyIG1vdmUsIG5ldyBzcGxpdCBwb3NpdGlvbiBpcyBpbmNvcnJlY3Q6CiAgLy8gPHBhcmFncmFwaD5BZDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+WGJ8Y3l6PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBDb3JyZWN0IHNwbGl0IHBvc2l0aW9uOgogIC8vIDxwYXJhZ3JhcGg+QXxkPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YYmN5ejwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHBhcmFncmFwaD5BPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5kPC9wYXJhZ3JhcGg+PHBhcmFncmFwaD5YYmN5ejwvcGFyYWdyYXBoPgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNvdXJjZVBvc2l0aW9uKSAmJiByYW5nZVRvTW92ZS5jb250YWluc1Bvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbikpIHsKICAgIHZhciBob3dNYW55UmVtb3ZlZCA9IGIuaG93TWFueSAtIChhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IC0gYi5zb3VyY2VQb3NpdGlvbi5vZmZzZXQpOwogICAgYS5ob3dNYW55IC09IGhvd01hbnlSZW1vdmVkOwoKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnRhcmdldFBvc2l0aW9uLm9mZnNldCkgewogICAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogICAgfQoKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGIuc291cmNlUG9zaXRpb24uY2xvbmUoKTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMzoKICAvLwogIC8vIFNwbGl0IGlzIGF0IGEgcG9zaXRpb24gd2hlcmUgbm9kZXMgd2VyZSBtb3ZlZC4KICAvLwogIC8vIFRoaXMgaXMgYSBzY2VuYXJpbyBkZXNjcmliZWQgaW4gYE1vdmVPcGVyYXRpb25gIHggYFNwbGl0T3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbiBidXQgZnJvbSB0aGUKICAvLyAic3BsaXQgb3BlcmF0aW9uIHBvaW50IG9mIHZpZXciLgogIC8vCgoKICB2YXIgc3BsaXRBdFRhcmdldCA9IGEuc3BsaXRQb3NpdGlvbi5pc0VxdWFsKGIudGFyZ2V0UG9zaXRpb24pOwoKICBpZiAoc3BsaXRBdFRhcmdldCAmJiAoY29udGV4dC5iYVJlbGF0aW9uID09ICdpbnNlcnRBdFNvdXJjZScgfHwgY29udGV4dC5hYlJlbGF0aW9uID09ICdzcGxpdEJlZm9yZScpKSB7CiAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogICAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgcmV0dXJuIFthXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8gRG9uJ3QgY2hhbmdlIGBob3dNYW55YCBpZiBtb3ZlIG9wZXJhdGlvbiBkb2VzIG5vdCByZWFsbHkgbW92ZSBhbnl0aGluZy4KICAvLwoKCiAgaWYgKCFiLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc291cmNlUG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPD0gYi5zb3VyY2VQb3NpdGlvbi5vZmZzZXQpIHsKICAgICAgYS5ob3dNYW55IC09IGIuaG93TWFueTsKICAgIH0KCiAgICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnRhcmdldFBvc2l0aW9uKSAmJiBhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IDwgYi50YXJnZXRQb3NpdGlvbi5vZmZzZXQpIHsKICAgICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICAgIH0KICB9IC8vIENoYW5nZSBwb3NpdGlvbiBzdGlja2luZXNzIHRvIGZvcmNlIGEgY29ycmVjdCB0cmFuc2Zvcm1hdGlvbi4KCgogIGEuc3BsaXRQb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTm9uZSc7CiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICBhLnNwbGl0UG9zaXRpb24uc3RpY2tpbmVzcyA9ICd0b05leHQnOwoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IGEuaW5zZXJ0aW9uUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIH0gZWxzZSB7CiAgICBhLmluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24oYS5zcGxpdFBvc2l0aW9uKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihTcGxpdE9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIGZ1bmN0aW9uIChhLCBiLCBjb250ZXh0KSB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU3BsaXQgYXQgdGhlIHNhbWUgcG9zaXRpb24uCiAgLy8KICAvLyBJZiB0aGVyZSBhbHJlYWR5IHdhcyBhIHNwbGl0IGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIGluIGBhYCBvcGVyYXRpb24sIGl0IG1lYW5zIHRoYXQgdGhlIGludGVudGlvbgogIC8vIGNvbnZleWVkIGJ5IGBhYCBvcGVyYXRpb24gaGFzIGFscmVhZHkgYmVlbiBmdWxmaWxsZWQgYW5kIGBhYCBzaG91bGQgbm90IGRvIGFueXRoaW5nICh0byBhdm9pZCBkb3VibGUgc3BsaXQpLgogIC8vCiAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGlmIHRoZXNlIGFyZSBuZXcgc3BsaXRzIG9yIHNwbGl0cyBjcmVhdGVkIGJ5IHVuZG8uIFRoZXNlIGhhdmUgZGlmZmVyZW50CiAgLy8gaW50ZW50aW9ucy4gQWxzbyBzcGxpdHMgbW92aW5nIGJhY2sgZGlmZmVyZW50IGVsZW1lbnRzIGZyb20gZ3JhdmV5YXJkIGhhdmUgZGlmZmVyZW50IGludGVudGlvbnMuIFRoZXkKICAvLyBhcmUganVzdCBkaWZmZXJlbnQgb3BlcmF0aW9ucy4KICAvLwogIC8vIFNvIHdlIGNhbmNlbCBzcGxpdCBvcGVyYXRpb24gb25seSBpZiBpdCB3YXMgcmVhbGx5IGlkZW50aWNhbC4KICAvLwogIC8vIEFsc28sIHRoZXJlIGlzIGFkZGl0aW9uYWwgY2FzZSwgd2hlcmUgc3BsaXQgb3BlcmF0aW9ucyBhcmVuJ3QgaWRlbnRpY2FsIGFuZCBzaG91bGQgbm90IGJlIGNhbmNlbGxlZCwgaG93ZXZlciB0aGUKICAvLyBkZWZhdWx0IHRyYW5zZm9ybWF0aW9uIGlzIGluY29ycmVjdCB0b28uCiAgLy8KICBpZiAoYS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSkgewogICAgaWYgKCFhLmdyYXZleWFyZFBvc2l0aW9uICYmICFiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KCiAgICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiBiLmdyYXZleWFyZFBvc2l0aW9uICYmIGEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9IC8vIFVzZSBjb250ZXh0IHRvIGtub3cgdGhhdCB0aGUgYGEuc3BsaXRQb3NpdGlvbmAgc2hvdWxkIHN0YXkgd2hlcmUgaXQgaXMuCiAgICAvLyBUaGlzIGhhcHBlbnMgZHVyaW5nIHVuZG8gd2hlbiBmaXJzdCBhIG1lcmdlIG9wZXJhdGlvbiBtb3ZlZCBub2RlcyB0byBgYS5zcGxpdFBvc2l0aW9uYCBhbmQgbm93IGBiYCBvcGVyYXRpb24gdW5kb2VzIHRoYXQgbWVyZ2UuCgoKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ3NwbGl0QmVmb3JlJykgewogICAgICAvLyBTaW5jZSBzcGxpdCBpcyBhdCB0aGUgc2FtZSBwb3NpdGlvbiwgdGhlcmUgYXJlIG5vIG5vZGVzIGxlZnQgdG8gc3BsaXQuCiAgICAgIGEuaG93TWFueSA9IDA7IC8vIE5vdGU6IHRoZXJlIHdhcyBgaWYgKCBhLmdyYXZleWFyZFBvc2l0aW9uIClgIGhlcmUgYnV0IGl0IHdhcyB1bmNvdmVyZWQgaW4gdGVzdHMgYW5kIEkgY291bGRuJ3QgZmluZCBhbnkgc2NlbmFyaW9zIGZvciBub3cuCiAgICAgIC8vIFRoYXQgd291bGQgaGF2ZSB0byBiZSBhIGBTcGxpdE9wZXJhdGlvbmAgdGhhdCBkaWRuJ3QgY29tZSBmcm9tIHVuZG8gYnV0IGlzIHRyYW5zZm9ybWVkIGJ5IG9wZXJhdGlvbnMgdGhhdCB3ZXJlIHVuZG9uZS4KICAgICAgLy8gSXQgY291bGQgaGFwcGVuIGlmIGBjb250ZXh0YCBpcyBlbmFibGVkIGluIGNvbGxhYm9yYXRpb24uCgogICAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogICAgICByZXR1cm4gW2FdOwogICAgfQogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gU2FtZSBub2RlIGlzIHVzaW5nIHRvIHNwbGl0IGRpZmZlcmVudCBlbGVtZW50cy4gVGhpcyBoYXBwZW5zIGluIHVuZG8gd2hlbiBwcmV2aW91c2x5IHNhbWUgZWxlbWVudCB3YXMgbWVyZ2VkIHRvCiAgLy8gdHdvIGRpZmZlcmVudCBlbGVtZW50cy4gVGhpcyBpcyBkZXNjcmliZWQgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uCiAgLy8KICAvLyBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBmb2xsb3cgdGhlIHNhbWUgbG9naWMuIFdlIHdpbGwgYXNzdW1lIHRoYXQgYGluc2VydGlvblBvc2l0aW9uYCBpcyBzYW1lIGZvciBib3RoCiAgLy8gc3BsaXQgb3BlcmF0aW9ucy4gVGhpcyBtaWdodCBub3QgYWx3YXlzIGJlIHRydWUgYnV0IGluIHRoZSByZWFsIGNhc2VzIHRoYXQgd2VyZSBleHBlcmllbmNlZCBpdCB3YXMuIEFmdGVyIGFsbCwKICAvLyBpZiB0aGVzZSBzcGxpdHMgYXJlIHJldmVyc2VzIG9mIG1lcmdlIG9wZXJhdGlvbnMgdGhhdCB3ZXJlIG1lcmdpbmcgdGhlIHNhbWUgZWxlbWVudCwgdGhlbiB0aGUgYGluc2VydGlvblBvc2l0aW9uYAogIC8vIHNob3VsZCBiZSBzYW1lIGZvciBib3RoIG9mIHRob3NlIHNwbGl0cy4KICAvLwogIC8vIEFnYWluLCB3ZSB3aWxsIGRlY2lkZSB3aGljaCBvcGVyYXRpb24gaXMgc3Ryb25nZXIgYnkgY2hlY2tpbmcgaWYgc3BsaXQgaGFwcGVucyBpbiBncmF2ZXlhcmQgb3IgaW4gbm9uLWdyYXZleWFyZCByb290LgogIC8vCgoKICBpZiAoYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiBiLmdyYXZleWFyZFBvc2l0aW9uICYmIGEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSkgewogICAgdmFyIGFJbkdyYXZleWFyZCA9IGEuc3BsaXRQb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICAgIHZhciBiSW5HcmF2ZXlhcmQgPSBiLnNwbGl0UG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7IC8vIElmIGBhSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBhYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBiYCBkb2Vzbid0LiBEb24ndCBtb3ZlIG5vZGVzIHRoZW4uCgogICAgdmFyIGFJc1dlYWsgPSBhSW5HcmF2ZXlhcmQgJiYgIWJJbkdyYXZleWFyZDsgLy8gSWYgYGJJc1dlYWtgIGl0IG1lYW5zIHRoYXQgYGJgIHBvaW50cyB0byBncmF2ZXlhcmQgd2hpbGUgYGFgIGRvZXNuJ3QuIEZvcmNlIG1vdmluZyBub2RlcyB0aGVuLgoKICAgIHZhciBiSXNXZWFrID0gYkluR3JhdmV5YXJkICYmICFhSW5HcmF2ZXlhcmQ7IC8vIEZvcmNlIG1vdmUgaWYgYGJgIGlzIHdlYWsgb3IgbmVpdGhlciBvcGVyYXRpb24gaXMgd2VhayBidXQgYGFgIGlzIHN0cm9uZ2VyIHRocm91Z2ggYGNvbnRleHQuYUlzU3Ryb25nYC4KCiAgICB2YXIgZm9yY2VNb3ZlID0gYklzV2VhayB8fCAhYUlzV2VhayAmJiBjb250ZXh0LmFJc1N0cm9uZzsKCiAgICBpZiAoZm9yY2VNb3ZlKSB7CiAgICAgIHZhciByZXN1bHQgPSBbXTsgLy8gRmlyc3Qgd2UgbmVlZCB0byBtb3ZlIGFueSBub2RlcyBzcGxpdCBieSBgYmAgYmFjayB0byB3aGVyZSB0aGV5IHdlcmUuCiAgICAgIC8vIERvIGl0IG9ubHkgaWYgYGJgIGFjdHVhbGx5IG1vdmVkIHNvbWV0aGluZy4KCiAgICAgIGlmIChiLmhvd01hbnkpIHsKICAgICAgICByZXN1bHQucHVzaChuZXcgTW92ZU9wZXJhdGlvbihiLm1vdmVUYXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55LCBiLnNwbGl0UG9zaXRpb24sIDApKTsKICAgICAgfSAvLyBUaGVuIHdlIG5lZWQgdG8gbW92ZSBub2RlcyBmcm9tIGBhYCBzcGxpdCBwb3NpdGlvbiB0byB0aGVpciBuZXcgZWxlbWVudC4KICAgICAgLy8gRG8gaXQgb25seSBpZiBgYWAgYWN0dWFsbHkgc2hvdWxkIG1vdmUgc29tZXRoaW5nLgoKCiAgICAgIGlmIChhLmhvd01hbnkpIHsKICAgICAgICByZXN1bHQucHVzaChuZXcgTW92ZU9wZXJhdGlvbihhLnNwbGl0UG9zaXRpb24sIGEuaG93TWFueSwgYS5tb3ZlVGFyZ2V0UG9zaXRpb24sIDApKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9CgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYS5ncmF2ZXlhcmRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0gLy8gQ2FzZSAzOgogIC8vCiAgLy8gUG9zaXRpb24gd2hlcmUgb3BlcmF0aW9uIGBiYCBpbnNlcnRlZCBhIG5ldyBub2RlIGFmdGVyIHNwbGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBvcGVyYXRpb24gYGFgIHNwbGl0IHBvc2l0aW9uLgogIC8vIEFzIGluIHNpbWlsYXIgY2FzZXMsIHRoZXJlIGlzIGFtYmlndWl0eSBpZiB0aGUgc3BsaXQgc2hvdWxkIGJlIGJlZm9yZSB0aGUgbmV3IG5vZGUgKGNyZWF0ZWQgYnkgYGJgKSBvciBhZnRlci4KICAvLwoKCiAgaWYgKGEuc3BsaXRQb3NpdGlvbi5pc0VxdWFsKGIuaW5zZXJ0aW9uUG9zaXRpb24pICYmIGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnc3BsaXRCZWZvcmUnKSB7CiAgICBhLmhvd01hbnkrKzsKICAgIHJldHVybiBbYV07CiAgfSAvLyBDYXNlIDQ6CiAgLy8KICAvLyBUaGlzIGlzIGEgbWlycm9yIHRvIHRoZSBjYXNlIDIuIGFib3ZlLgogIC8vCgoKICBpZiAoYi5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYS5pbnNlcnRpb25Qb3NpdGlvbikgJiYgY29udGV4dC5iYVJlbGF0aW9uID09ICdzcGxpdEJlZm9yZScpIHsKICAgIHZhciBuZXdQb3NpdGlvblBhdGggPSBiLmluc2VydGlvblBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgIG5ld1Bvc2l0aW9uUGF0aC5wdXNoKDApOwogICAgdmFyIG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuaW5zZXJ0aW9uUG9zaXRpb24ucm9vdCwgbmV3UG9zaXRpb25QYXRoKTsKICAgIHZhciBtb3ZlT3AgPSBuZXcgTW92ZU9wZXJhdGlvbihhLmluc2VydGlvblBvc2l0aW9uLCAxLCBuZXdQb3NpdGlvbiwgMCk7CiAgICByZXR1cm4gW2EsIG1vdmVPcF07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnNwbGl0UG9zaXRpb24ub2Zmc2V0KSB7CiAgICBhLmhvd01hbnkgLT0gYi5ob3dNYW55OwogIH0KCiAgYS5zcGxpdFBvc2l0aW9uID0gYS5zcGxpdFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgcmV0dXJuIFthXTsKfSk7IC8vIENoZWNrcyB3aGV0aGVyIGBNb3ZlT3BlcmF0aW9uYCBgdGFyZ2V0UG9zaXRpb25gIGlzIGluc2lkZSBhIG5vZGUgZnJvbSB0aGUgbW92ZWQgcmFuZ2Ugb2YgdGhlIG90aGVyIGBNb3ZlT3BlcmF0aW9uYC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IGEKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgpmdW5jdGlvbiBfbW92ZVRhcmdldEludG9Nb3ZlZFJhbmdlKGEsIGIpIHsKICByZXR1cm4gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSkgPT09IG51bGw7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBgTW92ZU9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uIENvbnZlcnRzIGdpdmVuIHJhbmdlcyBhbmQgdGFyZ2V0IHBvc2l0aW9uIHRvCi8vIG1vdmUgb3BlcmF0aW9ucyBhbmQgcmV0dXJucyB0aGVtLgovLwovLyBSYW5nZXMgYW5kIHRhcmdldCBwb3NpdGlvbiB3aWxsIGJlIHRyYW5zZm9ybWVkIG9uLXRoZS1mbHkgd2hlbiBnZW5lcmF0aW5nIG9wZXJhdGlvbnMuCi8vCi8vIEdpdmVuIGByYW5nZXNgIHNob3VsZCBiZSBpbiB0aGUgb3JkZXIgb2YgaG93IHRoZXkgd2VyZSBpbiB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtZWQgb3BlcmF0aW9uLgovLwovLyBHaXZlbiBgdGFyZ2V0UG9zaXRpb25gIGlzIHRoZSB0YXJnZXQgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHJhbmdlIGZyb20gYHJhbmdlc2AuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSByYW5nZXMKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXRQb3NpdGlvbgovLyBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbj59CgoKZnVuY3Rpb24gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCB0YXJnZXRQb3NpdGlvbikgewogIC8vIEF0IHRoaXMgbW9tZW50IHdlIGhhdmUgc29tZSByYW5nZXMgYW5kIGEgdGFyZ2V0IHBvc2l0aW9uLCB0byB3aGljaCB0aG9zZSByYW5nZXMgc2hvdWxkIGJlIG1vdmVkLgogIC8vIE9yZGVyIGluIGByYW5nZXNgIGFycmF5IGlzIHRoZSBnby10byBvcmRlciBvZiBhZnRlciB0cmFuc2Zvcm1hdGlvbi4KICAvLwogIC8vIFdlIGFyZSBhbG1vc3QgZG9uZS4gV2UgaGF2ZSBgcmFuZ2VzYCBhbmQgYHRhcmdldFBvc2l0aW9uYCB0byBtYWtlIG9wZXJhdGlvbnMgZnJvbS4KICAvLyBVbmZvcnR1bmF0ZWx5LCB0aG9zZSBvcGVyYXRpb25zIG1heSBhZmZlY3QgZWFjaCBvdGhlci4gUHJlY2lzZWx5LCBmaXJzdCBvcGVyYXRpb24gYWZ0ZXIgbW92ZQogIC8vIG1heSBhZmZlY3Qgc291cmNlIHJhbmdlIGFuZCB0YXJnZXQgcG9zaXRpb24gb2Ygc2Vjb25kIGFuZCB0aGlyZCBvcGVyYXRpb24uIFNhbWUgd2l0aCBzZWNvbmQKICAvLyBvcGVyYXRpb24gYWZmZWN0aW5nIHRoaXJkLgogIC8vCiAgLy8gV2UgbmVlZCB0byBmaXggdGhvc2Ugc291cmNlIHJhbmdlcyBhbmQgdGFyZ2V0IHBvc2l0aW9ucyBvbmNlIGFnYWluLCBiZWZvcmUgY29udmVydGluZyBgcmFuZ2VzYCB0byBvcGVyYXRpb25zLgogIHZhciBvcGVyYXRpb25zID0gW107IC8vIEtlZXAgaW4gbWluZCB0aGF0IG5vdGhpbmcgd2lsbCBiZSB0cmFuc2Zvcm1lZCBpZiB0aGVyZSBpcyBqdXN0IG9uZSByYW5nZSBpbiBgcmFuZ2VzYC4KCiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgIC8vIENyZWF0ZSBuZXcgb3BlcmF0aW9uIG91dCBvZiBhIHJhbmdlIGFuZCB0YXJnZXQgcG9zaXRpb24uCiAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07CiAgICB2YXIgb3AgPSBuZXcgTW92ZU9wZXJhdGlvbihyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLm9mZnNldCAtIHJhbmdlLnN0YXJ0Lm9mZnNldCwgdGFyZ2V0UG9zaXRpb24sIDApOwogICAgb3BlcmF0aW9ucy5wdXNoKG9wKTsgLy8gVHJhbnNmb3JtIG90aGVyIHJhbmdlcyBieSB0aGUgZ2VuZXJhdGVkIG9wZXJhdGlvbi4KCiAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspIHsKICAgICAgLy8gQWxsIHJhbmdlcyBpbiBgcmFuZ2VzYCBhcnJheSBzaG91bGQgYmU6CiAgICAgIC8vCiAgICAgIC8vICogbm9uLWludGVyc2VjdGluZyAodGhlc2UgYXJlIHBhcnQgb2Ygb3JpZ2luYWwgb3BlcmF0aW9uIHNvdXJjZSByYW5nZSksIGFuZAogICAgICAvLyAqIGB0YXJnZXRQb3NpdGlvbmAgZG9lcyBub3QgdGFyZ2V0IGludG8gdGhlbSAob3Bwb3NpdGUgd291bGQgbWVhbiB0aGF0IHRyYW5zZm9ybWVkIG9wZXJhdGlvbiB0YXJnZXRzICJpbnNpZGUgaXRzZWxmIikuCiAgICAgIC8vCiAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSAiY2xlYW4iIGFuZCBhbHdheXMgcmV0dXJuIG9uZSByZXN1bHQuCiAgICAgIHJhbmdlc1tqXSA9IHJhbmdlc1tqXS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUob3Auc291cmNlUG9zaXRpb24sIG9wLnRhcmdldFBvc2l0aW9uLCBvcC5ob3dNYW55KVswXTsKICAgIH0KCiAgICB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcC5zb3VyY2VQb3NpdGlvbiwgb3AudGFyZ2V0UG9zaXRpb24sIG9wLmhvd01hbnkpOwogIH0KCiAgcmV0dXJuIG9wZXJhdGlvbnM7Cn0="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js"],"names":["InsertOperation","AttributeOperation","RenameOperation","MarkerOperation","MoveOperation","RootAttributeOperation","MergeOperation","SplitOperation","NoOperation","Range","Position","compareArrays","transformations","Map","setTransformation","OperationA","OperationB","transformationFunction","aGroup","get","set","getTransformation","has","noUpdateTransformation","a","transform","b","context","constructor","clone","e","transformSets","operationsA","operationsB","options","slice","contextFactory","ContextFactory","document","useRelations","forceWeakRemove","setOriginalOperations","originalOperations","length","nextTransformIndex","WeakMap","op","data","nextBaseVersionA","baseVersion","nextBaseVersionB","originalOperationsACount","originalOperationsBCount","i","opA","indexB","opB","newOpsA","getContext","newOpsB","updateRelation","newOpA","splice","padWithNoOps","brokenOperationsACount","brokenOperationsBCount","updateBaseVersions","_history","history","_useRelations","_forceWeakRemove","_relations","operations","takeFrom","originalOperation","operation","targetPosition","isEqual","sourcePosition","movedRange","containsPosition","_setRelation","deletionPosition","isAfter","isBefore","splitPosition","markerRange","newRange","_createFromPositionAndShift","howMany","affectedLeft","start","affectedRight","end","containsRange","side","path","wasInLeftElement","wasStartBeforeMergedElement","wasEndBeforeMergedElement","wasInRightElement","aIsStrong","aWasUndone","_wasUndone","bWasUndone","abRelation","_getRelation","baRelation","originalOp","wasUndone","isUndoneOperation","origB","undoneB","getUndoneOperation","origA","relationsA","relation","push","key","range","getDifference","map","oldValue","newValue","common","getIntersection","hasSameParentAs","position","_getTransformedByInsertion","shouldReceiveAttributes","result","r","_getComplementaryAttributeOperations","unshift","insertOperation","nodes","insertValue","getNode","getAttribute","getShiftedBy","ranges","graveyardPosition","_getTransformedByMergeOperation","isCollapsed","_breakRangeByMoveOperation","moveOp","moveRange","difference","diff","_getTransformedByDeletion","getMovedRangeStart","spread","_getTransformedByMove","insertionPosition","offset","secondPart","moveTargetPosition","_getCombined","stickiness","_getTransformedBySplitOperation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","oldRange","name","_createFromRanges","aNewRange","_createAt","root","aToGraveyard","rootName","bToGraveyard","aIsWeak","bIsWeak","forceMove","removedRange","type","mergeInside","mergeSplittingElement","transformed","rangeA","rangeB","insertBefore","newTargetPosition","_moveTargetIntoMovedRange","getReversed","bTargetsToA","_makeMoveOperationsFromRanges","aTargetsToB","aCompB","getParentPath","shouldSpread","newRanges","rightRange","movesGraveyardElement","results","gyMoveSource","splitNodesMoveSource","gyMoveTarget","gyMove","splitNodesMoveTargetPath","splitNodesMoveTarget","splitNodesMove","oldName","newName","renamePath","splitPath","extraRename","getInsertionPosition","additionalSplit","rangeToMove","gyElementMoved","newParentPosition","newTargetPath","howManyRemoved","splitAtTarget","aInGraveyard","bInGraveyard","newPositionPath","newPosition","j"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;;;AAKA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,kBAAP,MAA+B,sBAA/B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,sBAAP,MAAmC,0BAAnC;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAOC,KAAP,MAAkB,UAAlB;AACA,OAAOC,QAAP,MAAqB,aAArB;AAEA,OAAOC,aAAP,MAA0B,6CAA1B;AAEA,IAAMC,eAAe,GAAG,IAAIC,GAAJ,EAAxB;AAEA;;;;AAIA;;;;;;;;;;;;;;;;;;;AAkBA,SAASC,iBAAT,CAA4BC,UAA5B,EAAwCC,UAAxC,EAAoDC,sBAApD,EAA6E;AAC5E,MAAIC,MAAM,GAAGN,eAAe,CAACO,GAAhB,CAAqBJ,UAArB,CAAb;;AAEA,MAAK,CAACG,MAAN,EAAe;AACdA,IAAAA,MAAM,GAAG,IAAIL,GAAJ,EAAT;AACAD,IAAAA,eAAe,CAACQ,GAAhB,CAAqBL,UAArB,EAAiCG,MAAjC;AACA;;AAEDA,EAAAA,MAAM,CAACE,GAAP,CAAYJ,UAAZ,EAAwBC,sBAAxB;AACA;AAED;;;;;;;;;;;;;;AAYA,SAASI,iBAAT,CAA4BN,UAA5B,EAAwCC,UAAxC,EAAqD;AACpD,MAAME,MAAM,GAAGN,eAAe,CAACO,GAAhB,CAAqBJ,UAArB,CAAf;;AAEA,MAAKG,MAAM,IAAIA,MAAM,CAACI,GAAP,CAAYN,UAAZ,CAAf,EAA0C;AACzC,WAAOE,MAAM,CAACC,GAAP,CAAYH,UAAZ,CAAP;AACA;;AAED,SAAOO,sBAAP;AACA;AAED;;;;;;;;;AAOA,SAASA,sBAAT,CAAiCC,CAAjC,EAAqC;AACpC,SAAO,CAAEA,CAAF,CAAP;AACA;AAED;;;;;;;;;;AAQA,OAAO,SAASC,SAAT,CAAoBD,CAApB,EAAuBE,CAAvB,EAAyC;AAAA,MAAfC,OAAe,uEAAL,EAAK;AAC/C,MAAMV,sBAAsB,GAAGI,iBAAiB,CAAEG,CAAC,CAACI,WAAJ,EAAiBF,CAAC,CAACE,WAAnB,CAAhD;;AAEA,MAAI;AACHJ,IAAAA,CAAC,GAAGA,CAAC,CAACK,KAAF,EAAJ;AAEA,WAAOZ,sBAAsB,CAAEO,CAAF,EAAKE,CAAL,EAAQC,OAAR,CAA7B;AACA,GAJD,CAIE,OAAQG,CAAR,EAAY;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,UAAMA,CAAN;AACA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAO,SAASC,aAAT,CAAwBC,WAAxB,EAAqCC,WAArC,EAAkDC,OAAlD,EAA4D;AAClE;AACA;AACAF,EAAAA,WAAW,GAAGA,WAAW,CAACG,KAAZ,EAAd;AACAF,EAAAA,WAAW,GAAGA,WAAW,CAACE,KAAZ,EAAd;AAEA,MAAMC,cAAc,GAAG,IAAIC,cAAJ,CAAoBH,OAAO,CAACI,QAA5B,EAAsCJ,OAAO,CAACK,YAA9C,EAA4DL,OAAO,CAACM,eAApE,CAAvB;AACAJ,EAAAA,cAAc,CAACK,qBAAf,CAAsCT,WAAtC;AACAI,EAAAA,cAAc,CAACK,qBAAf,CAAsCR,WAAtC;AAEA,MAAMS,kBAAkB,GAAGN,cAAc,CAACM,kBAA1C,CAVkE,CAYlE;;AACA,MAAKV,WAAW,CAACW,MAAZ,IAAsB,CAAtB,IAA2BV,WAAW,CAACU,MAAZ,IAAsB,CAAtD,EAA0D;AACzD,WAAO;AAAEX,MAAAA,WAAW,EAAXA,WAAF;AAAeC,MAAAA,WAAW,EAAXA,WAAf;AAA4BS,MAAAA,kBAAkB,EAAlBA;AAA5B,KAAP;AACA,GAfiE,CAgBlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AACA,MAAME,kBAAkB,GAAG,IAAIC,OAAJ,EAA3B,CAnJkE,CAqJlE;;AArJkE;AAAA;AAAA;;AAAA;AAsJlE,yBAAkBb,WAAlB,8HAAgC;AAAA,UAApBc,EAAoB;AAC/BF,MAAAA,kBAAkB,CAACxB,GAAnB,CAAwB0B,EAAxB,EAA4B,CAA5B;AACA,KAxJiE,CA0JlE;;AA1JkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA2JlE,MAAMC,IAAI,GAAG;AACZC,IAAAA,gBAAgB,EAAEhB,WAAW,CAAEA,WAAW,CAACW,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAD1D;AAEZC,IAAAA,gBAAgB,EAAEjB,WAAW,CAAEA,WAAW,CAACU,MAAZ,GAAqB,CAAvB,CAAX,CAAsCM,WAAtC,GAAoD,CAF1D;AAGZE,IAAAA,wBAAwB,EAAEnB,WAAW,CAACW,MAH1B;AAIZS,IAAAA,wBAAwB,EAAEnB,WAAW,CAACU;AAJ1B,GAAb,CA3JkE,CAkKlE;;AACA,MAAIU,CAAC,GAAG,CAAR,CAnKkE,CAqKlE;;AACA,SAAQA,CAAC,GAAGrB,WAAW,CAACW,MAAxB,EAAiC;AAAA;;AAChC;AACA,QAAMW,GAAG,GAAGtB,WAAW,CAAEqB,CAAF,CAAvB,CAFgC,CAIhC;;AACA,QAAME,MAAM,GAAGX,kBAAkB,CAACzB,GAAnB,CAAwBmC,GAAxB,CAAf,CALgC,CAOhC;;AACA,QAAKC,MAAM,IAAItB,WAAW,CAACU,MAA3B,EAAoC;AACnCU,MAAAA,CAAC;AACD;AACA;;AAED,QAAMG,GAAG,GAAGvB,WAAW,CAAEsB,MAAF,CAAvB,CAbgC,CAehC;;AACA,QAAME,OAAO,GAAGhC,SAAS,CAAE6B,GAAF,EAAOE,GAAP,EAAYpB,cAAc,CAACsB,UAAf,CAA2BJ,GAA3B,EAAgCE,GAAhC,EAAqC,IAArC,CAAZ,CAAzB;AACA,QAAMG,OAAO,GAAGlC,SAAS,CAAE+B,GAAF,EAAOF,GAAP,EAAYlB,cAAc,CAACsB,UAAf,CAA2BF,GAA3B,EAAgCF,GAAhC,EAAqC,KAArC,CAAZ,CAAzB,CAjBgC,CAkBhC;AAEA;;AACAlB,IAAAA,cAAc,CAACwB,cAAf,CAA+BN,GAA/B,EAAoCE,GAApC;AAEApB,IAAAA,cAAc,CAACK,qBAAf,CAAsCgB,OAAtC,EAA+CH,GAA/C;AACAlB,IAAAA,cAAc,CAACK,qBAAf,CAAsCkB,OAAtC,EAA+CH,GAA/C,EAxBgC,CA0BhC;AACA;AACA;AACA;;AA7BgC;AAAA;AAAA;;AAAA;AA8BhC,4BAAsBC,OAAtB,mIAAgC;AAAA,YAApBI,MAAoB;AAC/B;AACA;AACA;AACA;AACA;AACAjB,QAAAA,kBAAkB,CAACxB,GAAnB,CAAwByC,MAAxB,EAAgCN,MAAM,GAAGI,OAAO,CAAChB,MAAjD;AACA,OArC+B,CAuChC;;AAvCgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwChC,oBAAAX,WAAW,EAAC8B,MAAZ,sBAAoBT,CAApB,EAAuB,CAAvB,4BAA6BI,OAA7B;;AACA,oBAAAxB,WAAW,EAAC6B,MAAZ,sBAAoBP,MAApB,EAA4B,CAA5B,4BAAkCI,OAAlC;AACA;;AAED,MAAKzB,OAAO,CAAC6B,YAAb,EAA4B;AAC3B;AACA,QAAMC,sBAAsB,GAAGhC,WAAW,CAACW,MAAZ,GAAqBI,IAAI,CAACI,wBAAzD;AACA,QAAMc,sBAAsB,GAAGhC,WAAW,CAACU,MAAZ,GAAqBI,IAAI,CAACK,wBAAzD,CAH2B,CAK3B;AACA;AACA;AACA;;AACAW,IAAAA,YAAY,CAAE/B,WAAF,EAAeiC,sBAAsB,GAAGD,sBAAxC,CAAZ;AACAD,IAAAA,YAAY,CAAE9B,WAAF,EAAe+B,sBAAsB,GAAGC,sBAAxC,CAAZ;AACA,GA7NiE,CA+NlE;;;AACAC,EAAAA,kBAAkB,CAAElC,WAAF,EAAee,IAAI,CAACG,gBAApB,CAAlB;AACAgB,EAAAA,kBAAkB,CAAEjC,WAAF,EAAec,IAAI,CAACC,gBAApB,CAAlB;AAEA,SAAO;AAAEhB,IAAAA,WAAW,EAAXA,WAAF;AAAeC,IAAAA,WAAW,EAAXA,WAAf;AAA4BS,IAAAA,kBAAkB,EAAlBA;AAA5B,GAAP;AACA,C,CAED;AACA;;IACML,c;;;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAaC,QAAb,EAAuBC,YAAvB,EAA+D;AAAA,QAA1BC,eAA0B,uEAAR,KAAQ;;AAAA;;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAKE,kBAAL,GAA0B,IAAI7B,GAAJ,EAA1B,CAN8D,CAQ9D;;AACA,SAAKsD,QAAL,GAAgB7B,QAAQ,CAAC8B,OAAzB,CAT8D,CAW9D;;AACA,SAAKC,aAAL,GAAqB9B,YAArB;AAEA,SAAK+B,gBAAL,GAAwB,CAAC,CAAC9B,eAA1B,CAd8D,CAgB9D;AACA;AACA;;AACA,SAAK+B,UAAL,GAAkB,IAAI1D,GAAJ,EAAlB;AACA,G,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;0CACuB2D,U,EAA8B;AAAA,UAAlBC,QAAkB,uEAAP,IAAO;AACpD,UAAMC,iBAAiB,GAAGD,QAAQ,GAAG,KAAK/B,kBAAL,CAAwBvB,GAAxB,CAA6BsD,QAA7B,CAAH,GAA6C,IAA/E;AADoD;AAAA;AAAA;;AAAA;AAGpD,8BAAyBD,UAAzB,mIAAsC;AAAA,cAA1BG,SAA0B;AACrC,eAAKjC,kBAAL,CAAwBtB,GAAxB,CAA6BuD,SAA7B,EAAwCD,iBAAiB,IAAIC,SAA7D;AACA;AALmD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMpD,K,CAED;AACA;AACA;AACA;AACA;AACA;;;;mCACgBrB,G,EAAKE,G,EAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAASF,GAAG,CAAC1B,WAAb;AACC,aAAKxB,aAAL;AAAoB;AACnB,oBAASoD,GAAG,CAAC5B,WAAb;AACC,mBAAKtB,cAAL;AAAqB;AACpB,sBAAKgD,GAAG,CAACsB,cAAJ,CAAmBC,OAAnB,CAA4BrB,GAAG,CAACsB,cAAhC,KAAoDtB,GAAG,CAACuB,UAAJ,CAAeC,gBAAf,CAAiC1B,GAAG,CAACsB,cAArC,CAAzD,EAAiH;AAChH,yBAAKK,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,gBAA7B;AACA,mBAFD,MAEO,IAAKF,GAAG,CAACsB,cAAJ,CAAmBC,OAAnB,CAA4BrB,GAAG,CAAC0B,gBAAhC,CAAL,EAA0D;AAChE,yBAAKD,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,eAA7B;AACA,mBAFM,MAEA,IAAKF,GAAG,CAACsB,cAAJ,CAAmBO,OAAnB,CAA4B3B,GAAG,CAACsB,cAAhC,CAAL,EAAwD;AAC9D,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,iBAA7B;AACA;;AAED;AACA;;AAED,mBAAKpD,aAAL;AAAoB;AACnB,sBAAKkD,GAAG,CAACsB,cAAJ,CAAmBC,OAAnB,CAA4BrB,GAAG,CAACsB,cAAhC,KAAoDxB,GAAG,CAACsB,cAAJ,CAAmBQ,QAAnB,CAA6B5B,GAAG,CAACsB,cAAjC,CAAzD,EAA6G;AAC5G,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,cAA7B;AACA,mBAFD,MAEO;AACN,yBAAKyB,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,aAA7B;AACA;;AAED;AACA;AArBF;;AAwBA;AACA;;AAED,aAAKjD,cAAL;AAAqB;AACpB,oBAASiD,GAAG,CAAC5B,WAAb;AACC,mBAAKtB,cAAL;AAAqB;AACpB,sBAAKgD,GAAG,CAAC+B,aAAJ,CAAkBD,QAAlB,CAA4B5B,GAAG,CAACsB,cAAhC,CAAL,EAAwD;AACvD,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,aAA7B;AACA;;AAED;AACA;;AAED,mBAAKpD,aAAL;AAAoB;AACnB,sBAAKkD,GAAG,CAAC+B,aAAJ,CAAkBR,OAAlB,CAA2BrB,GAAG,CAACsB,cAA/B,KAAmDxB,GAAG,CAAC+B,aAAJ,CAAkBD,QAAlB,CAA4B5B,GAAG,CAACsB,cAAhC,CAAxD,EAA2G;AAC1G,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,aAA7B;AACA;;AAED;AACA;AAfF;;AAkBA;AACA;;AAED,aAAKlD,cAAL;AAAqB;AACpB,oBAASkD,GAAG,CAAC5B,WAAb;AACC,mBAAKtB,cAAL;AAAqB;AACpB,sBAAK,CAACgD,GAAG,CAACsB,cAAJ,CAAmBC,OAAnB,CAA4BrB,GAAG,CAACsB,cAAhC,CAAN,EAAyD;AACxD,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,qBAA7B;AACA;;AAED,sBAAKF,GAAG,CAACwB,cAAJ,CAAmBD,OAAnB,CAA4BrB,GAAG,CAACoB,cAAhC,CAAL,EAAwD;AACvD,yBAAKK,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,qBAA7B;AACA;;AAED,sBAAKF,GAAG,CAACwB,cAAJ,CAAmBD,OAAnB,CAA4BrB,GAAG,CAACsB,cAAhC,CAAL,EAAwD;AACvD,yBAAKG,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,kBAA7B;AACA;;AAED;AACA;;AAED,mBAAKjD,cAAL;AAAqB;AACpB,sBAAK+C,GAAG,CAACwB,cAAJ,CAAmBD,OAAnB,CAA4BrB,GAAG,CAAC6B,aAAhC,CAAL,EAAuD;AACtD,yBAAKJ,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B,eAA7B;AACA;AACD;AArBF;;AAwBA;AACA;;AAED,aAAKrD,eAAL;AAAsB;AACrB,gBAAMmF,WAAW,GAAGhC,GAAG,CAACiC,QAAxB;;AAEA,gBAAK,CAACD,WAAN,EAAoB;AACnB;AACA;;AAED,oBAAS9B,GAAG,CAAC5B,WAAb;AACC,mBAAKxB,aAAL;AAAoB;AACnB,sBAAM2E,UAAU,GAAGtE,KAAK,CAAC+E,2BAAN,CAAmChC,GAAG,CAACsB,cAAvC,EAAuDtB,GAAG,CAACiC,OAA3D,CAAnB;;AAEA,sBAAMC,YAAY,GAAGX,UAAU,CAACC,gBAAX,CAA6BM,WAAW,CAACK,KAAzC,KACpBZ,UAAU,CAACY,KAAX,CAAiBd,OAAjB,CAA0BS,WAAW,CAACK,KAAtC,CADD;AAGA,sBAAMC,aAAa,GAAGb,UAAU,CAACC,gBAAX,CAA6BM,WAAW,CAACO,GAAzC,KACrBd,UAAU,CAACc,GAAX,CAAehB,OAAf,CAAwBS,WAAW,CAACO,GAApC,CADD;;AAGA,sBAAK,CAAEH,YAAY,IAAIE,aAAlB,KAAqC,CAACb,UAAU,CAACe,aAAX,CAA0BR,WAA1B,CAA3C,EAAqF;AACpF,yBAAKL,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B;AAC5BuC,sBAAAA,IAAI,EAAEL,YAAY,GAAG,MAAH,GAAY,OADF;AAE5BM,sBAAAA,IAAI,EAAEN,YAAY,GAAGJ,WAAW,CAACK,KAAZ,CAAkBK,IAAlB,CAAuB7D,KAAvB,EAAH,GAAoCmD,WAAW,CAACO,GAAZ,CAAgBG,IAAhB,CAAqB7D,KAArB;AAF1B,qBAA7B;AAIA;;AAED;AACA;;AAED,mBAAK7B,cAAL;AAAqB;AACpB,sBAAM2F,gBAAgB,GAAGX,WAAW,CAACK,KAAZ,CAAkBd,OAAlB,CAA2BrB,GAAG,CAACoB,cAA/B,CAAzB;AACA,sBAAMsB,2BAA2B,GAAGZ,WAAW,CAACK,KAAZ,CAAkBd,OAAlB,CAA2BrB,GAAG,CAAC0B,gBAA/B,CAApC;AACA,sBAAMiB,yBAAyB,GAAGb,WAAW,CAACO,GAAZ,CAAgBhB,OAAhB,CAAyBrB,GAAG,CAAC0B,gBAA7B,CAAlC;AACA,sBAAMkB,iBAAiB,GAAGd,WAAW,CAACO,GAAZ,CAAgBhB,OAAhB,CAAyBrB,GAAG,CAACsB,cAA7B,CAA1B;;AAEA,sBAAKmB,gBAAgB,IAAIC,2BAApB,IAAmDC,yBAAnD,IAAgFC,iBAArF,EAAyG;AACxG,yBAAKnB,YAAL,CAAmB3B,GAAnB,EAAwBE,GAAxB,EAA6B;AAC5ByC,sBAAAA,gBAAgB,EAAhBA,gBAD4B;AAE5BC,sBAAAA,2BAA2B,EAA3BA,2BAF4B;AAG5BC,sBAAAA,yBAAyB,EAAzBA,yBAH4B;AAI5BC,sBAAAA,iBAAiB,EAAjBA;AAJ4B,qBAA7B;AAMA;;AAED;AACA;AApCF;;AAuCA;AACA;AA9HF;AAgIA,K,CAED;AACA;AACA;AACA;AACA;;;;+BACY9C,G,EAAKE,G,EAAK6C,S,EAAY;AACjC,aAAO;AACNA,QAAAA,SAAS,EAATA,SADM;AAENC,QAAAA,UAAU,EAAE,KAAKC,UAAL,CAAiBjD,GAAjB,CAFN;AAGNkD,QAAAA,UAAU,EAAE,KAAKD,UAAL,CAAiB/C,GAAjB,CAHN;AAINiD,QAAAA,UAAU,EAAE,KAAKpC,aAAL,GAAqB,KAAKqC,YAAL,CAAmBpD,GAAnB,EAAwBE,GAAxB,CAArB,GAAqD,IAJ3D;AAKNmD,QAAAA,UAAU,EAAE,KAAKtC,aAAL,GAAqB,KAAKqC,YAAL,CAAmBlD,GAAnB,EAAwBF,GAAxB,CAArB,GAAqD,IAL3D;AAMNd,QAAAA,eAAe,EAAE,KAAK8B;AANhB,OAAP;AAQA,K,CAED;AACA;AACA;AACA;AACA;AACA;;;;+BACYxB,E,EAAK;AAChB;AACA;AACA;AACA,UAAM8D,UAAU,GAAG,KAAKlE,kBAAL,CAAwBvB,GAAxB,CAA6B2B,EAA7B,CAAnB,CAJgB,CAMhB;;AACA,aAAO8D,UAAU,CAACC,SAAX,IAAwB,KAAK1C,QAAL,CAAc2C,iBAAd,CAAiCF,UAAjC,CAA/B;AACA,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iCACctD,G,EAAKE,G,EAAM;AACxB;AACA,UAAMuD,KAAK,GAAG,KAAKrE,kBAAL,CAAwBvB,GAAxB,CAA6BqC,GAA7B,CAAd;;AACA,UAAMwD,OAAO,GAAG,KAAK7C,QAAL,CAAc8C,kBAAd,CAAkCF,KAAlC,CAAhB,CAHwB,CAKxB;;;AACA,UAAK,CAACC,OAAN,EAAgB;AACf,eAAO,IAAP;AACA;;AAED,UAAME,KAAK,GAAG,KAAKxE,kBAAL,CAAwBvB,GAAxB,CAA6BmC,GAA7B,CAAd;;AACA,UAAM6D,UAAU,GAAG,KAAK5C,UAAL,CAAgBpD,GAAhB,CAAqB+F,KAArB,CAAnB,CAXwB,CAaxB;;;AACA,UAAKC,UAAL,EAAkB;AACjB,eAAOA,UAAU,CAAChG,GAAX,CAAgB6F,OAAhB,KAA6B,IAApC;AACA;;AAED,aAAO,IAAP;AACA,K,CAED;AACA;AACA;AACA;AACA;AACA;;;;iCACc1D,G,EAAKE,G,EAAK4D,Q,EAAW;AAClC;AACA,UAAMF,KAAK,GAAG,KAAKxE,kBAAL,CAAwBvB,GAAxB,CAA6BmC,GAA7B,CAAd;AACA,UAAMyD,KAAK,GAAG,KAAKrE,kBAAL,CAAwBvB,GAAxB,CAA6BqC,GAA7B,CAAd;;AAEA,UAAI2D,UAAU,GAAG,KAAK5C,UAAL,CAAgBpD,GAAhB,CAAqB+F,KAArB,CAAjB;;AAEA,UAAK,CAACC,UAAN,EAAmB;AAClBA,QAAAA,UAAU,GAAG,IAAItG,GAAJ,EAAb;;AACA,aAAK0D,UAAL,CAAgBnD,GAAhB,CAAqB8F,KAArB,EAA4BC,UAA5B;AACA;;AAEDA,MAAAA,UAAU,CAAC/F,GAAX,CAAgB2F,KAAhB,EAAuBK,QAAvB;AACA;;;;;AAGF;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;AAWA,SAASlD,kBAAT,CAA6BM,UAA7B,EAAyCvB,WAAzC,EAAuD;AAAA;AAAA;AAAA;;AAAA;AACtD,0BAAyBuB,UAAzB,mIAAsC;AAAA,UAA1BG,SAA0B;AACrCA,MAAAA,SAAS,CAAC1B,WAAV,GAAwBA,WAAW,EAAnC;AACA;AAHqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAItD;AAED;;;;;;;;;AAOA,SAASc,YAAT,CAAuBS,UAAvB,EAAmCiB,OAAnC,EAA6C;AAC5C,OAAM,IAAIpC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGoC,OAArB,EAA8BpC,CAAC,EAA/B,EAAoC;AACnCmB,IAAAA,UAAU,CAAC6C,IAAX,CAAiB,IAAI7G,WAAJ,CAAiB,CAAjB,CAAjB;AACA;AACD,C,CAED;;;AAEAM,iBAAiB,CAAEb,kBAAF,EAAsBA,kBAAtB,EAA0C,UAAEuB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AAC/E,MAAKH,CAAC,CAAC8F,GAAF,KAAU5F,CAAC,CAAC4F,GAAjB,EAAuB;AACtB;AAEA;AACA,QAAM9C,UAAU,GAAGhD,CAAC,CAAC+F,KAAF,CAAQC,aAAR,CAAuB9F,CAAC,CAAC6F,KAAzB,EAAiCE,GAAjC,CAAsC,UAAAF,KAAK,EAAI;AACjE,aAAO,IAAItH,kBAAJ,CAAwBsH,KAAxB,EAA+B/F,CAAC,CAAC8F,GAAjC,EAAsC9F,CAAC,CAACkG,QAAxC,EAAkDlG,CAAC,CAACmG,QAApD,EAA8D,CAA9D,CAAP;AACA,KAFkB,CAAnB,CAJsB,CAQtB;;AACA,QAAMC,MAAM,GAAGpG,CAAC,CAAC+F,KAAF,CAAQM,eAAR,CAAyBnG,CAAC,CAAC6F,KAA3B,CAAf;;AAEA,QAAKK,MAAL,EAAc;AACb;AACA;AACA;AACA,UAAKjG,OAAO,CAAC0E,SAAb,EAAyB;AACxB7B,QAAAA,UAAU,CAAC6C,IAAX,CAAiB,IAAIpH,kBAAJ,CAAwB2H,MAAxB,EAAgClG,CAAC,CAAC4F,GAAlC,EAAuC5F,CAAC,CAACiG,QAAzC,EAAmDnG,CAAC,CAACmG,QAArD,EAA+D,CAA/D,CAAjB;AACA;AACD;;AAED,QAAKnD,UAAU,CAAC7B,MAAX,IAAqB,CAA1B,EAA8B;AAC7B,aAAO,CAAE,IAAInC,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;;AAED,WAAOgE,UAAP;AACA,GAzBD,MAyBO;AACN;AACA,WAAO,CAAEhD,CAAF,CAAP;AACA;AACD,CA9BgB,CAAjB;AAgCAV,iBAAiB,CAAEb,kBAAF,EAAsBD,eAAtB,EAAuC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAKF,CAAC,CAAC+F,KAAF,CAAQ5B,KAAR,CAAcmC,eAAd,CAA+BpG,CAAC,CAACqG,QAAjC,KAA+CvG,CAAC,CAAC+F,KAAF,CAAQvC,gBAAR,CAA0BtD,CAAC,CAACqG,QAA5B,CAApD,EAA6F;AAC5F;AACA;AACA,QAAMR,KAAK,GAAG/F,CAAC,CAAC+F,KAAF,CAAQS,0BAAR,CAAoCtG,CAAC,CAACqG,QAAtC,EAAgDrG,CAAC,CAAC+D,OAAlD,EAA2D,CAAC/D,CAAC,CAACuG,uBAA9D,CAAd;;AACA,QAAMC,MAAM,GAAGX,KAAK,CAACE,GAAN,CAAW,UAAAU,CAAC,EAAI;AAC9B,aAAO,IAAIlI,kBAAJ,CAAwBkI,CAAxB,EAA2B3G,CAAC,CAAC8F,GAA7B,EAAkC9F,CAAC,CAACkG,QAApC,EAA8ClG,CAAC,CAACmG,QAAhD,EAA0DnG,CAAC,CAACyB,WAA5D,CAAP;AACA,KAFc,CAAf;;AAIA,QAAKvB,CAAC,CAACuG,uBAAP,EAAiC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,UAAMnF,EAAE,GAAGsF,oCAAoC,CAAE1G,CAAF,EAAKF,CAAC,CAAC8F,GAAP,EAAY9F,CAAC,CAACkG,QAAd,CAA/C;;AAEA,UAAK5E,EAAL,EAAU;AACToF,QAAAA,MAAM,CAACG,OAAP,CAAgBvF,EAAhB;AACA;AACD,KAzD2F,CA2D5F;;;AACA,WAAOoF,MAAP;AACA,GApEkE,CAsEnE;;;AACA1G,EAAAA,CAAC,CAAC+F,KAAF,GAAU/F,CAAC,CAAC+F,KAAF,CAAQS,0BAAR,CAAoCtG,CAAC,CAACqG,QAAtC,EAAgDrG,CAAC,CAAC+D,OAAlD,EAA2D,KAA3D,EAAoE,CAApE,CAAV;AAEA,SAAO,CAAEjE,CAAF,CAAP;AACA,CA1EgB,CAAjB;AA4EA;;;;;;;;;;;;;AAYA,SAAS4G,oCAAT,CAA+CE,eAA/C,EAAgEhB,GAAhE,EAAqEK,QAArE,EAAgF;AAC/E,MAAMY,KAAK,GAAGD,eAAe,CAACC,KAA9B,CAD+E,CAG/E;;AACA,MAAMC,WAAW,GAAGD,KAAK,CAACE,OAAN,CAAe,CAAf,EAAmBC,YAAnB,CAAiCpB,GAAjC,CAApB;;AAEA,MAAKkB,WAAW,IAAIb,QAApB,EAA+B;AAC9B,WAAO,IAAP;AACA;;AAED,MAAMJ,KAAK,GAAG,IAAI9G,KAAJ,CAAW6H,eAAe,CAACP,QAA3B,EAAqCO,eAAe,CAACP,QAAhB,CAAyBY,YAAzB,CAAuCL,eAAe,CAAC7C,OAAvD,CAArC,CAAd;AAEA,SAAO,IAAIxF,kBAAJ,CAAwBsH,KAAxB,EAA+BD,GAA/B,EAAoCkB,WAApC,EAAiDb,QAAjD,EAA2D,CAA3D,CAAP;AACA;;AAED7G,iBAAiB,CAAEb,kBAAF,EAAsBK,cAAtB,EAAsC,UAAEkB,CAAF,EAAKE,CAAL,EAAY;AAClE,MAAMkH,MAAM,GAAG,EAAf,CADkE,CAGlE;AACA;AACA;AACA;AACA;;AACA,MAAKpH,CAAC,CAAC+F,KAAF,CAAQ5B,KAAR,CAAcmC,eAAd,CAA+BpG,CAAC,CAACwD,gBAAjC,CAAL,EAA2D;AAC1D,QAAK1D,CAAC,CAAC+F,KAAF,CAAQvC,gBAAR,CAA0BtD,CAAC,CAACwD,gBAA5B,KAAkD1D,CAAC,CAAC+F,KAAF,CAAQ5B,KAAR,CAAcd,OAAd,CAAuBnD,CAAC,CAACwD,gBAAzB,CAAvD,EAAqG;AACpG0D,MAAAA,MAAM,CAACvB,IAAP,CAAa5G,KAAK,CAAC+E,2BAAN,CAAmC9D,CAAC,CAACmH,iBAArC,EAAwD,CAAxD,CAAb;AACA;AACD;;AAED,MAAMtB,KAAK,GAAG/F,CAAC,CAAC+F,KAAF,CAAQuB,+BAAR,CAAyCpH,CAAzC,CAAd,CAdkE,CAgBlE;;;AACA,MAAK,CAAC6F,KAAK,CAACwB,WAAZ,EAA0B;AACzBH,IAAAA,MAAM,CAACvB,IAAP,CAAaE,KAAb;AACA,GAnBiE,CAqBlE;;;AACA,SAAOqB,MAAM,CAACnB,GAAP,CAAY,UAAAF,KAAK,EAAI;AAC3B,WAAO,IAAItH,kBAAJ,CAAwBsH,KAAxB,EAA+B/F,CAAC,CAAC8F,GAAjC,EAAsC9F,CAAC,CAACkG,QAAxC,EAAkDlG,CAAC,CAACmG,QAApD,EAA8DnG,CAAC,CAACyB,WAAhE,CAAP;AACA,GAFM,CAAP;AAGA,CAzBgB,CAAjB;AA2BAnC,iBAAiB,CAAEb,kBAAF,EAAsBG,aAAtB,EAAqC,UAAEoB,CAAF,EAAKE,CAAL,EAAY;AACjE,MAAMkH,MAAM,GAAGI,0BAA0B,CAAExH,CAAC,CAAC+F,KAAJ,EAAW7F,CAAX,CAAzC,CADiE,CAGjE;;;AACA,SAAOkH,MAAM,CAACnB,GAAP,CAAY,UAAAF,KAAK;AAAA,WAAI,IAAItH,kBAAJ,CAAwBsH,KAAxB,EAA+B/F,CAAC,CAAC8F,GAAjC,EAAsC9F,CAAC,CAACkG,QAAxC,EAAkDlG,CAAC,CAACmG,QAApD,EAA8DnG,CAAC,CAACyB,WAAhE,CAAJ;AAAA,GAAjB,CAAP;AACA,CALgB,CAAjB,C,CAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS+F,0BAAT,CAAqCzB,KAArC,EAA4C0B,MAA5C,EAAqD;AACpD,MAAMC,SAAS,GAAGzI,KAAK,CAAC+E,2BAAN,CAAmCyD,MAAM,CAACnE,cAA1C,EAA0DmE,MAAM,CAACxD,OAAjE,CAAlB,CADoD,CAGpD;AACA;;;AACA,MAAImC,MAAM,GAAG,IAAb;AACA,MAAIuB,UAAU,GAAG,EAAjB,CANoD,CAQpD;;AACA,MAAKD,SAAS,CAACpD,aAAV,CAAyByB,KAAzB,EAAgC,IAAhC,CAAL,EAA8C;AAC7C;AACAK,IAAAA,MAAM,GAAGL,KAAT;AACA,GAHD,MAGO,IAAKA,KAAK,CAAC5B,KAAN,CAAYmC,eAAZ,CAA6BoB,SAAS,CAACvD,KAAvC,CAAL,EAAsD;AAC5D;AACA;AACAwD,IAAAA,UAAU,GAAG5B,KAAK,CAACC,aAAN,CAAqB0B,SAArB,CAAb;AACAtB,IAAAA,MAAM,GAAGL,KAAK,CAACM,eAAN,CAAuBqB,SAAvB,CAAT;AACA,GALM,MAKA;AACN;AACA;AACA;AACA;AACA;AACAC,IAAAA,UAAU,GAAG,CAAE5B,KAAF,CAAb;AACA;;AAED,MAAMW,MAAM,GAAG,EAAf,CA1BoD,CA4BpD;AACA;;AA7BoD;AAAA;AAAA;;AAAA;AA8BpD,0BAAkBiB,UAAlB,mIAA+B;AAAA,UAArBC,IAAqB;AAC9B;AACA;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACC,yBAAL,CAAgCJ,MAAM,CAACnE,cAAvC,EAAuDmE,MAAM,CAACxD,OAA9D,CAAP,CAH8B,CAK9B;;AACA,UAAMb,cAAc,GAAGqE,MAAM,CAACK,kBAAP,EAAvB,CAN8B,CAQ9B;;AACA,UAAMC,MAAM,GAAGH,IAAI,CAACzD,KAAL,CAAWmC,eAAX,CAA4BlD,cAA5B,CAAf,CAT8B,CAW9B;;AACAwE,MAAAA,IAAI,GAAGA,IAAI,CAACpB,0BAAL,CAAiCpD,cAAjC,EAAiDqE,MAAM,CAACxD,OAAxD,EAAiE8D,MAAjE,CAAP;AAEArB,MAAAA,MAAM,CAACb,IAAP,OAAAa,MAAM,qBAAUkB,IAAV,EAAN;AACA,KA7CmD,CA+CpD;AACA;;AAhDoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiDpD,MAAKxB,MAAL,EAAc;AACbM,IAAAA,MAAM,CAACb,IAAP,CACCO,MAAM,CAAC4B,qBAAP,CAA8BP,MAAM,CAACnE,cAArC,EAAqDmE,MAAM,CAACrE,cAA5D,EAA4EqE,MAAM,CAACxD,OAAnF,EAA4F,KAA5F,EAAqG,CAArG,CADD;AAGA;;AAED,SAAOyC,MAAP;AACA;;AAEDpH,iBAAiB,CAAEb,kBAAF,EAAsBM,cAAtB,EAAsC,UAAEiB,CAAF,EAAKE,CAAL,EAAY;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAKF,CAAC,CAAC+F,KAAF,CAAQ1B,GAAR,CAAYhB,OAAZ,CAAqBnD,CAAC,CAAC+H,iBAAvB,CAAL,EAAkD;AACjD,QAAK,CAAC/H,CAAC,CAACmH,iBAAR,EAA4B;AAC3BrH,MAAAA,CAAC,CAAC+F,KAAF,CAAQ1B,GAAR,CAAY6D,MAAZ;AACA;;AAED,WAAO,CAAElI,CAAF,CAAP;AACA,GArBiE,CAuBlE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKA,CAAC,CAAC+F,KAAF,CAAQ5B,KAAR,CAAcmC,eAAd,CAA+BpG,CAAC,CAAC2D,aAAjC,KAAoD7D,CAAC,CAAC+F,KAAF,CAAQvC,gBAAR,CAA0BtD,CAAC,CAAC2D,aAA5B,CAAzD,EAAuG;AACtG,QAAMsE,UAAU,GAAGnI,CAAC,CAACK,KAAF,EAAnB;AAEA8H,IAAAA,UAAU,CAACpC,KAAX,GAAmB,IAAI9G,KAAJ,CAClBiB,CAAC,CAACkI,kBAAF,CAAqB/H,KAArB,EADkB,EAElBL,CAAC,CAAC+F,KAAF,CAAQ1B,GAAR,CAAYgE,YAAZ,CAA0BnI,CAAC,CAAC2D,aAA5B,EAA2C3D,CAAC,CAACkI,kBAA7C,CAFkB,CAAnB;AAKApI,IAAAA,CAAC,CAAC+F,KAAF,CAAQ1B,GAAR,GAAcnE,CAAC,CAAC2D,aAAF,CAAgBxD,KAAhB,EAAd;AACAL,IAAAA,CAAC,CAAC+F,KAAF,CAAQ1B,GAAR,CAAYiE,UAAZ,GAAyB,YAAzB;AAEA,WAAO,CAAEtI,CAAF,EAAKmI,UAAL,CAAP;AACA,GAjDiE,CAmDlE;AACA;;;AACAnI,EAAAA,CAAC,CAAC+F,KAAF,GAAU/F,CAAC,CAAC+F,KAAF,CAAQwC,+BAAR,CAAyCrI,CAAzC,CAAV;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAxDgB,CAAjB;AA0DAV,iBAAiB,CAAEd,eAAF,EAAmBC,kBAAnB,EAAuC,UAAEuB,CAAF,EAAKE,CAAL,EAAY;AACnE,MAAMwG,MAAM,GAAG,CAAE1G,CAAF,CAAf,CADmE,CAGnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAKA,CAAC,CAACyG,uBAAF,IAA6BzG,CAAC,CAACuG,QAAF,CAAWD,eAAX,CAA4BpG,CAAC,CAAC6F,KAAF,CAAQ5B,KAApC,CAA7B,IAA4EjE,CAAC,CAAC6F,KAAF,CAAQvC,gBAAR,CAA0BxD,CAAC,CAACuG,QAA5B,CAAjF,EAA0H;AACzH,QAAMjF,EAAE,GAAGsF,oCAAoC,CAAE5G,CAAF,EAAKE,CAAC,CAAC4F,GAAP,EAAY5F,CAAC,CAACiG,QAAd,CAA/C;;AAEA,QAAK7E,EAAL,EAAU;AACToF,MAAAA,MAAM,CAACb,IAAP,CAAavE,EAAb;AACA;AACD,GAnBkE,CAqBnE;AACA;AACA;;;AACA,SAAOoF,MAAP;AACA,CAzBgB,CAAjB;AA2BApH,iBAAiB,CAAEd,eAAF,EAAmBA,eAAnB,EAAoC,UAAEwB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAKH,CAAC,CAACuG,QAAF,CAAWlD,OAAX,CAAoBnD,CAAC,CAACqG,QAAtB,KAAoCpG,OAAO,CAAC0E,SAAjD,EAA6D;AAC5D,WAAO,CAAE7E,CAAF,CAAP;AACA,GAZwE,CAczE;AACA;;;AACAA,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWiC,gCAAX,CAA6CtI,CAA7C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAnBgB,CAAjB;AAqBAV,iBAAiB,CAAEd,eAAF,EAAmBI,aAAnB,EAAkC,UAAEoB,CAAF,EAAKE,CAAL,EAAY;AAC9D;AACA;AACAF,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWkC,8BAAX,CAA2CvI,CAA3C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CANgB,CAAjB;AAQAV,iBAAiB,CAAEd,eAAF,EAAmBO,cAAnB,EAAmC,UAAEiB,CAAF,EAAKE,CAAL,EAAY;AAC/D;AACA;AACAF,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWgC,+BAAX,CAA4CrI,CAA5C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CANgB,CAAjB;AAQAV,iBAAiB,CAAEd,eAAF,EAAmBM,cAAnB,EAAmC,UAAEkB,CAAF,EAAKE,CAAL,EAAY;AAC/DF,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWe,+BAAX,CAA4CpH,CAA5C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAJgB,CAAjB,C,CAMA;;AAEAV,iBAAiB,CAAEX,eAAF,EAAmBH,eAAnB,EAAoC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AAChE,MAAKF,CAAC,CAAC0I,QAAP,EAAkB;AACjB1I,IAAAA,CAAC,CAAC0I,QAAF,GAAa1I,CAAC,CAAC0I,QAAF,CAAWF,gCAAX,CAA6CtI,CAA7C,EAAkD,CAAlD,CAAb;AACA;;AAED,MAAKF,CAAC,CAAC+D,QAAP,EAAkB;AACjB/D,IAAAA,CAAC,CAAC+D,QAAF,GAAa/D,CAAC,CAAC+D,QAAF,CAAWyE,gCAAX,CAA6CtI,CAA7C,EAAkD,CAAlD,CAAb;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CAVgB,CAAjB;AAYAV,iBAAiB,CAAEX,eAAF,EAAmBA,eAAnB,EAAoC,UAAEqB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACzE,MAAKH,CAAC,CAAC2I,IAAF,IAAUzI,CAAC,CAACyI,IAAjB,EAAwB;AACvB,QAAKxI,OAAO,CAAC0E,SAAb,EAAyB;AACxB7E,MAAAA,CAAC,CAAC0I,QAAF,GAAaxI,CAAC,CAAC6D,QAAF,GAAa7D,CAAC,CAAC6D,QAAF,CAAW1D,KAAX,EAAb,GAAkC,IAA/C;AACA,KAFD,MAEO;AACN,aAAO,CAAE,IAAIrB,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;AACD;;AAED,SAAO,CAAEgB,CAAF,CAAP;AACA,CAVgB,CAAjB;AAYAV,iBAAiB,CAAEX,eAAF,EAAmBG,cAAnB,EAAmC,UAAEkB,CAAF,EAAKE,CAAL,EAAY;AAC/D,MAAKF,CAAC,CAAC0I,QAAP,EAAkB;AACjB1I,IAAAA,CAAC,CAAC0I,QAAF,GAAa1I,CAAC,CAAC0I,QAAF,CAAWpB,+BAAX,CAA4CpH,CAA5C,CAAb;AACA;;AAED,MAAKF,CAAC,CAAC+D,QAAP,EAAkB;AACjB/D,IAAAA,CAAC,CAAC+D,QAAF,GAAa/D,CAAC,CAAC+D,QAAF,CAAWuD,+BAAX,CAA4CpH,CAA5C,CAAb;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CAVgB,CAAjB;AAYAV,iBAAiB,CAAEX,eAAF,EAAmBC,aAAnB,EAAkC,UAAEoB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvE,MAAKH,CAAC,CAAC0I,QAAP,EAAkB;AACjB1I,IAAAA,CAAC,CAAC0I,QAAF,GAAazJ,KAAK,CAAC2J,iBAAN,CAAyB5I,CAAC,CAAC0I,QAAF,CAAWD,8BAAX,CAA2CvI,CAA3C,CAAzB,CAAb;AACA;;AAED,MAAKF,CAAC,CAAC+D,QAAP,EAAkB;AACjB,QAAK5D,OAAO,CAAC8E,UAAb,EAA0B;AACzB,UAAM4D,SAAS,GAAG5J,KAAK,CAAC2J,iBAAN,CAAyB5I,CAAC,CAAC+D,QAAF,CAAW0E,8BAAX,CAA2CvI,CAA3C,CAAzB,CAAlB;;AAEA,UAAKC,OAAO,CAAC8E,UAAR,CAAmBV,IAAnB,IAA2B,MAA3B,IAAqCrE,CAAC,CAACkD,cAAF,CAAiBC,OAAjB,CAA0BrD,CAAC,CAAC+D,QAAF,CAAWI,KAArC,CAA1C,EAAyF;AACxFnE,QAAAA,CAAC,CAAC+D,QAAF,CAAWI,KAAX,CAAiBK,IAAjB,GAAwBrE,OAAO,CAAC8E,UAAR,CAAmBT,IAA3C;AACAxE,QAAAA,CAAC,CAAC+D,QAAF,CAAWM,GAAX,GAAiBwE,SAAS,CAACxE,GAA3B;AAEA,eAAO,CAAErE,CAAF,CAAP;AACA,OALD,MAKO,IAAKG,OAAO,CAAC8E,UAAR,CAAmBV,IAAnB,IAA2B,OAA3B,IAAsCrE,CAAC,CAACkD,cAAF,CAAiBC,OAAjB,CAA0BrD,CAAC,CAAC+D,QAAF,CAAWM,GAArC,CAA3C,EAAwF;AAC9FrE,QAAAA,CAAC,CAAC+D,QAAF,CAAWI,KAAX,GAAmB0E,SAAS,CAAC1E,KAA7B;AACAnE,QAAAA,CAAC,CAAC+D,QAAF,CAAWM,GAAX,CAAeG,IAAf,GAAsBrE,OAAO,CAAC8E,UAAR,CAAmBT,IAAzC;AAEA,eAAO,CAAExE,CAAF,CAAP;AACA;AACD;;AAEDA,IAAAA,CAAC,CAAC+D,QAAF,GAAa9E,KAAK,CAAC2J,iBAAN,CAAyB5I,CAAC,CAAC+D,QAAF,CAAW0E,8BAAX,CAA2CvI,CAA3C,CAAzB,CAAb;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CA1BgB,CAAjB;AA4BAV,iBAAiB,CAAEX,eAAF,EAAmBI,cAAnB,EAAmC,UAAEiB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACxE,MAAKH,CAAC,CAAC0I,QAAP,EAAkB;AACjB1I,IAAAA,CAAC,CAAC0I,QAAF,GAAa1I,CAAC,CAAC0I,QAAF,CAAWH,+BAAX,CAA4CrI,CAA5C,CAAb;AACA;;AAED,MAAKF,CAAC,CAAC+D,QAAP,EAAkB;AACjB,QAAK5D,OAAO,CAAC8E,UAAb,EAA0B;AACzB,UAAM4D,SAAS,GAAG7I,CAAC,CAAC+D,QAAF,CAAWwE,+BAAX,CAA4CrI,CAA5C,CAAlB;;AAEA,UAAKF,CAAC,CAAC+D,QAAF,CAAWI,KAAX,CAAiBd,OAAjB,CAA0BnD,CAAC,CAAC2D,aAA5B,KAA+C1D,OAAO,CAAC8E,UAAR,CAAmBP,2BAAvE,EAAqG;AACpG1E,QAAAA,CAAC,CAAC+D,QAAF,CAAWI,KAAX,GAAmBjF,QAAQ,CAAC4J,SAAT,CAAoB5I,CAAC,CAAC+H,iBAAtB,CAAnB;AACA,OAFD,MAEO,IAAKjI,CAAC,CAAC+D,QAAF,CAAWI,KAAX,CAAiBd,OAAjB,CAA0BnD,CAAC,CAAC2D,aAA5B,KAA+C,CAAC1D,OAAO,CAAC8E,UAAR,CAAmBR,gBAAxE,EAA2F;AACjGzE,QAAAA,CAAC,CAAC+D,QAAF,CAAWI,KAAX,GAAmBjF,QAAQ,CAAC4J,SAAT,CAAoB5I,CAAC,CAACkI,kBAAtB,CAAnB;AACA;;AAED,UAAKpI,CAAC,CAAC+D,QAAF,CAAWM,GAAX,CAAehB,OAAf,CAAwBnD,CAAC,CAAC2D,aAA1B,KAA6C1D,OAAO,CAAC8E,UAAR,CAAmBL,iBAArE,EAAyF;AACxF5E,QAAAA,CAAC,CAAC+D,QAAF,CAAWM,GAAX,GAAiBnF,QAAQ,CAAC4J,SAAT,CAAoB5I,CAAC,CAACkI,kBAAtB,CAAjB;AACA,OAFD,MAEO,IAAKpI,CAAC,CAAC+D,QAAF,CAAWM,GAAX,CAAehB,OAAf,CAAwBnD,CAAC,CAAC2D,aAA1B,KAA6C1D,OAAO,CAAC8E,UAAR,CAAmBN,yBAArE,EAAiG;AACvG3E,QAAAA,CAAC,CAAC+D,QAAF,CAAWM,GAAX,GAAiBnF,QAAQ,CAAC4J,SAAT,CAAoB5I,CAAC,CAAC+H,iBAAtB,CAAjB;AACA,OAFM,MAEA;AACNjI,QAAAA,CAAC,CAAC+D,QAAF,CAAWM,GAAX,GAAiBwE,SAAS,CAACxE,GAA3B;AACA;;AAED,aAAO,CAAErE,CAAF,CAAP;AACA;;AAEDA,IAAAA,CAAC,CAAC+D,QAAF,GAAa/D,CAAC,CAAC+D,QAAF,CAAWwE,+BAAX,CAA4CrI,CAA5C,CAAb;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CA9BgB,CAAjB,C,CAgCA;;AAEAV,iBAAiB,CAAER,cAAF,EAAkBN,eAAlB,EAAmC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AAC/D,MAAKF,CAAC,CAACsD,cAAF,CAAiBgD,eAAjB,CAAkCpG,CAAC,CAACqG,QAApC,CAAL,EAAsD;AACrDvG,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAACsD,cAAF,GAAmBtD,CAAC,CAACsD,cAAF,CAAiBkF,gCAAjB,CAAmDtI,CAAnD,CAAnB;AACAF,EAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBoF,gCAAjB,CAAmDtI,CAAnD,CAAnB;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CATgB,CAAjB;AAWAV,iBAAiB,CAAER,cAAF,EAAkBA,cAAlB,EAAkC,UAAEkB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAKH,CAAC,CAACsD,cAAF,CAAiBD,OAAjB,CAA0BnD,CAAC,CAACoD,cAA5B,KAAgDtD,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAACkD,cAA5B,CAArD,EAAoG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAK,CAACjD,OAAO,CAAC6E,UAAd,EAA2B;AAC1B,aAAO,CAAE,IAAIhG,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA,KAFD,MAEO;AACN,UAAMwF,IAAI,GAAGtE,CAAC,CAACmH,iBAAF,CAAoB7C,IAApB,CAAyB7D,KAAzB,EAAb;AACA6D,MAAAA,IAAI,CAACqB,IAAL,CAAW,CAAX;AAEA7F,MAAAA,CAAC,CAACsD,cAAF,GAAmB,IAAIpE,QAAJ,CAAcgB,CAAC,CAACmH,iBAAF,CAAoB0B,IAAlC,EAAwCvE,IAAxC,CAAnB;AACAxE,MAAAA,CAAC,CAACiE,OAAF,GAAY,CAAZ;AAEA,aAAO,CAAEjE,CAAF,CAAP;AACA;AACD,GA/BsE,CAiCvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MACCA,CAAC,CAACsD,cAAF,CAAiBD,OAAjB,CAA0BnD,CAAC,CAACoD,cAA5B,KAAgD,CAACtD,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAACkD,cAA5B,CAAjD,IACA,CAACjD,OAAO,CAAC6E,UADT,IACuB7E,OAAO,CAAC8E,UAAR,IAAsB,eAF9C,EAGE;AACD,QAAM+D,YAAY,GAAGhJ,CAAC,CAACoD,cAAF,CAAiB2F,IAAjB,CAAsBE,QAAtB,IAAkC,YAAvD;AACA,QAAMC,YAAY,GAAGhJ,CAAC,CAACkD,cAAF,CAAiB2F,IAAjB,CAAsBE,QAAtB,IAAkC,YAAvD,CAFC,CAID;;AACA,QAAME,OAAO,GAAGH,YAAY,IAAI,CAACE,YAAjC,CALC,CAOD;;AACA,QAAME,OAAO,GAAGF,YAAY,IAAI,CAACF,YAAjC,CARC,CAUD;;AACA,QAAMK,SAAS,GAAGD,OAAO,IAAM,CAACD,OAAD,IAAYhJ,OAAO,CAAC0E,SAAnD;;AAEA,QAAKwE,SAAL,EAAiB;AAChB,UAAM/F,cAAc,GAAGpD,CAAC,CAACkD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAAvB;;AACA,UAAMkD,cAAc,GAAGpD,CAAC,CAACoD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAAvB;;AAEA,aAAO,CAAE,IAAItB,aAAJ,CAAmB0E,cAAnB,EAAmCtD,CAAC,CAACiE,OAArC,EAA8Cb,cAA9C,EAA8D,CAA9D,CAAF,CAAP;AACA,KALD,MAKO;AACN,aAAO,CAAE,IAAIpE,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;AACD,GApFsE,CAsFvE;AACA;;;AACA,MAAKgB,CAAC,CAACsD,cAAF,CAAiBgD,eAAjB,CAAkCpG,CAAC,CAACkD,cAApC,CAAL,EAA4D;AAC3DpD,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAACsD,cAAF,GAAmBtD,CAAC,CAACsD,cAAF,CAAiBgE,+BAAjB,CAAkDpH,CAAlD,CAAnB;AACAF,EAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAAnB,CA7FuE,CA+FvE;AACA;;AACA,MAAK,CAACF,CAAC,CAACqH,iBAAF,CAAoBhE,OAApB,CAA6BnD,CAAC,CAACmH,iBAA/B,CAAD,IAAuD,CAAClH,OAAO,CAAC0E,SAArE,EAAiF;AAChF7E,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBC,+BAApB,CAAqDpH,CAArD,CAAtB;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CAtGgB,CAAjB;AAwGAV,iBAAiB,CAAER,cAAF,EAAkBF,aAAlB,EAAiC,UAAEoB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmJ,YAAY,GAAGrK,KAAK,CAAC+E,2BAAN,CAAmC9D,CAAC,CAACoD,cAArC,EAAqDpD,CAAC,CAAC+D,OAAvD,CAArB;;AAEA,MAAK/D,CAAC,CAACqJ,IAAF,IAAU,QAAV,IAAsB,CAACpJ,OAAO,CAAC6E,UAA/B,IAA6C,CAAC7E,OAAO,CAACa,eAA3D,EAA6E;AAC5E,QAAKhB,CAAC,CAAC0D,gBAAF,CAAmB4C,eAAnB,CAAoCpG,CAAC,CAACoD,cAAtC,KAA0DgG,YAAY,CAAC9F,gBAAb,CAA+BxD,CAAC,CAACsD,cAAjC,CAA/D,EAAmH;AAClH,aAAO,CAAE,IAAItE,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;AACD,GAlBqE,CAoBtE;AACA;;;AACA,MAAKgB,CAAC,CAACsD,cAAF,CAAiBgD,eAAjB,CAAkCpG,CAAC,CAACkD,cAApC,CAAL,EAA4D;AAC3DpD,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAED,MAAKjE,CAAC,CAACsD,cAAF,CAAiBgD,eAAjB,CAAkCpG,CAAC,CAACoD,cAApC,CAAL,EAA4D;AAC3DtD,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAACsD,cAAF,GAAmBtD,CAAC,CAACsD,cAAF,CAAiBmF,8BAAjB,CAAiDvI,CAAjD,CAAnB;AACAF,EAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBqF,8BAAjB,CAAiDvI,CAAjD,CAAnB,CA/BsE,CAiCtE;AACA;AACA;AACA;;AACA,MAAK,CAACF,CAAC,CAACqH,iBAAF,CAAoBhE,OAApB,CAA6BnD,CAAC,CAACkD,cAA/B,CAAN,EAAwD;AACvDpD,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBoB,8BAApB,CAAoDvI,CAApD,CAAtB;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CA1CgB,CAAjB;AA4CAV,iBAAiB,CAAER,cAAF,EAAkBC,cAAlB,EAAkC,UAAEiB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvE,MAAKD,CAAC,CAACmH,iBAAP,EAA2B;AAC1B;AACA;AACArH,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBQ,yBAApB,CAA+C3H,CAAC,CAACmH,iBAAjD,EAAoE,CAApE,CAAtB,CAH0B,CAK1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAKrH,CAAC,CAAC0D,gBAAF,CAAmBL,OAAnB,CAA4BnD,CAAC,CAACmH,iBAA9B,CAAL,EAAyD;AACxDrH,MAAAA,CAAC,CAACiE,OAAF,GAAY/D,CAAC,CAAC+D,OAAd;AACA;AACD,GAnBsE,CAqBvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKjE,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAAC2D,aAA5B,CAAL,EAAmD;AAClD,QAAM2F,WAAW,GAAGtJ,CAAC,CAAC+D,OAAF,IAAa,CAAjC;AACA,QAAMwF,qBAAqB,GAAGvJ,CAAC,CAACmH,iBAAF,IAAuBrH,CAAC,CAAC0D,gBAAF,CAAmBL,OAAnB,CAA4BnD,CAAC,CAACmH,iBAA9B,CAArD;;AAEA,QAAKmC,WAAW,IAAIC,qBAAf,IAAwCtJ,OAAO,CAAC8E,UAAR,IAAsB,qBAAnE,EAA2F;AAC1FjF,MAAAA,CAAC,CAACsD,cAAF,GAAmBtD,CAAC,CAACsD,cAAF,CAAiBiF,+BAAjB,CAAkDrI,CAAlD,CAAnB;AAEA,aAAO,CAAEF,CAAF,CAAP;AACA;AACD,GAlFsE,CAoFvE;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKA,CAAC,CAACsD,cAAF,CAAiBD,OAAjB,CAA0BnD,CAAC,CAAC2D,aAA5B,CAAL,EAAmD;AAClD;AACA;AACA;AACA,QAAK1D,OAAO,CAAC8E,UAAR,IAAsB,qBAA3B,EAAmD;AAClDjF,MAAAA,CAAC,CAACiE,OAAF,GAAY,CAAZ;AACAjE,MAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBmF,+BAAjB,CAAkDrI,CAAlD,CAAnB;AAEA,aAAO,CAAEF,CAAF,CAAP;AACA,KATiD,CAWlD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAKG,OAAO,CAAC8E,UAAR,IAAsB,kBAAtB,IAA4CjF,CAAC,CAACsD,cAAF,CAAiB4E,MAAjB,GAA0B,CAA3E,EAA+E;AAC9ElI,MAAAA,CAAC,CAACsD,cAAF,GAAmBpD,CAAC,CAACkI,kBAAF,CAAqB/H,KAArB,EAAnB;AACAL,MAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBmF,+BAAjB,CAAkDrI,CAAlD,CAAnB;AAEA,aAAO,CAAEF,CAAF,CAAP;AACA;AACD,GAlHsE,CAoHvE;AACA;;;AACA,MAAKA,CAAC,CAACsD,cAAF,CAAiBgD,eAAjB,CAAkCpG,CAAC,CAAC2D,aAApC,CAAL,EAA2D;AAC1D7D,IAAAA,CAAC,CAACiE,OAAF,GAAY/D,CAAC,CAAC2D,aAAF,CAAgBqE,MAA5B;AACA;;AAEDlI,EAAAA,CAAC,CAACsD,cAAF,GAAmBtD,CAAC,CAACsD,cAAF,CAAiBiF,+BAAjB,CAAkDrI,CAAlD,CAAnB;AACAF,EAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBmF,+BAAjB,CAAkDrI,CAAlD,CAAnB;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CA9HgB,CAAjB,C,CAgIA;;AAEAV,iBAAiB,CAAEV,aAAF,EAAiBJ,eAAjB,EAAkC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AAC9D,MAAMwH,SAAS,GAAGzI,KAAK,CAAC+E,2BAAN,CAAmChE,CAAC,CAACsD,cAArC,EAAqDtD,CAAC,CAACiE,OAAvD,CAAlB;;AACA,MAAMyF,WAAW,GAAGhC,SAAS,CAACc,gCAAV,CAA4CtI,CAA5C,EAA+C,KAA/C,EAAwD,CAAxD,CAApB;;AAEAF,EAAAA,CAAC,CAACsD,cAAF,GAAmBoG,WAAW,CAACvF,KAA/B;AACAnE,EAAAA,CAAC,CAACiE,OAAF,GAAYyF,WAAW,CAACrF,GAAZ,CAAgB6D,MAAhB,GAAyBwB,WAAW,CAACvF,KAAZ,CAAkB+D,MAAvD,CAL8D,CAO9D;AACA;AACA;AACA;AACA;AACA;;AACA,MAAK,CAAClI,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAACqG,QAA5B,CAAN,EAA+C;AAC9CvG,IAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBoF,gCAAjB,CAAmDtI,CAAnD,CAAnB;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CAlBgB,CAAjB;AAoBAV,iBAAiB,CAAEV,aAAF,EAAiBA,aAAjB,EAAgC,UAAEoB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACrE;AACA;AACA;AACA;AACA,MAAMwJ,MAAM,GAAG1K,KAAK,CAAC+E,2BAAN,CAAmChE,CAAC,CAACsD,cAArC,EAAqDtD,CAAC,CAACiE,OAAvD,CAAf;;AACA,MAAM2F,MAAM,GAAG3K,KAAK,CAAC+E,2BAAN,CAAmC9D,CAAC,CAACoD,cAArC,EAAqDpD,CAAC,CAAC+D,OAAvD,CAAf,CANqE,CAQrE;AACA;;;AACA,MAAIY,SAAS,GAAG1E,OAAO,CAAC0E,SAAxB,CAVqE,CAYrE;AACA;;AACA,MAAIgF,YAAY,GAAG,CAAC1J,OAAO,CAAC0E,SAA5B,CAdqE,CAgBrE;;AACA,MAAK1E,OAAO,CAAC8E,UAAR,IAAsB,cAAtB,IAAwC9E,OAAO,CAACgF,UAAR,IAAsB,aAAnE,EAAmF;AAClF0E,IAAAA,YAAY,GAAG,IAAf;AACA,GAFD,MAEO,IAAK1J,OAAO,CAAC8E,UAAR,IAAsB,aAAtB,IAAuC9E,OAAO,CAACgF,UAAR,IAAsB,cAAlE,EAAmF;AACzF0E,IAAAA,YAAY,GAAG,KAAf;AACA,GArBoE,CAuBrE;;;AACA,MAAIC,iBAAJ;;AAEA,MAAK9J,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAACkD,cAA5B,KAAgDyG,YAArD,EAAoE;AACnEC,IAAAA,iBAAiB,GAAG9J,CAAC,CAACoD,cAAF,CAAiByE,yBAAjB,CACnB3H,CAAC,CAACoD,cADiB,EAEnBpD,CAAC,CAAC+D,OAFiB,CAApB;AAIA,GALD,MAKO;AACN6F,IAAAA,iBAAiB,GAAG9J,CAAC,CAACoD,cAAF,CAAiB4E,qBAAjB,CACnB9H,CAAC,CAACoD,cADiB,EAEnBpD,CAAC,CAACkD,cAFiB,EAGnBlD,CAAC,CAAC+D,OAHiB,CAApB;AAKA,GArCoE,CAuCrE;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAK8F,yBAAyB,CAAE/J,CAAF,EAAKE,CAAL,CAAzB,IAAqC6J,yBAAyB,CAAE7J,CAAF,EAAKF,CAAL,CAAnE,EAA8E;AAC7E;AACA;AACA,WAAO,CAAEE,CAAC,CAAC8J,WAAF,EAAF,CAAP;AACA,GAjDoE,CAkDrE;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAGN,MAAM,CAACnG,gBAAP,CAAyBtD,CAAC,CAACkD,cAA3B,CAApB,CA1DqE,CA4DrE;AACA;;AACA,MAAK6G,WAAW,IAAIN,MAAM,CAACrF,aAAP,CAAsBsF,MAAtB,EAA8B,IAA9B,CAApB,EAA2D;AAC1D;AACA;AACAD,IAAAA,MAAM,CAACxF,KAAP,GAAewF,MAAM,CAACxF,KAAP,CAAa6D,qBAAb,CAAoC9H,CAAC,CAACoD,cAAtC,EAAsDpD,CAAC,CAACkD,cAAxD,EAAwElD,CAAC,CAAC+D,OAA1E,CAAf;AACA0F,IAAAA,MAAM,CAACtF,GAAP,GAAasF,MAAM,CAACtF,GAAP,CAAW2D,qBAAX,CAAkC9H,CAAC,CAACoD,cAApC,EAAoDpD,CAAC,CAACkD,cAAtD,EAAsElD,CAAC,CAAC+D,OAAxE,CAAb;AAEA,WAAOiG,6BAA6B,CAAE,CAAEP,MAAF,CAAF,EAAcG,iBAAd,CAApC;AACA,GArEoE,CAuErE;AACA;AACA;;;AACA,MAAMK,WAAW,GAAGP,MAAM,CAACpG,gBAAP,CAAyBxD,CAAC,CAACoD,cAA3B,CAApB;;AAEA,MAAK+G,WAAW,IAAIP,MAAM,CAACtF,aAAP,CAAsBqF,MAAtB,EAA8B,IAA9B,CAApB,EAA2D;AAC1D;AACA;AACAA,IAAAA,MAAM,CAACxF,KAAP,GAAewF,MAAM,CAACxF,KAAP,CAAakE,YAAb,CAA2BnI,CAAC,CAACoD,cAA7B,EAA6CpD,CAAC,CAAC4H,kBAAF,EAA7C,CAAf;AACA6B,IAAAA,MAAM,CAACtF,GAAP,GAAasF,MAAM,CAACtF,GAAP,CAAWgE,YAAX,CAAyBnI,CAAC,CAACoD,cAA3B,EAA2CpD,CAAC,CAAC4H,kBAAF,EAA3C,CAAb;AAEA,WAAOoC,6BAA6B,CAAE,CAAEP,MAAF,CAAF,EAAcG,iBAAd,CAApC;AACA,GAnFoE,CAoFrE;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMM,MAAM,GAAGjL,aAAa,CAAEa,CAAC,CAACsD,cAAF,CAAiB+G,aAAjB,EAAF,EAAoCnK,CAAC,CAACoD,cAAF,CAAiB+G,aAAjB,EAApC,CAA5B;;AAEA,MAAKD,MAAM,IAAI,QAAV,IAAsBA,MAAM,IAAI,WAArC,EAAmD;AAClD;AACA;AACA;AACAT,IAAAA,MAAM,CAACxF,KAAP,GAAewF,MAAM,CAACxF,KAAP,CAAa6D,qBAAb,CAAoC9H,CAAC,CAACoD,cAAtC,EAAsDpD,CAAC,CAACkD,cAAxD,EAAwElD,CAAC,CAAC+D,OAA1E,CAAf;AACA0F,IAAAA,MAAM,CAACtF,GAAP,GAAasF,MAAM,CAACtF,GAAP,CAAW2D,qBAAX,CAAkC9H,CAAC,CAACoD,cAApC,EAAoDpD,CAAC,CAACkD,cAAtD,EAAsElD,CAAC,CAAC+D,OAAxE,CAAb;AAEA,WAAOiG,6BAA6B,CAAE,CAAEP,MAAF,CAAF,EAAcG,iBAAd,CAApC;AACA,GAzGoE,CA0GrE;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAK9J,CAAC,CAACuJ,IAAF,IAAU,QAAV,IAAsBrJ,CAAC,CAACqJ,IAAF,IAAU,QAAhC,IAA4C,CAACpJ,OAAO,CAAC2E,UAArD,IAAmE,CAAC3E,OAAO,CAACa,eAAjF,EAAmG;AAClG6D,IAAAA,SAAS,GAAG,IAAZ;AACA,GAFD,MAEO,IAAK7E,CAAC,CAACuJ,IAAF,IAAU,QAAV,IAAsBrJ,CAAC,CAACqJ,IAAF,IAAU,QAAhC,IAA4C,CAACpJ,OAAO,CAAC6E,UAArD,IAAmE,CAAC7E,OAAO,CAACa,eAAjF,EAAmG;AACzG6D,IAAAA,SAAS,GAAG,KAAZ;AACA,GA1HoE,CA4HrE;AACA;;;AACA,MAAMuC,MAAM,GAAG,EAAf,CA9HqE,CAgIrE;AACA;;AACA,MAAMO,UAAU,GAAGgC,MAAM,CAAC3D,aAAP,CAAsB4D,MAAtB,CAAnB;AAlIqE;AAAA;AAAA;;AAAA;AAoIrE,0BAAqBjC,UAArB,mIAAkC;AAAA,UAAtB5B,KAAsB;AACjC;AACAA,MAAAA,KAAK,CAAC5B,KAAN,GAAc4B,KAAK,CAAC5B,KAAN,CAAY0D,yBAAZ,CAAuC3H,CAAC,CAACoD,cAAzC,EAAyDpD,CAAC,CAAC+D,OAA3D,CAAd;AACA8B,MAAAA,KAAK,CAAC1B,GAAN,GAAY0B,KAAK,CAAC1B,GAAN,CAAUwD,yBAAV,CAAqC3H,CAAC,CAACoD,cAAvC,EAAuDpD,CAAC,CAAC+D,OAAzD,CAAZ,CAHiC,CAKjC;;AACA,UAAMqG,YAAY,GAAGnL,aAAa,CAAE4G,KAAK,CAAC5B,KAAN,CAAYkG,aAAZ,EAAF,EAA+BnK,CAAC,CAAC4H,kBAAF,GAAuBuC,aAAvB,EAA/B,CAAb,IAAwF,MAA7G;;AACA,UAAME,SAAS,GAAGxE,KAAK,CAACS,0BAAN,CAAkCtG,CAAC,CAAC4H,kBAAF,EAAlC,EAA0D5H,CAAC,CAAC+D,OAA5D,EAAqEqG,YAArE,CAAlB;;AAEAlD,MAAAA,MAAM,CAACvB,IAAP,OAAAuB,MAAM,qBAAUmD,SAAV,EAAN;AACA,KA9IoE,CAgJrE;;AAhJqE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiJrE,MAAMnE,MAAM,GAAGuD,MAAM,CAACtD,eAAP,CAAwBuD,MAAxB,CAAf;;AAEA,MAAKxD,MAAM,KAAK,IAAX,IAAmBvB,SAAxB,EAAoC;AACnC;AACAuB,IAAAA,MAAM,CAACjC,KAAP,GAAeiC,MAAM,CAACjC,KAAP,CAAakE,YAAb,CAA2BnI,CAAC,CAACoD,cAA7B,EAA6CpD,CAAC,CAAC4H,kBAAF,EAA7C,CAAf;AACA1B,IAAAA,MAAM,CAAC/B,GAAP,GAAa+B,MAAM,CAAC/B,GAAP,CAAWgE,YAAX,CAAyBnI,CAAC,CAACoD,cAA3B,EAA2CpD,CAAC,CAAC4H,kBAAF,EAA3C,CAAb,CAHmC,CAKnC;AACA;AACA;AACA;AACA;AACA;;AACA,QAAKV,MAAM,CAACjG,MAAP,KAAkB,CAAvB,EAA2B;AAC1BiG,MAAAA,MAAM,CAACvB,IAAP,CAAaO,MAAb;AACA,KAFD,CAGA;AAHA,SAIK,IAAKgB,MAAM,CAACjG,MAAP,IAAiB,CAAtB,EAA0B;AAC9B,YAAKyI,MAAM,CAACzF,KAAP,CAAaP,QAAb,CAAuB+F,MAAM,CAACxF,KAA9B,KAAyCyF,MAAM,CAACzF,KAAP,CAAad,OAAb,CAAsBsG,MAAM,CAACxF,KAA7B,CAA9C,EAAqF;AACpFiD,UAAAA,MAAM,CAACP,OAAP,CAAgBT,MAAhB;AACA,SAFD,MAEO;AACNgB,UAAAA,MAAM,CAACvB,IAAP,CAAaO,MAAb;AACA;AACD,OANI,CAOL;AACA;AARK,WASA;AACJgB,UAAAA,MAAM,CAAC9E,MAAP,CAAe,CAAf,EAAkB,CAAlB,EAAqB8D,MAArB;AACA;AACD;;AAED,MAAKgB,MAAM,CAACjG,MAAP,KAAkB,CAAvB,EAA2B;AAC1B;AACA;AACA,WAAO,CAAE,IAAInC,WAAJ,CAAiBgB,CAAC,CAACyB,WAAnB,CAAF,CAAP;AACA;;AAED,SAAOyI,6BAA6B,CAAE9C,MAAF,EAAU0C,iBAAV,CAApC;AACA,CAvLgB,CAAjB;AAyLAxK,iBAAiB,CAAEV,aAAF,EAAiBG,cAAjB,EAAiC,UAAEiB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACtE,MAAI2J,iBAAiB,GAAG9J,CAAC,CAACoD,cAAF,CAAiB/C,KAAjB,EAAxB,CADsE,CAGtE;AACA;AACA;;AACA,MAAK,CAACL,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAAC+H,iBAA5B,CAAD,IAAoD,CAAC/H,CAAC,CAACmH,iBAAvD,IAA4ElH,OAAO,CAAC8E,UAAR,IAAsB,iBAAvG,EAA2H;AAC1H6E,IAAAA,iBAAiB,GAAG9J,CAAC,CAACoD,cAAF,CAAiBmF,+BAAjB,CAAkDrI,CAAlD,CAApB;AACA,GARqE,CAUtE;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMwH,SAAS,GAAGzI,KAAK,CAAC+E,2BAAN,CAAmChE,CAAC,CAACsD,cAArC,EAAqDtD,CAAC,CAACiE,OAAvD,CAAlB;;AAEA,MAAKyD,SAAS,CAACrD,GAAV,CAAchB,OAAd,CAAuBnD,CAAC,CAAC+H,iBAAzB,CAAL,EAAoD;AACnD;AACA;AACA,QAAK,CAAC/H,CAAC,CAACmH,iBAAR,EAA4B;AAC3BrH,MAAAA,CAAC,CAACiE,OAAF;AACA;;AAEDjE,IAAAA,CAAC,CAACoD,cAAF,GAAmB0G,iBAAnB;AAEA,WAAO,CAAE9J,CAAF,CAAP;AACA,GA7BqE,CA+BtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAK0H,SAAS,CAACvD,KAAV,CAAgBmC,eAAhB,CAAiCpG,CAAC,CAAC2D,aAAnC,KAAsD6D,SAAS,CAAClE,gBAAV,CAA4BtD,CAAC,CAAC2D,aAA9B,CAA3D,EAA2G;AAC1G,QAAI2G,UAAU,GAAG,IAAIvL,KAAJ,CAAWiB,CAAC,CAAC2D,aAAb,EAA4B6D,SAAS,CAACrD,GAAtC,CAAjB;AACAmG,IAAAA,UAAU,GAAGA,UAAU,CAACjC,+BAAX,CAA4CrI,CAA5C,CAAb;AAEA,QAAMkH,OAAM,GAAG,CACd,IAAInI,KAAJ,CAAWyI,SAAS,CAACvD,KAArB,EAA4BjE,CAAC,CAAC2D,aAA9B,CADc,EAEd2G,UAFc,CAAf;AAKA,WAAON,6BAA6B,CAAE9C,OAAF,EAAU0C,iBAAV,CAApC;AACA,GAzDqE,CA2DtE;AACA;AACA;AACA;AACA;;;AACA,MAAK9J,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAAC2D,aAA5B,KAA+C1D,OAAO,CAAC8E,UAAR,IAAsB,gBAA1E,EAA6F;AAC5F6E,IAAAA,iBAAiB,GAAG5J,CAAC,CAACkI,kBAAtB;AACA,GAlEqE,CAoEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKpI,CAAC,CAACoD,cAAF,CAAiBC,OAAjB,CAA0BnD,CAAC,CAAC+H,iBAA5B,KAAmD9H,OAAO,CAAC8E,UAAR,IAAsB,eAA9E,EAAgG;AAC/F6E,IAAAA,iBAAiB,GAAG9J,CAAC,CAACoD,cAAtB;AACA,GA3FqE,CA6FtE;AACA;;;AACA,MAAMsG,WAAW,GAAGhC,SAAS,CAACa,+BAAV,CAA2CrI,CAA3C,CAApB;;AACA,MAAMkH,MAAM,GAAG,CAAEsC,WAAF,CAAf,CAhGsE,CAkGtE;AACA;AACA;AACA;;AACA,MAAKxJ,CAAC,CAACmH,iBAAP,EAA2B;AAC1B,QAAMoD,qBAAqB,GAAG/C,SAAS,CAACvD,KAAV,CAAgBd,OAAhB,CAAyBnD,CAAC,CAACmH,iBAA3B,KAAkDK,SAAS,CAAClE,gBAAV,CAA4BtD,CAAC,CAACmH,iBAA9B,CAAhF;;AAEA,QAAKrH,CAAC,CAACiE,OAAF,GAAY,CAAZ,IAAiBwG,qBAAjB,IAA0C,CAACtK,OAAO,CAAC2E,UAAxD,EAAqE;AACpEsC,MAAAA,MAAM,CAACvB,IAAP,CAAa5G,KAAK,CAAC+E,2BAAN,CAAmC9D,CAAC,CAAC+H,iBAArC,EAAwD,CAAxD,CAAb;AACA;AACD;;AAED,SAAOiC,6BAA6B,CAAE9C,MAAF,EAAU0C,iBAAV,CAApC;AACA,CA/GgB,CAAjB;AAiHAxK,iBAAiB,CAAEV,aAAF,EAAiBE,cAAjB,EAAiC,UAAEkB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACtE,MAAMoD,UAAU,GAAGtE,KAAK,CAAC+E,2BAAN,CAAmChE,CAAC,CAACsD,cAArC,EAAqDtD,CAAC,CAACiE,OAAvD,CAAnB;;AAEA,MAAK/D,CAAC,CAACwD,gBAAF,CAAmB4C,eAAnB,CAAoCtG,CAAC,CAACsD,cAAtC,KAA0DC,UAAU,CAACC,gBAAX,CAA6BtD,CAAC,CAACoD,cAA/B,CAA/D,EAAiH;AAChH,QAAKtD,CAAC,CAACuJ,IAAF,IAAU,QAAV,IAAsB,CAACpJ,OAAO,CAACa,eAApC,EAAsD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAK,CAACb,OAAO,CAAC2E,UAAd,EAA2B;AAC1B,YAAM4F,OAAO,GAAG,EAAhB;AAEA,YAAIC,YAAY,GAAGzK,CAAC,CAACmH,iBAAF,CAAoBhH,KAApB,EAAnB;;AACA,YAAIuK,oBAAoB,GAAG1K,CAAC,CAACkD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAA3B;;AAEA,YAAKF,CAAC,CAACiE,OAAF,GAAY,CAAjB,EAAqB;AACpByG,UAAAA,OAAO,CAAC7E,IAAR,CAAc,IAAIjH,aAAJ,CAAmBoB,CAAC,CAACsD,cAArB,EAAqCtD,CAAC,CAACiE,OAAF,GAAY,CAAjD,EAAoDjE,CAAC,CAACoD,cAAtD,EAAsE,CAAtE,CAAd;AAEAuH,UAAAA,YAAY,GAAGA,YAAY,CAAC3C,qBAAb,CAAoChI,CAAC,CAACsD,cAAtC,EAAsDtD,CAAC,CAACoD,cAAxD,EAAwEpD,CAAC,CAACiE,OAAF,GAAY,CAApF,CAAf;AACA2G,UAAAA,oBAAoB,GAAGA,oBAAoB,CAAC5C,qBAArB,CAA4ChI,CAAC,CAACsD,cAA9C,EAA8DtD,CAAC,CAACoD,cAAhE,EAAgFpD,CAAC,CAACiE,OAAF,GAAY,CAA5F,CAAvB;AACA;;AAED,YAAM4G,YAAY,GAAG3K,CAAC,CAACwD,gBAAF,CAAmB2E,YAAnB,CAAiCrI,CAAC,CAACsD,cAAnC,EAAmDtD,CAAC,CAACoD,cAArD,CAArB;;AACA,YAAM0H,MAAM,GAAG,IAAIlM,aAAJ,CAAmB+L,YAAnB,EAAiC,CAAjC,EAAoCE,YAApC,EAAkD,CAAlD,CAAf;AAEA,YAAME,wBAAwB,GAAGD,MAAM,CAAChD,kBAAP,GAA4BtD,IAA5B,CAAiC7D,KAAjC,EAAjC;AACAoK,QAAAA,wBAAwB,CAAClF,IAAzB,CAA+B,CAA/B;AAEA,YAAMmF,oBAAoB,GAAG,IAAI9L,QAAJ,CAAc4L,MAAM,CAAC1H,cAAP,CAAsB2F,IAApC,EAA0CgC,wBAA1C,CAA7B;AACAH,QAAAA,oBAAoB,GAAGA,oBAAoB,CAAC5C,qBAArB,CAA4C2C,YAA5C,EAA0DE,YAA1D,EAAwE,CAAxE,CAAvB;AACA,YAAMI,cAAc,GAAG,IAAIrM,aAAJ,CAAmBgM,oBAAnB,EAAyC1K,CAAC,CAAC+D,OAA3C,EAAoD+G,oBAApD,EAA0E,CAA1E,CAAvB;AAEAN,QAAAA,OAAO,CAAC7E,IAAR,CAAciF,MAAd;AACAJ,QAAAA,OAAO,CAAC7E,IAAR,CAAcoF,cAAd;AAEA,eAAOP,OAAP;AACA;AACD,KAtCD,MAsCO;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAK1K,CAAC,CAACiE,OAAF,IAAa,CAAlB,EAAsB;AACrB,YAAK,CAAC9D,OAAO,CAAC6E,UAAd,EAA2B;AAC1B,iBAAO,CAAE,IAAIhG,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA,SAFD,MAEO;AACNgB,UAAAA,CAAC,CAACsD,cAAF,GAAmBpD,CAAC,CAACmH,iBAAF,CAAoBhH,KAApB,EAAnB;AACAL,UAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAAnB;AAEA,iBAAO,CAAEF,CAAF,CAAP;AACA;AACD;AACD;AACD,GA5DqE,CA8DtE;AACA;;;AACA,MAAM0H,SAAS,GAAGzI,KAAK,CAAC+E,2BAAN,CAAmChE,CAAC,CAACsD,cAArC,EAAqDtD,CAAC,CAACiE,OAAvD,CAAlB;;AACA,MAAMyF,WAAW,GAAGhC,SAAS,CAACJ,+BAAV,CAA2CpH,CAA3C,CAApB;;AAEAF,EAAAA,CAAC,CAACsD,cAAF,GAAmBoG,WAAW,CAACvF,KAA/B;AACAnE,EAAAA,CAAC,CAACiE,OAAF,GAAYyF,WAAW,CAACrF,GAAZ,CAAgB6D,MAAhB,GAAyBwB,WAAW,CAACvF,KAAZ,CAAkB+D,MAAvD;AACAlI,EAAAA,CAAC,CAACoD,cAAF,GAAmBpD,CAAC,CAACoD,cAAF,CAAiBkE,+BAAjB,CAAkDpH,CAAlD,CAAnB;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAxEgB,CAAjB,C,CA0EA;;AAEAV,iBAAiB,CAAEZ,eAAF,EAAmBF,eAAnB,EAAoC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AAChEF,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWiC,gCAAX,CAA6CtI,CAA7C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAJgB,CAAjB;AAMAV,iBAAiB,CAAEZ,eAAF,EAAmBI,cAAnB,EAAmC,UAAEkB,CAAF,EAAKE,CAAL,EAAY;AAC/D;AACA;AACA;AACA;AACA,MAAKF,CAAC,CAACuG,QAAF,CAAWlD,OAAX,CAAoBnD,CAAC,CAACwD,gBAAtB,CAAL,EAAgD;AAC/C1D,IAAAA,CAAC,CAACuG,QAAF,GAAarG,CAAC,CAACmH,iBAAF,CAAoBhH,KAApB,EAAb;AACAL,IAAAA,CAAC,CAACuG,QAAF,CAAW+B,UAAX,GAAwB,QAAxB;AAEA,WAAO,CAAEtI,CAAF,CAAP;AACA;;AAEDA,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWe,+BAAX,CAA4CpH,CAA5C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAfgB,CAAjB;AAiBAV,iBAAiB,CAAEZ,eAAF,EAAmBE,aAAnB,EAAkC,UAAEoB,CAAF,EAAKE,CAAL,EAAY;AAC9DF,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWkC,8BAAX,CAA2CvI,CAA3C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CAJgB,CAAjB;AAMAV,iBAAiB,CAAEZ,eAAF,EAAmBA,eAAnB,EAAoC,UAAEsB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACzE,MAAKH,CAAC,CAACuG,QAAF,CAAWlD,OAAX,CAAoBnD,CAAC,CAACqG,QAAtB,CAAL,EAAwC;AACvC,QAAKpG,OAAO,CAAC0E,SAAb,EAAyB;AACxB7E,MAAAA,CAAC,CAACkL,OAAF,GAAYhL,CAAC,CAACiL,OAAd;AACA,KAFD,MAEO;AACN,aAAO,CAAE,IAAInM,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;AACD;;AAED,SAAO,CAAEgB,CAAF,CAAP;AACA,CAVgB,CAAjB;AAYAV,iBAAiB,CAAEZ,eAAF,EAAmBK,cAAnB,EAAmC,UAAEiB,CAAF,EAAKE,CAAL,EAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMkL,UAAU,GAAGpL,CAAC,CAACuG,QAAF,CAAW/B,IAA9B;AACA,MAAM6G,SAAS,GAAGnL,CAAC,CAAC2D,aAAF,CAAgBwG,aAAhB,EAAlB;;AAEA,MAAKlL,aAAa,CAAEiM,UAAF,EAAcC,SAAd,CAAb,IAA0C,MAA1C,IAAoD,CAACnL,CAAC,CAACmH,iBAA5D,EAAgF;AAC/E,QAAMiE,WAAW,GAAG,IAAI5M,eAAJ,CAAqBsB,CAAC,CAACuG,QAAF,CAAWY,YAAX,CAAyB,CAAzB,CAArB,EAAmDnH,CAAC,CAACkL,OAArD,EAA8DlL,CAAC,CAACmL,OAAhE,EAAyE,CAAzE,CAApB;AAEA,WAAO,CAAEnL,CAAF,EAAKsL,WAAL,CAAP;AACA,GArB8D,CAuB/D;AACA;;;AACAtL,EAAAA,CAAC,CAACuG,QAAF,GAAavG,CAAC,CAACuG,QAAF,CAAWgC,+BAAX,CAA4CrI,CAA5C,CAAb;AAEA,SAAO,CAAEF,CAAF,CAAP;AACA,CA5BgB,CAAjB,C,CA8BA;;AAEAV,iBAAiB,CAAET,sBAAF,EAA0BA,sBAA1B,EAAkD,UAAEmB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvF,MAAKH,CAAC,CAAC+I,IAAF,KAAW7I,CAAC,CAAC6I,IAAb,IAAqB/I,CAAC,CAAC8F,GAAF,KAAU5F,CAAC,CAAC4F,GAAtC,EAA4C;AAC3C,QAAK,CAAC3F,OAAO,CAAC0E,SAAT,IAAsB7E,CAAC,CAACmG,QAAF,KAAejG,CAAC,CAACiG,QAA5C,EAAuD;AACtD,aAAO,CAAE,IAAInH,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA,KAFD,MAEO;AACNgB,MAAAA,CAAC,CAACkG,QAAF,GAAahG,CAAC,CAACiG,QAAf;AACA;AACD;;AAED,SAAO,CAAEnG,CAAF,CAAP;AACA,CAVgB,CAAjB,C,CAYA;;AAEAV,iBAAiB,CAAEP,cAAF,EAAkBP,eAAlB,EAAmC,UAAEwB,CAAF,EAAKE,CAAL,EAAY;AAC/D;AACA;AACA,MAAKF,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACqG,QAAnC,KAAiDvG,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,GAAyBhI,CAAC,CAACqG,QAAF,CAAW2B,MAA1F,EAAmG;AAClGlI,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgB2E,gCAAhB,CAAkDtI,CAAlD,CAAlB;AACAF,EAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AAEA,SAAO,CAAE7D,CAAF,CAAP;AACA,CAXgB,CAAjB;AAaAV,iBAAiB,CAAEP,cAAF,EAAkBD,cAAlB,EAAkC,UAAEkB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,CAACH,CAAC,CAACqH,iBAAH,IAAwB,CAAClH,OAAO,CAAC6E,UAAjC,IAA+ChF,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACoD,cAAnC,CAApD,EAA0G;AACzG,QAAM+H,SAAS,GAAGnL,CAAC,CAACmH,iBAAF,CAAoB7C,IAApB,CAAyB7D,KAAzB,EAAlB;AACA0K,IAAAA,SAAS,CAACxF,IAAV,CAAgB,CAAhB;AAEA,QAAMhC,aAAa,GAAG,IAAI3E,QAAJ,CAAcgB,CAAC,CAACmH,iBAAF,CAAoB0B,IAAlC,EAAwCsC,SAAxC,CAAtB;AACA,QAAMpD,iBAAiB,GAAGlJ,cAAc,CAACwM,oBAAf,CAAqC,IAAIrM,QAAJ,CAAcgB,CAAC,CAACmH,iBAAF,CAAoB0B,IAAlC,EAAwCsC,SAAxC,CAArC,CAA1B;AAEA,QAAMG,eAAe,GAAG,IAAIzM,cAAJ,CAAoB8E,aAApB,EAAmC,CAAnC,EAAsC,IAAtC,EAA4C,CAA5C,CAAxB;AACA2H,IAAAA,eAAe,CAACvD,iBAAhB,GAAoCA,iBAApC;AAEAjI,IAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgByD,+BAAhB,CAAiDpH,CAAjD,CAAlB;AACAF,IAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AACA7D,IAAAA,CAAC,CAACqH,iBAAF,GAAsBmE,eAAe,CAACvD,iBAAhB,CAAkC5H,KAAlC,EAAtB;AACAL,IAAAA,CAAC,CAACqH,iBAAF,CAAoBiB,UAApB,GAAiC,QAAjC;AAEA,WAAO,CAAEkD,eAAF,EAAmBxL,CAAnB,CAAP;AACA,GArEsE,CAuEvE;AACA;;;AACA,MAAKA,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACwD,gBAAnC,KAAyD,CAAC1D,CAAC,CAAC6D,aAAF,CAAgBF,OAAhB,CAAyBzD,CAAC,CAACwD,gBAA3B,CAA/D,EAA+G;AAC9G1D,IAAAA,CAAC,CAACiE,OAAF;AACA;;AAED,MAAKjE,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACkD,cAAnC,CAAL,EAA2D;AAC1DpD,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgByD,+BAAhB,CAAiDpH,CAAjD,CAAlB;AACAF,EAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;;AAEA,MAAK7D,CAAC,CAACqH,iBAAP,EAA2B;AAC1BrH,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBC,+BAApB,CAAqDpH,CAArD,CAAtB;AACA;;AAED,SAAO,CAAEF,CAAF,CAAP;AACA,CAzFgB,CAAjB;AA2FAV,iBAAiB,CAAEP,cAAF,EAAkBH,aAAlB,EAAiC,UAAEoB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACtE,MAAMsL,WAAW,GAAGxM,KAAK,CAAC+E,2BAAN,CAAmC9D,CAAC,CAACoD,cAArC,EAAqDpD,CAAC,CAAC+D,OAAvD,CAApB;;AAEA,MAAKjE,CAAC,CAACqH,iBAAP,EAA2B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAMqE,cAAc,GAAGD,WAAW,CAACtH,KAAZ,CAAkBd,OAAlB,CAA2BrD,CAAC,CAACqH,iBAA7B,KAAoDoE,WAAW,CAACjI,gBAAZ,CAA8BxD,CAAC,CAACqH,iBAAhC,CAA3E;;AAEA,QAAK,CAAClH,OAAO,CAAC6E,UAAT,IAAuB0G,cAA5B,EAA6C;AAC5C,UAAMpI,cAAc,GAAGtD,CAAC,CAAC6D,aAAF,CAAgB4E,8BAAhB,CAAgDvI,CAAhD,CAAvB;;AAEA,UAAMyL,iBAAiB,GAAG3L,CAAC,CAACqH,iBAAF,CAAoBoB,8BAApB,CAAoDvI,CAApD,CAA1B;;AACA,UAAM0L,aAAa,GAAGD,iBAAiB,CAACnH,IAAlB,CAAuB7D,KAAvB,EAAtB;AACAiL,MAAAA,aAAa,CAAC/F,IAAd,CAAoB,CAApB;AAEA,UAAMiE,iBAAiB,GAAG,IAAI5K,QAAJ,CAAcyM,iBAAiB,CAAC5C,IAAhC,EAAsC6C,aAAtC,CAA1B;AACA,UAAMnE,MAAM,GAAG,IAAI7I,aAAJ,CAAmB0E,cAAnB,EAAmCtD,CAAC,CAACiE,OAArC,EAA8C6F,iBAA9C,EAAiE,CAAjE,CAAf;AAEA,aAAO,CAAErC,MAAF,CAAP;AACA;;AAEDzH,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBoB,8BAApB,CAAoDvI,CAApD,CAAtB;AACA,GA1BqE,CA4BtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKF,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACoD,cAAnC,KAAuDmI,WAAW,CAACjI,gBAAZ,CAA8BxD,CAAC,CAAC6D,aAAhC,CAA5D,EAA8G;AAC7G,QAAMgI,cAAc,GAAG3L,CAAC,CAAC+D,OAAF,IAAcjE,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,GAAyBhI,CAAC,CAACoD,cAAF,CAAiB4E,MAAxD,CAAvB;AACAlI,IAAAA,CAAC,CAACiE,OAAF,IAAa4H,cAAb;;AAEA,QAAK7L,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACkD,cAAnC,KAAuDpD,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,GAAyBhI,CAAC,CAACkD,cAAF,CAAiB8E,MAAtG,EAA+G;AAC9GlI,MAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,IAAAA,CAAC,CAAC6D,aAAF,GAAkB3D,CAAC,CAACoD,cAAF,CAAiBjD,KAAjB,EAAlB;AACAL,IAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AAEA,WAAO,CAAE7D,CAAF,CAAP;AACA,GAzDqE,CA2DtE;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM8L,aAAa,GAAG9L,CAAC,CAAC6D,aAAF,CAAgBR,OAAhB,CAAyBnD,CAAC,CAACkD,cAA3B,CAAtB;;AAEA,MAAK0I,aAAa,KAAM3L,OAAO,CAACgF,UAAR,IAAsB,gBAAtB,IAA0ChF,OAAO,CAAC8E,UAAR,IAAsB,aAAtE,CAAlB,EAA0G;AACzGjF,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACAjE,IAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgBgE,yBAAhB,CAA2C3H,CAAC,CAACoD,cAA7C,EAA6DpD,CAAC,CAAC+D,OAA/D,CAAlB;AACAjE,IAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AAEA,WAAO,CAAE7D,CAAF,CAAP;AACA,GA1EqE,CA4EtE;AACA;AACA;;;AACA,MAAK,CAACE,CAAC,CAACoD,cAAF,CAAiBD,OAAjB,CAA0BnD,CAAC,CAACkD,cAA5B,CAAN,EAAqD;AACpD,QAAKpD,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACoD,cAAnC,KAAuDtD,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,IAA0BhI,CAAC,CAACoD,cAAF,CAAiB4E,MAAvG,EAAgH;AAC/GlI,MAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAED,QAAKjE,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAACkD,cAAnC,KAAuDpD,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,GAAyBhI,CAAC,CAACkD,cAAF,CAAiB8E,MAAtG,EAA+G;AAC9GlI,MAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;AACD,GAvFqE,CAyFtE;;;AACAjE,EAAAA,CAAC,CAAC6D,aAAF,CAAgByE,UAAhB,GAA6B,QAA7B;AACAtI,EAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgB4E,8BAAhB,CAAgDvI,CAAhD,CAAlB;AACAF,EAAAA,CAAC,CAAC6D,aAAF,CAAgByE,UAAhB,GAA6B,QAA7B;;AAEA,MAAKtI,CAAC,CAACqH,iBAAP,EAA2B;AAC1BrH,IAAAA,CAAC,CAACiI,iBAAF,GAAsBjI,CAAC,CAACiI,iBAAF,CAAoBQ,8BAApB,CAAoDvI,CAApD,CAAtB;AACA,GAFD,MAEO;AACNF,IAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AACA;;AAED,SAAO,CAAE7D,CAAF,CAAP;AACA,CArGgB,CAAjB;AAuGAV,iBAAiB,CAAEP,cAAF,EAAkBA,cAAlB,EAAkC,UAAEiB,CAAF,EAAKE,CAAL,EAAQC,OAAR,EAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAKH,CAAC,CAAC6D,aAAF,CAAgBR,OAAhB,CAAyBnD,CAAC,CAAC2D,aAA3B,CAAL,EAAkD;AACjD,QAAK,CAAC7D,CAAC,CAACqH,iBAAH,IAAwB,CAACnH,CAAC,CAACmH,iBAAhC,EAAoD;AACnD,aAAO,CAAE,IAAIrI,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;;AAED,QAAKgB,CAAC,CAACqH,iBAAF,IAAuBnH,CAAC,CAACmH,iBAAzB,IAA8CrH,CAAC,CAACqH,iBAAF,CAAoBhE,OAApB,CAA6BnD,CAAC,CAACmH,iBAA/B,CAAnD,EAAwG;AACvG,aAAO,CAAE,IAAIrI,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA,KAPgD,CASjD;AACA;;;AACA,QAAKmB,OAAO,CAAC8E,UAAR,IAAsB,aAA3B,EAA2C;AAC1C;AACAjF,MAAAA,CAAC,CAACiE,OAAF,GAAY,CAAZ,CAF0C,CAI1C;AACA;AACA;;AACAjE,MAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBkB,+BAApB,CAAqDrI,CAArD,CAAtB;AAEA,aAAO,CAAEF,CAAF,CAAP;AACA;AACD,GAvCsE,CAyCvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAKA,CAAC,CAACqH,iBAAF,IAAuBnH,CAAC,CAACmH,iBAAzB,IAA8CrH,CAAC,CAACqH,iBAAF,CAAoBhE,OAApB,CAA6BnD,CAAC,CAACmH,iBAA/B,CAAnD,EAAwG;AACvG,QAAM0E,YAAY,GAAG/L,CAAC,CAAC6D,aAAF,CAAgBkF,IAAhB,CAAqBE,QAArB,IAAiC,YAAtD;AACA,QAAM+C,YAAY,GAAG9L,CAAC,CAAC2D,aAAF,CAAgBkF,IAAhB,CAAqBE,QAArB,IAAiC,YAAtD,CAFuG,CAIvG;;AACA,QAAME,OAAO,GAAG4C,YAAY,IAAI,CAACC,YAAjC,CALuG,CAOvG;;AACA,QAAM5C,OAAO,GAAG4C,YAAY,IAAI,CAACD,YAAjC,CARuG,CAUvG;;AACA,QAAM1C,SAAS,GAAGD,OAAO,IAAM,CAACD,OAAD,IAAYhJ,OAAO,CAAC0E,SAAnD;;AAEA,QAAKwE,SAAL,EAAiB;AAChB,UAAM3C,MAAM,GAAG,EAAf,CADgB,CAGhB;AACA;;AACA,UAAKxG,CAAC,CAAC+D,OAAP,EAAiB;AAChByC,QAAAA,MAAM,CAACb,IAAP,CAAa,IAAIjH,aAAJ,CAAmBsB,CAAC,CAACkI,kBAArB,EAAyClI,CAAC,CAAC+D,OAA3C,EAAoD/D,CAAC,CAAC2D,aAAtD,EAAqE,CAArE,CAAb;AACA,OAPe,CAShB;AACA;;;AACA,UAAK7D,CAAC,CAACiE,OAAP,EAAiB;AAChByC,QAAAA,MAAM,CAACb,IAAP,CAAa,IAAIjH,aAAJ,CAAmBoB,CAAC,CAAC6D,aAArB,EAAoC7D,CAAC,CAACiE,OAAtC,EAA+CjE,CAAC,CAACoI,kBAAjD,EAAqE,CAArE,CAAb;AACA;;AAED,aAAO1B,MAAP;AACA,KAhBD,MAgBO;AACN,aAAO,CAAE,IAAI1H,WAAJ,CAAiB,CAAjB,CAAF,CAAP;AACA;AACD;;AAED,MAAKgB,CAAC,CAACqH,iBAAP,EAA2B;AAC1BrH,IAAAA,CAAC,CAACqH,iBAAF,GAAsBrH,CAAC,CAACqH,iBAAF,CAAoBkB,+BAApB,CAAqDrI,CAArD,CAAtB;AACA,GAzFsE,CA2FvE;AACA;AACA;AACA;AACA;;;AACA,MAAKF,CAAC,CAAC6D,aAAF,CAAgBR,OAAhB,CAAyBnD,CAAC,CAAC+H,iBAA3B,KAAkD9H,OAAO,CAAC8E,UAAR,IAAsB,aAA7E,EAA6F;AAC5FjF,IAAAA,CAAC,CAACiE,OAAF;AAEA,WAAO,CAAEjE,CAAF,CAAP;AACA,GApGsE,CAsGvE;AACA;AACA;AACA;;;AACA,MAAKE,CAAC,CAAC2D,aAAF,CAAgBR,OAAhB,CAAyBrD,CAAC,CAACiI,iBAA3B,KAAkD9H,OAAO,CAACgF,UAAR,IAAsB,aAA7E,EAA6F;AAC5F,QAAM8G,eAAe,GAAG/L,CAAC,CAAC+H,iBAAF,CAAoBzD,IAApB,CAAyB7D,KAAzB,EAAxB;AACAsL,IAAAA,eAAe,CAACpG,IAAhB,CAAsB,CAAtB;AAEA,QAAMqG,WAAW,GAAG,IAAIhN,QAAJ,CAAcgB,CAAC,CAAC+H,iBAAF,CAAoBc,IAAlC,EAAwCkD,eAAxC,CAApB;AACA,QAAMxE,MAAM,GAAG,IAAI7I,aAAJ,CAAmBoB,CAAC,CAACiI,iBAArB,EAAwC,CAAxC,EAA2CiE,WAA3C,EAAwD,CAAxD,CAAf;AAEA,WAAO,CAAElM,CAAF,EAAKyH,MAAL,CAAP;AACA,GAlHsE,CAoHvE;AACA;;;AACA,MAAKzH,CAAC,CAAC6D,aAAF,CAAgByC,eAAhB,CAAiCpG,CAAC,CAAC2D,aAAnC,KAAsD7D,CAAC,CAAC6D,aAAF,CAAgBqE,MAAhB,GAAyBhI,CAAC,CAAC2D,aAAF,CAAgBqE,MAApG,EAA6G;AAC5GlI,IAAAA,CAAC,CAACiE,OAAF,IAAa/D,CAAC,CAAC+D,OAAf;AACA;;AAEDjE,EAAAA,CAAC,CAAC6D,aAAF,GAAkB7D,CAAC,CAAC6D,aAAF,CAAgB0E,+BAAhB,CAAiDrI,CAAjD,CAAlB;AACAF,EAAAA,CAAC,CAACiI,iBAAF,GAAsBlJ,cAAc,CAACwM,oBAAf,CAAqCvL,CAAC,CAAC6D,aAAvC,CAAtB;AAEA,SAAO,CAAE7D,CAAF,CAAP;AACA,CA9HgB,CAAjB,C,CAgIA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAS+J,yBAAT,CAAoC/J,CAApC,EAAuCE,CAAvC,EAA2C;AAC1C,SAAOF,CAAC,CAACoD,cAAF,CAAiByE,yBAAjB,CAA4C3H,CAAC,CAACoD,cAA9C,EAA8DpD,CAAC,CAAC+D,OAAhE,MAA8E,IAArF;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiG,6BAAT,CAAwC9C,MAAxC,EAAgDhE,cAAhD,EAAiE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMJ,UAAU,GAAG,EAAnB,CAVgE,CAYhE;;AACA,OAAM,IAAInB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGuF,MAAM,CAACjG,MAA5B,EAAoCU,CAAC,EAArC,EAA0C;AACzC;AACA,QAAMkE,KAAK,GAAGqB,MAAM,CAAEvF,CAAF,CAApB;AACA,QAAMP,EAAE,GAAG,IAAI1C,aAAJ,CACVmH,KAAK,CAAC5B,KADI,EAEV4B,KAAK,CAAC1B,GAAN,CAAU6D,MAAV,GAAmBnC,KAAK,CAAC5B,KAAN,CAAY+D,MAFrB,EAGV9E,cAHU,EAIV,CAJU,CAAX;AAOAJ,IAAAA,UAAU,CAAC6C,IAAX,CAAiBvE,EAAjB,EAVyC,CAYzC;;AACA,SAAM,IAAI6K,CAAC,GAAGtK,CAAC,GAAG,CAAlB,EAAqBsK,CAAC,GAAG/E,MAAM,CAACjG,MAAhC,EAAwCgL,CAAC,EAAzC,EAA8C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA/E,MAAAA,MAAM,CAAE+E,CAAF,CAAN,GAAc/E,MAAM,CAAE+E,CAAF,CAAN,CAAYnE,qBAAZ,CAAmC1G,EAAE,CAACgC,cAAtC,EAAsDhC,EAAE,CAAC8B,cAAzD,EAAyE9B,EAAE,CAAC2C,OAA5E,EAAuF,CAAvF,CAAd;AACA;;AAEDb,IAAAA,cAAc,GAAGA,cAAc,CAAC4E,qBAAf,CAAsC1G,EAAE,CAACgC,cAAzC,EAAyDhC,EAAE,CAAC8B,cAA5D,EAA4E9B,EAAE,CAAC2C,OAA/E,CAAjB;AACA;;AAED,SAAOjB,UAAP;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\nconst transformations = new Map();\n\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation( OperationA, OperationB, transformationFunction ) {\n\tlet aGroup = transformations.get( OperationA );\n\n\tif ( !aGroup ) {\n\t\taGroup = new Map();\n\t\ttransformations.set( OperationA, aGroup );\n\t}\n\n\taGroup.set( OperationB, transformationFunction );\n}\n\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation( OperationA, OperationB ) {\n\tconst aGroup = transformations.get( OperationA );\n\n\tif ( aGroup && aGroup.has( OperationB ) ) {\n\t\treturn aGroup.get( OperationB );\n\t}\n\n\treturn noUpdateTransformation;\n}\n\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation( a ) {\n\treturn [ a ];\n}\n\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform( a, b, context = {} ) {\n\tconst transformationFunction = getTransformation( a.constructor, b.constructor );\n\n\ttry {\n\t\ta = a.clone();\n\n\t\treturn transformationFunction( a, b, context );\n\t} catch ( e ) {\n\t\t// @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n\t\t// @if CK_DEBUG // console.warn( 'Transformed operation', a );\n\t\t// @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n\t\t// @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n\t\t// @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n\t\t// @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n\n\t\tthrow e;\n\t}\n}\n\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets( operationsA, operationsB, options ) {\n\t// Create new arrays so the originally passed arguments are not changed.\n\t// No need to clone operations, they are cloned as they are transformed.\n\toperationsA = operationsA.slice();\n\toperationsB = operationsB.slice();\n\n\tconst contextFactory = new ContextFactory( options.document, options.useRelations, options.forceWeakRemove );\n\tcontextFactory.setOriginalOperations( operationsA );\n\tcontextFactory.setOriginalOperations( operationsB );\n\n\tconst originalOperations = contextFactory.originalOperations;\n\n\t// If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\tif ( operationsA.length == 0 || operationsB.length == 0 ) {\n\t\treturn { operationsA, operationsB, originalOperations };\n\t}\n\t//\n\t// Following is a description of transformation process:\n\t//\n\t// There are `operationsA` and `operationsB` to be transformed, both by both.\n\t//\n\t// So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n\t//\n\t// Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n\t// the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n\t// is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n\t//\n\t// However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n\t// we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n\t// All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n\t//\n\t// The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n\t//\n\t//          [the initial state]\n\t//         [common for a1 and b1]\n\t//\n\t//                   *\n\t//                  / \\\n\t//                 /   \\\n\t//               b1     a1\n\t//               /       \\\n\t//              /         \\\n\t//             *           *\n\t//            / \\         / \\\n\t//           /   \\       /   \\\n\t//         b2    a1'   b1'    a2\n\t//         /       \\   /       \\\n\t//        /         \\ /         \\\n\t//       *           *           *\n\t//        \\         / \\         /\n\t//         \\       /   \\       /\n\t//        a1''   b2'   a2'   b1''\n\t//           \\   /       \\   /\n\t//            \\ /         \\ /\n\t//             *           *\n\t//              \\         /\n\t//               \\       /\n\t//              a2''   b2''\n\t//                 \\   /\n\t//                  \\ /\n\t//                   *\n\t//\n\t//           [the final state]\n\t//\n\t// The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n\t// applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n\t// transformed.\n\t//\n\t// Another thing to consider is that an operation during transformation can be broken into multiple operations.\n\t// Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n\t//\n\t// In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n\t// (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n\t// by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n\t// from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n\t// by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n\t// following `operationsA` (in our case it is just `a2`).\n\t//\n\t// Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n\t// the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n\t// be transformed by both of them.\n\t//\n\t//                       *\n\t//                      / \\\n\t//                     /   \\\n\t//                    /     \\\n\t//                  b1       a1\n\t//                  /         \\\n\t//                 /           \\\n\t//                /             \\\n\t//               *               *\n\t//              / \\             / \\\n\t//             /  a11'         /   \\\n\t//            /     \\         /     \\\n\t//          b2       *      b1'      a2\n\t//          /       / \\     /         \\\n\t//         /       /  a12' /           \\\n\t//        /       /     \\ /             \\\n\t//       *       b2'     *               *\n\t//        \\     /       / \\             /\n\t//       a11'' /     b21'' \\           /\n\t//          \\ /       /     \\         /\n\t//           *       *      a2'     b1''\n\t//            \\     / \\       \\     /\n\t//          a12'' b22''\\       \\   /\n\t//              \\ /     \\       \\ /\n\t//               *      a2''     *\n\t//                \\       \\     /\n\t//                 \\       \\  b21'''\n\t//                  \\       \\ /\n\t//                a2'''      *\n\t//                    \\     /\n\t//                     \\  b22'''\n\t//                      \\ /\n\t//                       *\n\t//\n\t// Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n\t//\n\t// Having all that on mind, here is an outline for the transformation process algorithm:\n\t//\n\t// 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n\t//\n\t// 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n\t// All original `operationsA` are set to be transformed starting from the first operation `b`.\n\t//\n\t// 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n\t// by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n\t// with the transformation results.\n\t//\n\t// 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n\t// original operation.\n\t//\n\t// 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n\t// be transformed by.\n\t//\n\t// 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n\t// unless the last operation `a` was transformed.\n\t//\n\t// The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n\t// The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n\t// to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n\t// index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n\t// operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n\t// current `a` operation index to the next one.\n\t//\n\n\t// For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\tconst nextTransformIndex = new WeakMap();\n\n\t// For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\tfor ( const op of operationsA ) {\n\t\tnextTransformIndex.set( op, 0 );\n\t}\n\n\t// Additional data that is used for some postprocessing after the main transformation process is done.\n\tconst data = {\n\t\tnextBaseVersionA: operationsA[ operationsA.length - 1 ].baseVersion + 1,\n\t\tnextBaseVersionB: operationsB[ operationsB.length - 1 ].baseVersion + 1,\n\t\toriginalOperationsACount: operationsA.length,\n\t\toriginalOperationsBCount: operationsB.length\n\t};\n\n\t// Index of currently transformed operation `a`.\n\tlet i = 0;\n\n\t// While not all `operationsA` are transformed...\n\twhile ( i < operationsA.length ) {\n\t\t// Get \"current\" operation `a`.\n\t\tconst opA = operationsA[ i ];\n\n\t\t// For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\t\tconst indexB = nextTransformIndex.get( opA );\n\n\t\t// If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\t\tif ( indexB == operationsB.length ) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst opB = operationsB[ indexB ];\n\n\t\t// Transform `a` by `b` and `b` by `a`.\n\t\tconst newOpsA = transform( opA, opB, contextFactory.getContext( opA, opB, true ) );\n\t\tconst newOpsB = transform( opB, opA, contextFactory.getContext( opB, opA, false ) );\n\t\t// As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n\n\t\t// Update contextual information about operations.\n\t\tcontextFactory.updateRelation( opA, opB );\n\n\t\tcontextFactory.setOriginalOperations( newOpsA, opA );\n\t\tcontextFactory.setOriginalOperations( newOpsB, opB );\n\n\t\t// For new `a` operations, update their index of the next operation `b` to transform them by.\n\t\t//\n\t\t// This is needed even if there was only one result (`a` was not broken) because that information is used\n\t\t// at the beginning of this loop every time.\n\t\tfor ( const newOpA of newOpsA ) {\n\t\t\t// Acknowledge, that operation `b` also might be broken into multiple operations.\n\t\t\t//\n\t\t\t// This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n\t\t\t// spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n\t\t\t// be transformed by the same operation (part of it) again.\n\t\t\tnextTransformIndex.set( newOpA, indexB + newOpsB.length );\n\t\t}\n\n\t\t// Update `operationsA` and `operationsB` with the transformed versions.\n\t\toperationsA.splice( i, 1, ...newOpsA );\n\t\toperationsB.splice( indexB, 1, ...newOpsB );\n\t}\n\n\tif ( options.padWithNoOps ) {\n\t\t// If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n\t\tconst brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n\t\tconst brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n\n\t\t// Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n\t\t// that the base versions are equalled.\n\t\t//\n\t\t// Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\t\tpadWithNoOps( operationsA, brokenOperationsBCount - brokenOperationsACount );\n\t\tpadWithNoOps( operationsB, brokenOperationsACount - brokenOperationsBCount );\n\t}\n\n\t// Finally, update base versions of transformed operations.\n\tupdateBaseVersions( operationsA, data.nextBaseVersionB );\n\tupdateBaseVersions( operationsB, data.nextBaseVersionA );\n\n\treturn { operationsA, operationsB, originalOperations };\n}\n\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n\t// Creates `ContextFactory` instance.\n\t//\n\t// @param {module:engine/model/document~Document} document Document which the operations change.\n\t// @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n\t// better conflict resolution).\n\t// @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n\t// so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n\tconstructor( document, useRelations, forceWeakRemove = false ) {\n\t\t// For each operation that is created during transformation process, we keep a reference to the original operation\n\t\t// which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n\t\t// gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n\t\t// This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n\t\t// gathered data through original operation reference.\n\t\tthis.originalOperations = new Map();\n\n\t\t// `model.History` instance which information about undone operations will be taken from.\n\t\tthis._history = document.history;\n\n\t\t// Whether additional context should be used.\n\t\tthis._useRelations = useRelations;\n\n\t\tthis._forceWeakRemove = !!forceWeakRemove;\n\n\t\t// Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n\t\t// to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n\t\t// we keep relations between them.\n\t\tthis._relations = new Map();\n\t}\n\n\t// Sets \"original operation\" for given operations.\n\t//\n\t// During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n\t// or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n\t// so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n\t//\n\t// The original operation object will be used as such an universal linking id. Throughout the transformation process\n\t// all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n\t//\n\t// If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n\t// This should be used as an initialization step.\n\t//\n\t// If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n\t// for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n\t// `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n\t//\n\t// @param {Array.<module:engine/model/operation/operation~Operation>} operations\n\t// @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\tsetOriginalOperations( operations, takeFrom = null ) {\n\t\tconst originalOperation = takeFrom ? this.originalOperations.get( takeFrom ) : null;\n\n\t\tfor ( const operation of operations ) {\n\t\t\tthis.originalOperations.set( operation, originalOperation || operation );\n\t\t}\n\t}\n\n\t// Saves a relation between operations `opA` and `opB`.\n\t//\n\t// Relations are then later used to help solve conflicts when operations are transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\tupdateRelation( opA, opB ) {\n\t\t// The use of relations is described in a bigger detail in transformation functions.\n\t\t//\n\t\t// In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n\t\t// Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n\t\t// position is before the other operation source position. This kind of information gives contextual information when\n\t\t// transformation is used during undo. Similar checks are done for other pairs of operations.\n\t\t//\n\t\tswitch ( opA.constructor ) {\n\t\t\tcase MoveOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opB.movedRange.containsPosition( opA.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAtSource' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isEqual( opB.deletionPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBetween' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isAfter( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'moveTargetAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opA.targetPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase SplitOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isEqual( opB.sourcePosition ) || opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MergeOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( !opA.targetPosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeTargetNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSourceNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSameElement' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SplitOperation: {\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.splitPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitAtSource' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MarkerOperation: {\n\t\t\t\tconst markerRange = opA.newRange;\n\n\t\t\t\tif ( !markerRange ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tconst movedRange = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\tconst affectedLeft = movedRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\t\t\tmovedRange.start.isEqual( markerRange.start );\n\n\t\t\t\t\t\tconst affectedRight = movedRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\t\t\tmovedRange.end.isEqual( markerRange.end );\n\n\t\t\t\t\t\tif ( ( affectedLeft || affectedRight ) && !movedRange.containsRange( markerRange ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\tside: affectedLeft ? 'left' : 'right',\n\t\t\t\t\t\t\t\tpath: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tconst wasInLeftElement = markerRange.start.isEqual( opB.targetPosition );\n\t\t\t\t\t\tconst wasStartBeforeMergedElement = markerRange.start.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasEndBeforeMergedElement = markerRange.end.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasInRightElement = markerRange.end.isEqual( opB.sourcePosition );\n\n\t\t\t\t\t\tif ( wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\twasInLeftElement,\n\t\t\t\t\t\t\t\twasStartBeforeMergedElement,\n\t\t\t\t\t\t\t\twasEndBeforeMergedElement,\n\t\t\t\t\t\t\t\twasInRightElement\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {module:engine/model/operation/transform~TransformationContext}\n\tgetContext( opA, opB, aIsStrong ) {\n\t\treturn {\n\t\t\taIsStrong,\n\t\t\taWasUndone: this._wasUndone( opA ),\n\t\t\tbWasUndone: this._wasUndone( opB ),\n\t\t\tabRelation: this._useRelations ? this._getRelation( opA, opB ) : null,\n\t\t\tbaRelation: this._useRelations ? this._getRelation( opB, opA ) : null,\n\t\t\tforceWeakRemove: this._forceWeakRemove\n\t\t};\n\t}\n\n\t// Returns whether given operation `op` has already been undone.\n\t//\n\t// Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} op\n\t// @returns {Boolean}\n\t_wasUndone( op ) {\n\t\t// For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n\t\t// operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n\t\t// from which was undone. So get that original operation.\n\t\tconst originalOp = this.originalOperations.get( op );\n\n\t\t// And check with the document if the original operation was undone.\n\t\treturn originalOp.wasUndone || this._history.isUndoneOperation( originalOp );\n\t}\n\n\t// Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n\t// was set earlier or `null` if there was no relation between those operations.\n\t//\n\t// This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n\t//\n\t// When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n\t// undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n\t// we look forward in the future and ask if in that future `opB` was undone.\n\t//\n\t// Relations is a backward process to `wasUndone()`.\n\t//\n\t// Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n\t// operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n\t// a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n\t// between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n\t// a better decision when resolving a conflict between two operations, because we know more about the context of\n\t// those two operations.\n\t//\n\t// This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n\t// back to search for a meaningful contextual information.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {String|null}\n\t_getRelation( opA, opB ) {\n\t\t// Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n\t\tconst origB = this.originalOperations.get( opB );\n\t\tconst undoneB = this._history.getUndoneOperation( origB );\n\n\t\t// If `opB` is not undoing any operation, there is no relation.\n\t\tif ( !undoneB ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst relationsA = this._relations.get( origA );\n\n\t\t// Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\t\tif ( relationsA ) {\n\t\t\treturn relationsA.get( undoneB ) || null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Helper function for `ContextFactory#updateRelations`.\n\t//\n\t// @private\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @param {String} relation\n\t_setRelation( opA, opB, relation ) {\n\t\t// As always, setting is for original operations, not the clones/transformed operations.\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst origB = this.originalOperations.get( opB );\n\n\t\tlet relationsA = this._relations.get( origA );\n\n\t\tif ( !relationsA ) {\n\t\t\trelationsA = new Map();\n\t\t\tthis._relations.set( origA, relationsA );\n\t\t}\n\n\t\trelationsA.set( origB, relation );\n\t}\n}\n\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions( operations, baseVersion ) {\n\tfor ( const operation of operations ) {\n\t\toperation.baseVersion = baseVersion++;\n\t}\n}\n\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps( operations, howMany ) {\n\tfor ( let i = 0; i < howMany; i++ ) {\n\t\toperations.push( new NoOperation( 0 ) );\n\t}\n}\n\n// -----------------------\n\nsetTransformation( AttributeOperation, AttributeOperation, ( a, b, context ) => {\n\tif ( a.key === b.key ) {\n\t\t// If operations attributes are in conflict, check if their ranges intersect and manage them properly.\n\n\t\t// First, we want to apply change to the part of a range that has not been changed by the other operation.\n\t\tconst operations = a.range.getDifference( b.range ).map( range => {\n\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, 0 );\n\t\t} );\n\n\t\t// Then we take care of the common part of ranges.\n\t\tconst common = a.range.getIntersection( b.range );\n\n\t\tif ( common ) {\n\t\t\t// If this operation is more important, we also want to apply change to the part of the\n\t\t\t// original range that has already been changed by the other operation. Since that range\n\t\t\t// got changed we also have to update `oldValue`.\n\t\t\tif ( context.aIsStrong ) {\n\t\t\t\toperations.push( new AttributeOperation( common, b.key, b.newValue, a.newValue, 0 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( operations.length == 0 ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\treturn operations;\n\t} else {\n\t\t// If operations don't conflict, simply return an array containing just a clone of this operation.\n\t\treturn [ a ];\n\t}\n} );\n\nsetTransformation( AttributeOperation, InsertOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.position ) && a.range.containsPosition( b.position ) ) {\n\t\t// If new nodes should not receive attributes, two separated ranges will be returned.\n\t\t// Otherwise, one expanded range will be returned.\n\t\tconst range = a.range._getTransformedByInsertion( b.position, b.howMany, !b.shouldReceiveAttributes );\n\t\tconst result = range.map( r => {\n\t\t\treturn new AttributeOperation( r, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t} );\n\n\t\tif ( b.shouldReceiveAttributes ) {\n\t\t\t// `AttributeOperation#range` includes some newly inserted text.\n\t\t\t// The operation should also change the attribute of that text. An example:\n\t\t\t//\n\t\t\t// Bold should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar</p>\n\t\t\t//\n\t\t\t// In meantime, new text is typed:\n\t\t\t// <p>Fozxxbar</p>\n\t\t\t//\n\t\t\t// Bold should be applied also on the new text:\n\t\t\t// <p>Fo[zxxb]ar</p>\n\t\t\t// <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n\t\t\t//\n\t\t\t// There is a special case to consider here to consider.\n\t\t\t//\n\t\t\t// Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n\t\t\t// have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n\t\t\t//\n\t\t\t// Attribute `highlight=\"yellow\"` should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar<p>\n\t\t\t//\n\t\t\t// In meantime, character `x` with `highlight=\"red\"` is typed:\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n\t\t\t//\n\t\t\t// In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n\t\t\t// because that would lead to an exception (`oldValue` is incorrect for `x`).\n\t\t\t//\n\t\t\t// We also cannot break the original range as this would mess up a scenario when there are multiple following\n\t\t\t// insert operations, because then only the first inserted character is included in those ranges:\n\t\t\t// <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n\t\t\t//\n\t\t\t// So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n\t\t\t//\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n\t\t\t//\n\t\t\t// But before that operation would be applied, we will add an additional attribute operation that will change\n\t\t\t// attributes on the inserted nodes in a way which would make the original operation correct:\n\t\t\t//\n\t\t\t// <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n\t\t\t// <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n\t\t\t//\n\n\t\t\t// Generate complementary attribute operation. Be sure to add it before the original operation.\n\t\t\tconst op = _getComplementaryAttributeOperations( b, a.key, a.oldValue );\n\n\t\t\tif ( op ) {\n\t\t\t\tresult.unshift( op );\n\t\t\t}\n\t\t}\n\n\t\t// If nodes should not receive new attribute, we are done here.\n\t\treturn result;\n\t}\n\n\t// If insert operation is not expanding the attribute operation range, simply transform the range.\n\ta.range = a.range._getTransformedByInsertion( b.position, b.howMany, false )[ 0 ];\n\n\treturn [ a ];\n} );\n\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations( insertOperation, key, newValue ) {\n\tconst nodes = insertOperation.nodes;\n\n\t// At the beginning we store the attribute value from the first node.\n\tconst insertValue = nodes.getNode( 0 ).getAttribute( key );\n\n\tif ( insertValue == newValue ) {\n\t\treturn null;\n\t}\n\n\tconst range = new Range( insertOperation.position, insertOperation.position.getShiftedBy( insertOperation.howMany ) );\n\n\treturn new AttributeOperation( range, key, insertValue, newValue, 0 );\n}\n\nsetTransformation( AttributeOperation, MergeOperation, ( a, b ) => {\n\tconst ranges = [];\n\n\t// Case 1:\n\t//\n\t// Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n\t// An additional attribute operation that will change the (re)moved element needs to be generated.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.deletionPosition ) ) {\n\t\tif ( a.range.containsPosition( b.deletionPosition ) || a.range.start.isEqual( b.deletionPosition ) ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.graveyardPosition, 1 ) );\n\t\t}\n\t}\n\n\tconst range = a.range._getTransformedByMergeOperation( b );\n\n\t// Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\tif ( !range.isCollapsed ) {\n\t\tranges.push( range );\n\t}\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => {\n\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t} );\n} );\n\nsetTransformation( AttributeOperation, MoveOperation, ( a, b ) => {\n\tconst ranges = _breakRangeByMoveOperation( a.range, b );\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion ) );\n} );\n\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation( range, moveOp ) {\n\tconst moveRange = Range._createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany );\n\n\t// We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n\t// transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\tlet common = null;\n\tlet difference = [];\n\n\t// Let's compare the ranges.\n\tif ( moveRange.containsRange( range, true ) ) {\n\t\t// If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n\t\tcommon = range;\n\t} else if ( range.start.hasSameParentAs( moveRange.start ) ) {\n\t\t// If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n\t\t// that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n\t\tdifference = range.getDifference( moveRange );\n\t\tcommon = range.getIntersection( moveRange );\n\t} else {\n\t\t// In any other situation we assume that original range is different than move range, that is that move operation\n\t\t// moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n\t\t//\n\t\t// Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n\t\t// than `.getDifference` (we would get two ranges).\n\t\tdifference = [ range ];\n\t}\n\n\tconst result = [];\n\n\t// The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n\t// we do it by hand.\n\tfor ( let diff of difference ) {\n\t\t// First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n\t\t// as the range is different than the moved range.\n\t\tdiff = diff._getTransformedByDeletion( moveOp.sourcePosition, moveOp.howMany );\n\n\t\t// Transform also `targetPosition`.\n\t\tconst targetPosition = moveOp.getMovedRangeStart();\n\n\t\t// Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\t\tconst spread = diff.start.hasSameParentAs( targetPosition );\n\n\t\t// Transform by insertion of moved nodes.\n\t\tdiff = diff._getTransformedByInsertion( targetPosition, moveOp.howMany, spread );\n\n\t\tresult.push( ...diff );\n\t}\n\n\t// Common part can be simply transformed by the move operation. This is because move operation will not target to\n\t// that common part (the operation would have to target inside its own moved range).\n\tif ( common ) {\n\t\tresult.push(\n\t\t\tcommon._getTransformedByMove( moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false )[ 0 ]\n\t\t);\n\t}\n\n\treturn result;\n}\n\nsetTransformation( AttributeOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Split node is the last node in `AttributeOperation#range`.\n\t// `AttributeOperation#range` needs to be expanded to include the new (split) node.\n\t//\n\t// Attribute `type` to be changed to `numbered` but the `listItem` is split.\n\t// <listItem type=\"bulleted\">foobar</listItem>\n\t//\n\t// After split:\n\t// <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n\t//\n\t// After attribute change:\n\t// <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n\t//\n\tif ( a.range.end.isEqual( b.insertionPosition ) ) {\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.range.end.offset++;\n\t\t}\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n\t// not going to make a flat range.\n\t//\n\t// Content with range-to-change and split position:\n\t// <p>Fo[zb^a]r</p>\n\t//\n\t// After split:\n\t// <p>Fozb</p><p>ar</p>\n\t//\n\t// Make two separate ranges containing all nodes to change:\n\t// <p>Fo[zb]</p><p>[a]r</p>\n\t//\n\tif ( a.range.start.hasSameParentAs( b.splitPosition ) && a.range.containsPosition( b.splitPosition ) ) {\n\t\tconst secondPart = a.clone();\n\n\t\tsecondPart.range = new Range(\n\t\t\tb.moveTargetPosition.clone(),\n\t\t\ta.range.end._getCombined( b.splitPosition, b.moveTargetPosition )\n\t\t);\n\n\t\ta.range.end = b.splitPosition.clone();\n\t\ta.range.end.stickiness = 'toPrevious';\n\n\t\treturn [ a, secondPart ];\n\t}\n\n\t// The default case.\n\t//\n\ta.range = a.range._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, AttributeOperation, ( a, b ) => {\n\tconst result = [ a ];\n\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\t// This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n\t// although this case is a little less complicated. In this case we simply need to change attributes of the\n\t// inserted nodes and that's it.\n\t//\n\tif ( a.shouldReceiveAttributes && a.position.hasSameParentAs( b.range.start ) && b.range.containsPosition( a.position ) ) {\n\t\tconst op = _getComplementaryAttributeOperations( a, b.key, b.newValue );\n\n\t\tif ( op ) {\n\t\t\tresult.push( op );\n\t\t}\n\t}\n\n\t// The default case is: do nothing.\n\t// `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n\t//\n\treturn result;\n} );\n\nsetTransformation( InsertOperation, InsertOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n\t// what will be the order of inserted nodes. However, there is no additional information to help in that\n\t// decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n\t//\n\t// To achieve that, we will check if the operation is strong.\n\t// If it is, it won't get transformed. If it is not, it will be moved.\n\t//\n\tif ( a.position.isEqual( b.position ) && context.aIsStrong ) {\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MoveOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, SplitOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MergeOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MarkerOperation, InsertOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MarkerOperation, ( a, b, context ) => {\n\tif ( a.name == b.name ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldRange = b.newRange ? b.newRange.clone() : null;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MergeOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByMergeOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MoveOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = Range._createFromRanges( a.oldRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\n\t\t\tif ( context.abRelation.side == 'left' && b.targetPosition.isEqual( a.newRange.start ) ) {\n\t\t\t\ta.newRange.start.path = context.abRelation.path;\n\t\t\t\ta.newRange.end = aNewRange.end;\n\n\t\t\t\treturn [ a ];\n\t\t\t} else if ( context.abRelation.side == 'right' && b.targetPosition.isEqual( a.newRange.end ) ) {\n\t\t\t\ta.newRange.start = aNewRange.start;\n\t\t\t\ta.newRange.end.path = context.abRelation.path;\n\n\t\t\t\treturn [ a ];\n\t\t\t}\n\t\t}\n\n\t\ta.newRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, SplitOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedBySplitOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = a.newRange._getTransformedBySplitOperation( b );\n\n\t\t\tif ( a.newRange.start.isEqual( b.splitPosition ) && context.abRelation.wasStartBeforeMergedElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.insertionPosition );\n\t\t\t} else if ( a.newRange.start.isEqual( b.splitPosition ) && !context.abRelation.wasInLeftElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.moveTargetPosition );\n\t\t\t}\n\n\t\t\tif ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasInRightElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.moveTargetPosition );\n\t\t\t} else if ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasEndBeforeMergedElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.insertionPosition );\n\t\t\t} else {\n\t\t\t\ta.newRange.end = aNewRange.end;\n\t\t\t}\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\ta.newRange = a.newRange._getTransformedBySplitOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MergeOperation, InsertOperation, ( a, b ) => {\n\tif ( a.sourcePosition.hasSameParentAs( b.position ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByInsertOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Same merge operations.\n\t//\n\t// Both operations have same source and target positions. So the element already got merged and there is\n\t// theoretically nothing to do.\n\t//\n\tif ( a.sourcePosition.isEqual( b.sourcePosition ) && a.targetPosition.isEqual( b.targetPosition ) ) {\n\t\t// There are two ways that we can provide a do-nothing operation.\n\t\t//\n\t\t// First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n\t\t//\n\t\t// Second is a merge operation that has the source operation in the merged element - in the graveyard -\n\t\t// same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n\t\t// which is almost the same as NoOperation.\n\t\t//\n\t\t// This way the merge operation can be later transformed by split operation\n\t\t// to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n\t\t//\n\t\tif ( !context.bWasUndone ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\tconst path = b.graveyardPosition.path.slice();\n\t\t\tpath.push( 0 );\n\n\t\t\ta.sourcePosition = new Position( b.graveyardPosition.root, path );\n\t\t\ta.howMany = 0;\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same merge source position but different target position.\n\t//\n\t// This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n\t// and the other person removed that paragraph and merged the same paragraph to something before:\n\t//\n\t// Client A:\n\t// <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n\t// <p>Foo</p><p>BarXyz</p>\n\t//\n\t// Client B:\n\t// <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n\t// <p>Foo</p><p>[]Xyz</p>\n\t// <p>FooXyz</p>\n\t//\n\t// In this case we need to decide where finally \"Xyz\" will land:\n\t//\n\t// <p>FooXyz</p>               graveyard: <p>Bar</p>\n\t// <p>Foo</p>                  graveyard: <p>BarXyz</p>\n\t//\n\t// Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n\t// nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n\t// end up in the graveyard (see above).\n\t//\n\t// If neither or both operations point to graveyard, then let `aIsStrong` decide.\n\t//\n\tif (\n\t\ta.sourcePosition.isEqual( b.sourcePosition ) && !a.targetPosition.isEqual( b.targetPosition ) &&\n\t\t!context.bWasUndone && context.abRelation != 'splitAtSource'\n\t) {\n\t\tconst aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n\t\tconst bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aToGraveyard && !bToGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bToGraveyard && !aToGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst sourcePosition = b.targetPosition._getTransformedByMergeOperation( b );\n\t\t\tconst targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\treturn [ new MoveOperation( sourcePosition, a.howMany, targetPosition, 0 ) ];\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMergeOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t// Handle positions in graveyard.\n\t// If graveyard positions are same and `a` operation is strong - do not transform.\n\tif ( !a.graveyardPosition.isEqual( b.graveyardPosition ) || !context.aIsStrong ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MoveOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// The element to merge got removed.\n\t//\n\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t// from technical point of view. However, if the element was removed, the intention of the user deleting it\n\t// was to have it all deleted, together with its children. From user experience point of view, moving back the\n\t// removed nodes might be unexpected. This means that in this scenario we will block the merging.\n\t//\n\t// The exception of this rule would be if the remove operation was later undone.\n\t//\n\tconst removedRange = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\tif ( a.deletionPosition.hasSameParentAs( b.sourcePosition ) && removedRange.containsPosition( a.sourcePosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\tif ( a.sourcePosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMoveOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMoveOperation( b );\n\n\t// `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n\t// be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n\t// Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n\t// This means that we won't transform graveyard position if it is equal to move operation target position.\n\tif ( !a.graveyardPosition.isEqual( b.targetPosition ) ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, SplitOperation, ( a, b, context ) => {\n\tif ( b.graveyardPosition ) {\n\t\t// If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n\t\t// transform `a.graveyardPosition` accordingly.\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByDeletion( b.graveyardPosition, 1 );\n\n\t\t// This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n\t\t//\n\t\t// So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n\t\t// source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n\t\t// means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n\t\t//\n\t\t// If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n\t\t// `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n\t\t// properties.\n\t\t//\n\t\tif ( a.deletionPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\ta.howMany = b.howMany;\n\t\t}\n\t}\n\n\t// Case 1:\n\t//\n\t// Merge operation moves nodes to the place where split happens.\n\t// This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n\t// paragraph and there is a merge (delete) at the beginning of the second paragraph:\n\t//\n\t// <p>Foo{}</p><p>[]Bar</p>.\n\t//\n\t// Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n\t//\n\t// State after split:\n\t// <p>Foo</p><p></p><p>Bar</p>\n\t//\n\t// Now, `Bar` should be merged to the new paragraph:\n\t// <p>Foo</p><p>Bar</p>\n\t//\n\t// Instead of merging it to the original paragraph:\n\t// <p>FooBar</p><p></p>\n\t//\n\t// This means that `targetPosition` needs to be transformed. This is the default case though.\n\t// For example, if the split would be after `F`, `targetPosition` should also be transformed.\n\t//\n\t// There are three exceptions, though, when we want to keep `targetPosition` as it was.\n\t//\n\t// First exception is when the merge target position is inside an element (not at the end, as usual). This\n\t// happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n\t// targets inside the element we want to keep the original target position (and not transform it) because\n\t// we have additional context telling us that we want to merge to the original element. We can check if the\n\t// merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n\t// is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n\t//\n\t// Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n\t// if target position would be transformed, the merge operation would target at the source position:\n\t//\n\t// root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n\t//\n\t// SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n\t// MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n\t//\n\t// Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n\t// We would like to merge from the empty <p> to the \"Foo\" <p>:\n\t//\n\t// root: <p>Foo</p><p></p>\t\t\tgraveyard:\n\t//\n\t// MergeOperation#sourcePosition = root [ 1, 0 ]\n\t//\n\t// If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n\t//\n\t// Third exception is connected with relations. If this happens during undo and we have explicit information\n\t// that target position has not been affected by the operation which is undone by this split then this split should\n\t// not move the target position either.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) ) {\n\t\tconst mergeInside = b.howMany != 0;\n\t\tconst mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual( b.graveyardPosition );\n\n\t\tif ( mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved' ) {\n\t\t\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n\t// The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n\t// split element) or should be move to the beginning of the new element.\n\t//\n\tif ( a.sourcePosition.isEqual( b.splitPosition ) ) {\n\t\t// Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n\t\t// This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n\t\t// In that case `a` operation source position should stay where it is.\n\t\tif ( context.abRelation == 'mergeSourceNotMoved' ) {\n\t\t\ta.howMany = 0;\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\t// This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n\t\t// See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n\t\t// the special case is not applied.\n\t\t//\n\t\t// Now, the merge operation is transformed by the split which has undone that previous merge operation.\n\t\t// So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n\t\t//\n\t\tif ( context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0 ) {\n\t\t\ta.sourcePosition = b.moveTargetPosition.clone();\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.splitPosition ) ) {\n\t\ta.howMany = b.splitPosition.offset;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MoveOperation, InsertOperation, ( a, b ) => {\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByInsertOperation( b, false )[ 0 ];\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\n\t// See `InsertOperation` x `MoveOperation` transformation for details on this case.\n\t//\n\t// In summary, both operations point to the same place, so the order of nodes needs to be decided.\n\t// `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n\t// between operations.\n\t//\n\tif ( !a.targetPosition.isEqual( b.position ) ) {\n\t\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MoveOperation, MoveOperation, ( a, b, context ) => {\n\t//\n\t// Setting and evaluating some variables that will be used in special cases and default algorithm.\n\t//\n\t// Create ranges from `MoveOperations` properties.\n\tconst rangeA = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst rangeB = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t// Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n\t// this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\tlet aIsStrong = context.aIsStrong;\n\n\t// This will be used to decide the order of nodes if both operations target at the same position.\n\t// By default, use strong/weak operation mechanism.\n\tlet insertBefore = !context.aIsStrong;\n\n\t// If the relation is set, then use it to decide nodes order.\n\tif ( context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter' ) {\n\t\tinsertBefore = true;\n\t} else if ( context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore' ) {\n\t\tinsertBefore = false;\n\t}\n\n\t// `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\tlet newTargetPosition;\n\n\tif ( a.targetPosition.isEqual( b.targetPosition ) && insertBefore ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByDeletion(\n\t\t\tb.sourcePosition,\n\t\t\tb.howMany\n\t\t);\n\t} else {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByMove(\n\t\t\tb.sourcePosition,\n\t\t\tb.targetPosition,\n\t\t\tb.howMany\n\t\t);\n\t}\n\n\t//\n\t// Special case #1 + mirror.\n\t//\n\t// Special case when both move operations' target positions are inside nodes that are\n\t// being moved by the other move operation. So in other words, we move ranges into inside of each other.\n\t// This case can't be solved reasonably (on the other hand, it should not happen often).\n\tif ( _moveTargetIntoMovedRange( a, b ) && _moveTargetIntoMovedRange( b, a ) ) {\n\t\t// Instead of transforming operation, we return a reverse of the operation that we transform by.\n\t\t// So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n\t\treturn [ b.getReversed() ];\n\t}\n\t//\n\t// End of special case #1.\n\t//\n\n\t//\n\t// Special case #2.\n\t//\n\t// Check if `b` operation targets inside `rangeA`.\n\tconst bTargetsToA = rangeA.containsPosition( b.targetPosition );\n\n\t// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n\t// You might say that operation `b` is captured inside operation `a`.\n\tif ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {\n\t\t// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n\t\t// we need to transform `a` operation anyway.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\n\t//\n\t// Special case #2 mirror.\n\t//\n\tconst aTargetsToB = rangeB.containsPosition( a.targetPosition );\n\n\tif ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {\n\t\t// `a` operation is \"moved together\" with `b` operation.\n\t\t// Here, just move `rangeA` \"inside\" `rangeB`.\n\t\trangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\trangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #2.\n\t//\n\n\t//\n\t// Special case #3 + mirror.\n\t//\n\t// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n\t// but not on the same tree level. In such case ranges have common part but we have to treat it\n\t// differently, because in such case those ranges are not really conflicting and should be treated like\n\t// two separate ranges. Also we have to discard two difference parts.\n\tconst aCompB = compareArrays( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );\n\n\tif ( aCompB == 'prefix' || aCompB == 'extension' ) {\n\t\t// Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n\t\t// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n\t\t// like a one difference part.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #3.\n\t//\n\n\t//\n\t// Default case - ranges are on the same level or are not connected with each other.\n\t//\n\t// Modifier for default case.\n\t// Modifies `aIsStrong` flag in certain conditions.\n\t//\n\t// If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n\t// to provide more expected results.\n\tif ( a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = true;\n\t} else if ( a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = false;\n\t}\n\n\t// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n\t// This will aggregate transformed ranges.\n\tconst ranges = [];\n\n\t// Get the \"difference part\" of `a` operation source range.\n\t// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\tconst difference = rangeA.getDifference( rangeB );\n\n\tfor ( const range of difference ) {\n\t\t// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n\t\trange.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\trange.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\t\tconst shouldSpread = compareArrays( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';\n\t\tconst newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread );\n\n\t\tranges.push( ...newRanges );\n\t}\n\n\t// Then, we have to manage the \"common part\" of both move ranges.\n\tconst common = rangeA.getIntersection( rangeB );\n\n\tif ( common !== null && aIsStrong ) {\n\t\t// Calculate the new position of that part of original range.\n\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t// Take care of proper range order.\n\t\t//\n\t\t// Put `common` at appropriate place. Keep in mind that we are interested in original order.\n\t\t// Basically there are only three cases: there is zero, one or two difference ranges.\n\t\t//\n\t\t// If there is zero difference ranges, just push `common` in the array.\n\t\tif ( ranges.length === 0 ) {\n\t\t\tranges.push( common );\n\t\t}\n\t\t// If there is one difference range, we need to check whether common part was before it or after it.\n\t\telse if ( ranges.length == 1 ) {\n\t\t\tif ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {\n\t\t\t\tranges.unshift( common );\n\t\t\t} else {\n\t\t\t\tranges.push( common );\n\t\t\t}\n\t\t}\n\t\t// If there are more ranges (which means two), put common part between them. This is the only scenario\n\t\t// where there could be two difference ranges so we don't have to make any comparisons.\n\t\telse {\n\t\t\tranges.splice( 1, 0, common );\n\t\t}\n\t}\n\n\tif ( ranges.length === 0 ) {\n\t\t// If there are no \"source ranges\", nothing should be changed.\n\t\t// Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, SplitOperation, ( a, b, context ) => {\n\tlet newTargetPosition = a.targetPosition.clone();\n\n\t// Do not transform if target position is same as split insertion position and this split comes from undo.\n\t// This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n\t// We need to make a decision how we will resolve such conflict and this is less harmful way.\n\tif ( !a.targetPosition.isEqual( b.insertionPosition ) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter' ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 1:\n\t//\n\t// Last element in the moved range got split.\n\t//\n\t// In this case the default range transformation will not work correctly as the element created by\n\t// split operation would be outside the range. The range to move needs to be fixed manually.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( moveRange.end.isEqual( b.insertionPosition ) ) {\n\t\t// Do it only if this is a \"natural\" split, not a one that comes from undo.\n\t\t// If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.howMany++;\n\t\t}\n\n\t\ta.targetPosition = newTargetPosition;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split happened between the moved nodes. In this case two ranges to move need to be generated.\n\t//\n\t// Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n\t// <p>F[oz|ba]r</p><p>Xyz</p>\n\t//\n\t// After split:\n\t// <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n\t//\n\t// Correct ranges:\n\t// <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n\t//\n\t// After move:\n\t// <p>F</p><p>r</p><p>Xyzozba</p>\n\t//\n\tif ( moveRange.start.hasSameParentAs( b.splitPosition ) && moveRange.containsPosition( b.splitPosition ) ) {\n\t\tlet rightRange = new Range( b.splitPosition, moveRange.end );\n\t\trightRange = rightRange._getTransformedBySplitOperation( b );\n\n\t\tconst ranges = [\n\t\t\tnew Range( moveRange.start, b.splitPosition ),\n\t\t\trightRange\n\t\t];\n\n\t\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n\t}\n\n\t// Case 3:\n\t//\n\t// Move operation targets at the split position. We need to decide if the nodes should be inserted\n\t// at the end of the split element or at the beginning of the new element.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) && context.abRelation == 'insertAtSource' ) {\n\t\tnewTargetPosition = b.moveTargetPosition;\n\t}\n\n\t// Case 4:\n\t//\n\t// Move operation targets just after the split element. We need to decide if the nodes should be inserted\n\t// between two parts of split element, or after the new element.\n\t//\n\t// Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n\t// <p>Foo|bar</p>^<p>baz</p>\n\t// <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n\t//\n\t// If there is no contextual information between operations (for example, they come from collaborative\n\t// editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n\t// However, if the split is from undo, in the past, the moved content might be targeting between the\n\t// split parts, meaning that was exactly user's intention:\n\t//\n\t// <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n\t// <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n\t// <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n\t//\n\t// In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n\t// so we need to transform accordingly. We can detect this scenario thanks to relations.\n\t//\n\tif ( a.targetPosition.isEqual( b.insertionPosition ) && context.abRelation == 'insertBetween' ) {\n\t\tnewTargetPosition = a.targetPosition;\n\t}\n\n\t// The default case.\n\t//\n\tconst transformed = moveRange._getTransformedBySplitOperation( b );\n\tconst ranges = [ transformed ];\n\n\t// Case 5:\n\t//\n\t// Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n\t//\n\tif ( b.graveyardPosition ) {\n\t\tconst movesGraveyardElement = moveRange.start.isEqual( b.graveyardPosition ) || moveRange.containsPosition( b.graveyardPosition );\n\n\t\tif ( a.howMany > 1 && movesGraveyardElement && !context.aWasUndone ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.insertionPosition, 1 ) );\n\t\t}\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, MergeOperation, ( a, b, context ) => {\n\tconst movedRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( b.deletionPosition.hasSameParentAs( a.sourcePosition ) && movedRange.containsPosition( b.sourcePosition ) ) {\n\t\tif ( a.type == 'remove' && !context.forceWeakRemove ) {\n\t\t\t// Case 1:\n\t\t\t//\n\t\t\t// The element to remove got merged.\n\t\t\t//\n\t\t\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t\t\t// from technical point of view. However, if the element was removed, the intention of the user\n\t\t\t// deleting it was to have it all deleted. From user experience point of view, moving back the\n\t\t\t// removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n\t\t\t//\n\t\t\tif ( !context.aWasUndone ) {\n\t\t\t\tconst results = [];\n\n\t\t\t\tlet gyMoveSource = b.graveyardPosition.clone();\n\t\t\t\tlet splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\tif ( a.howMany > 1 ) {\n\t\t\t\t\tresults.push( new MoveOperation( a.sourcePosition, a.howMany - 1, a.targetPosition, 0 ) );\n\n\t\t\t\t\tgyMoveSource = gyMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t}\n\n\t\t\t\tconst gyMoveTarget = b.deletionPosition._getCombined( a.sourcePosition, a.targetPosition );\n\t\t\t\tconst gyMove = new MoveOperation( gyMoveSource, 1, gyMoveTarget, 0 );\n\n\t\t\t\tconst splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n\t\t\t\tsplitNodesMoveTargetPath.push( 0 );\n\n\t\t\t\tconst splitNodesMoveTarget = new Position( gyMove.targetPosition.root, splitNodesMoveTargetPath );\n\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( gyMoveSource, gyMoveTarget, 1 );\n\t\t\t\tconst splitNodesMove = new MoveOperation( splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0 );\n\n\t\t\t\tresults.push( gyMove );\n\t\t\t\tresults.push( splitNodesMove );\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t} else {\n\t\t\t// Case 2:\n\t\t\t//\n\t\t\t// The element to move got merged and it was the only element to move.\n\t\t\t// In this case just don't do anything, leave the node in the graveyard. Without special case\n\t\t\t// it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n\t\t\t//\n\t\t\tif ( a.howMany == 1 ) {\n\t\t\t\tif ( !context.bWasUndone ) {\n\t\t\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t\t\t} else {\n\t\t\t\t\ta.sourcePosition = b.graveyardPosition.clone();\n\t\t\t\t\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\t\treturn [ a ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByMergeOperation( b );\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RenameOperation, InsertOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MergeOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Element to rename got merged, so it was moved to `b.graveyardPosition`.\n\t//\n\tif ( a.position.isEqual( b.deletionPosition ) ) {\n\t\ta.position = b.graveyardPosition.clone();\n\t\ta.position.stickiness = 'toNext';\n\n\t\treturn [ a ];\n\t}\n\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MoveOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, RenameOperation, ( a, b, context ) => {\n\tif ( a.position.isEqual( b.position ) ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldName = b.newName;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The element to rename has been split. In this case, the new element should be also renamed.\n\t//\n\t// User decides to change the paragraph to a list item:\n\t// <paragraph>Foobar</paragraph>\n\t//\n\t// However, in meantime, split happens:\n\t// <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n\t//\n\t// As a result, rename both elements:\n\t// <listItem>Foo</listItem><listItem>bar</listItem>\n\t//\n\tconst renamePath = a.position.path;\n\tconst splitPath = b.splitPosition.getParentPath();\n\n\tif ( compareArrays( renamePath, splitPath ) == 'same' && !b.graveyardPosition ) {\n\t\tconst extraRename = new RenameOperation( a.position.getShiftedBy( 1 ), a.oldName, a.newName, 0 );\n\n\t\treturn [ a, extraRename ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RootAttributeOperation, RootAttributeOperation, ( a, b, context ) => {\n\tif ( a.root === b.root && a.key === b.key ) {\n\t\tif ( !context.aIsStrong || a.newValue === b.newValue ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\ta.oldValue = b.newValue;\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( SplitOperation, InsertOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.position ) && a.splitPosition.offset < b.position.offset ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByInsertOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split element got merged. If two different elements were merged, clients will have different content.\n\t//\n\t// Example. Merge at `{}`, split at `[]`:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// On merge side it will look like this:\n\t// <heading>FooB[]ar</heading>\n\t// <heading>FooB</heading><heading>ar</heading>\n\t//\n\t// On split side it will look like this:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t// <heading>FooB</heading><paragraph>ar</paragraph>\n\t//\n\t// Clearly, the second element is different for both clients.\n\t//\n\t// We could use the removed merge element from graveyard as a split element but then clients would have a different\n\t// model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n\t//\n\t// To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n\t// in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n\t// used for splitting. Example below.\n\t//\n\t// Original state:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// Merge side client:\n\t//\n\t// After merge:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n\t//\n\t// Extra split:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n\t//\n\t// Use the \"cloned\" element from graveyard:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// Split side client:\n\t//\n\t// After split:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t//\n\t// After merge:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// This special case scenario only applies if the original split operation clones the split element.\n\t// If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n\t// knows exactly which element it should use. So there would be no original problem with different contents.\n\t//\n\t// Additionally, the special case applies only if the merge wasn't already undone.\n\t//\n\tif ( !a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\tconst splitPath = b.graveyardPosition.path.slice();\n\t\tsplitPath.push( 0 );\n\n\t\tconst splitPosition = new Position( b.graveyardPosition.root, splitPath );\n\t\tconst insertionPosition = SplitOperation.getInsertionPosition( new Position( b.graveyardPosition.root, splitPath ) );\n\n\t\tconst additionalSplit = new SplitOperation( splitPosition, 0, null, 0 );\n\t\tadditionalSplit.insertionPosition = insertionPosition;\n\n\t\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t\ta.graveyardPosition = additionalSplit.insertionPosition.clone();\n\t\ta.graveyardPosition.stickiness = 'toNext';\n\n\t\treturn [ additionalSplit, a ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.deletionPosition ) && !a.splitPosition.isAfter( b.deletionPosition ) ) {\n\t\ta.howMany--;\n\t}\n\n\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MoveOperation, ( a, b, context ) => {\n\tconst rangeToMove = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( a.graveyardPosition ) {\n\t\t// Case 1:\n\t\t//\n\t\t// Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n\t\t// is already moved to the correct position, we need to only move the nodes after the split position.\n\t\t// This will be done by `MoveOperation` instead of `SplitOperation`.\n\t\t//\n\t\tconst gyElementMoved = rangeToMove.start.isEqual( a.graveyardPosition ) || rangeToMove.containsPosition( a.graveyardPosition );\n\n\t\tif ( !context.bWasUndone && gyElementMoved ) {\n\t\t\tconst sourcePosition = a.splitPosition._getTransformedByMoveOperation( b );\n\n\t\t\tconst newParentPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t\t\tconst newTargetPath = newParentPosition.path.slice();\n\t\t\tnewTargetPath.push( 0 );\n\n\t\t\tconst newTargetPosition = new Position( newParentPosition.root, newTargetPath );\n\t\t\tconst moveOp = new MoveOperation( sourcePosition, a.howMany, newTargetPosition, 0 );\n\n\t\t\treturn [ moveOp ];\n\t\t}\n\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\t// Case 2:\n\t//\n\t// If the split position is inside the moved range, we need to shift the split position to a proper place.\n\t// The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n\t//\n\t// Characters `bc` should be moved to the second paragraph while split position is between them:\n\t// <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n\t//\n\t// After move, new split position is incorrect:\n\t// <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n\t//\n\t// Correct split position:\n\t// <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\t// After split:\n\t// <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && rangeToMove.containsPosition( a.splitPosition ) ) {\n\t\tconst howManyRemoved = b.howMany - ( a.splitPosition.offset - b.sourcePosition.offset );\n\t\ta.howMany -= howManyRemoved;\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\n\t\ta.splitPosition = b.sourcePosition.clone();\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 3:\n\t//\n\t// Split is at a position where nodes were moved.\n\t//\n\t// This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n\t// \"split operation point of view\".\n\t//\n\tconst splitAtTarget = a.splitPosition.isEqual( b.targetPosition );\n\n\tif ( splitAtTarget && ( context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore' ) ) {\n\t\ta.howMany += b.howMany;\n\t\ta.splitPosition = a.splitPosition._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t// Don't change `howMany` if move operation does not really move anything.\n\t//\n\tif ( !b.sourcePosition.isEqual( b.targetPosition ) ) {\n\t\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && a.splitPosition.offset <= b.sourcePosition.offset ) {\n\t\t\ta.howMany -= b.howMany;\n\t\t}\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\t}\n\n\t// Change position stickiness to force a correct transformation.\n\ta.splitPosition.stickiness = 'toNone';\n\ta.splitPosition = a.splitPosition._getTransformedByMoveOperation( b );\n\ta.splitPosition.stickiness = 'toNext';\n\n\tif ( a.graveyardPosition ) {\n\t\ta.insertionPosition = a.insertionPosition._getTransformedByMoveOperation( b );\n\t} else {\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, SplitOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split at the same position.\n\t//\n\t// If there already was a split at the same position as in `a` operation, it means that the intention\n\t// conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n\t//\n\t// However, there is a difference if these are new splits or splits created by undo. These have different\n\t// intentions. Also splits moving back different elements from graveyard have different intentions. They\n\t// are just different operations.\n\t//\n\t// So we cancel split operation only if it was really identical.\n\t//\n\t// Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n\t// default transformation is incorrect too.\n\t//\n\tif ( a.splitPosition.isEqual( b.splitPosition ) ) {\n\t\tif ( !a.graveyardPosition && !b.graveyardPosition ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\t// Use context to know that the `a.splitPosition` should stay where it is.\n\t\t// This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\t\tif ( context.abRelation == 'splitBefore' ) {\n\t\t\t// Since split is at the same position, there are no nodes left to split.\n\t\t\ta.howMany = 0;\n\n\t\t\t// Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n\t\t\t// That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n\t\t\t// It could happen if `context` is enabled in collaboration.\n\t\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same node is using to split different elements. This happens in undo when previously same element was merged to\n\t// two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n\t//\n\t// In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n\t// split operations. This might not always be true but in the real cases that were experienced it was. After all,\n\t// if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n\t// should be same for both of those splits.\n\t//\n\t// Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n\t//\n\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\tconst aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n\t\tconst bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aInGraveyard && !bInGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bInGraveyard && !aInGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst result = [];\n\n\t\t\t// First we need to move any nodes split by `b` back to where they were.\n\t\t\t// Do it only if `b` actually moved something.\n\t\t\tif ( b.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( b.moveTargetPosition, b.howMany, b.splitPosition, 0 ) );\n\t\t\t}\n\n\t\t\t// Then we need to move nodes from `a` split position to their new element.\n\t\t\t// Do it only if `a` actually should move something.\n\t\t\tif ( a.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( a.splitPosition, a.howMany, a.moveTargetPosition, 0 ) );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 3:\n\t//\n\t// Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n\t// As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n\t//\n\tif ( a.splitPosition.isEqual( b.insertionPosition ) && context.abRelation == 'splitBefore' ) {\n\t\ta.howMany++;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 4:\n\t//\n\t// This is a mirror to the case 2. above.\n\t//\n\tif ( b.splitPosition.isEqual( a.insertionPosition ) && context.baRelation == 'splitBefore' ) {\n\t\tconst newPositionPath = b.insertionPosition.path.slice();\n\t\tnewPositionPath.push( 0 );\n\n\t\tconst newPosition = new Position( b.insertionPosition.root, newPositionPath );\n\t\tconst moveOp = new MoveOperation( a.insertionPosition, 1, newPosition, 0 );\n\n\t\treturn [ a, moveOp ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.splitPosition ) && a.splitPosition.offset < b.splitPosition.offset ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedBySplitOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange( a, b ) {\n\treturn a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;\n}\n\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges( ranges, targetPosition ) {\n\t// At this moment we have some ranges and a target position, to which those ranges should be moved.\n\t// Order in `ranges` array is the go-to order of after transformation.\n\t//\n\t// We are almost done. We have `ranges` and `targetPosition` to make operations from.\n\t// Unfortunately, those operations may affect each other. Precisely, first operation after move\n\t// may affect source range and target position of second and third operation. Same with second\n\t// operation affecting third.\n\t//\n\t// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n\tconst operations = [];\n\n\t// Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t// Create new operation out of a range and target position.\n\t\tconst range = ranges[ i ];\n\t\tconst op = new MoveOperation(\n\t\t\trange.start,\n\t\t\trange.end.offset - range.start.offset,\n\t\t\ttargetPosition,\n\t\t\t0\n\t\t);\n\n\t\toperations.push( op );\n\n\t\t// Transform other ranges by the generated operation.\n\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t// All ranges in `ranges` array should be:\n\t\t\t//\n\t\t\t// * non-intersecting (these are part of original operation source range), and\n\t\t\t// * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n\t\t\t//\n\t\t\t// This means that the transformation will be \"clean\" and always return one result.\n\t\t\tranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];\n\t\t}\n\n\t\ttargetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany );\n\t}\n\n\treturn operations;\n}\n"]}]}