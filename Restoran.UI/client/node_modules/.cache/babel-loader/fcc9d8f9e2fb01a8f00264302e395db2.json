{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\model.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\model.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2giOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNlYXJjaCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IiOwppbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIkM6XFxVc2Vyc1xccGNcXERlc2t0b3BcXFJlc3RvcmFuXFxSZXN0b3JhblxcUmVzdG9yYW4uVUlcXGNsaWVudFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MiOwoKLyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDIwLCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9tb2RlbAogKi8KaW1wb3J0IEJhdGNoIGZyb20gJy4vYmF0Y2gnOwppbXBvcnQgV3JpdGVyIGZyb20gJy4vd3JpdGVyJzsKaW1wb3J0IFNjaGVtYSBmcm9tICcuL3NjaGVtYSc7CmltcG9ydCBEb2N1bWVudCBmcm9tICcuL2RvY3VtZW50JzsKaW1wb3J0IE1hcmtlckNvbGxlY3Rpb24gZnJvbSAnLi9tYXJrZXJjb2xsZWN0aW9uJzsKaW1wb3J0IE9ic2VydmFibGVNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9vYnNlcnZhYmxlbWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCBNb2RlbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBNb2RlbFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgTW9kZWxTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgT3BlcmF0aW9uRmFjdG9yeSBmcm9tICcuL29wZXJhdGlvbi9vcGVyYXRpb25mYWN0b3J5JzsKaW1wb3J0IF9pbnNlcnRDb250ZW50IGZyb20gJy4vdXRpbHMvaW5zZXJ0Y29udGVudCc7CmltcG9ydCBfZGVsZXRlQ29udGVudCBmcm9tICcuL3V0aWxzL2RlbGV0ZWNvbnRlbnQnOwppbXBvcnQgX21vZGlmeVNlbGVjdGlvbiBmcm9tICcuL3V0aWxzL21vZGlmeXNlbGVjdGlvbic7CmltcG9ydCBfZ2V0U2VsZWN0ZWRDb250ZW50IGZyb20gJy4vdXRpbHMvZ2V0c2VsZWN0ZWRjb250ZW50JzsKaW1wb3J0IHsgaW5qZWN0U2VsZWN0aW9uUG9zdEZpeGVyIH0gZnJvbSAnLi91dGlscy9zZWxlY3Rpb24tcG9zdC1maXhlcic7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOyAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGNvbnN0IHsgZHVtcFRyZWVzIH0gPSByZXF1aXJlKCAnLi4vZGV2LXV0aWxzL3V0aWxzJyApOwovLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGNvbnN0IHsgT3BlcmF0aW9uUmVwbGF5ZXIgfSA9IHJlcXVpcmUoICcuLi9kZXYtdXRpbHMvb3BlcmF0aW9ucmVwbGF5ZXInICkuZGVmYXVsdDsKCi8qKgogKiBFZGl0b3IncyBkYXRhIG1vZGVsLiBSZWFkIGFib3V0IHRoZSBtb2RlbCBpbiB0aGUKICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSBlbmdpbmUgYXJjaGl0ZWN0dXJlIGd1aWRlfS4KICoKICogQG1peGVzIG1vZHVsZTp1dGlscy9vYnNlcnZhYmxlbWl4aW5+T2JzZXJ2YWJsZU1peGluCiAqLwoKdmFyIE1vZGVsID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gTW9kZWwoKSB7CiAgICB2YXIgX3RoaXMgPSB0aGlzOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RlbCk7CgogICAgLyoqCiAgICAgKiBNb2RlbCdzIG1hcmtlciBjb2xsZWN0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tYXJrZXJjb2xsZWN0aW9ufk1hcmtlckNvbGxlY3Rpb259CiAgICAgKi8KICAgIHRoaXMubWFya2VycyA9IG5ldyBNYXJrZXJDb2xsZWN0aW9uKCk7CiAgICAvKioKICAgICAqIE1vZGVsJ3MgZG9jdW1lbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fQogICAgICovCgogICAgdGhpcy5kb2N1bWVudCA9IG5ldyBEb2N1bWVudCh0aGlzKTsKICAgIC8qKgogICAgICogTW9kZWwncyBzY2hlbWEuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWF9CiAgICAgKi8KCiAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoKTsKICAgIC8qKgogICAgICogQWxsIGNhbGxiYWNrcyBhZGRlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2V9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlfSBtZXRob2RzIHdhaXRpbmcgdG8gYmUgZXhlY3V0ZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtBcnJheS48RnVuY3Rpb24+fQogICAgICovCgogICAgdGhpcy5fcGVuZGluZ0NoYW5nZXMgPSBbXTsKICAgIC8qKgogICAgICogVGhlIGxhc3QgY3JlYXRlZCBhbmQgY3VycmVudGx5IHVzZWQgd3JpdGVyIGluc3RhbmNlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9CiAgICAgKi8KCiAgICB0aGlzLl9jdXJyZW50V3JpdGVyID0gbnVsbDsKICAgIFsnaW5zZXJ0Q29udGVudCcsICdkZWxldGVDb250ZW50JywgJ21vZGlmeVNlbGVjdGlvbicsICdnZXRTZWxlY3RlZENvbnRlbnQnLCAnYXBwbHlPcGVyYXRpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7CiAgICAgIHJldHVybiBfdGhpcy5kZWNvcmF0ZShtZXRob2ROYW1lKTsKICAgIH0pOyAvLyBBZGRpbmcgb3BlcmF0aW9uIHZhbGlkYXRpb24gd2l0aCBgaGlnaGVzdGAgcHJpb3JpdHksIHNvIGl0IGlzIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZlYXR1cmUgd291bGQgbGlrZQogICAgLy8gdG8gZG8gYW55dGhpbmcgd2l0aCB0aGUgb3BlcmF0aW9uLiBJZiB0aGUgb3BlcmF0aW9uIGhhcyBpbmNvcnJlY3QgcGFyYW1ldGVycyBpdCBzaG91bGQgdGhyb3cgb24gdGhlIGVhcmxpZXN0IG9jY2FzaW9uLgoKICAgIHRoaXMub24oJ2FwcGx5T3BlcmF0aW9uJywgZnVuY3Rpb24gKGV2dCwgYXJncykgewogICAgICB2YXIgb3BlcmF0aW9uID0gYXJnc1swXTsKCiAgICAgIG9wZXJhdGlvbi5fdmFsaWRhdGUoKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdoaWdoZXN0JwogICAgfSk7IC8vIFJlZ2lzdGVyIHNvbWUgZGVmYXVsdCBhYnN0cmFjdCBlbnRpdGllcy4KCiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJHJvb3QnLCB7CiAgICAgIGlzTGltaXQ6IHRydWUKICAgIH0pOwogICAgdGhpcy5zY2hlbWEucmVnaXN0ZXIoJyRibG9jaycsIHsKICAgICAgYWxsb3dJbjogJyRyb290JywKICAgICAgaXNCbG9jazogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJHRleHQnLCB7CiAgICAgIGFsbG93SW46ICckYmxvY2snLAogICAgICBpc0lubGluZTogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJGNsaXBib2FyZEhvbGRlcicsIHsKICAgICAgYWxsb3dDb250ZW50T2Y6ICckcm9vdCcsCiAgICAgIGlzTGltaXQ6IHRydWUKICAgIH0pOwogICAgdGhpcy5zY2hlbWEuZXh0ZW5kKCckdGV4dCcsIHsKICAgICAgYWxsb3dJbjogJyRjbGlwYm9hcmRIb2xkZXInCiAgICB9KTsgLy8gQW4gZWxlbWVudCBuZWVkZWQgYnkgdGhlIGB1cGNhc3RFbGVtZW50VG9NYXJrZXJgIGNvbnZlcnRlci4KICAgIC8vIFRoaXMgZWxlbWVudCB0ZW1wb3JhcmlseSByZXByZXNlbnRzIGEgbWFya2VyIGJvdW5kYXJ5IGR1cmluZyB0aGUgY29udmVyc2lvbiBwcm9jZXNzIGFuZCBpcyByZW1vdmVkCiAgICAvLyBhdCB0aGUgZW5kIG9mIHRoZSBjb252ZXJzaW9uLiBgVXBjYXN0RGlzcGF0Y2hlcmAgb3IgYXQgbGVhc3QgYENvbnZlcnNpb25gIGNsYXNzIGxvb2tzIGxpa2UgYQogICAgLy8gYmV0dGVyIHBsYWNlIGZvciB0aGlzIHJlZ2lzdHJhdGlvbiBidXQgYm90aCBrbm93IG5vdGhpbmcgYWJvdXQgYFNjaGVtYWAuCgogICAgdGhpcy5zY2hlbWEucmVnaXN0ZXIoJyRtYXJrZXInKTsKICAgIHRoaXMuc2NoZW1hLmFkZENoaWxkQ2hlY2soZnVuY3Rpb24gKGNvbnRleHQsIGNoaWxkRGVmaW5pdGlvbikgewogICAgICBpZiAoY2hpbGREZWZpbml0aW9uLm5hbWUgPT09ICckbWFya2VyJykgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9KTsKICAgIGluamVjdFNlbGVjdGlvblBvc3RGaXhlcih0aGlzKTsgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB0aGlzLm9uKCAnYXBwbHlPcGVyYXRpb24nLCAoKSA9PiB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlkdW1wVHJlZXMoIHRoaXMuZG9jdW1lbnQsIHRoaXMuZG9jdW1lbnQudmVyc2lvbiApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9LCB7IHByaW9yaXR5OiAnbG93ZXN0JyB9ICk7CiAgfQogIC8qKgogICAqIFRoZSBgY2hhbmdlKClgIG1ldGhvZCBpcyB0aGUgcHJpbWFyeSB3YXkgb2YgY2hhbmdpbmcgdGhlIG1vZGVsLiBZb3Ugc2hvdWxkIHVzZSBpdCB0byBtb2RpZnkgYWxsIGRvY3VtZW50IG5vZGVzCiAgICogKGluY2x1ZGluZyBkZXRhY2hlZCBub2RlcyDigJMgaS5lLiBub2RlcyBub3QgYWRkZWQgdG8gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2RvY3VtZW50IG1vZGVsIGRvY3VtZW50fSksCiAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3NlbGVjdGlvbiBkb2N1bWVudCdzIHNlbGVjdGlvbn0sIGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI21hcmtlcnMgbW9kZWwgbWFya2Vyc30uCiAgICoKICAgKgkJbW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAgICoJCX0gKTsKICAgKgogICAqIEFsbCBjaGFuZ2VzIGluc2lkZSB0aGUgY2hhbmdlIGJsb2NrIHVzZSB0aGUgc2FtZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gc28gdGhleSBhcmUgY29tYmluZWQKICAgKiBpbnRvIGEgc2luZ2xlIHVuZG8gc3RlcC4KICAgKgogICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgJ2VuZCcgKTsgLy8gZm9vLgogICAqCiAgICoJCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQkJd3JpdGVyLmluc2VydFRleHQoICdiYXInLCBwYXJhZ3JhcGgsICdlbmQnICk7IC8vIGZvb2Jhci4KICAgKgkJCX0gKTsKICAgKgogICAqIAkJCXdyaXRlci5pbnNlcnRUZXh0KCAnYm9tJywgcGFyYWdyYXBoLCAnZW5kJyApOyAvLyBmb29iYXJib20uCiAgICoJCX0gKTsKICAgKgogICAqIFRoZSBjYWxsYmFjayBvZiB0aGUgYGNoYW5nZSgpYCBibG9jayBpcyBleGVjdXRlZCBzeW5jaHJvbm91c2x5LgogICAqCiAgICogWW91IGNhbiBhbHNvIHJldHVybiBhIHZhbHVlIGZyb20gdGhlIGNoYW5nZSBibG9jay4KICAgKgogICAqCQljb25zdCBpbWcgPSBtb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQlyZXR1cm4gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdpbWcnICk7CiAgICoJCX0gKTsKICAgKgogICAqIEBzZWUgI2VucXVldWVDaGFuZ2UKICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB3aGljaCBtYXkgbW9kaWZ5IHRoZSBtb2RlbC4KICAgKiBAcmV0dXJucyB7Kn0gVmFsdWUgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLgogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKE1vZGVsLCBbewogICAga2V5OiAiY2hhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2UoY2FsbGJhY2spIHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgYmxvY2ssIGNyZWF0ZSBhIG5ldyBiYXRjaCBhbmQgc3RhcnQgYF9ydW5QZW5kaW5nQ2hhbmdlc2AgZXhlY3V0aW9uIGZsb3cuCiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2hhbmdlcy5wdXNoKHsKICAgICAgICAgICAgYmF0Y2g6IG5ldyBCYXRjaCgpLAogICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sKICAgICAgICAgIH0pOwoKICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5QZW5kaW5nQ2hhbmdlcygpWzBdOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgb3V0ZXJtb3N0IGJsb2NrLCBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLgogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2N1cnJlbnRXcml0ZXIpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgLy8gQGlmIENLX0RFQlVHIC8vIHRocm93IGVycjsKCiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KICAgICAgICBDS0VkaXRvckVycm9yLnJldGhyb3dVbmV4cGVjdGVkRXJyb3IoZXJyLCB0aGlzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBUaGUgYGVucXVldWVDaGFuZ2UoKWAgbWV0aG9kIHBlcmZvcm1zIHNpbWlsYXIgdGFzayBhcyB0aGUge0BsaW5rICNjaGFuZ2UgYGNoYW5nZSgpYCBtZXRob2R9LCB3aXRoIHR3byBtYWpvciBkaWZmZXJlbmNlcy4KICAgICAqCiAgICAgKiBGaXJzdCwgdGhlIGNhbGxiYWNrIG9mIGBlbnF1ZXVlQ2hhbmdlKClgIGlzIGV4ZWN1dGVkIHdoZW4gYWxsIG90aGVyIGVucXVldWVkIGNoYW5nZXMgYXJlIGRvbmUuIEl0IG1pZ2h0IGJlIGV4ZWN1dGVkCiAgICAgKiBpbW1lZGlhdGVseSBpZiBpdCBpcyBub3QgbmVzdGVkIGluIGFueSBvdGhlciBjaGFuZ2UgYmxvY2ssIGJ1dCBpZiBpdCBpcyBuZXN0ZWQgaW4gYW5vdGhlciAoZW5xdWV1ZSljaGFuZ2UgYmxvY2ssCiAgICAgKiBpdCB3aWxsIGJlIGRlbGF5ZWQgYW5kIGV4ZWN1dGVkIGFmdGVyIHRoZSBvdXRlcm1vc3QgYmxvY2suCiAgICAgKgogICAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc29sZS5sb2coIDEgKTsKICAgICAqCiAgICAgKgkJCW1vZGVsLmVucXVldWVDaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCQljb25zb2xlLmxvZyggMiApOwogICAgICoJCQl9ICk7CiAgICAgKgogICAgICogCQkJY29uc29sZS5sb2coIDMgKTsKICAgICAqCQl9ICk7IC8vIFdpbGwgbG9nOiAxLCAzLCAyLgogICAgICoKICAgICAqIFNlY29uZCwgaXQgbGV0cyB5b3UgZGVmaW5lIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gaW50byB3aGljaCB5b3Ugd2FudCB0byBhZGQgeW91ciBjaGFuZ2VzLgogICAgICogQnkgZGVmYXVsdCwgYSBuZXcgYmF0Y2ggaXMgY3JlYXRlZC4gSW4gdGhlIHNhbXBsZSBhYm92ZSwgYGNoYW5nZWAgYW5kIGBlbnF1ZXVlQ2hhbmdlYCBibG9ja3MgdXNlIGEgZGlmZmVyZW50CiAgICAgKiBiYXRjaCAoYW5kIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSBzaW5jZSBlYWNoIG9mIHRoZW0gb3BlcmF0ZXMgb24gdGhlIHNlcGFyYXRlIGJhdGNoKS4KICAgICAqCiAgICAgKiBXaGVuIHVzaW5nIHRoZSBgZW5xdWV1ZUNoYW5nZSgpYCBibG9jayB5b3UgY2FuIGFsc28gYWRkIHNvbWUgY2hhbmdlcyB0byB0aGUgYmF0Y2ggeW91IHVzZWQgYmVmb3JlLgogICAgICoKICAgICAqCQltb2RlbC5lbnF1ZXVlQ2hhbmdlKCBiYXRjaCwgd3JpdGVyID0+IHsKICAgICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIFRoZSBiYXRjaCBpbnN0YW5jZSBjYW4gYmUgb2J0YWluZWQgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2JhdGNoIHRoZSB3cml0ZXJ9LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaHwndHJhbnNwYXJlbnQnfCdkZWZhdWx0J30gYmF0Y2hPclR5cGUgQmF0Y2ggb3IgYmF0Y2ggdHlwZSBzaG91bGQgYmUgdXNlZCBpbiB0aGUgY2FsbGJhY2suCiAgICAgKiBJZiBub3QgZGVmaW5lZCwgYSBuZXcgYmF0Y2ggd2lsbCBiZSBjcmVhdGVkLgogICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggbWF5IG1vZGlmeSB0aGUgbW9kZWwuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZW5xdWV1ZUNoYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZW5xdWV1ZUNoYW5nZShiYXRjaE9yVHlwZSwgY2FsbGJhY2spIHsKICAgICAgdHJ5IHsKICAgICAgICBpZiAodHlwZW9mIGJhdGNoT3JUeXBlID09PSAnc3RyaW5nJykgewogICAgICAgICAgYmF0Y2hPclR5cGUgPSBuZXcgQmF0Y2goYmF0Y2hPclR5cGUpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJhdGNoT3JUeXBlID09ICdmdW5jdGlvbicpIHsKICAgICAgICAgIGNhbGxiYWNrID0gYmF0Y2hPclR5cGU7CiAgICAgICAgICBiYXRjaE9yVHlwZSA9IG5ldyBCYXRjaCgpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5fcGVuZGluZ0NoYW5nZXMucHVzaCh7CiAgICAgICAgICBiYXRjaDogYmF0Y2hPclR5cGUsCiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sKICAgICAgICB9KTsKCiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDaGFuZ2VzLmxlbmd0aCA9PSAxKSB7CiAgICAgICAgICB0aGlzLl9ydW5QZW5kaW5nQ2hhbmdlcygpOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgLy8gQGlmIENLX0RFQlVHIC8vIHRocm93IGVycjsKCiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KICAgICAgICBDS0VkaXRvckVycm9yLnJldGhyb3dVbmV4cGVjdGVkRXJyb3IoZXJyLCB0aGlzKTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiB7QGxpbmsgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4jZGVjb3JhdGUgRGVjb3JhdGVkfSBmdW5jdGlvbiBmb3IgYXBwbHlpbmcKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbnN9IHRvIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIHdheSBvZiBjaGFuZ2luZyB0aGUgbW9kZWwuIEl0IGlzIGV4cG9zZWQgZm9yIHZlcnkgc3BlY2lmaWMgdXNlIGNhc2VzIChsaWtlIHRoZSB1bmRvIGZlYXR1cmUpLgogICAgICogTm9ybWFsbHksIHRvIG1vZGlmeSB0aGUgbW9kZWwsIHlvdSB3aWxsIHdhbnQgdG8gdXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIgYFdyaXRlcmB9LgogICAgICogU2VlIGFsc28ge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSNjaGFuZ2luZy10aGUtbW9kZWwgQ2hhbmdpbmcgdGhlIG1vZGVsfSBzZWN0aW9uCiAgICAgKiBvZiB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSBFZGl0aW5nIGFyY2hpdGVjdHVyZX0gZ3VpZGUuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJhcHBseU9wZXJhdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY29uc29sZS5sb2coICdBcHBseWluZyAnICsgb3BlcmF0aW9uICk7CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gaWYgKCAhdGhpcy5fb3BlcmF0aW9uTG9ncyApIHsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwl0aGlzLl9vcGVyYXRpb25Mb2dzID0gW107CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQogICAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRoaXMuX29wZXJhdGlvbkxvZ3MucHVzaCggSlNPTi5zdHJpbmdpZnkoIG9wZXJhdGlvbiApICk7CiAgICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy9pZiAoICF0aGlzLl9hcHBsaWVkT3BlcmF0aW9ucyApIHsKICAgICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwl0aGlzLl9hcHBsaWVkT3BlcmF0aW9ucyA9IFtdOwogICAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vfQogICAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vdGhpcy5fYXBwbGllZE9wZXJhdGlvbnMucHVzaCggb3BlcmF0aW9uICk7CiAgICAgIG9wZXJhdGlvbi5fZXhlY3V0ZSgpOwogICAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGdldEFwcGxpZWRPcGVyYXRpb24oKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCWlmICggIXRoaXMuX2FwcGxpZWRPcGVyYXRpb25zICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwkJcmV0dXJuICcnOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwl9CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCXJldHVybiB0aGlzLl9hcHBsaWVkT3BlcmF0aW9ucy5tYXAoIEpTT04uc3RyaW5naWZ5ICkuam9pbiggJy0tLS0tLS0nICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gY3JlYXRlUmVwbGF5ZXIoIHN0cmluZ2lmaWVkT3BlcmF0aW9ucyApIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JcmV0dXJuIG5ldyBPcGVyYXRpb25SZXBsYXllciggdGhpcywgJy0tLS0tLS0nLCBzdHJpbmdpZmllZE9wZXJhdGlvbnMgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKICAgIC8qKgogICAgICogSW5zZXJ0cyBjb250ZW50IGF0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yIHNwZWNpZmllZCBieSB0aGUgc2VsZWN0aW9uLCBhcyBvbmUgd291bGQgZXhwZWN0IHRoZSBwYXN0ZQogICAgICogZnVuY3Rpb25hbGl0eSB0byB3b3JrLgogICAgICoKICAgICAqIFRoaXMgaXMgYSBoaWdoLWxldmVsIG1ldGhvZC4gSXQgdGFrZXMgdGhlIHtAbGluayAjc2NoZW1hIHNjaGVtYX0gaW50byBjb25zaWRlcmF0aW9uIHdoZW4gaW5zZXJ0aW5nCiAgICAgKiB0aGUgY29udGVudCwgY2xlYXJzIHRoZSBnaXZlbiBzZWxlY3Rpb24ncyBjb250ZW50IGJlZm9yZSBpbnNlcnRpbmcgbm9kZXMgYW5kIG1vdmVzIHRoZSBzZWxlY3Rpb24KICAgICAqIHRvIGl0cyB0YXJnZXQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcHJvY2Vzcy4KICAgICAqIEl0IGNhbiBzcGxpdCBlbGVtZW50cywgbWVyZ2UgdGhlbSwgd3JhcCBiYXJlIHRleHQgbm9kZXMgd2l0aCBwYXJhZ3JhcGhzLCBldGMuICZtZGFzaDsganVzdCBsaWtlIHRoZQogICAgICogcGFzdGluZyBmZWF0dXJlIHNob3VsZCBkby4KICAgICAqCiAgICAgKiBGb3IgbG93ZXItbGV2ZWwgbWV0aG9kcyBzZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBgV3JpdGVyYH0uCiAgICAgKgogICAgICogVGhpcyBtZXRob2QsIHVubGlrZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIGBXcml0ZXJgfSdzIG1ldGhvZHMsIGRvZXMgbm90IGhhdmUgdG8gYmUgdXNlZAogICAgICogaW5zaWRlIGEge0BsaW5rICNjaGFuZ2UgYGNoYW5nZSgpYCBibG9ja30uCiAgICAgKgogICAgICogIyBDb252ZXJzaW9uIGFuZCBzY2hlbWEKICAgICAqCiAgICAgKiBJbnNlcnRpbmcgZWxlbWVudHMgYW5kIHRleHQgbm9kZXMgaW50byB0aGUgbW9kZWwgaXMgbm90IGVub3VnaCB0byBtYWtlIENLRWRpdG9yIDUgcmVuZGVyIHRoYXQgY29udGVudAogICAgICogdG8gdGhlIHVzZXIuIENLRWRpdG9yIDUgaW1wbGVtZW50cyBhIG1vZGVsLXZpZXctY29udHJvbGxlciBhcmNoaXRlY3R1cmUgYW5kIHdoYXQgYG1vZGVsLmluc2VydENvbnRlbnQoKWAgZG9lcwogICAgICogaXMgb25seSBhZGRpbmcgbm9kZXMgdG8gdGhlIG1vZGVsLiBBZGRpdGlvbmFsbHksIHlvdSBuZWVkIHRvIGRlZmluZQogICAgICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSNjb252ZXJzaW9uIGNvbnZlcnRlcnN9IGJldHdlZW4gdGhlIG1vZGVsIGFuZCB2aWV3CiAgICAgKiBhbmQgZGVmaW5lIHRob3NlIG5vZGVzIGluIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI3NjaGVtYSBzY2hlbWF9LgogICAgICoKICAgICAqIFNvLCB3aGlsZSB0aGlzIG1ldGhvZCBtYXkgc2VlbSBzaW1pbGFyIHRvIENLRWRpdG9yIDQgYGVkaXRvci5pbnNlcnRIdG1sKClgIChpbiBmYWN0LCBib3RoIG1ldGhvZHMKICAgICAqIGFyZSB1c2VkIGZvciBwYXN0ZS1saWtlIGNvbnRlbnQgaW5zZXJ0aW9uKSwgdGhlIENLRWRpdG9yIDUgbWV0aG9kIGNhbm5vdCBiZSB1c2UgdG8gaW5zZXJ0IGFyYml0cmFyeSBIVE1MCiAgICAgKiB1bmxlc3MgY29udmVydGVycyBhcmUgZGVmaW5lZCBmb3IgYWxsIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGluIHRoYXQgSFRNTC4KICAgICAqCiAgICAgKiAjIEV4YW1wbGVzCiAgICAgKgogICAgICogVXNpbmcgYGluc2VydENvbnRlbnQoKWAgd2l0aCBhIG1hbnVhbGx5IGNyZWF0ZWQgbW9kZWwgc3RydWN0dXJlOgogICAgICoKICAgICAqCQkvLyBMZXQncyBjcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHN1Y2ggY29udGVudCBhczoKICAgICAqCQkvLwogICAgICoJCS8vIDxwYXJhZ3JhcGg+Zm9vPC9wYXJhZ3JhcGg+CiAgICAgKgkJLy8gPGJsb2NrUXVvdGU+CiAgICAgKgkJLy8gICAgPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4KICAgICAqCQkvLyA8L2Jsb2NrUXVvdGU+CiAgICAgKgkJY29uc3QgZG9jRnJhZyA9IGVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWNvbnN0IHAxID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJCWNvbnN0IHAyID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJCWNvbnN0IGJsb2NrUXVvdGUgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ2Jsb2NrUXVvdGUnICk7CiAgICAgKgkJCWNvbnN0IGRvY0ZyYWcgPSB3cml0ZXIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOwogICAgICoKICAgICAqCQkJd3JpdGVyLmFwcGVuZCggcDEsIGRvY0ZyYWcgKTsKICAgICAqCQkJd3JpdGVyLmFwcGVuZCggYmxvY2tRdW90ZSwgZG9jRnJhZyApOwogICAgICoJCQl3cml0ZXIuYXBwZW5kKCBwMiwgYmxvY2tRdW90ZSApOwogICAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHAxICk7CiAgICAgKgkJCXdyaXRlci5pbnNlcnRUZXh0KCAnYmFyJywgcDIgKTsKICAgICAqCiAgICAgKgkJCXJldHVybiBkb2NGcmFnOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKgkJLy8gaW5zZXJ0Q29udGVudCgpIGRvZXMgbm90IGhhdmUgdG8gYmUgdXNlZCBpbiBhIGNoYW5nZSgpIGJsb2NrLiBJdCBjYW4sIHRob3VnaCwKICAgICAqCQkvLyBzbyB0aGlzIGNvZGUgY291bGQgYmUgbW92ZWQgdG8gdGhlIGNhbGxiYWNrIGRlZmluZWQgYWJvdmUuCiAgICAgKgkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIGRvY0ZyYWcgKTsKICAgICAqCiAgICAgKiBVc2luZyBgaW5zZXJ0Q29udGVudCgpYCB3aXRoIGFuIEhUTUwgc3RyaW5nIGNvbnZlcnRlZCB0byBhIG1vZGVsIGRvY3VtZW50IGZyYWdtZW50IChzaW1pbGFyIHRvIHRoZSBwYXN0aW5nIG1lY2hhbmlzbSk6CiAgICAgKgogICAgICoJCS8vIFlvdSBjYW4gY3JlYXRlIHlvdXIgb3duIEh0bWxEYXRhUHJvY2Vzc29yIGluc3RhbmNlIG9yIHVzZSBlZGl0b3IuZGF0YS5wcm9jZXNzb3IKICAgICAqCQkvLyBpZiB5b3UgaGF2ZSBub3Qgb3ZlcnJpZGRlbiB0aGUgZGVmYXVsdCBvbmUgKHdoaWNoIGlzIHRoZSBIdG1sRGF0YVByb2Nlc3NvciBpbnN0YW5jZSkuCiAgICAgKgkJY29uc3QgaHRtbERQID0gbmV3IEh0bWxEYXRhUHJvY2Vzc29yKCB2aWV3RG9jdW1lbnQgKTsKICAgICAqCiAgICAgKgkJLy8gQ29udmVydCBhbiBIVE1MIHN0cmluZyB0byBhIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQ6CiAgICAgKgkJY29uc3Qgdmlld0ZyYWdtZW50ID0gaHRtbERQLnRvVmlldyggaHRtbFN0cmluZyApOwogICAgICoKICAgICAqCQkvLyBDb252ZXJ0IHRoZSB2aWV3IGRvY3VtZW50IGZyYWdtZW50IHRvIGEgbW9kZWwgZG9jdW1lbnQgZnJhZ21lbnQKICAgICAqCQkvLyBpbiB0aGUgY29udGV4dCBvZiAkcm9vdC4gVGhpcyBjb252ZXJzaW9uIHRha2VzIHRoZSBzY2hlbWEgaW50bwogICAgICoJCS8vIGFjY291bnQgc28gaWYsIGZvciBleGFtcGxlLCB0aGUgdmlldyBkb2N1bWVudCBmcmFnbWVudCBjb250YWluZWQgYSBiYXJlIHRleHQgbm9kZSwKICAgICAqCQkvLyB0aGlzIHRleHQgbm9kZSBjYW5ub3QgYmUgYSBjaGlsZCBvZiAkcm9vdCwgc28gaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5CiAgICAgKgkJLy8gd3JhcHBlZCB3aXRoIGEgPHBhcmFncmFwaD4uIFlvdSBjYW4gZGVmaW5lIHRoZSBjb250ZXh0IHlvdXJzZWxmIChpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciksCiAgICAgKgkJLy8gYW5kIGUuZy4gY29udmVydCB0aGUgY29udGVudCBsaWtlIGl0IHdvdWxkIGhhcHBlbiBpbiBhIDxwYXJhZ3JhcGg+LgogICAgICoJCS8vIE5vdGU6IFRoZSBjbGlwYm9hcmQgZmVhdHVyZSB1c2VzIGEgY3VzdG9tIGNvbnRleHQgY2FsbGVkICRjbGlwYm9hcmRIb2xkZXIKICAgICAqCQkvLyB3aGljaCBoYXMgYSBsb29zZW5lZCBzY2hlbWEuCiAgICAgKgkJY29uc3QgbW9kZWxGcmFnbWVudCA9IGVkaXRvci5kYXRhLnRvTW9kZWwoIHZpZXdGcmFnbWVudCApOwogICAgICoKICAgICAqCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggbW9kZWxGcmFnbWVudCApOwogICAgICoKICAgICAqIEJ5IGRlZmF1bHQgdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIGRvY3VtZW50IHNlbGVjdGlvbiBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB3aXRoIGEgcG9zaXRpb24sIHJhbmdlIG9yIHNlbGVjdGlvbiBpbnN0YW5jZS4KICAgICAqCiAgICAgKgkJLy8gSW5zZXJ0IHRleHQgYXQgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2VsZWN0aW9uIHBvc2l0aW9uLgogICAgICoJCWVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWVkaXRvci5tb2RlbC5pbnNlcnRDb250ZW50KCB3cml0ZXIuY3JlYXRlVGV4dCggJ3gnICkgKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICoJCS8vIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gcG9zaXRpb24gLSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIHdpbGwgbm90IGJlIG1vZGlmaWVkLgogICAgICoJCWVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWVkaXRvci5tb2RlbC5pbnNlcnRDb250ZW50KCB3cml0ZXIuY3JlYXRlVGV4dCggJ3gnICksIGRvYy5nZXRSb290KCksIDIgKTsKICAgICAqCiAgICAgKgkJCS8vIFdoaWNoIGlzIGEgc2hvcnRoYW5kIGZvcjoKICAgICAqCQkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIHdyaXRlci5jcmVhdGVUZXh0KCAneCcgKSwgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoIGRvYy5nZXRSb290KCksIDIgKSApOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiBJZiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufSBpcyBwYXNzZWQgYXMgYHNlbGVjdGFibGVgCiAgICAgKiBpdCB3aWxsIGJlIG1vdmVkIHRvIHRoZSB0YXJnZXQgcG9zaXRpb24gKHdoZXJlIHRoZSBkb2N1bWVudCBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBpbnNlcnRpb24pLgogICAgICoKICAgICAqCQllZGl0b3IubW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAgICoJCQkvLyBJbnNlcnQgdGV4dCByZXBsYWNpbmcgdGhlIGdpdmVuIHNlbGVjdGlvbiBpbnN0YW5jZS4KICAgICAqCQkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICAgKgogICAgICoJCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggd3JpdGVyLmNyZWF0ZVRleHQoICd4JyApLCBzZWxlY3Rpb24gKTsKICAgICAqCiAgICAgKgkJCS8vIGluc2VydENvbnRlbnQoKSBtb2RpZmllcyB0aGUgcGFzc2VkIHNlbGVjdGlvbiBpbnN0YW5jZSBzbyBpdCBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGRvY3VtZW50IHNlbGVjdGlvbi4KICAgICAqCQkJLy8gTm90ZTogVGhpcyBpcyBub3QgbmVjZXNzYXJ5IHdoZW4geW91IHBhc3NlZCB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIHRvIGluc2VydENvbnRlbnQoKS4KICAgICAqCQkJd3JpdGVyLnNldFNlbGVjdGlvbiggc2VsZWN0aW9uICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBmaXJlcyBpbnNlcnRDb250ZW50CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBjb250ZW50IFRoZSBjb250ZW50IHRvIGluc2VydC4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gW3NlbGVjdGFibGU9bW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uXQogICAgICogVGhlIHNlbGVjdGlvbiBpbnRvIHdoaWNoIHRoZSBjb250ZW50IHNob3VsZCBiZSBpbnNlcnRlZC4gSWYgbm90IHByb3ZpZGVkIHRoZSBjdXJyZW50IG1vZGVsIGRvY3VtZW50IHNlbGVjdGlvbiB3aWxsIGJlIHVzZWQuCiAgICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIFRvIGJlIHVzZWQgd2hlbiBhIG1vZGVsIGl0ZW0gd2FzIHBhc3NlZCBhcyBgc2VsZWN0YWJsZWAuCiAgICAgKiBUaGlzIHBhcmFtIGRlZmluZXMgYSBwb3NpdGlvbiBpbiByZWxhdGlvbiB0byB0aGF0IGl0ZW0uCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gUmFuZ2Ugd2hpY2ggY29udGFpbnMgYWxsIHRoZSBwZXJmb3JtZWQgY2hhbmdlcy4gVGhpcyBpcyBhIHJhbmdlIHRoYXQsIGlmIHJlbW92ZWQsCiAgICAgKiB3b3VsZCByZXR1cm4gdGhlIG1vZGVsIHRvIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIGluc2VydGlvbi4gSWYgbm8gY2hhbmdlcyB3ZXJlIHByZWZvcm1lZCBieSBgaW5zZXJ0Q29udGVudGAsIHJldHVybnMgYSByYW5nZSBjb2xsYXBzZWQKICAgICAqIGF0IHRoZSBpbnNlcnRpb24gcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaW5zZXJ0Q29udGVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Q29udGVudChjb250ZW50LCBzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0KSB7CiAgICAgIHJldHVybiBfaW5zZXJ0Q29udGVudCh0aGlzLCBjb250ZW50LCBzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0KTsKICAgIH0KICAgIC8qKgogICAgICogRGVsZXRlcyBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24gYW5kIG1lcmdlIHNpYmxpbmdzLiBUaGUgcmVzdWx0aW5nIHNlbGVjdGlvbiBpcyBhbHdheXMgY29sbGFwc2VkLgogICAgICoKICAgICAqICoqTm90ZToqKiBGb3IgdGhlIHNha2Ugb2YgcHJlZGljdGFiaWxpdHksIHRoZSByZXN1bHRpbmcgc2VsZWN0aW9uIHNob3VsZCBhbHdheXMgYmUgY29sbGFwc2VkLgogICAgICogSW4gY2FzZXMgd2hlcmUgYSBmZWF0dXJlIHdhbnRzIHRvIG1vZGlmeSBkZWxldGluZyBiZWhhdmlvciBzbyBzZWxlY3Rpb24gaXNuJ3QgY29sbGFwc2VkCiAgICAgKiAoZS5nLiBhIHRhYmxlIGZlYXR1cmUgbWF5IHdhbnQgdG8ga2VlcCByb3cgc2VsZWN0aW9uIGFmdGVyIHByZXNzaW5nIDxrYmQ+QmFja3NwYWNlPC9rYmQ+KSwKICAgICAqIHRoZW4gdGhhdCBiZWhhdmlvciBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gdGhlIHZpZXcncyBsaXN0ZW5lci4gQXQgdGhlIHNhbWUgdGltZSwgdGhlIHRhYmxlIGZlYXR1cmUKICAgICAqIHdpbGwgbmVlZCB0byBtb2RpZnkgdGhpcyBtZXRob2QncyBiZWhhdmlvciB0b28sIGUuZy4gdG8gImRlbGV0ZSBjb250ZW50cyBhbmQgdGhlbiBjb2xsYXBzZQogICAgICogdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGxhc3Qgc2VsZWN0ZWQgY2VsbCIgb3IgImRlbGV0ZSB0aGUgcm93IGFuZCBjb2xsYXBzZSBzZWxlY3Rpb24gc29tZXdoZXJlIG5lYXIiLgogICAgICogVGhhdCBuZWVkcyB0byBiZSBkb25lIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG90aGVyIGZlYXR1cmVzIHdoaWNoIHVzZSBgZGVsZXRlQ29udGVudCgpYCB3aWxsIHdvcmsgd2VsbCB3aXRoIHRhYmxlcy4KICAgICAqCiAgICAgKiBAZmlyZXMgZGVsZXRlQ29udGVudAogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gc2VsZWN0aW9uCiAgICAgKiBTZWxlY3Rpb24gb2Ygd2hpY2ggdGhlIGNvbnRlbnQgc2hvdWxkIGJlIGRlbGV0ZWQuCiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmxlYXZlVW5tZXJnZWQ9ZmFsc2VdIFdoZXRoZXIgdG8gbWVyZ2UgZWxlbWVudHMgYWZ0ZXIgcmVtb3ZpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIHNlbGVjdGlvbi4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZSBgPGhlYWRpbmcxPnhbeDwvaGVhZGluZzE+PHBhcmFncmFwaD55XXk8L3BhcmFncmFwaD5gIHdpbGwgYmVjb21lOgogICAgICoKICAgICAqICogYDxoZWFkaW5nMT54Xnk8L2hlYWRpbmcxPmAgd2l0aCB0aGUgb3B0aW9uIGRpc2FibGVkIChgbGVhdmVVbm1lcmdlZCA9PSBmYWxzZWApCiAgICAgKiAqIGA8aGVhZGluZzE+eF48L2hlYWRpbmcxPjxwYXJhZ3JhcGg+eTwvcGFyYWdyYXBoPmAgd2l0aCBlbmFibGVkIChgbGVhdmVVbm1lcmdlZCA9PSB0cnVlYCkuCiAgICAgKgogICAgICogTm90ZToge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc09iamVjdCBvYmplY3R9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgbGltaXR9CiAgICAgKiBlbGVtZW50cyB3aWxsIG5vdCBiZSBtZXJnZWQuCiAgICAgKgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb05vdFJlc2V0RW50aXJlQ29udGVudD1mYWxzZV0gV2hldGhlciB0byBza2lwIHJlcGxhY2luZyB0aGUgZW50aXJlIGNvbnRlbnQgd2l0aCBhCiAgICAgKiBwYXJhZ3JhcGggd2hlbiB0aGUgZW50aXJlIGNvbnRlbnQgd2FzIHNlbGVjdGVkLgogICAgICoKICAgICAqIEZvciBleGFtcGxlIGA8aGVhZGluZzE+W3g8L2hlYWRpbmcxPjxwYXJhZ3JhcGg+eV08L3BhcmFncmFwaD5gIHdpbGwgYmVjb21lOgogICAgICoKICAgICAqICogYDxwYXJhZ3JhcGg+XjwvcGFyYWdyYXBoPmAgd2l0aCB0aGUgb3B0aW9uIGRpc2FibGVkIChgZG9Ob3RSZXNldEVudGlyZUNvbnRlbnQgPT0gZmFsc2VgKQogICAgICogKiBgPGhlYWRpbmcxPl48L2hlYWRpbmcxPmAgd2l0aCBlbmFibGVkIChgZG9Ob3RSZXNldEVudGlyZUNvbnRlbnQgPT0gdHJ1ZWApCiAgICAgKgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb05vdEF1dG9wYXJhZ3JhcGg9ZmFsc2VdIFdoZXRoZXIgdG8gY3JlYXRlIGEgcGFyYWdyYXBoIGlmIGFmdGVyIGNvbnRlbnQgZGVsZXRpb24gc2VsZWN0aW9uIGlzIG1vdmVkCiAgICAgKiB0byBhIHBsYWNlIHdoZXJlIHRleHQgY2Fubm90IGJlIGluc2VydGVkLgogICAgICoKICAgICAqIEZvciBleGFtcGxlIGA8cGFyYWdyYXBoPng8L3BhcmFncmFwaD5bPGltYWdlIHNyYz0iZm9vLmpwZyI+PC9pbWFnZT5dYCB3aWxsIGJlY29tZToKICAgICAqCiAgICAgKiAqIGA8cGFyYWdyYXBoPng8L3BhcmFncmFwaD48cGFyYWdyYXBoPltdPC9wYXJhZ3JhcGg+YCB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQgKGBkb05vdEF1dG9wYXJhZ3JhcGggPT0gZmFsc2VgKQogICAgICogKiBgPHBhcmFncmFwaD54W108L3BhcmFncmFwaD5gIHdpdGggdGhlIG9wdGlvbiBlbmFibGVkIChgZG9Ob3RBdXRvcGFyYWdyYXBoID09IHRydWVgKS4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogaWYgdGhlcmUgaXMgbm8gdmFsaWQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb24sIHRoZSBwYXJhZ3JhcGggd2lsbCBhbHdheXMgYmUgY3JlYXRlZDoKICAgICAqCiAgICAgKiBgWzxpbWFnZSBzcmM9ImZvby5qcGciPjwvaW1hZ2U+XWAgLT4gYDxwYXJhZ3JhcGg+W108L3BhcmFncmFwaD5gLgogICAgICoKICAgICAqIEBwYXJhbSB7J2ZvcndhcmQnfCdiYWNrd2FyZCd9IFtvcHRpb25zLmRpcmVjdGlvbj0nYmFja3dhcmQnXSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBjb250ZW50IGlzIGJlaW5nIGNvbnN1bWVkLgogICAgICogRGVsZXRpbmcgYmFja3dhcmQgY29ycmVzcG9uZHMgdG8gdXNpbmcgdGhlIDxrYmQ+QmFja3NwYWNlPC9rYmQ+IGtleSwgd2hpbGUgZGVsZXRpbmcgY29udGVudCBmb3J3YXJkIGNvcnJlc3BvbmRzIHRvCiAgICAgKiB0aGUgPGtiZD5TaGlmdDwva2JkPis8a2JkPkJhY2tzcGFjZTwva2JkPiBrZXlzdHJva2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZGVsZXRlQ29udGVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ29udGVudChzZWxlY3Rpb24sIG9wdGlvbnMpIHsKICAgICAgX2RlbGV0ZUNvbnRlbnQodGhpcywgc2VsZWN0aW9uLCBvcHRpb25zKTsKICAgIH0KICAgIC8qKgogICAgICogTW9kaWZpZXMgdGhlIHNlbGVjdGlvbi4gQ3VycmVudGx5LCB0aGUgc3VwcG9ydGVkIG1vZGlmaWNhdGlvbnMgYXJlOgogICAgICoKICAgICAqICogRXh0ZW5kaW5nLiBUaGUgc2VsZWN0aW9uIGZvY3VzIGlzIG1vdmVkIGluIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnMuZGlyZWN0aW9uYCB3aXRoIGEgc3RlcCBzcGVjaWZpZWQgaW4gYG9wdGlvbnMudW5pdGAuCiAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgZm9yIGB1bml0YCBhcmU6CiAgICAgKiAgKiBgJ2NoYXJhY3RlcidgIChkZWZhdWx0KSAtIG1vdmVzIHNlbGVjdGlvbiBieSBvbmUgdXNlci1wZXJjZWl2ZWQgY2hhcmFjdGVyLiBJbiBtb3N0IGNhc2VzIHRoaXMgbWVhbnMgbW92aW5nIGJ5IG9uZQogICAgICogIGNoYXJhY3RlciBpbiBgU3RyaW5nYCBzZW5zZS4gSG93ZXZlciwgdW5pY29kZSBhbHNvIGRlZmluZXMgImNvbWJpbmcgbWFya3MiLiBUaGVzZSBhcmUgc3BlY2lhbCBzeW1ib2xzLCB0aGF0IGNvbWJpbmVzCiAgICAgKiAgd2l0aCBhIHN5bWJvbCBiZWZvcmUgaXQgKCJiYXNlIGNoYXJhY3RlciIpIHRvIGNyZWF0ZSBvbmUgdXNlci1wZXJjZWl2ZWQgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgYHHMh8yjYCBpcyBhIG5vcm1hbAogICAgICogIGxldHRlciBgcWAgd2l0aCB0d28gImNvbWJpbmluZyBtYXJrcyI6IHVwcGVyIGRvdCAoYFV4MDMwN2ApIGFuZCBsb3dlciBkb3QgKGBVeDAzMjNgKS4gRm9yIG1vc3QgYWN0aW9ucywgaS5lLiBleHRlbmRpbmcKICAgICAqICBzZWxlY3Rpb24gYnkgb25lIHBvc2l0aW9uLCBpdCBpcyBjb3JyZWN0IHRvIGluY2x1ZGUgYm90aCAiYmFzZSBjaGFyYWN0ZXIiIGFuZCBhbGwgb2YgaXQncyAiY29tYmluaW5nIG1hcmtzIi4gVGhhdCBpcwogICAgICogIHdoeSBgJ2NoYXJhY3RlcidgIHZhbHVlIGlzIG1vc3QgbmF0dXJhbCBhbmQgY29tbW9uIG1ldGhvZCBvZiBtb2RpZnlpbmcgc2VsZWN0aW9uLgogICAgICogICogYCdjb2RlUG9pbnQnYCAtIG1vdmVzIHNlbGVjdGlvbiBieSBvbmUgdW5pY29kZSBjb2RlIHBvaW50LiBJbiBjb250cmFyeSB0bywgYCdjaGFyYWN0ZXInYCB1bml0LCB0aGlzIHdpbGwgaW5zZXJ0CiAgICAgKiAgc2VsZWN0aW9uIGJldHdlZW4gImJhc2UgY2hhcmFjdGVyIiBhbmQgImNvbWJpbmluZyBtYXJrIiwgYmVjYXVzZSAiY29tYmluaW5nIG1hcmtzIiBoYXZlIHRoZWlyIG93biB1bmljb2RlIGNvZGUgcG9pbnRzLgogICAgICogIEhvd2V2ZXIsIGZvciB0ZWNobmljYWwgcmVhc29ucywgdW5pY29kZSBjb2RlIHBvaW50cyB3aXRoIHZhbHVlcyBhYm92ZSBgVXhGRkZGYCBhcmUgcmVwcmVzZW50ZWQgaW4gbmF0aXZlIGBTdHJpbmdgIGJ5CiAgICAgKiAgdHdvIGNoYXJhY3RlcnMsIGNhbGxlZCAic3Vycm9nYXRlIHBhaXJzIi4gSGFsdmVzIG9mICJzdXJyb2dhdGUgcGFpcnMiIGhhdmUgYSBtZWFuaW5nIG9ubHkgd2hlbiBwbGFjZWQgbmV4dCB0byBlYWNoIG90aGVyLgogICAgICogIEZvciBleGFtcGxlIGDwqK2OYCBpcyByZXByZXNlbnRlZCBpbiBgU3RyaW5nYCBieSBgXHVEODYyXHVERjRFYC4gQm90aCBgXHVEODYyYCBhbmQgYFx1REY0RWAgZG8gbm90IGhhdmUgYW55IG1lYW5pbmcKICAgICAqICBvdXRzaWRlIHRoZSBwYWlyIChhcmUgcmVuZGVyZWQgYXMgPyB3aGVuIGFsb25lKS4gUG9zaXRpb24gYmV0d2VlbiB0aGVtIHdvdWxkIGJlIGluY29ycmVjdC4gSW4gdGhpcyBjYXNlLCBzZWxlY3Rpb24KICAgICAqICBleHRlbnNpb24gd2lsbCBpbmNsdWRlIHdob2xlICJzdXJyb2dhdGUgcGFpciIuCiAgICAgKiAgKiBgJ3dvcmQnYCAtIG1vdmVzIHNlbGVjdGlvbiBieSBhIHdob2xlIHdvcmQuCiAgICAgKgogICAgICogKipOb3RlOioqIGlmIHlvdSBleHRlbmQgYSBmb3J3YXJkIHNlbGVjdGlvbiBpbiBhIGJhY2t3YXJkIGRpcmVjdGlvbiB5b3Ugd2lsbCBpbiBmYWN0IHNocmluayBpdC4KICAgICAqCiAgICAgKiBAZmlyZXMgbW9kaWZ5U2VsZWN0aW9uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9ufSBzZWxlY3Rpb24KICAgICAqIFRoZSBzZWxlY3Rpb24gdG8gbW9kaWZ5LgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHsnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW29wdGlvbnMuZGlyZWN0aW9uPSdmb3J3YXJkJ10gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb2RpZmllZC4KICAgICAqIEBwYXJhbSB7J2NoYXJhY3Rlcid8J2NvZGVQb2ludCd8J3dvcmQnfSBbb3B0aW9ucy51bml0PSdjaGFyYWN0ZXInXSBUaGUgdW5pdCBieSB3aGljaCBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vZGlmaWVkLgogICAgICovCgogIH0sIHsKICAgIGtleTogIm1vZGlmeVNlbGVjdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbW9kaWZ5U2VsZWN0aW9uKHNlbGVjdGlvbiwgb3B0aW9ucykgewogICAgICBfbW9kaWZ5U2VsZWN0aW9uKHRoaXMsIHNlbGVjdGlvbiwgb3B0aW9ucyk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgYSBjbG9uZSBvZiB0aGUgc2VsZWN0ZWQgY29udGVudC4KICAgICAqCiAgICAgKiBGb3IgZXhhbXBsZSwgZm9yIHRoZSBmb2xsb3dpbmcgc2VsZWN0aW9uOgogICAgICoKICAgICAqIGBgYGh0bWwKICAgICAqIDxwYXJhZ3JhcGg+eDwvcGFyYWdyYXBoPgogICAgICogPGJsb2NrUXVvdGU+CiAgICAgKgk8cGFyYWdyYXBoPnk8L3BhcmFncmFwaD4KICAgICAqCTxoZWFkaW5nMT5maXJbc3Q8L2hlYWRpbmcxPgogICAgICogPC9ibG9ja1F1b3RlPgogICAgICogPHBhcmFncmFwaD5zZV1jb25kPC9wYXJhZ3JhcGg+CiAgICAgKiA8cGFyYWdyYXBoPno8L3BhcmFncmFwaD4KICAgICAqIGBgYAogICAgICoKICAgICAqIEl0IHdpbGwgcmV0dXJuIGEgZG9jdW1lbnQgZnJhZ21lbnQgd2l0aCBzdWNoIGEgY29udGVudDoKICAgICAqCiAgICAgKiBgYGBodG1sCiAgICAgKiA8YmxvY2tRdW90ZT4KICAgICAqCTxoZWFkaW5nMT5zdDwvaGVhZGluZzE+CiAgICAgKiA8L2Jsb2NrUXVvdGU+CiAgICAgKiA8cGFyYWdyYXBoPnNlPC9wYXJhZ3JhcGg+CiAgICAgKiBgYGAKICAgICAqCiAgICAgKiBAZmlyZXMgZ2V0U2VsZWN0ZWRDb250ZW50CiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9ufSBzZWxlY3Rpb24KICAgICAqIFRoZSBzZWxlY3Rpb24gb2Ygd2hpY2ggY29udGVudCB3aWxsIGJlIHJldHVybmVkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldFNlbGVjdGVkQ29udGVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDb250ZW50KHNlbGVjdGlvbikgewogICAgICByZXR1cm4gX2dldFNlbGVjdGVkQ29udGVudCh0aGlzLCBzZWxlY3Rpb24pOwogICAgfQogICAgLyoqCiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2V9IG9yCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaGFzIGFueSBtZWFuaW5nZnVsIGNvbnRlbnQuCiAgICAgKgogICAgICogTWVhbmluZ2Z1bCBjb250ZW50IGlzOgogICAgICoKICAgICAqICogYW55IHRleHQgbm9kZSAoYG9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZXNgIGFsbG93cyBjb250cm9sbGluZyB3aGV0aGVyIHRoaXMgdGV4dCBub2RlIG11c3QgYWxzbyBjb250YWluCiAgICAgKiBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyksCiAgICAgKiAqIG9yIGFueSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzT2JqZWN0IG9iamVjdCBlbGVtZW50fSwKICAgICAqICogb3IgYW55IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyIG1hcmtlcn0gd2hpY2gKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyI19hZmZlY3RzRGF0YSBhZmZlY3RzIGRhdGF9LgogICAgICoKICAgICAqIFRoaXMgbWVhbnMgdGhhdCBhIHJhbmdlIGNvbnRhaW5pbmcgYW4gZW1wdHkgYDxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+YCBpcyBub3QgY29uc2lkZXJlZCB0byBoYXZlIGEgbWVhbmluZ2Z1bCBjb250ZW50LgogICAgICogSG93ZXZlciwgYSByYW5nZSBjb250YWluaW5nIGFuIGA8aW1hZ2U+PC9pbWFnZT5gICh3aGljaCB3b3VsZCBub3JtYWxseSBiZSBtYXJrZWQgaW4gdGhlIHNjaGVtYSBhcyBhbiBvYmplY3QgZWxlbWVudCkKICAgICAqIGlzIGNvbnNpZGVyZWQgbm9uLWVtcHR5LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcmFuZ2VPckVsZW1lbnQgUmFuZ2Ugb3IgZWxlbWVudCB0byBjaGVjay4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlV2hpdGVzcGFjZXNdIFdoZXRoZXIgdGV4dCBub2RlIHdpdGggd2hpdGVzcGFjZXMgb25seSBzaG91bGQgYmUgY29uc2lkZXJlZCBlbXB0eS4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImhhc0NvbnRlbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NvbnRlbnQocmFuZ2VPckVsZW1lbnQsIG9wdGlvbnMpIHsKICAgICAgdmFyIHJhbmdlID0gcmFuZ2VPckVsZW1lbnQgaW5zdGFuY2VvZiBNb2RlbEVsZW1lbnQgPyBNb2RlbFJhbmdlLl9jcmVhdGVJbihyYW5nZU9yRWxlbWVudCkgOiByYW5nZU9yRWxlbWVudDsKCiAgICAgIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IG1hcmtlcnMgd2hpY2ggYWZmZWN0cyBkYXRhIGluIHRoaXMgZ2l2ZW4gcmFuZ2UuCgoKICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLm1hcmtlcnMuZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlKHJhbmdlKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHsKICAgICAgICAgIHZhciBpbnRlcnNlY3RpbmdNYXJrZXIgPSBfc3RlcC52YWx1ZTsKCiAgICAgICAgICBpZiAoaW50ZXJzZWN0aW5nTWFya2VyLmFmZmVjdHNEYXRhKSB7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LAogICAgICAgICAgX3JlZiRpZ25vcmVXaGl0ZXNwYWNlID0gX3JlZi5pZ25vcmVXaGl0ZXNwYWNlcywKICAgICAgICAgIGlnbm9yZVdoaXRlc3BhY2VzID0gX3JlZiRpZ25vcmVXaGl0ZXNwYWNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaWdub3JlV2hpdGVzcGFjZTsKCiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7CiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTsKICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHJhbmdlLmdldEl0ZW1zKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHsKICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAyLnZhbHVlOwoKICAgICAgICAgIGlmIChpdGVtLmlzKCd0ZXh0UHJveHknKSkgewogICAgICAgICAgICBpZiAoIWlnbm9yZVdoaXRlc3BhY2VzKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5kYXRhLnNlYXJjaCgvXFMvKSAhPT0gLTEpIHsKICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNjaGVtYS5pc09iamVjdChpdGVtKSkgewogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7CiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTsKICAgICAgICAgIH0KICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikgewogICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBwb3NpdGlvbiBmcm9tIHRoZSBnaXZlbiByb290IGFuZCBwYXRoIGluIHRoYXQgcm9vdC4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVQb3NpdGlvbkZyb21QYXRoIGBXcml0ZXIjY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCgpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gcm9vdCBSb290IG9mIHRoZSBwb3NpdGlvbi4KICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj59IHBhdGggUG9zaXRpb24gcGF0aC4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGh9LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgocm9vdCwgcGF0aCwgc3RpY2tpbmVzcykgewogICAgICByZXR1cm4gbmV3IE1vZGVsUG9zaXRpb24ocm9vdCwgcGF0aCwgc3RpY2tpbmVzcyk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGxvY2F0aW9uLiBUaGUgbG9jYXRpb24gY2FuIGJlIHNwZWNpZmllZCBhczoKICAgICAqCiAgICAgKiAqIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LAogICAgICogKiBhIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXQgaW4gdGhhdCBlbGVtZW50LAogICAgICogKiBhIHBhcmVudCBlbGVtZW50IGFuZCBgJ2VuZCdgICh0aGUgcG9zaXRpb24gd2lsbCBiZSBzZXQgYXQgdGhlIGVuZCBvZiB0aGF0IGVsZW1lbnQpLAogICAgICogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfSBhbmQgYCdiZWZvcmUnYCBvciBgJ2FmdGVyJ2AKICAgICAqICh0aGUgcG9zaXRpb24gd2lsbCBiZSBzZXQgYmVmb3JlIG9yIGFmdGVyIHRoZSBnaXZlbiBtb2RlbCBpdGVtKS4KICAgICAqCiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIG90aGVyIGZhY3RvcnkgbWV0aG9kcyBzdWNoIGFzOgogICAgICoKICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUG9zaXRpb25CZWZvcmUgYGNyZWF0ZVBvc2l0aW9uQmVmb3JlKClgfSwKICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUG9zaXRpb25BZnRlciBgY3JlYXRlUG9zaXRpb25BZnRlcigpYH0uCiAgICAgKgogICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlUG9zaXRpb25BdCBgV3JpdGVyI2NyZWF0ZVBvc2l0aW9uQXQoKWB9LAogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgICAqIEBwYXJhbSB7TnVtYmVyfCdlbmQnfCdiZWZvcmUnfCdhZnRlcid9IFtvZmZzZXRdIE9mZnNldCBvciBvbmUgb2YgdGhlIGZsYWdzLiBVc2VkIG9ubHkgd2hlbgogICAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVBvc2l0aW9uQXQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgICByZXR1cm4gTW9kZWxQb3NpdGlvbi5fY3JlYXRlQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24gYWZ0ZXIgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVQb3NpdGlvbkFmdGVyIGBXcml0ZXIjY3JlYXRlUG9zaXRpb25BZnRlcigpYH0uCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGFmdGVyIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25BZnRlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25BZnRlcihpdGVtKSB7CiAgICAgIHJldHVybiBNb2RlbFBvc2l0aW9uLl9jcmVhdGVBZnRlcihpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiBiZWZvcmUgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVQb3NpdGlvbkJlZm9yZSBgV3JpdGVyI2NyZWF0ZVBvc2l0aW9uQmVmb3JlKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gYmVmb3JlIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUG9zaXRpb25CZWZvcmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uQmVmb3JlKGl0ZW0pIHsKICAgICAgcmV0dXJuIE1vZGVsUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIHNwYW5uaW5nIGZyb20gdGhlIGBzdGFydGAgcG9zaXRpb24gdG8gdGhlIGBlbmRgIHBvc2l0aW9uLgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVJhbmdlIGBXcml0ZXIjY3JlYXRlUmFuZ2UoKWB9OgogICAgICoKICAgICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICAgKgkJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc3RhcnQgU3RhcnQgcG9zaXRpb24uCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFtlbmRdIEVuZCBwb3NpdGlvbi4gSWYgbm90IHNldCwgdGhlIHJhbmdlIHdpbGwgYmUgY29sbGFwc2VkCiAgICAgKiB0byB0aGUgYHN0YXJ0YCBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZVJhbmdlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSYW5nZShzdGFydCwgZW5kKSB7CiAgICAgIHJldHVybiBuZXcgTW9kZWxSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAgICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgICAqCiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVSYW5nZUluIGBXcml0ZXIjY3JlYXRlUmFuZ2VJbigpYH06CiAgICAgKgogICAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgICAqCQkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2VJbiggcGFyYWdyYXBoICk7CiAgICAgKgkJfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2VJbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2VJbihlbGVtZW50KSB7CiAgICAgIHJldHVybiBNb2RlbFJhbmdlLl9jcmVhdGVJbihlbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIHJhbmdlIHRoYXQgc3RhcnRzIGJlZm9yZSB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19IGFuZCBlbmRzIGFmdGVyIGl0LgogICAgICoKICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIG9uIGB3cml0ZXJgIGluc3RhbmNlIGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVJhbmdlT24gYFdyaXRlci5jcmVhdGVSYW5nZU9uKClgfToKICAgICAqCiAgICAgKgkJbW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAgICoJCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZU9uKCBwYXJhZ3JhcGggKTsKICAgICAqCQl9ICk7CiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbQogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlUmFuZ2VPbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmFuZ2VPbihpdGVtKSB7CiAgICAgIHJldHVybiBNb2RlbFJhbmdlLl9jcmVhdGVPbihpdGVtKTsKICAgIH0KICAgIC8qKgogICAgICogQ3JlYXRlcyBhIG5ldyBzZWxlY3Rpb24gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlIHNlbGVjdGFibGV9CiAgICAgKiBvciBjcmVhdGVzIGFuIGVtcHR5IHNlbGVjdGlvbiBpZiBubyBhcmd1bWVudHMgd2VyZSBwYXNzZWQuCiAgICAgKgogICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlU2VsZWN0aW9uIGBXcml0ZXIjY3JlYXRlU2VsZWN0aW9uKClgfS4KICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBlbXB0eSBzZWxlY3Rpb24gd2l0aG91dCByYW5nZXMuCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbigpOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICAgKgkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0LCBlbmQgKTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcmFuZ2VzCiAgICAgKgkJY29uc3QgcmFuZ2VzID0gWyB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0MSwgZW5kMiApLCB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXIyLCBlbmQyICkgXTsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZXMgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0aGUgb3RoZXIgc2VsZWN0aW9uLgogICAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAgICoJCWNvbnN0IG90aGVyU2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbigpOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIG90aGVyU2VsZWN0aW9uICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gdGhlIGdpdmVuIGRvY3VtZW50IHNlbGVjdGlvbi4KICAgICAqCQkvLyBOb3RlOiBJdCBkb2Vzbid0IGNvcGllcyBzZWxlY3Rpb24gYXR0cmlidXRlcy4KICAgICAqCQljb25zdCBkb2N1bWVudFNlbGVjdGlvbiA9IG1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbjsKICAgICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBkb2N1bWVudFNlbGVjdGlvbiApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICAgKgkJY29uc3QgcG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgcGF0aCApOwogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBvc2l0aW9uICk7CiAgICAgKgogICAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW4gdGhlIGdpdmVuIGVsZW1lbnQuCiAgICAgKgkJY29uc3QgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUKICAgICAqCQkvLyBmaXJzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ2luJyApOwogICAgICoKICAgICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2Ugb24gYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMKICAgICAqCQkvLyBqdXN0IGFmdGVyIHRoZSBpdGVtLgogICAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ29uJyApOwogICAgICoKICAgICAqCQkvLyBBZGRpdGlvbmFsIG9wdGlvbnMgKGAnYmFja3dhcmQnYCkgY2FuIGJlIHNwZWNpZmllZCBhcyB0aGUgbGFzdCBhcmd1bWVudC4KICAgICAqCiAgICAgKgkJLy8gQ3JlYXRlcyBiYWNrd2FyZCBzZWxlY3Rpb24uCiAgICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcmFuZ2UsIHsgYmFja3dhcmQ6IHRydWUgfSApOwogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBTZXRzIHBsYWNlIG9yIG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb259CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY3JlYXRlU2VsZWN0aW9uIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucykgewogICAgICByZXR1cm4gbmV3IE1vZGVsU2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvYmF0Y2h+QmF0Y2h9IGluc3RhbmNlLgogICAgICoKICAgICAqICoqTm90ZToqKiBJbiBtb3N0IGNhc2VzIGNyZWF0aW5nIGEgYmF0Y2ggaW5zdGFuY2UgaXMgbm90IG5lY2Vzc2FyeSBhcyB0aGV5IGFyZSBjcmVhdGVkIHdoZW4gdXNpbmc6CiAgICAgKgogICAgICogKiB7QGxpbmsgI2NoYW5nZSBgY2hhbmdlKClgfSwKICAgICAqICoge0BsaW5rICNlbnF1ZXVlQ2hhbmdlIGBlbnF1ZXVlQ2hhbmdlKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0geyd0cmFuc3BhcmVudCd8J2RlZmF1bHQnfSBbdHlwZT0nZGVmYXVsdCddIFRoZSB0eXBlIG9mIHRoZSBiYXRjaC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofQogICAgICovCgogIH0sIHsKICAgIGtleTogImNyZWF0ZUJhdGNoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVCYXRjaCh0eXBlKSB7CiAgICAgIHJldHVybiBuZXcgQmF0Y2godHlwZSk7CiAgICB9CiAgICAvKioKICAgICAqIENyZWF0ZXMgYW4gb3BlcmF0aW9uIGluc3RhbmNlIGZyb20gYSBKU09OIG9iamVjdCAocGFyc2VkIEpTT04gc3RyaW5nKS4KICAgICAqCiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9uZmFjdG9yeX5PcGVyYXRpb25GYWN0b3J5LmZyb21KU09OIGBPcGVyYXRpb25GYWN0b3J5LmZyb21KU09OKClgfS4KICAgICAqCiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBEZXNlcmlhbGl6ZWQgSlNPTiBvYmplY3QuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJjcmVhdGVPcGVyYXRpb25Gcm9tSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uRnJvbUpTT04oanNvbikgewogICAgICByZXR1cm4gT3BlcmF0aW9uRmFjdG9yeS5mcm9tSlNPTihqc29uLCB0aGlzLmRvY3VtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbGwgZXZlbnRzIGxpc3RlbmVycyBzZXQgYnkgbW9kZWwgaW5zdGFuY2UgYW5kIGRlc3Ryb3lzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJkZXN0cm95IiwKICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkgewogICAgICB0aGlzLmRvY3VtZW50LmRlc3Ryb3koKTsKICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7CiAgICB9CiAgICAvKioKICAgICAqIENvbW1vbiBwYXJ0IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZX0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2V9CiAgICAgKiB3aGljaCBjYWxscyBjYWxsYmFja3MgYW5kIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZXNlIGNhbGxiYWNrcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHJldHVybnMge0FycmF5LjwqPn0gQXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IGNhbGxiYWNrcy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfcnVuUGVuZGluZ0NoYW5nZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5QZW5kaW5nQ2hhbmdlcygpIHsKICAgICAgdmFyIHJldCA9IFtdOwogICAgICB0aGlzLmZpcmUoJ19iZWZvcmVDaGFuZ2VzJyk7CgogICAgICB3aGlsZSAodGhpcy5fcGVuZGluZ0NoYW5nZXMubGVuZ3RoKSB7CiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHdyaXRlciB1c2luZyBiYXRjaCBpbnN0YW5jZSBjcmVhdGVkIGZvciB0aGlzIGNoYWluIG9mIGNoYW5nZXMuCiAgICAgICAgdmFyIGN1cnJlbnRCYXRjaCA9IHRoaXMuX3BlbmRpbmdDaGFuZ2VzWzBdLmJhdGNoOwogICAgICAgIHRoaXMuX2N1cnJlbnRXcml0ZXIgPSBuZXcgV3JpdGVyKHRoaXMsIGN1cnJlbnRCYXRjaCk7IC8vIEV4ZWN1dGUgY2hhbmdlcyBjYWxsYmFjayBhbmQgZ2F0aGVyIHRoZSByZXR1cm5lZCB2YWx1ZS4KCiAgICAgICAgdmFyIGNhbGxiYWNrUmV0dXJuVmFsdWUgPSB0aGlzLl9wZW5kaW5nQ2hhbmdlc1swXS5jYWxsYmFjayh0aGlzLl9jdXJyZW50V3JpdGVyKTsKCiAgICAgICAgcmV0LnB1c2goY2FsbGJhY2tSZXR1cm5WYWx1ZSk7CgogICAgICAgIHRoaXMuZG9jdW1lbnQuX2hhbmRsZUNoYW5nZUJsb2NrKHRoaXMuX2N1cnJlbnRXcml0ZXIpOwoKICAgICAgICB0aGlzLl9wZW5kaW5nQ2hhbmdlcy5zaGlmdCgpOwoKICAgICAgICB0aGlzLl9jdXJyZW50V3JpdGVyID0gbnVsbDsKICAgICAgfQoKICAgICAgdGhpcy5maXJlKCdfYWZ0ZXJDaGFuZ2VzJyk7CiAgICAgIHJldHVybiByZXQ7CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIHdoZW4gZW50ZXJpbmcgdGhlIG91dGVybW9zdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNlbnF1ZXVlQ2hhbmdlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBibG9jay4KICAgICAqCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKiBAZXZlbnQgX2JlZm9yZUNoYW5nZXMKICAgICAqLwoKICAgIC8qKgogICAgICogRmlyZWQgd2hlbiBsZWF2aW5nIHRoZSBvdXRlcm1vc3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0gb3IKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NoYW5nZX0gYmxvY2suCiAgICAgKgogICAgICogQHByb3RlY3RlZAogICAgICogQGV2ZW50IF9hZnRlckNoYW5nZXMKICAgICAqLwoKICAgIC8qKgogICAgICogRmlyZWQgZXZlcnkgdGltZSBhbnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9ufSBpcyBhcHBsaWVkIG9uIHRoZSBtb2RlbAogICAgICogdXNpbmcge0BsaW5rICNhcHBseU9wZXJhdGlvbn0uCiAgICAgKgogICAgICogTm90ZSB0aGF0IHRoaXMgZXZlbnQgaXMgc3VpdGFibGUgb25seSBmb3IgdmVyeSBzcGVjaWZpYyB1c2UtY2FzZXMuIFVzZSBpdCBpZiB5b3UgbmVlZCB0byBsaXN0ZW4gdG8gZXZlcnkgc2luZ2xlIG9wZXJhdGlvbgogICAgICogYXBwbGllZCBvbiB0aGUgZG9jdW1lbnQuIEhvd2V2ZXIsIGluIG1vc3QgY2FzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6Y2hhbmdlfSBzaG91bGQKICAgICAqIGJlIHVzZWQuCiAgICAgKgogICAgICogQSBmZXcgY2FsbGJhY2tzIGFyZSBhbHJlYWR5IGFkZGVkIHRvIHRoaXMgZXZlbnQgYnkgZW5naW5lIGludGVybmFsIGNsYXNzZXM6CiAgICAgKgogICAgICogKiB3aXRoIGBoaWdoZXN0YCBwcmlvcml0eSBvcGVyYXRpb24gaXMgdmFsaWRhdGVkLAogICAgICogKiB3aXRoIGBub3JtYWxgIHByaW9yaXR5IG9wZXJhdGlvbiBpcyBleGVjdXRlZCwKICAgICAqICogd2l0aCBgbG93YCBwcmlvcml0eSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IHVwZGF0ZXMgaXRzIHZlcnNpb24sCiAgICAgKiAqIHdpdGggYGxvd2AgcHJpb3JpdHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXBvc2l0aW9ufkxpdmVQb3NpdGlvbn0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVyYW5nZX5MaXZlUmFuZ2V9CiAgICAgKiB1cGRhdGUgdGhlbXNlbHZlcy4KICAgICAqCiAgICAgKiBAZXZlbnQgYXBwbHlPcGVyYXRpb24KICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzIG9mIHRoZSBgYXBwbHlPcGVyYXRpb25gIHdoaWNoIGlzIGFuIGFycmF5IHdpdGggYSBzaW5nbGUgZWxlbWVudCAtIGFwcGxpZWQKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbn0uCiAgICAgKi8KCiAgICAvKioKICAgICAqIEV2ZW50IGZpcmVkIHdoZW4ge0BsaW5rICNpbnNlcnRDb250ZW50fSBtZXRob2QgaXMgY2FsbGVkLgogICAgICoKICAgICAqIFRoZSB7QGxpbmsgI2luc2VydENvbnRlbnQgZGVmYXVsdCBhY3Rpb24gb2YgdGhhdCBtZXRob2R9IGlzIGltcGxlbWVudGVkIGFzIGEKICAgICAqIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgc28gaXQgY2FuIGJlIGZ1bGx5IGN1c3RvbWl6ZWQgYnkgdGhlIGZlYXR1cmVzLgogICAgICoKICAgICAqICoqTm90ZSoqIFRoZSBgc2VsZWN0YWJsZWAgcGFyYW1ldGVyIGZvciB0aGUge0BsaW5rICNpbnNlcnRDb250ZW50fSBpcyBvcHRpb25hbC4gV2hlbiBgdW5kZWZpbmVkYCB2YWx1ZSBpcyBwYXNzZWQgdGhlIG1ldGhvZCB1c2VzCiAgICAgKiBgbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uYC4KICAgICAqCiAgICAgKiBAZXZlbnQgaW5zZXJ0Q29udGVudAogICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAgICovCgogICAgLyoqCiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjZGVsZXRlQ29udGVudH0gbWV0aG9kIGlzIGNhbGxlZC4KICAgICAqCiAgICAgKiBUaGUge0BsaW5rICNkZWxldGVDb250ZW50IGRlZmF1bHQgYWN0aW9uIG9mIHRoYXQgbWV0aG9kfSBpcyBpbXBsZW1lbnRlZCBhcyBhCiAgICAgKiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHNvIGl0IGNhbiBiZSBmdWxseSBjdXN0b21pemVkIGJ5IHRoZSBmZWF0dXJlcy4KICAgICAqCiAgICAgKiBAZXZlbnQgZGVsZXRlQ29udGVudAogICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAgICovCgogICAgLyoqCiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjbW9kaWZ5U2VsZWN0aW9ufSBtZXRob2QgaXMgY2FsbGVkLgogICAgICoKICAgICAqIFRoZSB7QGxpbmsgI21vZGlmeVNlbGVjdGlvbiBkZWZhdWx0IGFjdGlvbiBvZiB0aGF0IG1ldGhvZH0gaXMgaW1wbGVtZW50ZWQgYXMgYQogICAgICogbGlzdGVuZXIgdG8gdGhpcyBldmVudCBzbyBpdCBjYW4gYmUgZnVsbHkgY3VzdG9taXplZCBieSB0aGUgZmVhdHVyZXMuCiAgICAgKgogICAgICogQGV2ZW50IG1vZGlmeVNlbGVjdGlvbgogICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAgICovCgogICAgLyoqCiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjZ2V0U2VsZWN0ZWRDb250ZW50fSBtZXRob2QgaXMgY2FsbGVkLgogICAgICoKICAgICAqIFRoZSB7QGxpbmsgI2dldFNlbGVjdGVkQ29udGVudCBkZWZhdWx0IGFjdGlvbiBvZiB0aGF0IG1ldGhvZH0gaXMgaW1wbGVtZW50ZWQgYXMgYQogICAgICogbGlzdGVuZXIgdG8gdGhpcyBldmVudCBzbyBpdCBjYW4gYmUgZnVsbHkgY3VzdG9taXplZCBieSB0aGUgZmVhdHVyZXMuCiAgICAgKgogICAgICogQGV2ZW50IGdldFNlbGVjdGVkQ29udGVudAogICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAgICovCgogIH1dKTsKCiAgcmV0dXJuIE1vZGVsOwp9KCk7CgpleHBvcnQgeyBNb2RlbCBhcyBkZWZhdWx0IH07Cm1peChNb2RlbCwgT2JzZXJ2YWJsZU1peGluKTs="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js"],"names":["Batch","Writer","Schema","Document","MarkerCollection","ObservableMixin","mix","ModelElement","ModelRange","ModelPosition","ModelSelection","OperationFactory","insertContent","deleteContent","modifySelection","getSelectedContent","injectSelectionPostFixer","CKEditorError","Model","markers","document","schema","_pendingChanges","_currentWriter","forEach","methodName","decorate","on","evt","args","operation","_validate","priority","register","isLimit","allowIn","isBlock","isInline","allowContentOf","extend","addChildCheck","context","childDefinition","name","callback","length","push","batch","_runPendingChanges","err","rethrowUnexpectedError","batchOrType","_execute","content","selectable","placeOrOffset","selection","options","rangeOrElement","range","_createIn","isCollapsed","getMarkersIntersectingRange","intersectingMarker","affectsData","ignoreWhitespaces","getItems","item","is","data","search","isObject","root","path","stickiness","itemOrPosition","offset","_createAt","_createAfter","_createBefore","start","end","element","_createOn","type","json","fromJSON","destroy","stopListening","ret","fire","currentBatch","callbackReturnValue","_handleChangeBlock","shift"],"mappings":";;;;;;;;;;;;;AAAA;;;;;AAKA;;;AAIA,OAAOA,KAAP,MAAkB,SAAlB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,OAAOC,QAAP,MAAqB,YAArB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,eAAP,MAA4B,+CAA5B;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AACA,OAAOC,YAAP,MAAyB,WAAzB;AACA,OAAOC,UAAP,MAAuB,SAAvB;AACA,OAAOC,aAAP,MAA0B,YAA1B;AACA,OAAOC,cAAP,MAA2B,aAA3B;AACA,OAAOC,gBAAP,MAA6B,8BAA7B;AAEA,OAAOC,cAAP,MAA0B,uBAA1B;AACA,OAAOC,cAAP,MAA0B,uBAA1B;AACA,OAAOC,gBAAP,MAA4B,yBAA5B;AACA,OAAOC,mBAAP,MAA+B,4BAA/B;AACA,SAASC,wBAAT,QAAyC,8BAAzC;AACA,OAAOC,aAAP,MAA0B,6CAA1B,C,CAEA;AACA;;AAEA;;;;;;;IAMqBC,K;;;AACpB,mBAAc;AAAA;;AAAA;;AACb;;;;;;AAMA,SAAKC,OAAL,GAAe,IAAIf,gBAAJ,EAAf;AAEA;;;;;;;AAMA,SAAKgB,QAAL,GAAgB,IAAIjB,QAAJ,CAAc,IAAd,CAAhB;AAEA;;;;;;;AAMA,SAAKkB,MAAL,GAAc,IAAInB,MAAJ,EAAd;AAEA;;;;;;;;AAOA,SAAKoB,eAAL,GAAuB,EAAvB;AAEA;;;;;;;AAMA,SAAKC,cAAL,GAAsB,IAAtB;AAEA,KAAE,eAAF,EAAmB,eAAnB,EAAoC,iBAApC,EAAuD,oBAAvD,EAA6E,gBAA7E,EACEC,OADF,CACW,UAAAC,UAAU;AAAA,aAAI,KAAI,CAACC,QAAL,CAAeD,UAAf,CAAJ;AAAA,KADrB,EA1Ca,CA6Cb;AACA;;AACA,SAAKE,EAAL,CAAS,gBAAT,EAA2B,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AAC3C,UAAMC,SAAS,GAAGD,IAAI,CAAE,CAAF,CAAtB;;AAEAC,MAAAA,SAAS,CAACC,SAAV;AACA,KAJD,EAIG;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KAJH,EA/Ca,CAqDb;;AACA,SAAKX,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BC,MAAAA,OAAO,EAAE;AADqB,KAA/B;AAGA,SAAKb,MAAL,CAAYY,QAAZ,CAAsB,QAAtB,EAAgC;AAC/BE,MAAAA,OAAO,EAAE,OADsB;AAE/BC,MAAAA,OAAO,EAAE;AAFsB,KAAhC;AAIA,SAAKf,MAAL,CAAYY,QAAZ,CAAsB,OAAtB,EAA+B;AAC9BE,MAAAA,OAAO,EAAE,QADqB;AAE9BE,MAAAA,QAAQ,EAAE;AAFoB,KAA/B;AAIA,SAAKhB,MAAL,CAAYY,QAAZ,CAAsB,kBAAtB,EAA0C;AACzCK,MAAAA,cAAc,EAAE,OADyB;AAEzCJ,MAAAA,OAAO,EAAE;AAFgC,KAA1C;AAIA,SAAKb,MAAL,CAAYkB,MAAZ,CAAoB,OAApB,EAA6B;AAAEJ,MAAAA,OAAO,EAAE;AAAX,KAA7B,EArEa,CAuEb;AACA;AACA;AACA;;AACA,SAAKd,MAAL,CAAYY,QAAZ,CAAsB,SAAtB;AACA,SAAKZ,MAAL,CAAYmB,aAAZ,CAA2B,UAAEC,OAAF,EAAWC,eAAX,EAAgC;AAC1D,UAAKA,eAAe,CAACC,IAAhB,KAAyB,SAA9B,EAA0C;AACzC,eAAO,IAAP;AACA;AACD,KAJD;AAMA3B,IAAAA,wBAAwB,CAAE,IAAF,CAAxB,CAlFa,CAoFb;AACA;AACA;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAmCQ4B,Q,EAAW;AAClB,UAAI;AACH,YAAK,KAAKtB,eAAL,CAAqBuB,MAArB,KAAgC,CAArC,EAAyC;AACxC;AACA,eAAKvB,eAAL,CAAqBwB,IAArB,CAA2B;AAAEC,YAAAA,KAAK,EAAE,IAAI/C,KAAJ,EAAT;AAAsB4C,YAAAA,QAAQ,EAARA;AAAtB,WAA3B;;AAEA,iBAAO,KAAKI,kBAAL,GAA2B,CAA3B,CAAP;AACA,SALD,MAKO;AACN;AACA,iBAAOJ,QAAQ,CAAE,KAAKrB,cAAP,CAAf;AACA;AACD,OAVD,CAUE,OAAQ0B,GAAR,EAAc;AACf;;AACA;AACAhC,QAAAA,aAAa,CAACiC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAiCeE,W,EAAaP,Q,EAAW;AACtC,UAAI;AACH,YAAK,OAAOO,WAAP,KAAuB,QAA5B,EAAuC;AACtCA,UAAAA,WAAW,GAAG,IAAInD,KAAJ,CAAWmD,WAAX,CAAd;AACA,SAFD,MAEO,IAAK,OAAOA,WAAP,IAAsB,UAA3B,EAAwC;AAC9CP,UAAAA,QAAQ,GAAGO,WAAX;AACAA,UAAAA,WAAW,GAAG,IAAInD,KAAJ,EAAd;AACA;;AAED,aAAKsB,eAAL,CAAqBwB,IAArB,CAA2B;AAAEC,UAAAA,KAAK,EAAEI,WAAT;AAAsBP,UAAAA,QAAQ,EAARA;AAAtB,SAA3B;;AAEA,YAAK,KAAKtB,eAAL,CAAqBuB,MAArB,IAA+B,CAApC,EAAwC;AACvC,eAAKG,kBAAL;AACA;AACD,OAbD,CAaE,OAAQC,GAAR,EAAc;AACf;;AACA;AACAhC,QAAAA,aAAa,CAACiC,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD;AAED;;;;;;;;;;;;;;mCAWgBnB,S,EAAY;AAC3B;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEAA,MAAAA,SAAS,CAACsB,QAAV;AACA,K,CAED;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAoHeC,O,EAASC,U,EAAYC,a,EAAgB;AACnD,aAAO3C,cAAa,CAAE,IAAF,EAAQyC,OAAR,EAAiBC,UAAjB,EAA6BC,aAA7B,CAApB;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAiDeC,S,EAAWC,O,EAAU;AACnC5C,MAAAA,cAAa,CAAE,IAAF,EAAQ2C,SAAR,EAAmBC,OAAnB,CAAb;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCA6BiBD,S,EAAWC,O,EAAU;AACrC3C,MAAAA,gBAAe,CAAE,IAAF,EAAQ0C,SAAR,EAAmBC,OAAnB,CAAf;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uCA6BoBD,S,EAAY;AAC/B,aAAOzC,mBAAkB,CAAE,IAAF,EAAQyC,SAAR,CAAzB;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;+BAqBYE,c,EAAgBD,O,EAAU;AACrC,UAAME,KAAK,GAAGD,cAAc,YAAYnD,YAA1B,GAAyCC,UAAU,CAACoD,SAAX,CAAsBF,cAAtB,CAAzC,GAAkFA,cAAhG;;AAEA,UAAKC,KAAK,CAACE,WAAX,EAAyB;AACxB,eAAO,KAAP;AACA,OALoC,CAOrC;;;AAPqC;AAAA;AAAA;;AAAA;AAQrC,6BAAkC,KAAK1C,OAAL,CAAa2C,2BAAb,CAA0CH,KAA1C,CAAlC,8HAAsF;AAAA,cAA1EI,kBAA0E;;AACrF,cAAKA,kBAAkB,CAACC,WAAxB,EAAsC;AACrC,mBAAO,IAAP;AACA;AACD;AAZoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,iBAcCP,OAAO,IAAI,EAdZ;AAAA,uCAc7BQ,iBAd6B;AAAA,UAc7BA,iBAd6B,sCAcT,KAdS;;AAAA;AAAA;AAAA;;AAAA;AAgBrC,8BAAoBN,KAAK,CAACO,QAAN,EAApB,mIAAuC;AAAA,cAA3BC,IAA2B;;AACtC,cAAKA,IAAI,CAACC,EAAL,CAAS,WAAT,CAAL,EAA8B;AAC7B,gBAAK,CAACH,iBAAN,EAA0B;AACzB,qBAAO,IAAP;AACA,aAFD,MAEO,IAAKE,IAAI,CAACE,IAAL,CAAUC,MAAV,CAAkB,IAAlB,MAA6B,CAAC,CAAnC,EAAuC;AAC7C,qBAAO,IAAP;AACA;AACD,WAND,MAMO,IAAK,KAAKjD,MAAL,CAAYkD,QAAZ,CAAsBJ,IAAtB,CAAL,EAAoC;AAC1C,mBAAO,IAAP;AACA;AACD;AA1BoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4BrC,aAAO,KAAP;AACA;AAED;;;;;;;;;;;;;;;2CAYwBK,I,EAAMC,I,EAAMC,U,EAAa;AAChD,aAAO,IAAIjE,aAAJ,CAAmB+D,IAAnB,EAAyBC,IAAzB,EAA+BC,UAA/B,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;qCAqBkBC,c,EAAgBC,M,EAAS;AAC1C,aAAOnE,aAAa,CAACoE,SAAd,CAAyBF,cAAzB,EAAyCC,MAAzC,CAAP;AACA;AAED;;;;;;;;;;;;wCASqBT,I,EAAO;AAC3B,aAAO1D,aAAa,CAACqE,YAAd,CAA4BX,IAA5B,CAAP;AACA;AAED;;;;;;;;;;;;yCASsBA,I,EAAO;AAC5B,aAAO1D,aAAa,CAACsE,aAAd,CAA6BZ,IAA7B,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;gCAeaa,K,EAAOC,G,EAAM;AACzB,aAAO,IAAIzE,UAAJ,CAAgBwE,KAAhB,EAAuBC,GAAvB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;kCAceC,O,EAAU;AACxB,aAAO1E,UAAU,CAACoD,SAAX,CAAsBsB,OAAtB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;kCAaef,I,EAAO;AACrB,aAAO3D,UAAU,CAAC2E,SAAX,CAAsBhB,IAAtB,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAuDiBb,U,EAAYC,a,EAAeE,O,EAAU;AACrD,aAAO,IAAI/C,cAAJ,CAAoB4C,UAApB,EAAgCC,aAAhC,EAA+CE,OAA/C,CAAP;AACA;AAED;;;;;;;;;;;;;;gCAWa2B,I,EAAO;AACnB,aAAO,IAAIpF,KAAJ,CAAWoF,IAAX,CAAP;AACA;AAED;;;;;;;;;;;4CAQyBC,I,EAAO;AAC/B,aAAO1E,gBAAgB,CAAC2E,QAAjB,CAA2BD,IAA3B,EAAiC,KAAKjE,QAAtC,CAAP;AACA;AAED;;;;;;8BAGU;AACT,WAAKA,QAAL,CAAcmE,OAAd;AACA,WAAKC,aAAL;AACA;AAED;;;;;;;;;;yCAOqB;AACpB,UAAMC,GAAG,GAAG,EAAZ;AAEA,WAAKC,IAAL,CAAW,gBAAX;;AAEA,aAAQ,KAAKpE,eAAL,CAAqBuB,MAA7B,EAAsC;AACrC;AACA,YAAM8C,YAAY,GAAG,KAAKrE,eAAL,CAAsB,CAAtB,EAA0ByB,KAA/C;AACA,aAAKxB,cAAL,GAAsB,IAAItB,MAAJ,CAAY,IAAZ,EAAkB0F,YAAlB,CAAtB,CAHqC,CAKrC;;AACA,YAAMC,mBAAmB,GAAG,KAAKtE,eAAL,CAAsB,CAAtB,EAA0BsB,QAA1B,CAAoC,KAAKrB,cAAzC,CAA5B;;AACAkE,QAAAA,GAAG,CAAC3C,IAAJ,CAAU8C,mBAAV;;AAEA,aAAKxE,QAAL,CAAcyE,kBAAd,CAAkC,KAAKtE,cAAvC;;AAEA,aAAKD,eAAL,CAAqBwE,KAArB;;AACA,aAAKvE,cAAL,GAAsB,IAAtB;AACA;;AAED,WAAKmE,IAAL,CAAW,eAAX;AAEA,aAAOD,GAAP;AACA;AAED;;;;;;;;AAQA;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;AAaA;;;;;;;;;;AAUA;;;;;;;;;;AAUA;;;;;;;;;;;;;;;SA90BoBvE,K;AAy1BrBZ,GAAG,CAAEY,KAAF,EAASb,eAAT,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\n\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\nimport OperationFactory from './operation/operationfactory';\n\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model {\n\tconstructor() {\n\t\t/**\n\t\t * Model's marker collection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis.markers = new MarkerCollection();\n\n\t\t/**\n\t\t * Model's document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis.document = new Document( this );\n\n\t\t/**\n\t\t * Model's schema.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/schema~Schema}\n\t\t */\n\t\tthis.schema = new Schema();\n\n\t\t/**\n\t\t * All callbacks added by {@link module:engine/model/model~Model#change} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Function>}\n\t\t */\n\t\tthis._pendingChanges = [];\n\n\t\t/**\n\t\t * The last created and currently used writer instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/writer~Writer}\n\t\t */\n\t\tthis._currentWriter = null;\n\n\t\t[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation' ]\n\t\t\t.forEach( methodName => this.decorate( methodName ) );\n\n\t\t// Adding operation validation with `highest` priority, so it is called before any other feature would like\n\t\t// to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\t\tthis.on( 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\toperation._validate();\n\t\t}, { priority: 'highest' } );\n\n\t\t// Register some default abstract entities.\n\t\tthis.schema.register( '$root', {\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.register( '$block', {\n\t\t\tallowIn: '$root',\n\t\t\tisBlock: true\n\t\t} );\n\t\tthis.schema.register( '$text', {\n\t\t\tallowIn: '$block',\n\t\t\tisInline: true\n\t\t} );\n\t\tthis.schema.register( '$clipboardHolder', {\n\t\t\tallowContentOf: '$root',\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.extend( '$text', { allowIn: '$clipboardHolder' } );\n\n\t\t// An element needed by the `upcastElementToMarker` converter.\n\t\t// This element temporarily represents a marker boundary during the conversion process and is removed\n\t\t// at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n\t\t// better place for this registration but both know nothing about `Schema`.\n\t\tthis.schema.register( '$marker' );\n\t\tthis.schema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( childDefinition.name === '$marker' ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\tinjectSelectionPostFixer( this );\n\n\t\t// @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n\t\t// @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n\t\t// @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n\t * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n\t * the {@link module:engine/model/document~Document#selection document's selection}, and\n\t * {@link module:engine/model/model~Model#markers model markers}.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n\t * into a single undo step.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n\t *\n\t *\t\t\tmodel.change( writer => {\n\t *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n\t *\t\t} );\n\t *\n\t * The callback of the `change()` block is executed synchronously.\n\t *\n\t * You can also return a value from the change block.\n\t *\n\t *\t\tconst img = model.change( writer => {\n\t *\t\t\treturn writer.createElement( 'img' );\n\t *\t\t} );\n\t *\n\t * @see #enqueueChange\n\t * @param {Function} callback Callback function which may modify the model.\n\t * @returns {*} Value returned by the callback.\n\t */\n\tchange( callback ) {\n\t\ttry {\n\t\t\tif ( this._pendingChanges.length === 0 ) {\n\t\t\t\t// If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n\t\t\t\tthis._pendingChanges.push( { batch: new Batch(), callback } );\n\n\t\t\t\treturn this._runPendingChanges()[ 0 ];\n\t\t\t} else {\n\t\t\t\t// If this is not the outermost block, just execute the callback.\n\t\t\t\treturn callback( this._currentWriter );\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n\t *\n\t * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n\t * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n\t * it will be delayed and executed after the outermost block.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconsole.log( 1 );\n\t *\n\t *\t\t\tmodel.enqueueChange( writer => {\n\t *\t\t\t\tconsole.log( 2 );\n\t *\t\t\t} );\n\t *\n\t * \t\t\tconsole.log( 3 );\n\t *\t\t} ); // Will log: 1, 3, 2.\n\t *\n\t * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n\t * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n\t * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n\t *\n\t * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n\t *\n\t *\t\tmodel.enqueueChange( batch, writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * The batch instance can be obtained from {@link module:engine/model/writer~Writer#batch the writer}.\n\t *\n\t * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n\t * If not defined, a new batch will be created.\n\t * @param {Function} callback Callback function which may modify the model.\n\t */\n\tenqueueChange( batchOrType, callback ) {\n\t\ttry {\n\t\t\tif ( typeof batchOrType === 'string' ) {\n\t\t\t\tbatchOrType = new Batch( batchOrType );\n\t\t\t} else if ( typeof batchOrType == 'function' ) {\n\t\t\t\tcallback = batchOrType;\n\t\t\t\tbatchOrType = new Batch();\n\t\t\t}\n\n\t\t\tthis._pendingChanges.push( { batch: batchOrType, callback } );\n\n\t\t\tif ( this._pendingChanges.length == 1 ) {\n\t\t\t\tthis._runPendingChanges();\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n\t * {@link module:engine/model/operation/operation~Operation operations} to the model.\n\t *\n\t * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n\t * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n\t * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n\t * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n\t */\n\tapplyOperation( operation ) {\n\t\t// @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n\n\t\t// @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n\t\t// @if CK_DEBUG_ENGINE // }\n\n\t\t// @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n\n\t\t// @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n\t\t// @if CK_DEBUG_ENGINE //}\n\n\t\t// @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n\n\t\toperation._execute();\n\t}\n\n\t// @if CK_DEBUG_ENGINE // getAppliedOperation() {\n\t// @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\t\treturn '';\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t/**\n\t * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n\t * functionality to work.\n\t *\n\t * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n\t * the content, clears the given selection's content before inserting nodes and moves the selection\n\t * to its target position at the end of the process.\n\t * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n\t * pasting feature should do.\n\t *\n\t * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n\t *\n\t * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n\t * inside a {@link #change `change()` block}.\n\t *\n\t * # Conversion and schema\n\t *\n\t * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n\t * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n\t * is only adding nodes to the model. Additionally, you need to define\n\t * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n\t * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n\t *\n\t * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n\t * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n\t * unless converters are defined for all elements and attributes in that HTML.\n\t *\n\t * # Examples\n\t *\n\t * Using `insertContent()` with a manually created model structure:\n\t *\n\t *\t\t// Let's create a document fragment containing such content as:\n\t *\t\t//\n\t *\t\t// <paragraph>foo</paragraph>\n\t *\t\t// <blockQuote>\n\t *\t\t//    <paragraph>bar</paragraph>\n\t *\t\t// </blockQuote>\n\t *\t\tconst docFrag = editor.model.change( writer => {\n\t *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n\t *\t\t\tconst docFrag = writer.createDocumentFragment();\n\t *\n\t *\t\t\twriter.append( p1, docFrag );\n\t *\t\t\twriter.append( blockQuote, docFrag );\n\t *\t\t\twriter.append( p2, blockQuote );\n\t *\t\t\twriter.insertText( 'foo', p1 );\n\t *\t\t\twriter.insertText( 'bar', p2 );\n\t *\n\t *\t\t\treturn docFrag;\n\t *\t\t} );\n\t *\n\t *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n\t *\t\t// so this code could be moved to the callback defined above.\n\t *\t\teditor.model.insertContent( docFrag );\n\t *\n\t * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n\t *\n\t *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n\t *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n\t *\t\tconst htmlDP = new HtmlDataProcessor( viewDocument );\n\t *\n\t *\t\t// Convert an HTML string to a view document fragment:\n\t *\t\tconst viewFragment = htmlDP.toView( htmlString );\n\t *\n\t *\t\t// Convert the view document fragment to a model document fragment\n\t *\t\t// in the context of $root. This conversion takes the schema into\n\t *\t\t// account so if, for example, the view document fragment contained a bare text node,\n\t *\t\t// this text node cannot be a child of $root, so it will be automatically\n\t *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n\t *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n\t *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n\t *\t\t// which has a loosened schema.\n\t *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n\t *\n\t *\t\teditor.model.insertContent( modelFragment );\n\t *\n\t * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n\t *\n\t *\t\t// Insert text at the current document selection position.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n\t *\t\t} );\n\t *\n\t *\t\t// Insert text at a given position - the document selection will not be modified.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n\t *\n\t *\t\t\t// Which is a shorthand for:\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n\t *\t\t} );\n\t *\n\t * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable`\n\t * it will be moved to the target position (where the document selection should be moved after the insertion).\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\t// Insert text replacing the given selection instance.\n\t *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n\t *\n\t *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n\t *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n\t *\t\t\twriter.setSelection( selection );\n\t *\t\t} );\n\t *\n\t * @fires insertContent\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n\t * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n\t * This param defines a position in relation to that item.\n\t * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n\t * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n\t * at the insertion position.\n\t */\n\tinsertContent( content, selectable, placeOrOffset ) {\n\t\treturn insertContent( this, content, selectable, placeOrOffset );\n\t}\n\n\t/**\n\t * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n\t *\n\t * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n\t * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n\t * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n\t * then that behavior should be implemented in the view's listener. At the same time, the table feature\n\t * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n\t * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n\t * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n\t *\n\t * @fires deleteContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection of which the content should be deleted.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n\t *\n\t * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n\t *\n\t * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n\t * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n\t *\n\t * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n\t * elements will not be merged.\n\t *\n\t * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n\t * paragraph when the entire content was selected.\n\t *\n\t * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n\t *\n\t * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n\t * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n\t *\n\t * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n\t * to a place where text cannot be inserted.\n\t *\n\t * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n\t *\n\t * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n\t * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n\t *\n\t * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n\t *\n\t * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n\t *\n\t * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.\n\t * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to\n\t * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.\n\t */\n\tdeleteContent( selection, options ) {\n\t\tdeleteContent( this, selection, options );\n\t}\n\n\t/**\n\t * Modifies the selection. Currently, the supported modifications are:\n\t *\n\t * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n\t * Possible values for `unit` are:\n\t *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n\t *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n\t *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n\t *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n\t *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n\t *  why `'character'` value is most natural and common method of modifying selection.\n\t *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n\t *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n\t *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n\t *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n\t *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n\t *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n\t *  extension will include whole \"surrogate pair\".\n\t *  * `'word'` - moves selection by a whole word.\n\t *\n\t * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n\t *\n\t * @fires modifySelection\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection to modify.\n\t * @param {Object} [options]\n\t * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n\t */\n\tmodifySelection( selection, options ) {\n\t\tmodifySelection( this, selection, options );\n\t}\n\n\t/**\n\t * Gets a clone of the selected content.\n\t *\n\t * For example, for the following selection:\n\t *\n\t * ```html\n\t * <paragraph>x</paragraph>\n\t * <blockQuote>\n\t *\t<paragraph>y</paragraph>\n\t *\t<heading1>fir[st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se]cond</paragraph>\n\t * <paragraph>z</paragraph>\n\t * ```\n\t *\n\t * It will return a document fragment with such a content:\n\t *\n\t * ```html\n\t * <blockQuote>\n\t *\t<heading1>st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se</paragraph>\n\t * ```\n\t *\n\t * @fires getSelectedContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection of which content will be returned.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetSelectedContent( selection ) {\n\t\treturn getSelectedContent( this, selection );\n\t}\n\n\t/**\n\t * Checks whether the given {@link module:engine/model/range~Range range} or\n\t * {@link module:engine/model/element~Element element} has any meaningful content.\n\t *\n\t * Meaningful content is:\n\t *\n\t * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n\t * any non-whitespace characters),\n\t * * or any {@link module:engine/model/schema~Schema#isObject object element},\n\t * * or any {@link module:engine/model/markercollection~Marker marker} which\n\t * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n\t *\n\t * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n\t * However, a range containing an `<image></image>` (which would normally be marked in the schema as an object element)\n\t * is considered non-empty.\n\t *\n\t * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n\t * @returns {Boolean}\n\t */\n\thasContent( rangeOrElement, options ) {\n\t\tconst range = rangeOrElement instanceof ModelElement ? ModelRange._createIn( rangeOrElement ) : rangeOrElement;\n\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there are any markers which affects data in this given range.\n\t\tfor ( const intersectingMarker of this.markers.getMarkersIntersectingRange( range ) ) {\n\t\t\tif ( intersectingMarker.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tconst { ignoreWhitespaces = false } = options || {};\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tif ( item.is( 'textProxy' ) ) {\n\t\t\t\tif ( !ignoreWhitespaces ) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if ( item.data.search( /\\S/ ) !== -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if ( this.schema.isObject( item ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a position from the given root and path in that root.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn new ModelPosition( root, path, stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * a parent element and offset in that element,\n\t * * a parent element and `'end'` (the position will be set at the end of that element),\n\t * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n\t * (the position will be set before or after the given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n\t * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn ModelPosition._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn ModelPosition._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn ModelPosition._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from the `start` position to the `end` position.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRange( start, end );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n\t * to the `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new ModelRange( start, end );\n\t}\n\n\t/**\n\t * Creates a range inside the given element which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeIn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn ModelRange._createIn( element );\n\t}\n\n\t/**\n\t * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * Note: This method is also available on `writer` instance as\n\t * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeOn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn ModelRange._createOn( item );\n\t}\n\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new ModelSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/batch~Batch} instance.\n\t *\n\t * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n\t *\n\t * * {@link #change `change()`},\n\t * * {@link #enqueueChange `enqueueChange()`}.\n\t *\n\t * @param {'transparent'|'default'} [type='default'] The type of the batch.\n\t * @returns {module:engine/model/batch~Batch}\n\t */\n\tcreateBatch( type ) {\n\t\treturn new Batch( type );\n\t}\n\n\t/**\n\t * Creates an operation instance from a JSON object (parsed JSON string).\n\t *\n\t * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.\n\t *\n\t * @param {Object} json Deserialized JSON object.\n\t * @returns {module:engine/model/operation/operation~Operation}\n\t */\n\tcreateOperationFromJSON( json ) {\n\t\treturn OperationFactory.fromJSON( json, this.document );\n\t}\n\n\t/**\n\t * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n\t */\n\tdestroy() {\n\t\tthis.document.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n\t * which calls callbacks and returns array of values returned by these callbacks.\n\t *\n\t * @private\n\t * @returns {Array.<*>} Array of values returned by callbacks.\n\t */\n\t_runPendingChanges() {\n\t\tconst ret = [];\n\n\t\tthis.fire( '_beforeChanges' );\n\n\t\twhile ( this._pendingChanges.length ) {\n\t\t\t// Create a new writer using batch instance created for this chain of changes.\n\t\t\tconst currentBatch = this._pendingChanges[ 0 ].batch;\n\t\t\tthis._currentWriter = new Writer( this, currentBatch );\n\n\t\t\t// Execute changes callback and gather the returned value.\n\t\t\tconst callbackReturnValue = this._pendingChanges[ 0 ].callback( this._currentWriter );\n\t\t\tret.push( callbackReturnValue );\n\n\t\t\tthis.document._handleChangeBlock( this._currentWriter );\n\n\t\t\tthis._pendingChanges.shift();\n\t\t\tthis._currentWriter = null;\n\t\t}\n\n\t\tthis.fire( '_afterChanges' );\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _beforeChanges\n\t */\n\n\t/**\n\t * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _afterChanges\n\t */\n\n\t/**\n\t * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n\t * using {@link #applyOperation}.\n\t *\n\t * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n\t * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n\t * be used.\n\t *\n\t * A few callbacks are already added to this event by engine internal classes:\n\t *\n\t * * with `highest` priority operation is validated,\n\t * * with `normal` priority operation is executed,\n\t * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n\t * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n\t * update themselves.\n\t *\n\t * @event applyOperation\n\t * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t */\n\n\t/**\n\t * Event fired when {@link #insertContent} method is called.\n\t *\n\t * The {@link #insertContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n\t * `model.document.selection`.\n\t *\n\t * @event insertContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #deleteContent} method is called.\n\t *\n\t * The {@link #deleteContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event deleteContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #modifySelection} method is called.\n\t *\n\t * The {@link #modifySelection default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event modifySelection\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #getSelectedContent} method is called.\n\t *\n\t * The {@link #getSelectedContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event getSelectedContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n}\n\nmix( Model, ObservableMixin );\n"]}]}