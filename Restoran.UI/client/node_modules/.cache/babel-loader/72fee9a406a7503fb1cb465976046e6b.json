{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\mapper.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\conversion\\mapper.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1581760786382},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5tYXAiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvY29udmVyc2lvbi9tYXBwZXIKICovCmltcG9ydCBNb2RlbFBvc2l0aW9uIGZyb20gJy4uL21vZGVsL3Bvc2l0aW9uJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwppbXBvcnQgVmlld1Bvc2l0aW9uIGZyb20gJy4uL3ZpZXcvcG9zaXRpb24nOwppbXBvcnQgVmlld1JhbmdlIGZyb20gJy4uL3ZpZXcvcmFuZ2UnOwppbXBvcnQgVmlld1RleHQgZnJvbSAnLi4vdmlldy90ZXh0JzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7Ci8qKgogKiBNYXBzIGVsZW1lbnRzLCBwb3NpdGlvbnMgYW5kIG1hcmtlcnMgYmV0d2VlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50fkRvY3VtZW50IHRoZSB2aWV3fSBhbmQKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWwgdGhlIG1vZGVsfS4KICoKICogVGhlIGluc3RhbmNlIG9mIHRoZSBNYXBwZXIgdXNlZCBmb3IgdGhlIGVkaXRpbmcgcGlwZWxpbmUgaXMgYXZhaWxhYmxlIGluCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnRyb2xsZXIvZWRpdGluZ2NvbnRyb2xsZXJ+RWRpdGluZ0NvbnRyb2xsZXIjbWFwcGVyIGBlZGl0b3IuZWRpdGluZy5tYXBwZXJgfS4KICoKICogTWFwcGVyIHVzZXMgYm91bmQgZWxlbWVudHMgdG8gZmluZCBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGFuZCBwb3NpdGlvbnMsIHNvLCB0byBnZXQgcHJvcGVyIHJlc3VsdHMsCiAqIGFsbCBtb2RlbCBlbGVtZW50cyBzaG91bGQgYmUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI2JpbmRFbGVtZW50cyBib3VuZH0uCiAqCiAqIFRvIG1hcCBjb21wbGV4IG1vZGVsIHRvL2Zyb20gdmlldyByZWxhdGlvbnMsIHlvdSBtYXkgcHJvdmlkZSBjdXN0b20gY2FsbGJhY2tzIGZvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6bW9kZWxUb1ZpZXdQb3NpdGlvbiBtb2RlbFRvVmlld1Bvc2l0aW9uIGV2ZW50fSBhbmQKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI2V2ZW50OnZpZXdUb01vZGVsUG9zaXRpb24gdmlld1RvTW9kZWxQb3NpdGlvbiBldmVudH0gdGhhdCBhcmUgZmlyZWQgd2hlbmV2ZXIKICogYSBwb3NpdGlvbiBtYXBwaW5nIHJlcXVlc3Qgb2NjdXJzLgogKiBUaG9zZSBldmVudHMgYXJlIGZpcmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciN0b1ZpZXdQb3NpdGlvbiB0b1ZpZXdQb3NpdGlvbn0KICogYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciN0b01vZGVsUG9zaXRpb24gdG9Nb2RlbFBvc2l0aW9ufSBtZXRob2RzLiBgTWFwcGVyYCBhZGRzIGl0J3Mgb3duIGRlZmF1bHQgY2FsbGJhY2tzCiAqIHdpdGggYCdsb3dlc3QnYCBwcmlvcml0eS4gVG8gb3ZlcnJpZGUgZGVmYXVsdCBgTWFwcGVyYCBtYXBwaW5nLCBhZGQgY3VzdG9tIGNhbGxiYWNrIHdpdGggaGlnaGVyIHByaW9yaXR5IGFuZAogKiBzdG9wIHRoZSBldmVudC4KICovCgp2YXIgTWFwcGVyID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgbWFwcGVyLgogICAqLwogIGZ1bmN0aW9uIE1hcHBlcigpIHsKICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcHBlcik7CgogICAgLyoqCiAgICAgKiBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCiAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgY29udGFpbmluZyBjYWxsYmFja3MgYmV0d2VlbiB2aWV3IGVsZW1lbnQgbmFtZXMgYW5kIGZ1bmN0aW9ucyBldmFsdWF0aW5nIGxlbmd0aCBvZiB2aWV3IGVsZW1lbnRzCiAgICAgKiBpbiBtb2RlbC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3MgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIE1vZGVsIG1hcmtlciBuYW1lIHRvIHZpZXcgZWxlbWVudHMgbWFwcGluZy4KICAgICAqCiAgICAgKiBLZXlzIGFyZSBgU3RyaW5nYHMgd2hpbGUgdmFsdWVzIGFyZSBgU2V0YHMgd2l0aCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnRzfS4KICAgICAqIE9uZSBtYXJrZXIgKG5hbWUpIGNhbiBiZSBtYXBwZWQgdG8gbXVsdGlwbGUgZWxlbWVudHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcH0KICAgICAqLwoKICAgIHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgbWFya2VyIG5hbWVzIG1hcHBpbmcuCiAgICAgKgogICAgICogVGhpcyBpcyByZXZlcnNlIHRvIHtAbGluayB+TWFwcGVyI19tYXJrZXJOYW1lVG9FbGVtZW50c30gbWFwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogU3RvcmVzIG1hcmtlciBuYW1lcyBvZiBtYXJrZXJzIHdoaWNoIGhhcyBjaGFuZ2VkIGR1ZSB0byB1bmJpbmRpbmcgYSB2aWV3IGVsZW1lbnQgKHNvIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdmlldyBlbGVtZW50CiAgICAgKiBoYXMgYmVlbiByZW1vdmVkLCBtb3ZlZCBvciByZW5hbWVkKS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7U2V0Ljxtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyPn0KICAgICAqLwoKICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyA9IG5ldyBTZXQoKTsgLy8gRGVmYXVsdCBtYXBwZXIgYWxnb3JpdGhtIGZvciBtYXBwaW5nIG1vZGVsIHBvc2l0aW9uIHRvIHZpZXcgcG9zaXRpb24uCgogICAgdGhpcy5vbignbW9kZWxUb1ZpZXdQb3NpdGlvbicsIGZ1bmN0aW9uIChldnQsIGRhdGEpIHsKICAgICAgaWYgKGRhdGEudmlld1Bvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgdmlld0NvbnRhaW5lciA9IF90aGlzLl9tb2RlbFRvVmlld01hcHBpbmcuZ2V0KGRhdGEubW9kZWxQb3NpdGlvbi5wYXJlbnQpOwoKICAgICAgZGF0YS52aWV3UG9zaXRpb24gPSBfdGhpcy5fZmluZFBvc2l0aW9uSW4odmlld0NvbnRhaW5lciwgZGF0YS5tb2RlbFBvc2l0aW9uLm9mZnNldCk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93JwogICAgfSk7IC8vIERlZmF1bHQgbWFwcGVyIGFsZ29yaXRobSBmb3IgbWFwcGluZyB2aWV3IHBvc2l0aW9uIHRvIG1vZGVsIHBvc2l0aW9uLgoKICAgIHRoaXMub24oJ3ZpZXdUb01vZGVsUG9zaXRpb24nLCBmdW5jdGlvbiAoZXZ0LCBkYXRhKSB7CiAgICAgIGlmIChkYXRhLm1vZGVsUG9zaXRpb24pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciB2aWV3QmxvY2sgPSBfdGhpcy5maW5kTWFwcGVkVmlld0FuY2VzdG9yKGRhdGEudmlld1Bvc2l0aW9uKTsKCiAgICAgIHZhciBtb2RlbFBhcmVudCA9IF90aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuZ2V0KHZpZXdCbG9jayk7CgogICAgICB2YXIgbW9kZWxPZmZzZXQgPSBfdGhpcy5fdG9Nb2RlbE9mZnNldChkYXRhLnZpZXdQb3NpdGlvbi5wYXJlbnQsIGRhdGEudmlld1Bvc2l0aW9uLm9mZnNldCwgdmlld0Jsb2NrKTsKCiAgICAgIGRhdGEubW9kZWxQb3NpdGlvbiA9IE1vZGVsUG9zaXRpb24uX2NyZWF0ZUF0KG1vZGVsUGFyZW50LCBtb2RlbE9mZnNldCk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93JwogICAgfSk7CiAgfQogIC8qKgogICAqIE1hcmtzIG1vZGVsIGFuZCB2aWV3IGVsZW1lbnRzIGFzIGNvcnJlc3BvbmRpbmcuIENvcnJlc3BvbmRpbmcgZWxlbWVudHMgY2FuIGJlIHJldHJpZXZlZCBieSB1c2luZwogICAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjdG9Nb2RlbEVsZW1lbnQgdG9Nb2RlbEVsZW1lbnR9IGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciN0b1ZpZXdFbGVtZW50IHRvVmlld0VsZW1lbnR9IG1ldGhvZHMuCiAgICogVGhlIGluZm9ybWF0aW9uIHRoYXQgZWxlbWVudHMgYXJlIGJvdW5kIGlzIGFsc28gdXNlZCB0byB0cmFuc2xhdGUgcG9zaXRpb25zLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gbW9kZWxFbGVtZW50IE1vZGVsIGVsZW1lbnQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudCBWaWV3IGVsZW1lbnQuCiAgICovCgoKICBfY3JlYXRlQ2xhc3MoTWFwcGVyLCBbewogICAga2V5OiAiYmluZEVsZW1lbnRzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRWxlbWVudHMobW9kZWxFbGVtZW50LCB2aWV3RWxlbWVudCkgewogICAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcuc2V0KG1vZGVsRWxlbWVudCwgdmlld0VsZW1lbnQpOwoKICAgICAgdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLnNldCh2aWV3RWxlbWVudCwgbW9kZWxFbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogVW5iaW5kcyBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9IGZyb20gdGhlIG1hcC4KICAgICAqCiAgICAgKiAqKk5vdGU6Kiogdmlldy10by1tb2RlbCBiaW5kaW5nIHdpbGwgYmUgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC4gSG93ZXZlciwgY29ycmVzcG9uZGluZyBtb2RlbC10by12aWV3IGJpbmRpbmcKICAgICAqIHdpbGwgYmUgcmVtb3ZlZCBvbmx5IGlmIG1vZGVsIGVsZW1lbnQgaXMgc3RpbGwgYm91bmQgdG8gcGFzc2VkIGB2aWV3RWxlbWVudGAuCiAgICAgKgogICAgICogVGhpcyBiZWhhdmlvciBsZXRzIGZvciByZS1iaW5kaW5nIG1vZGVsIGVsZW1lbnQgdG8gYW5vdGhlciB2aWV3IGVsZW1lbnQgd2l0aG91dCBmZWFyIG9mIGxvc2luZyB0aGUgbmV3IGJpbmRpbmcKICAgICAqIHdoZW4gdGhlIHByZXZpb3VzbHkgYm91bmQgdmlldyBlbGVtZW50IGlzIHVuYm91bmQuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudCBWaWV3IGVsZW1lbnQgdG8gdW5iaW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInVuYmluZFZpZXdFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRWaWV3RWxlbWVudCh2aWV3RWxlbWVudCkgewogICAgICB2YXIgbW9kZWxFbGVtZW50ID0gdGhpcy50b01vZGVsRWxlbWVudCh2aWV3RWxlbWVudCk7CgogICAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuZGVsZXRlKHZpZXdFbGVtZW50KTsKCiAgICAgIGlmICh0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5oYXModmlld0VsZW1lbnQpKSB7CiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlOwogICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDsKCiAgICAgICAgdHJ5IHsKICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLmdldCh2aWV3RWxlbWVudClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7CiAgICAgICAgICAgIHZhciBtYXJrZXJOYW1lID0gX3N0ZXAudmFsdWU7CgogICAgICAgICAgICB0aGlzLl91bmJvdW5kTWFya2VyTmFtZXMuYWRkKG1hcmtlck5hbWUpOwogICAgICAgICAgfQogICAgICAgIH0gY2F0Y2ggKGVycikgewogICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmdldChtb2RlbEVsZW1lbnQpID09IHZpZXdFbGVtZW50KSB7CiAgICAgICAgdGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmRlbGV0ZShtb2RlbEVsZW1lbnQpOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIFVuYmluZHMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IG1vZGVsIGVsZW1lbnR9IGZyb20gdGhlIG1hcC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogbW9kZWwtdG8tdmlldyBiaW5kaW5nIHdpbGwgYmUgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC4gSG93ZXZlciwgY29ycmVzcG9uZGluZyB2aWV3LXRvLW1vZGVsIGJpbmRpbmcKICAgICAqIHdpbGwgYmUgcmVtb3ZlZCBvbmx5IGlmIHZpZXcgZWxlbWVudCBpcyBzdGlsbCBib3VuZCB0byBwYXNzZWQgYG1vZGVsRWxlbWVudGAuCiAgICAgKgogICAgICogVGhpcyBiZWhhdmlvciBsZXRzIGZvciByZS1iaW5kaW5nIHZpZXcgZWxlbWVudCB0byBhbm90aGVyIG1vZGVsIGVsZW1lbnQgd2l0aG91dCBmZWFyIG9mIGxvc2luZyB0aGUgbmV3IGJpbmRpbmcKICAgICAqIHdoZW4gdGhlIHByZXZpb3VzbHkgYm91bmQgbW9kZWwgZWxlbWVudCBpcyB1bmJvdW5kLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG1vZGVsRWxlbWVudCBNb2RlbCBlbGVtZW50IHRvIHVuYmluZC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ1bmJpbmRNb2RlbEVsZW1lbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZE1vZGVsRWxlbWVudChtb2RlbEVsZW1lbnQpIHsKICAgICAgdmFyIHZpZXdFbGVtZW50ID0gdGhpcy50b1ZpZXdFbGVtZW50KG1vZGVsRWxlbWVudCk7CgogICAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcuZGVsZXRlKG1vZGVsRWxlbWVudCk7CgogICAgICBpZiAodGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLmdldCh2aWV3RWxlbWVudCkgPT0gbW9kZWxFbGVtZW50KSB7CiAgICAgICAgdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLmRlbGV0ZSh2aWV3RWxlbWVudCk7CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogQmluZHMgZ2l2ZW4gbWFya2VyIG5hbWUgd2l0aCBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnR9LiBUaGUgZWxlbWVudAogICAgICogd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBzZXQgb2YgZWxlbWVudHMgYm91bmQgd2l0aCBnaXZlbiBtYXJrZXIgbmFtZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBiaW5kLgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTWFya2VyIG5hbWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiYmluZEVsZW1lbnRUb01hcmtlciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEVsZW1lbnRUb01hcmtlcihlbGVtZW50LCBuYW1lKSB7CiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzLmdldChuYW1lKSB8fCBuZXcgU2V0KCk7CiAgICAgIGVsZW1lbnRzLmFkZChlbGVtZW50KTsKICAgICAgdmFyIG5hbWVzID0gdGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuZ2V0KGVsZW1lbnQpIHx8IG5ldyBTZXQoKTsKICAgICAgbmFtZXMuYWRkKG5hbWUpOwoKICAgICAgdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuc2V0KG5hbWUsIGVsZW1lbnRzKTsKCiAgICAgIHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLnNldChlbGVtZW50LCBuYW1lcyk7CiAgICB9CiAgICAvKioKICAgICAqIFVuYmluZHMgYW4gZWxlbWVudCBmcm9tIGdpdmVuIG1hcmtlciBuYW1lLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHVuYmluZC4KICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgogICAgICovCgogIH0sIHsKICAgIGtleTogInVuYmluZEVsZW1lbnRGcm9tTWFya2VyTmFtZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRWxlbWVudEZyb21NYXJrZXJOYW1lKGVsZW1lbnQsIG5hbWUpIHsKICAgICAgdmFyIG5hbWVUb0VsZW1lbnRzID0gdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZ2V0KG5hbWUpOwoKICAgICAgaWYgKG5hbWVUb0VsZW1lbnRzKSB7CiAgICAgICAgbmFtZVRvRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpOwoKICAgICAgICBpZiAobmFtZVRvRWxlbWVudHMuc2l6ZSA9PSAwKSB7CiAgICAgICAgICB0aGlzLl9tYXJrZXJOYW1lVG9FbGVtZW50cy5kZWxldGUobmFtZSk7CiAgICAgICAgfQogICAgICB9CgogICAgICB2YXIgZWxlbWVudFRvTmFtZXMgPSB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5nZXQoZWxlbWVudCk7CgogICAgICBpZiAoZWxlbWVudFRvTmFtZXMpIHsKICAgICAgICBlbGVtZW50VG9OYW1lcy5kZWxldGUobmFtZSk7CgogICAgICAgIGlmIChlbGVtZW50VG9OYW1lcy5zaXplID09IDApIHsKICAgICAgICAgIHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLmRlbGV0ZShlbGVtZW50KTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbGwgbWFya2VyIG5hbWVzIG9mIG1hcmtlcnMgd2hpY2ggaGFzIGNoYW5nZWQgZHVlIHRvIHVuYmluZGluZyBhIHZpZXcgZWxlbWVudCAoc28gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2aWV3IGVsZW1lbnQKICAgICAqIGhhcyBiZWVuIHJlbW92ZWQsIG1vdmVkIG9yIHJlbmFtZWQpIHNpbmNlIHRoZSBsYXN0IGZsdXNoLiBBZnRlciByZXR1cm5pbmcsIHRoZSBtYXJrZXIgbmFtZXMgbGlzdCBpcyBjbGVhcmVkLgogICAgICoKICAgICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmbHVzaFVuYm91bmRNYXJrZXJOYW1lcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmx1c2hVbmJvdW5kTWFya2VyTmFtZXMoKSB7CiAgICAgIHZhciBtYXJrZXJOYW1lcyA9IEFycmF5LmZyb20odGhpcy5fdW5ib3VuZE1hcmtlck5hbWVzKTsKCiAgICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcy5jbGVhcigpOwoKICAgICAgcmV0dXJuIG1hcmtlck5hbWVzOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBtb2RlbCB0byB2aWV3IGFuZCB2aWV3IHRvIG1vZGVsIGJpbmRpbmdzLgogICAgICovCgogIH0sIHsKICAgIGtleTogImNsZWFyQmluZGluZ3MiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQmluZGluZ3MoKSB7CiAgICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgICAgIHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgICAgIHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzID0gbmV3IE1hcCgpOwogICAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcyA9IG5ldyBNYXAoKTsKICAgICAgdGhpcy5fdW5ib3VuZE1hcmtlck5hbWVzID0gbmV3IFNldCgpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIG1vZGVsIGVsZW1lbnQuCiAgICAgKgogICAgICogKipOb3RlOioqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gZG9lcyBub3QgaGF2ZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gbW9kZWwuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudCBWaWV3IGVsZW1lbnQuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8dW5kZWZpbmVkfSBDb3JyZXNwb25kaW5nIG1vZGVsIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvTW9kZWxFbGVtZW50IiwKICAgIHZhbHVlOiBmdW5jdGlvbiB0b01vZGVsRWxlbWVudCh2aWV3RWxlbWVudCkgewogICAgICByZXR1cm4gdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLmdldCh2aWV3RWxlbWVudCk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgdmlldyBlbGVtZW50LgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG1vZGVsRWxlbWVudCBNb2RlbCBlbGVtZW50LgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8dW5kZWZpbmVkfSBDb3JyZXNwb25kaW5nIHZpZXcgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9WaWV3RWxlbWVudCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9WaWV3RWxlbWVudChtb2RlbEVsZW1lbnQpIHsKICAgICAgcmV0dXJuIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5nZXQobW9kZWxFbGVtZW50KTsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCByYW5nZS4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gdmlld1JhbmdlIFZpZXcgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gQ29ycmVzcG9uZGluZyBtb2RlbCByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b01vZGVsUmFuZ2UiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvTW9kZWxSYW5nZSh2aWV3UmFuZ2UpIHsKICAgICAgcmV0dXJuIG5ldyBNb2RlbFJhbmdlKHRoaXMudG9Nb2RlbFBvc2l0aW9uKHZpZXdSYW5nZS5zdGFydCksIHRoaXMudG9Nb2RlbFBvc2l0aW9uKHZpZXdSYW5nZS5lbmQpKTsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyB2aWV3IHJhbmdlLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gbW9kZWxSYW5nZSBNb2RlbCByYW5nZS4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IENvcnJlc3BvbmRpbmcgdmlldyByYW5nZS4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJ0b1ZpZXdSYW5nZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9WaWV3UmFuZ2UobW9kZWxSYW5nZSkgewogICAgICByZXR1cm4gbmV3IFZpZXdSYW5nZSh0aGlzLnRvVmlld1Bvc2l0aW9uKG1vZGVsUmFuZ2Uuc3RhcnQpLCB0aGlzLnRvVmlld1Bvc2l0aW9uKG1vZGVsUmFuZ2UuZW5kKSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgbW9kZWwgcG9zaXRpb24uCiAgICAgKgogICAgICogQGZpcmVzIHZpZXdUb01vZGVsUG9zaXRpb24KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB2aWV3UG9zaXRpb24gVmlldyBwb3NpdGlvbi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBDb3JyZXNwb25kaW5nIG1vZGVsIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvTW9kZWxQb3NpdGlvbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Nb2RlbFBvc2l0aW9uKHZpZXdQb3NpdGlvbikgewogICAgICB2YXIgZGF0YSA9IHsKICAgICAgICB2aWV3UG9zaXRpb246IHZpZXdQb3NpdGlvbiwKICAgICAgICBtYXBwZXI6IHRoaXMKICAgICAgfTsKICAgICAgdGhpcy5maXJlKCd2aWV3VG9Nb2RlbFBvc2l0aW9uJywgZGF0YSk7CiAgICAgIHJldHVybiBkYXRhLm1vZGVsUG9zaXRpb247CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgdmlldyBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAZmlyZXMgbW9kZWxUb1ZpZXdQb3NpdGlvbgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2RlbFBvc2l0aW9uIE1vZGVsIHBvc2l0aW9uLgogICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHBvc2l0aW9uIG1hcHBpbmcgcHJvY2Vzcy4KICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNQaGFudG9tPWZhbHNlXSBTaG91bGQgYmUgc2V0IHRvIGB0cnVlYCBpZiB0aGUgbW9kZWwgcG9zaXRpb24gdG8gbWFwIGlzIHBvaW50aW5nIHRvIGEgcGxhY2UKICAgICAqIGluIG1vZGVsIHRyZWUgd2hpY2ggbm8gbG9uZ2VyIGV4aXN0cy4gRm9yIGV4YW1wbGUsIGl0IGNvdWxkIGJlIGFuIGVuZCBvZiBhIHJlbW92ZWQgbW9kZWwgcmFuZ2UuCiAgICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBDb3JyZXNwb25kaW5nIHZpZXcgcG9zaXRpb24uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAidG9WaWV3UG9zaXRpb24iLAogICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmlld1Bvc2l0aW9uKG1vZGVsUG9zaXRpb24pIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHsKICAgICAgICBpc1BoYW50b206IGZhbHNlCiAgICAgIH07CiAgICAgIHZhciBkYXRhID0gewogICAgICAgIG1vZGVsUG9zaXRpb246IG1vZGVsUG9zaXRpb24sCiAgICAgICAgbWFwcGVyOiB0aGlzLAogICAgICAgIGlzUGhhbnRvbTogb3B0aW9ucy5pc1BoYW50b20KICAgICAgfTsKICAgICAgdGhpcy5maXJlKCdtb2RlbFRvVmlld1Bvc2l0aW9uJywgZGF0YSk7CiAgICAgIHJldHVybiBkYXRhLnZpZXdQb3NpdGlvbjsKICAgIH0KICAgIC8qKgogICAgICogR2V0cyBhbGwgdmlldyBlbGVtZW50cyBib3VuZCB0byB0aGUgZ2l2ZW4gbWFya2VyIG5hbWUuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTWFya2VyIG5hbWUuCiAgICAgKiBAcmV0dXJucyB7U2V0Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50PnxudWxsfSBWaWV3IGVsZW1lbnRzIGJvdW5kIHdpdGggZ2l2ZW4gbWFya2VyIG5hbWUgb3IgYG51bGxgCiAgICAgKiBpZiBubyBlbGVtZW50cyBhcmUgYm91bmQgdG8gZ2l2ZW4gbWFya2VyIG5hbWUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWFya2VyTmFtZVRvRWxlbWVudHMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIG1hcmtlck5hbWVUb0VsZW1lbnRzKG5hbWUpIHsKICAgICAgdmFyIGJvdW5kRWxlbWVudHMgPSB0aGlzLl9tYXJrZXJOYW1lVG9FbGVtZW50cy5nZXQobmFtZSk7CgogICAgICBpZiAoIWJvdW5kRWxlbWVudHMpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgdmFyIGVsZW1lbnRzID0gbmV3IFNldCgpOwogICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlOwogICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7CiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7CgogICAgICB0cnkgewogICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBib3VuZEVsZW1lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7CiAgICAgICAgICB2YXIgZWxlbWVudCA9IF9zdGVwMi52YWx1ZTsKCiAgICAgICAgICBpZiAoZWxlbWVudC5pcygnYXR0cmlidXRlRWxlbWVudCcpKSB7CiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7CiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTsKICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDsKCiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNXaXRoU2FtZUlkKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHsKICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IF9zdGVwMy52YWx1ZTsKICAgICAgICAgICAgICAgIGVsZW1lbnRzLmFkZChjbG9uZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlOwogICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjsKICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZWxlbWVudHMuYWRkKGVsZW1lbnQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTsKICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkgewogICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpOwogICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7CiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBlbGVtZW50czsKICAgIH0KICAgIC8qKgogICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCBldmFsdWF0ZXMgdGhlIGxlbmd0aCBpbiB0aGUgbW9kZWwgb2YgYSB2aWV3IGVsZW1lbnQgd2l0aCBnaXZlbiBuYW1lLgogICAgICoKICAgICAqIFRoZSBjYWxsYmFjayBpcyBmaXJlZCB3aXRoIG9uZSBhcmd1bWVudCwgd2hpY2ggaXMgYSB2aWV3IGVsZW1lbnQgaW5zdGFuY2UuIFRoZSBjYWxsYmFjayBpcyBleHBlY3RlZCB0byByZXR1cm4KICAgICAqIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbGVuZ3RoIG9mIHZpZXcgZWxlbWVudCBpbiBtb2RlbC4KICAgICAqCiAgICAgKgkJLy8gTGlzdCBpdGVtIGluIHZpZXcgbWF5IGNvbnRhaW4gbmVzdGVkIGxpc3QsIHdoaWNoIGhhdmUgb3RoZXIgbGlzdCBpdGVtcy4gSW4gbW9kZWwgdGhvdWdoLAogICAgICoJCS8vIHRoZSBsaXN0cyBhcmUgcmVwcmVzZW50ZWQgYnkgZmxhdCBzdHJ1Y3R1cmUuIEJlY2F1c2Ugb2YgdGhvc2UgZGlmZmVyZW5jZXMsIGxlbmd0aCBvZiBsaXN0IHZpZXcgZWxlbWVudAogICAgICoJCS8vIG1heSBiZSBncmVhdGVyIHRoYW4gb25lLiBJbiB0aGUgY2FsbGJhY2sgaXQncyBjaGVja2VkIGhvdyBtYW55IG5lc3RlZCBsaXN0IGl0ZW1zIGFyZSBpbiBldmFsdWF0ZWQgbGlzdCBpdGVtLgogICAgICoKICAgICAqCQlmdW5jdGlvbiBnZXRWaWV3TGlzdEl0ZW1MZW5ndGgoIGVsZW1lbnQgKSB7CiAgICAgKgkJCWxldCBsZW5ndGggPSAxOwogICAgICoKICAgICAqCQkJZm9yICggbGV0IGNoaWxkIG9mIGVsZW1lbnQuZ2V0Q2hpbGRyZW4oKSApIHsKICAgICAqCQkJCWlmICggY2hpbGQubmFtZSA9PSAndWwnIHx8IGNoaWxkLm5hbWUgPT0gJ29sJyApIHsKICAgICAqCQkJCQlmb3IgKCBsZXQgaXRlbSBvZiBjaGlsZC5nZXRDaGlsZHJlbigpICkgewogICAgICoJCQkJCQlsZW5ndGggKz0gZ2V0Vmlld0xpc3RJdGVtTGVuZ3RoKCBpdGVtICk7CiAgICAgKgkJCQkJfQogICAgICoJCQkJfQogICAgICoJCQl9CiAgICAgKgogICAgICoJCQlyZXR1cm4gbGVuZ3RoOwogICAgICoJCX0KICAgICAqCiAgICAgKgkJbWFwcGVyLnJlZ2lzdGVyVmlld1RvTW9kZWxMZW5ndGgoICdsaScsIGdldFZpZXdMaXN0SXRlbUxlbmd0aCApOwogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3RWxlbWVudE5hbWUgTmFtZSBvZiB2aWV3IGVsZW1lbnQgZm9yIHdoaWNoIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQuCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsZW5ndGhDYWxsYmFjayBGdW5jdGlvbiByZXR1cm4gYSBsZW5ndGggb2YgdmlldyBlbGVtZW50IGluc3RhbmNlIGluIG1vZGVsLgogICAgICovCgogIH0sIHsKICAgIGtleTogInJlZ2lzdGVyVmlld1RvTW9kZWxMZW5ndGgiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyVmlld1RvTW9kZWxMZW5ndGgodmlld0VsZW1lbnROYW1lLCBsZW5ndGhDYWxsYmFjaykgewogICAgICB0aGlzLl92aWV3VG9Nb2RlbExlbmd0aENhbGxiYWNrcy5zZXQodmlld0VsZW1lbnROYW1lLCBsZW5ndGhDYWxsYmFjayk7CiAgICB9CiAgICAvKioKICAgICAqIEZvciBnaXZlbiBgdmlld1Bvc2l0aW9uYCwgZmluZHMgYW5kIHJldHVybnMgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhpcyBwb3NpdGlvbiB0aGF0IGhhcyBhIG1hcHBpbmcgdG8KICAgICAqIHRoZSBtb2RlbC4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFBvc2l0aW9uIGZvciB3aGljaCBtYXBwZWQgYW5jZXN0b3Igc2hvdWxkIGJlIGZvdW5kLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZmluZE1hcHBlZFZpZXdBbmNlc3RvciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE1hcHBlZFZpZXdBbmNlc3Rvcih2aWV3UG9zaXRpb24pIHsKICAgICAgdmFyIHBhcmVudCA9IHZpZXdQb3NpdGlvbi5wYXJlbnQ7CgogICAgICB3aGlsZSAoIXRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5oYXMocGFyZW50KSkgewogICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBwYXJlbnQ7CiAgICB9CiAgICAvKioKICAgICAqIENhbGN1bGF0ZXMgbW9kZWwgb2Zmc2V0IGJhc2VkIG9uIHRoZSB2aWV3IHBvc2l0aW9uIGFuZCB0aGUgYmxvY2sgZWxlbWVudC4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQk8cD5mb288Yj5iYXxyPC9iPjwvcD4gLy8gX3RvTW9kZWxPZmZzZXQoIGIsIDIsIHAgKSAtPiA1CiAgICAgKgogICAgICogSXMgYSBzdW0gb2Y6CiAgICAgKgogICAgICoJCTxwPmZvb3w8Yj5iYXI8L2I+PC9wPiAvLyBfdG9Nb2RlbE9mZnNldCggcCwgMywgcCApIC0+IDMKICAgICAqCQk8cD5mb288Yj5iYXxyPC9iPjwvcD4gLy8gX3RvTW9kZWxPZmZzZXQoIGIsIDIsIGIgKSAtPiAyCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld1BhcmVudCBQb3NpdGlvbiBwYXJlbnQuCiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmlld09mZnNldCBQb3NpdGlvbiBvZmZzZXQuCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdCbG9jayBCbG9jayB1c2VkIGFzIGEgYmFzZSB0byBjYWxjdWxhdGUgb2Zmc2V0LgogICAgICogQHJldHVybnMge051bWJlcn0gT2Zmc2V0IGluIHRoZSBtb2RlbC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJfdG9Nb2RlbE9mZnNldCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvTW9kZWxPZmZzZXQodmlld1BhcmVudCwgdmlld09mZnNldCwgdmlld0Jsb2NrKSB7CiAgICAgIGlmICh2aWV3QmxvY2sgIT0gdmlld1BhcmVudCkgewogICAgICAgIC8vIFNlZSBleGFtcGxlLgogICAgICAgIHZhciBvZmZzZXRUb1BhcmVudFN0YXJ0ID0gdGhpcy5fdG9Nb2RlbE9mZnNldCh2aWV3UGFyZW50LnBhcmVudCwgdmlld1BhcmVudC5pbmRleCwgdmlld0Jsb2NrKTsKCiAgICAgICAgdmFyIG9mZnNldEluUGFyZW50ID0gdGhpcy5fdG9Nb2RlbE9mZnNldCh2aWV3UGFyZW50LCB2aWV3T2Zmc2V0LCB2aWV3UGFyZW50KTsKCiAgICAgICAgcmV0dXJuIG9mZnNldFRvUGFyZW50U3RhcnQgKyBvZmZzZXRJblBhcmVudDsKICAgICAgfSAvLyB2aWV3QmxvY2sgPT0gdmlld1BhcmVudCwgc28gd2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuCiAgICAgIC8vIElmIHRoZSBwb3NpdGlvbiBpcyBhIHRleHQgaXQgaXMgc2ltcGxlICgiYmF8ciIgLT4gMikuCgoKICAgICAgaWYgKHZpZXdQYXJlbnQuaXMoJ3RleHQnKSkgewogICAgICAgIHJldHVybiB2aWV3T2Zmc2V0OwogICAgICB9IC8vIElmIHRoZSBwb3NpdGlvbiBpcyBpbiBhbiBlbGVtZW50IHdlIG5lZWQgdG8gc3VtIGxlbmd0aHMgb2Ygc2libGluZ3MgKCA8Yj4gYmFyIDwvYj4gZm9vIHwgLT4gMyArIDMgPSA2ICkuCgoKICAgICAgdmFyIG1vZGVsT2Zmc2V0ID0gMDsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld09mZnNldDsgaSsrKSB7CiAgICAgICAgbW9kZWxPZmZzZXQgKz0gdGhpcy5nZXRNb2RlbExlbmd0aCh2aWV3UGFyZW50LmdldENoaWxkKGkpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG1vZGVsT2Zmc2V0OwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHRoZSBsZW5ndGggb2YgdGhlIHZpZXcgZWxlbWVudCBpbiB0aGUgbW9kZWwuCiAgICAgKgogICAgICogVGhlIGxlbmd0aCBpcyBjYWxjdWxhdGVkIGFzIGZvbGxvd3M6CiAgICAgKiAqIGlmIHtAbGluayAjcmVnaXN0ZXJWaWV3VG9Nb2RlbExlbmd0aCBsZW5ndGggbWFwcGluZyBjYWxsYmFja30gaXMgcHJvdmlkZWQgZm9yIGdpdmVuIGB2aWV3Tm9kZWAgaXQgaXMgdXNlZCB0bwogICAgICogZXZhbHVhdGUgbW9kZWwgbGVuZ3RoIChgdmlld05vZGVgIGlzIHVzZWQgYXMgZmlyc3QgYW5kIG9ubHkgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgY2FsbGJhY2spLAogICAgICogKiBsZW5ndGggb2YgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB0ZXh0IG5vZGV9IGlzIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgaXQncwogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQjZGF0YSBkYXRhfSwKICAgICAqICogbGVuZ3RoIG9mIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50IHVpIGVsZW1lbnR9IGlzIGVxdWFsIHRvIDAsCiAgICAgKiAqIGxlbmd0aCBvZiBhIG1hcHBlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSBpcyBlcXVhbCB0byAxLAogICAgICogKiBsZW5ndGggb2YgYSBub3QtbWFwcGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IGlzIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgaXQncyBjaGlsZHJlbi4KICAgICAqCiAgICAgKiBFeGFtcGxlczoKICAgICAqCiAgICAgKgkJZm9vICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAzIC8vIFRleHQgbGVuZ3RoIGlzIGVxdWFsIHRvIGl0J3MgZGF0YSBsZW5ndGguCiAgICAgKgkJPHA+Zm9vPC9wPiAgICAgICAgICAgICAgICAgICAtPiAxIC8vIExlbmd0aCBvZiBhbiBlbGVtZW50IHdoaWNoIGlzIG1hcHBlZCBpcyBieSBkZWZhdWx0IGVxdWFsIHRvIDEuCiAgICAgKgkJPGI+Zm9vPC9iPiAgICAgICAgICAgICAgICAgICAtPiAzIC8vIExlbmd0aCBvZiBhbiBlbGVtZW50IHdoaWNoIGlzIG5vdCBtYXBwZWQgaXMgYSBsZW5ndGggb2YgaXRzIGNoaWxkcmVuLgogICAgICoJCTxkaXY+PHA+eDwvcD48cD55PC9wPjwvZGl2PiAgLT4gMiAvLyBBc3N1bWluZyB0aGF0IDxkaXY+IGlzIG5vdCBtYXBwZWQgYW5kIDxwPiBhcmUgbWFwcGVkLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld05vZGUgVmlldyBub2RlLgogICAgICogQHJldHVybnMge051bWJlcn0gTGVuZ3RoIG9mIHRoZSBub2RlIGluIHRoZSB0cmVlIG1vZGVsLgogICAgICovCgogIH0sIHsKICAgIGtleTogImdldE1vZGVsTGVuZ3RoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlbExlbmd0aCh2aWV3Tm9kZSkgewogICAgICBpZiAodGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3MuZ2V0KHZpZXdOb2RlLm5hbWUpKSB7CiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3MuZ2V0KHZpZXdOb2RlLm5hbWUpOwoKICAgICAgICByZXR1cm4gY2FsbGJhY2sodmlld05vZGUpOwogICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5oYXModmlld05vZGUpKSB7CiAgICAgICAgcmV0dXJuIDE7CiAgICAgIH0gZWxzZSBpZiAodmlld05vZGUuaXMoJ3RleHQnKSkgewogICAgICAgIHJldHVybiB2aWV3Tm9kZS5kYXRhLmxlbmd0aDsKICAgICAgfSBlbHNlIGlmICh2aWV3Tm9kZS5pcygndWlFbGVtZW50JykpIHsKICAgICAgICByZXR1cm4gMDsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgbGVuID0gMDsKICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlOwogICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTsKICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkOwoKICAgICAgICB0cnkgewogICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHZpZXdOb2RlLmdldENoaWxkcmVuKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHsKICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXA0LnZhbHVlOwogICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRNb2RlbExlbmd0aChjaGlsZCk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlOwogICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHsKICAgICAgICAgICAgICBfaXRlcmF0b3I0LnJldHVybigpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I0KSB7CiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbGVuOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEZpbmRzIHRoZSBwb3NpdGlvbiBpbiB0aGUgdmlldyBub2RlIChvciBpdHMgY2hpbGRyZW4pIHdpdGggdGhlIGV4cGVjdGVkIG1vZGVsIG9mZnNldC4KICAgICAqCiAgICAgKiBFeGFtcGxlOgogICAgICoKICAgICAqCQk8cD5mbzxiPmJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNAogICAgICoKICAgICAqCQlfZmluZFBvc2l0aW9uSW4oIHAsIDQgKToKICAgICAqCQk8cD58Zm88Yj5iYXI8L2I+Ym9tPC9wPiAtPiBleHBlY3RlZCBvZmZzZXQ6IDQsIGFjdHVhbCBvZmZzZXQ6IDAKICAgICAqCQk8cD5mb3w8Yj5iYXI8L2I+Ym9tPC9wPiAtPiBleHBlY3RlZCBvZmZzZXQ6IDQsIGFjdHVhbCBvZmZzZXQ6IDIKICAgICAqCQk8cD5mbzxiPmJhcjwvYj58Ym9tPC9wPiAtPiBleHBlY3RlZCBvZmZzZXQ6IDQsIGFjdHVhbCBvZmZzZXQ6IDUgLT4gd2UgYXJlIHRvbyBmYXIKICAgICAqCiAgICAgKgkJX2ZpbmRQb3NpdGlvbkluKCBiLCA0IC0gKCA1IC0gMyApICk6CiAgICAgKgkJPHA+Zm88Yj58YmFyPC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiAyLCBhY3R1YWwgb2Zmc2V0OiAwCiAgICAgKgkJPHA+Zm88Yj5iYXJ8PC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiAyLCBhY3R1YWwgb2Zmc2V0OiAzIC0+IHdlIGFyZSB0b28gZmFyCiAgICAgKgogICAgICoJCV9maW5kUG9zaXRpb25JbiggYmFyLCAyIC0gKCAzIC0gMyApICk6CiAgICAgKgkJV2UgYXJlIGluIHRoZSB0ZXh0IG5vZGUgc28gd2UgY2FuIHNpbXBsZSBmaW5kIHRoZSBvZmZzZXQuCiAgICAgKgkJPHA+Zm88Yj5iYXxyPC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiAyLCBhY3R1YWwgb2Zmc2V0OiAyIC0+IHBvc2l0aW9uIGZvdW5kCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld1BhcmVudCBUcmVlIHZpZXcgZWxlbWVudCBpbiB3aGljaCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIHBvc2l0aW9uLgogICAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkT2Zmc2V0IEV4cGVjdGVkIG9mZnNldC4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IEZvdW5kIHBvc2l0aW9uLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9maW5kUG9zaXRpb25JbiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRQb3NpdGlvbkluKHZpZXdQYXJlbnQsIGV4cGVjdGVkT2Zmc2V0KSB7CiAgICAgIC8vIExhc3Qgc2Nhbm5lZCB2aWV3IG5vZGUuCiAgICAgIHZhciB2aWV3Tm9kZTsgLy8gTGVuZ3RoIG9mIHRoZSBsYXN0IHNjYW5uZWQgdmlldyBub2RlLgoKICAgICAgdmFyIGxhc3RMZW5ndGggPSAwOwogICAgICB2YXIgbW9kZWxPZmZzZXQgPSAwOwogICAgICB2YXIgdmlld09mZnNldCA9IDA7IC8vIEluIHRoZSB0ZXh0IG5vZGUgaXQgaXMgc2ltcGxlOiBvZmZzZXQgaW4gdGhlIG1vZGVsIGVxdWFscyBvZmZzZXQgaW4gdGhlIHRleHQuCgogICAgICBpZiAodmlld1BhcmVudC5pcygndGV4dCcpKSB7CiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24odmlld1BhcmVudCwgZXhwZWN0ZWRPZmZzZXQpOwogICAgICB9IC8vIEluIG90aGVyIGNhc2VzIHdlIGFkZCBsZW5ndGhzIG9mIGNoaWxkIG5vZGVzIHRvIGZpbmQgdGhlIHByb3BlciBvZmZzZXQuCiAgICAgIC8vIElmIGl0IGlzIHNtYWxsZXIgd2UgYWRkIHRoZSBsZW5ndGguCgoKICAgICAgd2hpbGUgKG1vZGVsT2Zmc2V0IDwgZXhwZWN0ZWRPZmZzZXQpIHsKICAgICAgICB2aWV3Tm9kZSA9IHZpZXdQYXJlbnQuZ2V0Q2hpbGQodmlld09mZnNldCk7CiAgICAgICAgbGFzdExlbmd0aCA9IHRoaXMuZ2V0TW9kZWxMZW5ndGgodmlld05vZGUpOwogICAgICAgIG1vZGVsT2Zmc2V0ICs9IGxhc3RMZW5ndGg7CiAgICAgICAgdmlld09mZnNldCsrOwogICAgICB9IC8vIElmIGl0IGVxdWFscyB3ZSBmb3VuZCB0aGUgcG9zaXRpb24uCgoKICAgICAgaWYgKG1vZGVsT2Zmc2V0ID09IGV4cGVjdGVkT2Zmc2V0KSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVWaWV3UG9zaXRpb25Ub1RleHROb2RlKG5ldyBWaWV3UG9zaXRpb24odmlld1BhcmVudCwgdmlld09mZnNldCkpOwogICAgICB9IC8vIElmIGl0IGlzIGhpZ2hlciB3ZSBuZWVkIHRvIGVudGVyIGxhc3QgY2hpbGQuCiAgICAgIGVsc2UgewogICAgICAgICAgLy8gKCBtb2RlbE9mZnNldCAtIGxhc3RMZW5ndGggKSBpcyB0aGUgb2Zmc2V0IHRvIHRoZSBjaGlsZCB3ZSBlbnRlciwKICAgICAgICAgIC8vIHNvIHdlIHN1YnRyYWN0IGl0IGZyb20gdGhlIGV4cGVjdGVkIG9mZnNldCB0byBmaW5lIHRoZSBvZmZzZXQgaW4gdGhlIGNoaWxkLgogICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQb3NpdGlvbkluKHZpZXdOb2RlLCBleHBlY3RlZE9mZnNldCAtIChtb2RlbE9mZnNldCAtIGxhc3RMZW5ndGgpKTsKICAgICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIEJlY2F1c2Ugd2UgcHJlZmVyIHBvc2l0aW9ucyBpbiB0ZXh0IG5vZGVzIG92ZXIgcG9zaXRpb25zIG5leHQgdG8gdGV4dCBub2RlIG1vdmVzIHZpZXcgcG9zaXRpb24gdG8gdGhlIHRleHQgbm9kZQogICAgICogaWYgaXQgd2FzIG5leHQgdG8gaXQuCiAgICAgKgogICAgICoJCTxwPltdPGI+Zm9vPC9iPjwvcD4gLT4gPHA+W108Yj5mb288L2I+PC9wPiAvLyBkbyBub3QgdG91Y2ggaWYgcG9zaXRpb24gaXMgbm90IGRpcmVjdGx5IG5leHQgdG8gdGV4dAogICAgICoJCTxwPmZvb1tdPGI+Zm9vPC9iPjwvcD4gLT4gPHA+Zm9ve308Yj5mb288L2I+PC9wPiAvLyBtb3ZlIHRvIHRleHQgbm9kZQogICAgICoJCTxwPjxiPltdZm9vPC9iPjwvcD4gLT4gPHA+PGI+e31mb288L2I+PC9wPiAvLyBtb3ZlIHRvIHRleHQgbm9kZQogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFBvc2l0aW9uIHBvdGVudGlhbGx5IG5leHQgdG8gdGV4dCBub2RlLgogICAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gaW4gdGV4dCBub2RlIGlmIHBvc3NpYmxlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9tb3ZlVmlld1Bvc2l0aW9uVG9UZXh0Tm9kZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVWaWV3UG9zaXRpb25Ub1RleHROb2RlKHZpZXdQb3NpdGlvbikgewogICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMganVzdCBhZnRlciB0ZXh0IG5vZGUsIHB1dCBpdCBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlLgogICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMganVzdCBiZWZvcmUgdGV4dCBub2RlLCBwdXQgaXQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGF0IHRleHQgbm9kZS4KICAgICAgdmFyIG5vZGVCZWZvcmUgPSB2aWV3UG9zaXRpb24ubm9kZUJlZm9yZTsKICAgICAgdmFyIG5vZGVBZnRlciA9IHZpZXdQb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAobm9kZUJlZm9yZSBpbnN0YW5jZW9mIFZpZXdUZXh0KSB7CiAgICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24obm9kZUJlZm9yZSwgbm9kZUJlZm9yZS5kYXRhLmxlbmd0aCk7CiAgICAgIH0gZWxzZSBpZiAobm9kZUFmdGVyIGluc3RhbmNlb2YgVmlld1RleHQpIHsKICAgICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbihub2RlQWZ0ZXIsIDApOwogICAgICB9IC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIGdpdmVuIHBvc2l0aW9uLgoKCiAgICAgIHJldHVybiB2aWV3UG9zaXRpb247CiAgICB9CiAgICAvKioKICAgICAqIEZpcmVkIGZvciBlYWNoIG1vZGVsLXRvLXZpZXcgcG9zaXRpb24gbWFwcGluZyByZXF1ZXN0LiBUaGUgcHVycG9zZSBvZiB0aGlzIGV2ZW50IGlzIHRvIGVuYWJsZSBjdXN0b20gbW9kZWwtdG8tdmlldyBwb3NpdGlvbgogICAgICogbWFwcGluZy4gQ2FsbGJhY2tzIGFkZGVkIHRvIHRoaXMgZXZlbnQgdGFrZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBtb2RlbCBwb3NpdGlvbn0gYW5kIGFyZSBleHBlY3RlZCB0bwogICAgICogY2FsY3VsYXRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gdmlldyBwb3NpdGlvbn0uIENhbGN1bGF0ZWQgdmlldyBwb3NpdGlvbiBzaG91bGQgYmUgYWRkZWQgYXMgYHZpZXdQb3NpdGlvbmAKICAgICAqIHZhbHVlIGluIGBkYXRhYCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgYXMgb25lIG9mIHBhcmFtZXRlcnMgdG8gdGhlIGV2ZW50IGNhbGxiYWNrLgogICAgICoKICAgICAqIAkJLy8gQXNzdW1lIHRoYXQgImNhcHRpb25lZEltYWdlIiBtb2RlbCBlbGVtZW50IGlzIGNvbnZlcnRlZCB0byA8aW1nPiBhbmQgZm9sbG93aW5nIDxzcGFuPiBlbGVtZW50cyBpbiB2aWV3LAogICAgICogCQkvLyBhbmQgdGhlIG1vZGVsIGVsZW1lbnQgaXMgYm91bmQgdG8gPGltZz4gZWxlbWVudC4gRm9yY2UgbWFwcGluZyBtb2RlbCBwb3NpdGlvbnMgaW5zaWRlICJjYXB0aW9uZWRJbWFnZSIgdG8gdGhhdAogICAgICogCQkvLyA8c3Bhbj4gZWxlbWVudC4KICAgICAqCQltYXBwZXIub24oICdtb2RlbFRvVmlld1Bvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICAgKgkJCWNvbnN0IHBvc2l0aW9uUGFyZW50ID0gbW9kZWxQb3NpdGlvbi5wYXJlbnQ7CiAgICAgKgogICAgICoJCQlpZiAoIHBvc2l0aW9uUGFyZW50Lm5hbWUgPT0gJ2NhcHRpb25lZEltYWdlJyApIHsKICAgICAqCQkJCWNvbnN0IHZpZXdJbWcgPSBkYXRhLm1hcHBlci50b1ZpZXdFbGVtZW50KCBwb3NpdGlvblBhcmVudCApOwogICAgICoJCQkJY29uc3Qgdmlld0NhcHRpb24gPSB2aWV3SW1nLm5leHRTaWJsaW5nOyAvLyBUaGUgPHNwYW4+IGVsZW1lbnQuCiAgICAgKgogICAgICoJCQkJZGF0YS52aWV3UG9zaXRpb24gPSBuZXcgVmlld1Bvc2l0aW9uKCB2aWV3Q2FwdGlvbiwgbW9kZWxQb3NpdGlvbi5vZmZzZXQgKTsKICAgICAqCiAgICAgKgkJCQkvLyBTdG9wIHRoZSBldmVudCBpZiBvdGhlciBjYWxsYmFja3Mgc2hvdWxkIG5vdCBtb2RpZnkgY2FsY3VsYXRlZCB2YWx1ZS4KICAgICAqCQkJCWV2dC5zdG9wKCk7CiAgICAgKgkJCX0KICAgICAqCQl9ICk7CiAgICAgKgogICAgICogKipOb3RlOioqIGtlZXAgaW4gbWluZCB0aGF0IHNvbWV0aW1lcyBhICJwaGFudG9tIiBtb2RlbCBwb3NpdGlvbiBpcyBiZWluZyBjb252ZXJ0ZWQuICJQaGFudG9tIiBtb2RlbCBwb3NpdGlvbiBpcwogICAgICogYSBwb3NpdGlvbiB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBwbGFjZSBpbiBtb2RlbC4gU3VjaCBwb3NpdGlvbiBtaWdodCBzdGlsbCBiZSB2YWxpZCBmb3IgY29udmVyc2lvbiwgdGhvdWdoCiAgICAgKiAoaXQgd291bGQgcG9pbnQgdG8gYSBjb3JyZWN0IHBsYWNlIGluIHZpZXcgd2hlbiBjb252ZXJ0ZWQpLiBPbmUgZXhhbXBsZSBvZiBzdWNoIHNpdHVhdGlvbiBpcyB3aGVuIGEgcmFuZ2UgaXMKICAgICAqIHJlbW92ZWQgZnJvbSBtb2RlbCwgdGhlcmUgbWF5IGJlIGEgbmVlZCB0byBtYXAgdGhlIHJhbmdlJ3MgZW5kICh3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgbW9kZWwgcG9zaXRpb24pLiBUbwogICAgICogaGFuZGxlIHN1Y2ggc2l0dWF0aW9uLCBjaGVjayBgZGF0YS5pc1BoYW50b21gIGZsYWc6CiAgICAgKgogICAgICogCQkvLyBBc3N1bWUgdGhhdCB0aGVyZSBpcyAiY3VzdG9tRWxlbWVudCIgbW9kZWwgZWxlbWVudCBhbmQgd2hlbmV2ZXIgcG9zaXRpb24gaXMgYmVmb3JlIGl0LCB3ZSB3YW50IHRvIG1vdmUgaXQKICAgICAqIAkJLy8gdG8gdGhlIGluc2lkZSBvZiB0aGUgdmlldyBlbGVtZW50IGJvdW5kIHRvICJjdXN0b21FbGVtZW50Ii4KICAgICAqCQltYXBwZXIub24oICdtb2RlbFRvVmlld1Bvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICAgKgkJCWlmICggZGF0YS5pc1BoYW50b20gKSB7CiAgICAgKgkJCQlyZXR1cm47CiAgICAgKgkJCX0KICAgICAqCiAgICAgKgkJCS8vIEJlbG93IGxpbmUgbWlnaHQgY3Jhc2ggZm9yIHBoYW50b20gcG9zaXRpb24gdGhhdCBkb2VzIG5vdCBleGlzdCBpbiBtb2RlbC4KICAgICAqCQkJY29uc3Qgc2libGluZyA9IGRhdGEubW9kZWxQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICoKICAgICAqCQkJLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZWxlbWVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi4KICAgICAqCQkJaWYgKCAhc2libGluZy5pcyggJ2N1c3RvbUVsZW1lbnQnICkgKSB7CiAgICAgKgkJCQlyZXR1cm47CiAgICAgKgkJCX0KICAgICAqCiAgICAgKgkJCWNvbnN0IHZpZXdFbGVtZW50ID0gZGF0YS5tYXBwZXIudG9WaWV3RWxlbWVudCggc2libGluZyApOwogICAgICoKICAgICAqCQkJZGF0YS52aWV3UG9zaXRpb24gPSBuZXcgVmlld1Bvc2l0aW9uKCBzaWJsaW5nLCAwICk7CiAgICAgKgogICAgICoJCQlldnQuc3RvcCgpOwogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiAqKk5vdGU6KiogZGVmYXVsdCBtYXBwaW5nIGNhbGxiYWNrIGlzIHByb3ZpZGVkIHdpdGggYGxvd2AgcHJpb3JpdHkgc2V0dGluZyBhbmQgZG9lcyBub3QgY2FuY2VsIHRoZSBldmVudCwgc28gaXQgaXMgcG9zc2libGUgdG8KICAgICAqIGF0dGFjaCBhIGN1c3RvbSBjYWxsYmFjayBhZnRlciBkZWZhdWx0IGNhbGxiYWNrIGFuZCBhbHNvIHVzZSBgZGF0YS52aWV3UG9zaXRpb25gIGNhbGN1bGF0ZWQgYnkgZGVmYXVsdCBjYWxsYmFjawogICAgICogKGZvciBleGFtcGxlIHRvIGZpeCBpdCkuCiAgICAgKgogICAgICogKipOb3RlOioqIGRlZmF1bHQgbWFwcGluZyBjYWxsYmFjayB3aWxsIG5vdCBmaXJlIGlmIGBkYXRhLnZpZXdQb3NpdGlvbmAgaXMgYWxyZWFkeSBzZXQuCiAgICAgKgogICAgICogKipOb3RlOioqIHRoZXNlIGNhbGxiYWNrcyBhcmUgY2FsbGVkICoqdmVyeSBvZnRlbioqLiBGb3IgZWZmaWNpZW5jeSByZWFzb25zLCBpdCBpcyBhZHZpc2VkIHRvIHVzZSB0aGVtIG9ubHkgd2hlbiBwb3NpdGlvbgogICAgICogbWFwcGluZyBiZXR3ZWVuIGdpdmVuIG1vZGVsIGFuZCB2aWV3IGVsZW1lbnRzIGlzIHVuc29sdmFibGUgdXNpbmcganVzdCBlbGVtZW50cyBtYXBwaW5nIGFuZCBkZWZhdWx0IGFsZ29yaXRobS4gQWxzbywKICAgICAqIHRoZSBjb25kaXRpb24gdGhhdCBjaGVja3MgaWYgc3BlY2lhbCBjYXNlIHNjZW5hcmlvIGhhcHBlbmVkIHNob3VsZCBiZSBhcyBzaW1wbGUgYXMgcG9zc2libGUuCiAgICAgKgogICAgICogQGV2ZW50IG1vZGVsVG9WaWV3UG9zaXRpb24KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgcGlwZWxpbmUgb2JqZWN0IHRoYXQgY2FuIHN0b3JlIGFuZCBwYXNzIGRhdGEgYmV0d2VlbiBjYWxsYmFja3MuIFRoZSBjYWxsYmFjayBzaG91bGQgYWRkCiAgICAgKiBgdmlld1Bvc2l0aW9uYCB2YWx1ZSB0byB0aGF0IG9iamVjdCB3aXRoIGNhbGN1bGF0ZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiB2aWV3IHBvc2l0aW9ufS4KICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXJ9IGRhdGEubWFwcGVyIE1hcHBlciBpbnN0YW5jZSB0aGF0IGZpcmVkIHRoZSBldmVudC4KICAgICAqLwoKICAgIC8qKgogICAgICogRmlyZWQgZm9yIGVhY2ggdmlldy10by1tb2RlbCBwb3NpdGlvbiBtYXBwaW5nIHJlcXVlc3QuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6bW9kZWxUb1ZpZXdQb3NpdGlvbn0uCiAgICAgKgogICAgICogCQkvLyBTZWUgZXhhbXBsZSBpbiBgbW9kZWxUb1ZpZXdQb3NpdGlvbmAgZXZlbnQgZGVzY3JpcHRpb24uCiAgICAgKiAJCS8vIFRoaXMgY3VzdG9tIG1hcHBpbmcgd2lsbCBtYXAgcG9zaXRpb25zIGZyb20gPHNwYW4+IGVsZW1lbnQgbmV4dCB0byA8aW1nPiB0byB0aGUgImNhcHRpb25lZEltYWdlIiBlbGVtZW50LgogICAgICoJCW1hcHBlci5vbiggJ3ZpZXdUb01vZGVsUG9zaXRpb24nLCAoIGV2dCwgZGF0YSApID0+IHsKICAgICAqCQkJY29uc3QgcG9zaXRpb25QYXJlbnQgPSB2aWV3UG9zaXRpb24ucGFyZW50OwogICAgICoKICAgICAqCQkJaWYgKCBwb3NpdGlvblBhcmVudC5oYXNDbGFzcyggJ2ltYWdlLWNhcHRpb24nICkgKSB7CiAgICAgKgkJCQljb25zdCB2aWV3SW1nID0gcG9zaXRpb25QYXJlbnQucHJldmlvdXNTaWJsaW5nOwogICAgICoJCQkJY29uc3QgbW9kZWxJbWcgPSBkYXRhLm1hcHBlci50b01vZGVsRWxlbWVudCggdmlld0ltZyApOwogICAgICoKICAgICAqCQkJCWRhdGEubW9kZWxQb3NpdGlvbiA9IG5ldyBNb2RlbFBvc2l0aW9uKCBtb2RlbEltZywgdmlld1Bvc2l0aW9uLm9mZnNldCApOwogICAgICoJCQkJZXZ0LnN0b3AoKTsKICAgICAqCQkJfQogICAgICoJCX0gKTsKICAgICAqCiAgICAgKiAqKk5vdGU6KiogZGVmYXVsdCBtYXBwaW5nIGNhbGxiYWNrIGlzIHByb3ZpZGVkIHdpdGggYGxvd2AgcHJpb3JpdHkgc2V0dGluZyBhbmQgZG9lcyBub3QgY2FuY2VsIHRoZSBldmVudCwgc28gaXQgaXMgcG9zc2libGUgdG8KICAgICAqIGF0dGFjaCBhIGN1c3RvbSBjYWxsYmFjayBhZnRlciBkZWZhdWx0IGNhbGxiYWNrIGFuZCBhbHNvIHVzZSBgZGF0YS5tb2RlbFBvc2l0aW9uYCBjYWxjdWxhdGVkIGJ5IGRlZmF1bHQgY2FsbGJhY2sKICAgICAqIChmb3IgZXhhbXBsZSB0byBmaXggaXQpLgogICAgICoKICAgICAqICoqTm90ZToqKiBkZWZhdWx0IG1hcHBpbmcgY2FsbGJhY2sgd2lsbCBub3QgZmlyZSBpZiBgZGF0YS5tb2RlbFBvc2l0aW9uYCBpcyBhbHJlYWR5IHNldC4KICAgICAqCiAgICAgKiAqKk5vdGU6KiogdGhlc2UgY2FsbGJhY2tzIGFyZSBjYWxsZWQgKip2ZXJ5IG9mdGVuKiouIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGl0IGlzIGFkdmlzZWQgdG8gdXNlIHRoZW0gb25seSB3aGVuIHBvc2l0aW9uCiAgICAgKiBtYXBwaW5nIGJldHdlZW4gZ2l2ZW4gbW9kZWwgYW5kIHZpZXcgZWxlbWVudHMgaXMgdW5zb2x2YWJsZSB1c2luZyBqdXN0IGVsZW1lbnRzIG1hcHBpbmcgYW5kIGRlZmF1bHQgYWxnb3JpdGhtLiBBbHNvLAogICAgICogdGhlIGNvbmRpdGlvbiB0aGF0IGNoZWNrcyBpZiBzcGVjaWFsIGNhc2Ugc2NlbmFyaW8gaGFwcGVuZWQgc2hvdWxkIGJlIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS4KICAgICAqCiAgICAgKiBAZXZlbnQgdmlld1RvTW9kZWxQb3NpdGlvbgogICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBwaXBlbGluZSBvYmplY3QgdGhhdCBjYW4gc3RvcmUgYW5kIHBhc3MgZGF0YSBiZXR3ZWVuIGNhbGxiYWNrcy4gVGhlIGNhbGxiYWNrIHNob3VsZCBhZGQKICAgICAqIGBtb2RlbFBvc2l0aW9uYCB2YWx1ZSB0byB0aGF0IG9iamVjdCB3aXRoIGNhbGN1bGF0ZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gbW9kZWwgcG9zaXRpb259LgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0gZGF0YS5tYXBwZXIgTWFwcGVyIGluc3RhbmNlIHRoYXQgZmlyZWQgdGhlIGV2ZW50LgogICAgICovCgogIH1dKTsKCiAgcmV0dXJuIE1hcHBlcjsKfSgpOwoKZXhwb3J0IHsgTWFwcGVyIGFzIGRlZmF1bHQgfTsKbWl4KE1hcHBlciwgRW1pdHRlck1peGluKTs="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","EmitterMixin","mix","Mapper","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","_findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","modelElement","viewElement","set","toModelElement","delete","has","markerName","add","toViewElement","element","name","elements","names","nameToElements","size","elementToNames","markerNames","Array","from","clear","viewRange","toModelPosition","start","end","modelRange","toViewPosition","mapper","fire","options","isPhantom","boundElements","is","getElementsWithSameId","clone","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","getChildren","child","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"mappings":";;;;;;;;;;;;;;AAAA;;;;;AAKA;;;AAIA,OAAOA,aAAP,MAA0B,mBAA1B;AACA,OAAOC,UAAP,MAAuB,gBAAvB;AAEA,OAAOC,YAAP,MAAyB,kBAAzB;AACA,OAAOC,SAAP,MAAsB,eAAtB;AACA,OAAOC,QAAP,MAAqB,cAArB;AAEA,OAAOC,YAAP,MAAyB,4CAAzB;AACA,OAAOC,GAAP,MAAgB,mCAAhB;AAEA;;;;;;;;;;;;;;;;;;;;IAmBqBC,M;;;AACpB;;;AAGA,oBAAc;AAAA;;AAAA;;AACb;;;;;;AAMA,SAAKC,mBAAL,GAA2B,IAAIC,OAAJ,EAA3B;AAEA;;;;;;;AAMA,SAAKC,mBAAL,GAA2B,IAAID,OAAJ,EAA3B;AAEA;;;;;;;;AAOA,SAAKE,2BAAL,GAAmC,IAAIC,GAAJ,EAAnC;AAEA;;;;;;;;;;AASA,SAAKC,qBAAL,GAA6B,IAAID,GAAJ,EAA7B;AAEA;;;;;;;;;AAQA,SAAKE,qBAAL,GAA6B,IAAIF,GAAJ,EAA7B;AAEA;;;;;;;;AAOA,SAAKG,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B,CAtDa,CAwDb;;AACA,SAAKC,EAAL,CAAS,qBAAT,EAAgC,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AAChD,UAAKA,IAAI,CAACC,YAAV,EAAyB;AACxB;AACA;;AAED,UAAMC,aAAa,GAAG,KAAI,CAACb,mBAAL,CAAyBc,GAAzB,CAA8BH,IAAI,CAACI,aAAL,CAAmBC,MAAjD,CAAtB;;AAEAL,MAAAA,IAAI,CAACC,YAAL,GAAoB,KAAI,CAACK,eAAL,CAAsBJ,aAAtB,EAAqCF,IAAI,CAACI,aAAL,CAAmBG,MAAxD,CAApB;AACA,KARD,EAQG;AAAEC,MAAAA,QAAQ,EAAE;AAAZ,KARH,EAzDa,CAmEb;;AACA,SAAKV,EAAL,CAAS,qBAAT,EAAgC,UAAEC,GAAF,EAAOC,IAAP,EAAiB;AAChD,UAAKA,IAAI,CAACI,aAAV,EAA0B;AACzB;AACA;;AAED,UAAMK,SAAS,GAAG,KAAI,CAACC,sBAAL,CAA6BV,IAAI,CAACC,YAAlC,CAAlB;;AACA,UAAMU,WAAW,GAAG,KAAI,CAACpB,mBAAL,CAAyBY,GAAzB,CAA8BM,SAA9B,CAApB;;AACA,UAAMG,WAAW,GAAG,KAAI,CAACC,cAAL,CAAqBb,IAAI,CAACC,YAAL,CAAkBI,MAAvC,EAA+CL,IAAI,CAACC,YAAL,CAAkBM,MAAjE,EAAyEE,SAAzE,CAApB;;AAEAT,MAAAA,IAAI,CAACI,aAAL,GAAqBvB,aAAa,CAACiC,SAAd,CAAyBH,WAAzB,EAAsCC,WAAtC,CAArB;AACA,KAVD,EAUG;AAAEJ,MAAAA,QAAQ,EAAE;AAAZ,KAVH;AAWA;AAED;;;;;;;;;;;;;iCAScO,Y,EAAcC,W,EAAc;AACzC,WAAK3B,mBAAL,CAAyB4B,GAAzB,CAA8BF,YAA9B,EAA4CC,WAA5C;;AACA,WAAKzB,mBAAL,CAAyB0B,GAAzB,CAA8BD,WAA9B,EAA2CD,YAA3C;AACA;AAED;;;;;;;;;;;;;;sCAWmBC,W,EAAc;AAChC,UAAMD,YAAY,GAAG,KAAKG,cAAL,CAAqBF,WAArB,CAArB;;AAEA,WAAKzB,mBAAL,CAAyB4B,MAAzB,CAAiCH,WAAjC;;AAEA,UAAK,KAAKrB,qBAAL,CAA2ByB,GAA3B,CAAgCJ,WAAhC,CAAL,EAAqD;AAAA;AAAA;AAAA;;AAAA;AACpD,+BAA0B,KAAKrB,qBAAL,CAA2BQ,GAA3B,CAAgCa,WAAhC,CAA1B,8HAA0E;AAAA,gBAA9DK,UAA8D;;AACzE,iBAAKzB,mBAAL,CAAyB0B,GAAzB,CAA8BD,UAA9B;AACA;AAHmD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIpD;;AAED,UAAK,KAAKhC,mBAAL,CAAyBc,GAAzB,CAA8BY,YAA9B,KAAgDC,WAArD,EAAmE;AAClE,aAAK3B,mBAAL,CAAyB8B,MAAzB,CAAiCJ,YAAjC;AACA;AACD;AAED;;;;;;;;;;;;;;uCAWoBA,Y,EAAe;AAClC,UAAMC,WAAW,GAAG,KAAKO,aAAL,CAAoBR,YAApB,CAApB;;AAEA,WAAK1B,mBAAL,CAAyB8B,MAAzB,CAAiCJ,YAAjC;;AAEA,UAAK,KAAKxB,mBAAL,CAAyBY,GAAzB,CAA8Ba,WAA9B,KAA+CD,YAApD,EAAmE;AAClE,aAAKxB,mBAAL,CAAyB4B,MAAzB,CAAiCH,WAAjC;AACA;AACD;AAED;;;;;;;;;;wCAOqBQ,O,EAASC,I,EAAO;AACpC,UAAMC,QAAQ,GAAG,KAAKhC,qBAAL,CAA2BS,GAA3B,CAAgCsB,IAAhC,KAA0C,IAAI5B,GAAJ,EAA3D;AACA6B,MAAAA,QAAQ,CAACJ,GAAT,CAAcE,OAAd;AAEA,UAAMG,KAAK,GAAG,KAAKhC,qBAAL,CAA2BQ,GAA3B,CAAgCqB,OAAhC,KAA6C,IAAI3B,GAAJ,EAA3D;AACA8B,MAAAA,KAAK,CAACL,GAAN,CAAWG,IAAX;;AAEA,WAAK/B,qBAAL,CAA2BuB,GAA3B,CAAgCQ,IAAhC,EAAsCC,QAAtC;;AACA,WAAK/B,qBAAL,CAA2BsB,GAA3B,CAAgCO,OAAhC,EAAyCG,KAAzC;AACA;AAED;;;;;;;;;gDAM6BH,O,EAASC,I,EAAO;AAC5C,UAAMG,cAAc,GAAG,KAAKlC,qBAAL,CAA2BS,GAA3B,CAAgCsB,IAAhC,CAAvB;;AAEA,UAAKG,cAAL,EAAsB;AACrBA,QAAAA,cAAc,CAACT,MAAf,CAAuBK,OAAvB;;AAEA,YAAKI,cAAc,CAACC,IAAf,IAAuB,CAA5B,EAAgC;AAC/B,eAAKnC,qBAAL,CAA2ByB,MAA3B,CAAmCM,IAAnC;AACA;AACD;;AAED,UAAMK,cAAc,GAAG,KAAKnC,qBAAL,CAA2BQ,GAA3B,CAAgCqB,OAAhC,CAAvB;;AAEA,UAAKM,cAAL,EAAsB;AACrBA,QAAAA,cAAc,CAACX,MAAf,CAAuBM,IAAvB;;AAEA,YAAKK,cAAc,CAACD,IAAf,IAAuB,CAA5B,EAAgC;AAC/B,eAAKlC,qBAAL,CAA2BwB,MAA3B,CAAmCK,OAAnC;AACA;AACD;AACD;AAED;;;;;;;;;8CAM0B;AACzB,UAAMO,WAAW,GAAGC,KAAK,CAACC,IAAN,CAAY,KAAKrC,mBAAjB,CAApB;;AAEA,WAAKA,mBAAL,CAAyBsC,KAAzB;;AAEA,aAAOH,WAAP;AACA;AAED;;;;;;oCAGgB;AACf,WAAK1C,mBAAL,GAA2B,IAAIC,OAAJ,EAA3B;AACA,WAAKC,mBAAL,GAA2B,IAAID,OAAJ,EAA3B;AACA,WAAKI,qBAAL,GAA6B,IAAID,GAAJ,EAA7B;AACA,WAAKE,qBAAL,GAA6B,IAAIF,GAAJ,EAA7B;AACA,WAAKG,mBAAL,GAA2B,IAAIC,GAAJ,EAA3B;AACA;AAED;;;;;;;;;;;mCAQgBmB,W,EAAc;AAC7B,aAAO,KAAKzB,mBAAL,CAAyBY,GAAzB,CAA8Ba,WAA9B,CAAP;AACA;AAED;;;;;;;;;kCAMeD,Y,EAAe;AAC7B,aAAO,KAAK1B,mBAAL,CAAyBc,GAAzB,CAA8BY,YAA9B,CAAP;AACA;AAED;;;;;;;;;iCAMcoB,S,EAAY;AACzB,aAAO,IAAIrD,UAAJ,CAAgB,KAAKsD,eAAL,CAAsBD,SAAS,CAACE,KAAhC,CAAhB,EAAyD,KAAKD,eAAL,CAAsBD,SAAS,CAACG,GAAhC,CAAzD,CAAP;AACA;AAED;;;;;;;;;gCAMaC,U,EAAa;AACzB,aAAO,IAAIvD,SAAJ,CAAe,KAAKwD,cAAL,CAAqBD,UAAU,CAACF,KAAhC,CAAf,EAAwD,KAAKG,cAAL,CAAqBD,UAAU,CAACD,GAAhC,CAAxD,CAAP;AACA;AAED;;;;;;;;;;oCAOiBrC,Y,EAAe;AAC/B,UAAMD,IAAI,GAAG;AACZC,QAAAA,YAAY,EAAZA,YADY;AAEZwC,QAAAA,MAAM,EAAE;AAFI,OAAb;AAKA,WAAKC,IAAL,CAAW,qBAAX,EAAkC1C,IAAlC;AAEA,aAAOA,IAAI,CAACI,aAAZ;AACA;AAED;;;;;;;;;;;;;mCAUgBA,a,EAAgD;AAAA,UAAjCuC,OAAiC,uEAAvB;AAAEC,QAAAA,SAAS,EAAE;AAAb,OAAuB;AAC/D,UAAM5C,IAAI,GAAG;AACZI,QAAAA,aAAa,EAAbA,aADY;AAEZqC,QAAAA,MAAM,EAAE,IAFI;AAGZG,QAAAA,SAAS,EAAED,OAAO,CAACC;AAHP,OAAb;AAMA,WAAKF,IAAL,CAAW,qBAAX,EAAkC1C,IAAlC;AAEA,aAAOA,IAAI,CAACC,YAAZ;AACA;AAED;;;;;;;;;;yCAOsBwB,I,EAAO;AAC5B,UAAMoB,aAAa,GAAG,KAAKnD,qBAAL,CAA2BS,GAA3B,CAAgCsB,IAAhC,CAAtB;;AAEA,UAAK,CAACoB,aAAN,EAAsB;AACrB,eAAO,IAAP;AACA;;AAED,UAAMnB,QAAQ,GAAG,IAAI7B,GAAJ,EAAjB;AAP4B;AAAA;AAAA;;AAAA;AAS5B,8BAAuBgD,aAAvB,mIAAuC;AAAA,cAA3BrB,OAA2B;;AACtC,cAAKA,OAAO,CAACsB,EAAR,CAAY,kBAAZ,CAAL,EAAwC;AAAA;AAAA;AAAA;;AAAA;AACvC,oCAAqBtB,OAAO,CAACuB,qBAAR,EAArB,mIAAuD;AAAA,oBAA3CC,KAA2C;AACtDtB,gBAAAA,QAAQ,CAACJ,GAAT,CAAc0B,KAAd;AACA;AAHsC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIvC,WAJD,MAIO;AACNtB,YAAAA,QAAQ,CAACJ,GAAT,CAAcE,OAAd;AACA;AACD;AAjB2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmB5B,aAAOE,QAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CA6B2BuB,e,EAAiBC,c,EAAiB;AAC5D,WAAK1D,2BAAL,CAAiCyB,GAAjC,CAAsCgC,eAAtC,EAAuDC,cAAvD;AACA;AAED;;;;;;;;;;2CAOwBjD,Y,EAAe;AACtC,UAAII,MAAM,GAAGJ,YAAY,CAACI,MAA1B;;AAEA,aAAQ,CAAC,KAAKd,mBAAL,CAAyB6B,GAAzB,CAA8Bf,MAA9B,CAAT,EAAkD;AACjDA,QAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACA;;AAED,aAAOA,MAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;mCAkBgB8C,U,EAAYC,U,EAAY3C,S,EAAY;AACnD,UAAKA,SAAS,IAAI0C,UAAlB,EAA+B;AAC9B;AACA,YAAME,mBAAmB,GAAG,KAAKxC,cAAL,CAAqBsC,UAAU,CAAC9C,MAAhC,EAAwC8C,UAAU,CAACG,KAAnD,EAA0D7C,SAA1D,CAA5B;;AACA,YAAM8C,cAAc,GAAG,KAAK1C,cAAL,CAAqBsC,UAArB,EAAiCC,UAAjC,EAA6CD,UAA7C,CAAvB;;AAEA,eAAOE,mBAAmB,GAAGE,cAA7B;AACA,OAPkD,CASnD;AAEA;;;AACA,UAAKJ,UAAU,CAACL,EAAX,CAAe,MAAf,CAAL,EAA+B;AAC9B,eAAOM,UAAP;AACA,OAdkD,CAgBnD;;;AACA,UAAIxC,WAAW,GAAG,CAAlB;;AAEA,WAAM,IAAI4C,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,UAArB,EAAiCI,CAAC,EAAlC,EAAuC;AACtC5C,QAAAA,WAAW,IAAI,KAAK6C,cAAL,CAAqBN,UAAU,CAACO,QAAX,CAAqBF,CAArB,CAArB,CAAf;AACA;;AAED,aAAO5C,WAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;mCAsBgB+C,Q,EAAW;AAC1B,UAAK,KAAKnE,2BAAL,CAAiCW,GAAjC,CAAsCwD,QAAQ,CAAClC,IAA/C,CAAL,EAA6D;AAC5D,YAAMmC,QAAQ,GAAG,KAAKpE,2BAAL,CAAiCW,GAAjC,CAAsCwD,QAAQ,CAAClC,IAA/C,CAAjB;;AAEA,eAAOmC,QAAQ,CAAED,QAAF,CAAf;AACA,OAJD,MAIO,IAAK,KAAKpE,mBAAL,CAAyB6B,GAAzB,CAA8BuC,QAA9B,CAAL,EAAgD;AACtD,eAAO,CAAP;AACA,OAFM,MAEA,IAAKA,QAAQ,CAACb,EAAT,CAAa,MAAb,CAAL,EAA6B;AACnC,eAAOa,QAAQ,CAAC3D,IAAT,CAAc6D,MAArB;AACA,OAFM,MAEA,IAAKF,QAAQ,CAACb,EAAT,CAAa,WAAb,CAAL,EAAkC;AACxC,eAAO,CAAP;AACA,OAFM,MAEA;AACN,YAAIgB,GAAG,GAAG,CAAV;AADM;AAAA;AAAA;;AAAA;AAGN,gCAAqBH,QAAQ,CAACI,WAAT,EAArB,mIAA8C;AAAA,gBAAlCC,KAAkC;AAC7CF,YAAAA,GAAG,IAAI,KAAKL,cAAL,CAAqBO,KAArB,CAAP;AACA;AALK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAON,eAAOF,GAAP;AACA;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCAyBiBX,U,EAAYc,c,EAAiB;AAC7C;AACA,UAAIN,QAAJ,CAF6C,CAG7C;;AACA,UAAIO,UAAU,GAAG,CAAjB;AAEA,UAAItD,WAAW,GAAG,CAAlB;AACA,UAAIwC,UAAU,GAAG,CAAjB,CAP6C,CAS7C;;AACA,UAAKD,UAAU,CAACL,EAAX,CAAe,MAAf,CAAL,EAA+B;AAC9B,eAAO,IAAI/D,YAAJ,CAAkBoE,UAAlB,EAA8Bc,cAA9B,CAAP;AACA,OAZ4C,CAc7C;AAEA;;;AACA,aAAQrD,WAAW,GAAGqD,cAAtB,EAAuC;AACtCN,QAAAA,QAAQ,GAAGR,UAAU,CAACO,QAAX,CAAqBN,UAArB,CAAX;AACAc,QAAAA,UAAU,GAAG,KAAKT,cAAL,CAAqBE,QAArB,CAAb;AACA/C,QAAAA,WAAW,IAAIsD,UAAf;AACAd,QAAAA,UAAU;AACV,OAtB4C,CAwB7C;;;AACA,UAAKxC,WAAW,IAAIqD,cAApB,EAAqC;AACpC,eAAO,KAAKE,2BAAL,CAAkC,IAAIpF,YAAJ,CAAkBoE,UAAlB,EAA8BC,UAA9B,CAAlC,CAAP;AACA,OAFD,CAGA;AAHA,WAIK;AACJ;AACA;AACA,iBAAO,KAAK9C,eAAL,CAAsBqD,QAAtB,EAAgCM,cAAc,IAAKrD,WAAW,GAAGsD,UAAnB,CAA9C,CAAP;AACA;AACD;AAED;;;;;;;;;;;;;;;gDAY6BjE,Y,EAAe;AAC3C;AACA;AACA,UAAMmE,UAAU,GAAGnE,YAAY,CAACmE,UAAhC;AACA,UAAMC,SAAS,GAAGpE,YAAY,CAACoE,SAA/B;;AAEA,UAAKD,UAAU,YAAYnF,QAA3B,EAAsC;AACrC,eAAO,IAAIF,YAAJ,CAAkBqF,UAAlB,EAA8BA,UAAU,CAACpE,IAAX,CAAgB6D,MAA9C,CAAP;AACA,OAFD,MAEO,IAAKQ,SAAS,YAAYpF,QAA1B,EAAqC;AAC3C,eAAO,IAAIF,YAAJ,CAAkBsF,SAAlB,EAA6B,CAA7B,CAAP;AACA,OAV0C,CAY3C;;;AACA,aAAOpE,YAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA/mBoBb,M;AAipBrBD,GAAG,CAAEC,MAAF,EAAUF,YAAV,CAAH","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t/**\n\t\t * View element to model marker names mapping.\n\t\t *\n\t\t * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._elementToMarkerNames = new Map();\n\n\t\t/**\n\t\t * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t\t * has been removed, moved or renamed).\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/markercollection~Marker>}\n\t\t */\n\t\tthis._unboundMarkerNames = new Set();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tdata.viewPosition = this._findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewBlock = this.findMappedViewAncestor( data.viewPosition );\n\t\t\tconst modelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition._createAt( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to passed `viewElement`.\n\t *\n\t * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t */\n\tunbindViewElement( viewElement ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\tif ( this._elementToMarkerNames.has( viewElement ) ) {\n\t\t\tfor ( const markerName of this._elementToMarkerNames.get( viewElement ) ) {\n\t\t\t\tthis._unboundMarkerNames.add( markerName );\n\t\t\t}\n\t\t}\n\n\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n\t * will be removed only if view element is still bound to passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\t\telements.add( element );\n\n\t\tconst names = this._elementToMarkerNames.get( element ) || new Set();\n\t\tnames.add( name );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t\tthis._elementToMarkerNames.set( element, names );\n\t}\n\n\t/**\n\t * Unbinds an element from given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to unbind.\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementFromMarkerName( element, name ) {\n\t\tconst nameToElements = this._markerNameToElements.get( name );\n\n\t\tif ( nameToElements ) {\n\t\t\tnameToElements.delete( element );\n\n\t\t\tif ( nameToElements.size == 0 ) {\n\t\t\t\tthis._markerNameToElements.delete( name );\n\t\t\t}\n\t\t}\n\n\t\tconst elementToNames = this._elementToMarkerNames.get( element );\n\n\t\tif ( elementToNames ) {\n\t\t\telementToNames.delete( name );\n\n\t\t\tif ( elementToNames.size == 0 ) {\n\t\t\t\tthis._elementToMarkerNames.delete( element );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tflushUnboundMarkerNames() {\n\t\tconst markerNames = Array.from( this._unboundMarkerNames );\n\n\t\tthis._unboundMarkerNames.clear();\n\n\t\treturn markerNames;\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t\tthis._elementToMarkerNames = new Map();\n\t\tthis._unboundMarkerNames = new Set();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n\t * if no elements are bound to given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of view element in model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n\t * the model.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindMappedViewAncestor( viewPosition ) {\n\t\tlet parent = viewPosition.parent;\n\n\t\twhile ( !this._viewToModelMapping.has( parent ) ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n\t * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( 'text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\t_findPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\t_findPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\t_findPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\t_findPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: offset in the model equals offset in the text.\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this._findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n\t * if it was next to it.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n\t * @returns {module:engine/view/position~Position} Position in text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after text node, put it at the end of that text node.\n\t\t// If the position is just before text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n\t * value in `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n\t * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n\t * (it would point to a correct place in view when converted). One example of such situation is when a range is\n\t * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n\t * handle such situation, check `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n\t * \t\t// to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n"]}]}