{"remainingRequest":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\node.js","dependencies":[{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-engine\\src\\model\\node.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\@ckeditor\\ckeditor5-dev-webpack-plugin\\lib\\translatesourceloader.js","mtime":499162500000},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1581760768702},{"path":"C:\\Users\\pc\\Desktop\\Restoran\\Restoran\\Restoran.UI\\client\\node_modules\\babel-loader\\lib\\index.js","mtime":1581760768279}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrIjsKaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICJDOlxcVXNlcnNcXHBjXFxEZXNrdG9wXFxSZXN0b3JhblxcUmVzdG9yYW5cXFJlc3RvcmFuLlVJXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCi8qKgogKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyMCwgQ0tTb3VyY2UgLSBGcmVkZXJpY28gS25hYmJlbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC4KICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3Itb3NzLWxpY2Vuc2UKICovCgovKioKICogQG1vZHVsZSBlbmdpbmUvbW9kZWwvbm9kZQogKi8KaW1wb3J0IHRvTWFwIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL3RvbWFwJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOyAvLyBUbyBjaGVjayBpZiBjb21wb25lbnQgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLgoKaW1wb3J0ICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy92ZXJzaW9uJzsKLyoqCiAqIE1vZGVsIG5vZGUuIE1vc3QgYmFzaWMgc3RydWN0dXJlIG9mIG1vZGVsIHRyZWUuCiAqCiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBpcyBhIGJhc2UgZm9yIG90aGVyIGNsYXNzZXMgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBub2RlcyBpbiBtb2RlbC4KICoKICogKipOb3RlOioqIElmIGEgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBtb2RlbCB0cmVlLCB5b3UgY2FuIG1hbmlwdWxhdGUgaXQgdXNpbmcgaXQncyBBUEkuCiAqIEhvd2V2ZXIsIGl0IGlzICoqdmVyeSBpbXBvcnRhbnQqKiB0aGF0IG5vZGVzIGFscmVhZHkgYXR0YWNoZWQgdG8gbW9kZWwgdHJlZSBzaG91bGQgYmUgb25seSBjaGFuZ2VkIHRocm91Z2gKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBXcml0ZXIgQVBJfS4KICoKICogQ2hhbmdlcyBkb25lIGJ5IGBOb2RlYCBtZXRob2RzLCBsaWtlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCNfaW5zZXJ0Q2hpbGQgX2luc2VydENoaWxkfSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjX3NldEF0dHJpYnV0ZSBfc2V0QXR0cmlidXRlfQogKiBkbyBub3QgZ2VuZXJhdGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9uc30KICogd2hpY2ggYXJlIGVzc2VudGlhbCBmb3IgY29ycmVjdCBlZGl0b3Igd29yayBpZiB5b3UgbW9kaWZ5IG5vZGVzIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50IGRvY3VtZW50fSByb290LgogKgogKiBUaGUgZmxvdyBvZiB3b3JraW5nIG9uIGBOb2RlYCAoYW5kIGNsYXNzZXMgdGhhdCBpbmhlcml0cyBmcm9tIGl0KSBpcyBhcyBzdWNoOgogKiAxLiBZb3UgY2FuIGNyZWF0ZSBhIGBOb2RlYCBpbnN0YW5jZSwgbW9kaWZ5IGl0IHVzaW5nIGl0J3MgQVBJLgogKiAyLiBBZGQgYE5vZGVgIHRvIHRoZSBtb2RlbCB1c2luZyBgQmF0Y2hgIEFQSS4KICogMy4gQ2hhbmdlIGBOb2RlYCB0aGF0IHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBtb2RlbCB1c2luZyBgQmF0Y2hgIEFQSS4KICoKICogU2ltaWxhcmx5LCB5b3UgY2Fubm90IHVzZSBgQmF0Y2hgIEFQSSBvbiBhIG5vZGUgdGhhdCBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIG1vZGVsIHRyZWUsIHdpdGggdGhlIGV4Y2VwdGlvbgogKiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2luc2VydCBpbnNlcnRpbmd9IHRoYXQgbm9kZSB0byB0aGUgbW9kZWwgdHJlZS4KICoKICogQmUgYXdhcmUgdGhhdCB1c2luZyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3JlbW92ZSByZW1vdmUgZnJvbSBCYXRjaCBBUEl9IGRvZXMgbm90IGFsbG93IHRvIHVzZSBgTm9kZWAgQVBJIGJlY2F1c2UKICogdGhlIGluZm9ybWF0aW9uIGFib3V0IGBOb2RlYCBpcyBzdGlsbCBrZXB0IGluIG1vZGVsIGRvY3VtZW50LgogKgogKiBJbiBjYXNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50IG5vZGV9LCBhZGRpbmcgYW5kIHJlbW92aW5nIGNoaWxkcmVuIGFsc28gY291bnRzIGFzIGNoYW5naW5nIGEgbm9kZSBhbmQKICogZm9sbG93cyBzYW1lIHJ1bGVzLgogKi8KCnZhciBOb2RlID0KLyojX19QVVJFX18qLwpmdW5jdGlvbiAoKSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIG1vZGVsIG5vZGUuCiAgICoKICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzLCBzbyB0aGlzIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS4KICAgKgogICAqIEBhYnN0cmFjdAogICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdIE5vZGUncyBhdHRyaWJ1dGVzLiBTZWUge0BsaW5rIG1vZHVsZTp1dGlscy90b21hcH50b01hcH0gZm9yIGEgbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuCiAgICovCiAgZnVuY3Rpb24gTm9kZShhdHRycykgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpOwoKICAgIC8qKgogICAgICogUGFyZW50IG9mIHRoaXMgbm9kZS4gSXQgY291bGQgYmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fQogICAgICogb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fS4KICAgICAqIEVxdWFscyB0byBgbnVsbGAgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9CiAgICAgKi8KICAgIHRoaXMucGFyZW50ID0gbnVsbDsKICAgIC8qKgogICAgICogQXR0cmlidXRlcyBzZXQgb24gdGhpcyBub2RlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9IG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI19hdHRycwogICAgICovCgogICAgdGhpcy5fYXR0cnMgPSB0b01hcChhdHRycyk7CiAgfQogIC8qKgogICAqIEluZGV4IG9mIHRoaXMgbm9kZSBpbiBpdCdzIHBhcmVudCBvciBgbnVsbGAgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgKgogICAqIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IHRocm93cyBhbiBlcnJvciBpZiB0aGlzIG5vZGUncyBwYXJlbnQgZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0LgogICAqIFRoaXMgbWVhbnMgdGhhdCBtb2RlbCB0cmVlIGdvdCBicm9rZW4uCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9CiAgICovCgoKICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3sKICAgIGtleTogImlzQXR0YWNoZWQiLAoKICAgIC8qKgogICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGluIGEgdHJlZSByb290ZWQgaW4gdGhlIGRvY3VtZW50IChpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9mIGl0cyByb290cykuCiAgICAgKgogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KICAgIHZhbHVlOiBmdW5jdGlvbiBpc0F0dGFjaGVkKCkgewogICAgICByZXR1cm4gdGhpcy5yb290LmlzKCdyb290RWxlbWVudCcpOwogICAgfQogICAgLyoqCiAgICAgKiBHZXRzIHBhdGggdG8gdGhlIG5vZGUuIFRoZSBwYXRoIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgc3RhcnRpbmcgb2Zmc2V0cyBvZiBjb25zZWN1dGl2ZSBhbmNlc3RvcnMgb2YgdGhpcyBub2RlLAogICAgICogYmVnaW5uaW5nIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3Jvb3Qgcm9vdH0sIGRvd24gdG8gdGhpcyBub2RlJ3Mgc3RhcnRpbmcgb2Zmc2V0LiBUaGUgcGF0aCBjYW4gYmUgdXNlZCB0bwogICAgICogY3JlYXRlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIFBvc2l0aW9ufSBpbnN0YW5jZS4KICAgICAqCiAgICAgKgkJY29uc3QgYWJjID0gbmV3IFRleHQoICdhYmMnICk7CiAgICAgKgkJY29uc3QgZm9vID0gbmV3IFRleHQoICdmb28nICk7CiAgICAgKgkJY29uc3QgaDEgPSBuZXcgRWxlbWVudCggJ2gxJywgbnVsbCwgbmV3IFRleHQoICdoZWFkZXInICkgKTsKICAgICAqCQljb25zdCBwID0gbmV3IEVsZW1lbnQoICdwJywgbnVsbCwgWyBhYmMsIGZvbyBdICk7CiAgICAgKgkJY29uc3QgZGl2ID0gbmV3IEVsZW1lbnQoICdkaXYnLCBudWxsLCBbIGgxLCBwIF0gKTsKICAgICAqCQlmb28uZ2V0UGF0aCgpOyAvLyBSZXR1cm5zIFsgMSwgMyBdLiBgZm9vYCBpcyBpbiBgcGAgd2hpY2ggaXMgaW4gYGRpdmAuIGBwYCBzdGFydHMgYXQgb2Zmc2V0IDEsIHdoaWxlIGBmb29gIGF0IDMuCiAgICAgKgkJaDEuZ2V0UGF0aCgpOyAvLyBSZXR1cm5zIFsgMCBdLgogICAgICoJCWRpdi5nZXRQYXRoKCk7IC8vIFJldHVybnMgW10uCiAgICAgKgogICAgICogQHJldHVybnMge0FycmF5LjxOdW1iZXI+fSBUaGUgcGF0aC4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRQYXRoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoKCkgewogICAgICB2YXIgcGF0aCA9IFtdOwogICAgICB2YXIgbm9kZSA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzCgogICAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHsKICAgICAgICBwYXRoLnVuc2hpZnQobm9kZS5zdGFydE9mZnNldCk7CiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50OwogICAgICB9CgogICAgICByZXR1cm4gcGF0aDsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhbmNlc3RvcnMgYXJyYXkgb2YgdGhpcyBub2RlLgogICAgICoKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIHRoaXMgbm9kZSB3aWxsIGJlIGFsc28gaW5jbHVkZWQgaW4gcGFyZW50J3MgYXJyYXkuCiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBhcmVudEZpcnN0PWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsIGFycmF5IHdpbGwgYmUgc29ydGVkIGZyb20gbm9kZSdzIHBhcmVudCB0byByb290IGVsZW1lbnQsCiAgICAgKiBvdGhlcndpc2Ugcm9vdCBlbGVtZW50IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5LgogICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFuY2VzdG9ycy4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBbmNlc3RvcnMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuY2VzdG9ycygpIHsKICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHsKICAgICAgICBpbmNsdWRlU2VsZjogZmFsc2UsCiAgICAgICAgcGFyZW50Rmlyc3Q6IGZhbHNlCiAgICAgIH07CiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXTsKICAgICAgdmFyIHBhcmVudCA9IG9wdGlvbnMuaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQ7CgogICAgICB3aGlsZSAocGFyZW50KSB7CiAgICAgICAgYW5jZXN0b3JzW29wdGlvbnMucGFyZW50Rmlyc3QgPyAncHVzaCcgOiAndW5zaGlmdCddKHBhcmVudCk7CiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIGFuY2VzdG9yczsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICogd2hpY2ggaXMgYSBjb21tb24gYW5jZXN0b3Igb2YgYm90aCBub2Rlcy4KICAgICAqCiAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIFRoZSBzZWNvbmQgbm9kZS4KICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LgogICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGJvdGggbm9kZXMgd2lsbCBiZSBjb25zaWRlcmVkICJhbmNlc3RvcnMiIHRvby4KICAgICAqIFdoaWNoIG1lYW5zIHRoYXQgaWYgZS5nLiBub2RlIEEgaXMgaW5zaWRlIEIsIHRoZW4gdGhlaXIgY29tbW9uIGFuY2VzdG9yIHdpbGwgYmUgQi4KICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldENvbW1vbkFuY2VzdG9yIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlKSB7CiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTsKICAgICAgdmFyIGFuY2VzdG9yc0EgPSB0aGlzLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgICAgdmFyIGFuY2VzdG9yc0IgPSBub2RlLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgICAgdmFyIGkgPSAwOwoKICAgICAgd2hpbGUgKGFuY2VzdG9yc0FbaV0gPT0gYW5jZXN0b3JzQltpXSAmJiBhbmNlc3RvcnNBW2ldKSB7CiAgICAgICAgaSsrOwogICAgICB9CgogICAgICByZXR1cm4gaSA9PT0gMCA/IG51bGwgOiBhbmNlc3RvcnNBW2kgLSAxXTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBiZWZvcmUgZ2l2ZW4gbm9kZS4gYGZhbHNlYCBpcyByZXR1cm5lZCBpZiBub2RlcyBhcmUgaW4gZGlmZmVyZW50IHRyZWVzIChmb3IgZXhhbXBsZSwKICAgICAqIGluIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9cykuCiAgICAgKgogICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gbm9kZSBOb2RlIHRvIGNvbXBhcmUgd2l0aC4KICAgICAqIEByZXR1cm5zIHtCb29sZWFufQogICAgICovCgogIH0sIHsKICAgIGtleTogImlzQmVmb3JlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JlZm9yZShub2RlKSB7CiAgICAgIC8vIEdpdmVuIG5vZGUgaXMgbm90IGJlZm9yZSB0aGlzIG5vZGUgaWYgdGhleSBhcmUgc2FtZS4KICAgICAgaWYgKHRoaXMgPT0gbm9kZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBSZXR1cm4gYGZhbHNlYCBpZiBpdCBpcyBpbXBvc3NpYmxlIHRvIGNvbXBhcmUgbm9kZXMuCgoKICAgICAgaWYgKHRoaXMucm9vdCAhPT0gbm9kZS5yb290KSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICB2YXIgdGhpc1BhdGggPSB0aGlzLmdldFBhdGgoKTsKICAgICAgdmFyIG5vZGVQYXRoID0gbm9kZS5nZXRQYXRoKCk7CiAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXJyYXlzKHRoaXNQYXRoLCBub2RlUGF0aCk7CgogICAgICBzd2l0Y2ggKHJlc3VsdCkgewogICAgICAgIGNhc2UgJ3ByZWZpeCc6CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICAgICAgY2FzZSAnZXh0ZW5zaW9uJzoKICAgICAgICAgIHJldHVybiBmYWxzZTsKCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiB0aGlzUGF0aFtyZXN1bHRdIDwgbm9kZVBhdGhbcmVzdWx0XTsKICAgICAgfQogICAgfQogICAgLyoqCiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIGlzIGFmdGVyIGdpdmVuIG5vZGUuIGBmYWxzZWAgaXMgcmV0dXJuZWQgaWYgbm9kZXMgYXJlIGluIGRpZmZlcmVudCB0cmVlcyAoZm9yIGV4YW1wbGUsCiAgICAgKiBpbiBkaWZmZXJlbnQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fXMpLgogICAgICoKICAgICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgTm9kZSB0byBjb21wYXJlIHdpdGguCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJpc0FmdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FmdGVyKG5vZGUpIHsKICAgICAgLy8gR2l2ZW4gbm9kZSBpcyBub3QgYmVmb3JlIHRoaXMgbm9kZSBpZiB0aGV5IGFyZSBzYW1lLgogICAgICBpZiAodGhpcyA9PSBub2RlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIFJldHVybiBgZmFsc2VgIGlmIGl0IGlzIGltcG9zc2libGUgdG8gY29tcGFyZSBub2Rlcy4KCgogICAgICBpZiAodGhpcy5yb290ICE9PSBub2RlLnJvb3QpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0gLy8gSW4gb3RoZXIgY2FzZXMsIGp1c3QgY2hlY2sgaWYgdGhlIGBub2RlYCBpcyBiZWZvcmUsIGFuZCByZXR1cm4gdGhlIG9wcG9zaXRlLgoKCiAgICAgIHJldHVybiAhdGhpcy5pc0JlZm9yZShub2RlKTsKICAgIH0KICAgIC8qKgogICAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGhhcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkuCiAgICAgKgogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIGNoZWNrLgogICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgaXMgc2V0IG9uIG5vZGUsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAgICovCgogIH0sIHsKICAgIGtleTogImhhc0F0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlKGtleSkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMuaGFzKGtleSk7CiAgICB9CiAgICAvKioKICAgICAqIEdldHMgYW4gYXR0cmlidXRlIHZhbHVlIGZvciBnaXZlbiBrZXkgb3IgYHVuZGVmaW5lZGAgaWYgdGhhdCBhdHRyaWJ1dGUgaXMgbm90IHNldCBvbiBub2RlLgogICAgICoKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byBsb29rIGZvci4KICAgICAqIEByZXR1cm5zIHsqfSBBdHRyaWJ1dGUgdmFsdWUgb3IgYHVuZGVmaW5lZGAuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0QXR0cmlidXRlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoa2V5KSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5nZXQoa2V5KTsKICAgIH0KICAgIC8qKgogICAgICogUmV0dXJucyBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhpcyBub2RlJ3MgYXR0cmlidXRlcy4KICAgICAqCiAgICAgKiBBdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBhcnJheXMgY29udGFpbmluZyB0d28gaXRlbXMuIEZpcnN0IG9uZSBpcyBhdHRyaWJ1dGUga2V5IGFuZCBzZWNvbmQgaXMgYXR0cmlidXRlIHZhbHVlLgogICAgICogVGhpcyBmb3JtYXQgaXMgYWNjZXB0ZWQgYnkgbmF0aXZlIGBNYXBgIG9iamVjdCBhbmQgYWxzbyBjYW4gYmUgcGFzc2VkIGluIGBOb2RlYCBjb25zdHJ1Y3Rvci4KICAgICAqCiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPCo+fQogICAgICovCgogIH0sIHsKICAgIGtleTogImdldEF0dHJpYnV0ZXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoKSB7CiAgICAgIHJldHVybiB0aGlzLl9hdHRycy5lbnRyaWVzKCk7CiAgICB9CiAgICAvKioKICAgICAqIFJldHVybnMgaXRlcmF0b3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoaXMgbm9kZSdzIGF0dHJpYnV0ZSBrZXlzLgogICAgICoKICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZS48U3RyaW5nPn0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRBdHRyaWJ1dGVLZXlzIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVLZXlzKCkgewogICAgICByZXR1cm4gdGhpcy5fYXR0cnMua2V5cygpOwogICAgfQogICAgLyoqCiAgICAgKiBDb252ZXJ0cyBgTm9kZWAgdG8gcGxhaW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LgogICAgICoKICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGBOb2RlYCBjb252ZXJ0ZWQgdG8gcGxhaW4gb2JqZWN0LgogICAgICovCgogIH0sIHsKICAgIGtleTogInRvSlNPTiIsCiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkgewogICAgICB2YXIganNvbiA9IHt9OyAvLyBTZXJpYWxpemVzIGF0dHJpYnV0ZXMgdG8gdGhlIG9iamVjdC4KICAgICAgLy8gYXR0cmlidXRlcyA9IHsgYTogJ2ZvbycsIGI6IDEsIGM6IHRydWUgfS4KCiAgICAgIGlmICh0aGlzLl9hdHRycy5zaXplKSB7CiAgICAgICAganNvbi5hdHRyaWJ1dGVzID0gQXJyYXkuZnJvbSh0aGlzLl9hdHRycykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGF0dHIpIHsKICAgICAgICAgIHJlc3VsdFthdHRyWzBdXSA9IGF0dHJbMV07CiAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0sIHt9KTsKICAgICAgfQoKICAgICAgcmV0dXJuIGpzb247CiAgICB9CiAgICAvKioKICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLgogICAgICoKICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHByb2Nlc3NpbmcgbW9kZWwgb2JqZWN0cyB0aGF0IGFyZSBvZiB1bmtub3duIHR5cGUuIEZvciBleGFtcGxlLCBhIGZ1bmN0aW9uCiAgICAgKiBtYXkgcmV0dXJuIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBvciBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0KICAgICAqIHRoYXQgY2FuIGJlIGVpdGhlciBhIHRleHQgbm9kZSBvciBhbiBlbGVtZW50LiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjaGVjayB3aGF0IGtpbmQgb2Ygb2JqZWN0IGlzIHJldHVybmVkLgogICAgICoKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnZWxlbWVudCcgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGFuIGVsZW1lbnQKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnbm9kZScgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGEgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYW4gZWxlbWVudCkKICAgICAqCQlzb21lT2JqZWN0LmlzKCAnZG9jdW1lbnRGcmFnbWVudCcgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQKICAgICAqCiAgICAgKiBTaW5jZSB0aGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBvbiBhIHJhbmdlIG9mIHZpZXcgb2JqZWN0cywgeW91IGNhbiBwcmVmaXggdGhlIHR5cGUgb2YgdGhlIG9iamVjdCB3aXRoCiAgICAgKiBgbW9kZWw6YCBvciBgdmlldzpgIHRvIGNoZWNrLCBmb3IgZXhhbXBsZSwgaWYgdGhpcyBpcyB0aGUgbW9kZWwncyBvciB2aWV3J3MgZWxlbWVudDoKICAgICAqCiAgICAgKgkJbW9kZWxFbGVtZW50LmlzKCAnbW9kZWw6ZWxlbWVudCcgKTsgLy8gLT4gdHJ1ZQogICAgICoJCW1vZGVsRWxlbWVudC5pcyggJ3ZpZXc6ZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgICAqCiAgICAgKiBCeSB1c2luZyB0aGlzIG1ldGhvZCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGNoZWNrIGEgbmFtZSBvZiBhbiBlbGVtZW50OgogICAgICoKICAgICAqCQlpbWFnZUVsZW1lbnQuaXMoICdpbWFnZScgKTsgLy8gLT4gdHJ1ZQogICAgICoJCWltYWdlRWxlbWVudC5pcyggJ2VsZW1lbnQnLCAnaW1hZ2UnICk7IC8vIC0+IHNhbWUgYXMgYWJvdmUKICAgICAqCQlpbWFnZUVsZW1lbnQuaXMoICdtb2RlbDplbGVtZW50JywgJ2ltYWdlJyApOyAvLyAtPiBzYW1lIGFzIGFib3ZlLCBidXQgbW9yZSBwcmVjaXNlCiAgICAgKgogICAgICogVGhlIGxpc3Qgb2YgbW9kZWwgb2JqZWN0cyB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2Q6CiAgICAgKgogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaXMgYE5vZGUjaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHR+VGV4dCNpcyBgVGV4dCNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50I2lzIGBFbGVtZW50I2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yb290ZWxlbWVudH5Sb290RWxlbWVudCNpcyBgUm9vdEVsZW1lbnQjaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI2lzIGBQb3NpdGlvbiNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXBvc2l0aW9ufkxpdmVQb3NpdGlvbiNpcyBgTGl2ZVBvc2l0aW9uI2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNpcyBgUmFuZ2UjaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVyYW5nZX5MaXZlUmFuZ2UjaXMgYExpdmVSYW5nZSNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I2lzIGBEb2N1bWVudEZyYWdtZW50I2lzKClgfQogICAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9uI2lzIGBTZWxlY3Rpb24jaXMoKWB9CiAgICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uI2lzIGBEb2N1bWVudFNlbGVjdGlvbiNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIjaXMgYE1hcmtlciNpcygpYH0KICAgICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eSNpcyBgVGV4dFByb3h5I2lzKClgfQogICAgICoKICAgICAqIEBtZXRob2QgI2lzCiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiaXMiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGlzKHR5cGUpIHsKICAgICAgcmV0dXJuIHR5cGUgPT0gJ25vZGUnIHx8IHR5cGUgPT0gJ21vZGVsOm5vZGUnOwogICAgfQogICAgLyoqCiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG5vZGUsIHRoYXQgaXMgYSBub2RlIHdpdGggZXhhY3RseSBzYW1lIGF0dHJpYnV0ZXMsIGFuZCByZXR1cm5zIGl0LgogICAgICoKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gTm9kZSB3aXRoIHNhbWUgYXR0cmlidXRlcyBhcyB0aGlzIG5vZGUuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2Nsb25lIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLl9hdHRycyk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgdGhpcyBub2RlIGZyb20gaXQncyBwYXJlbnQuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjcmVtb3ZlCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JlbW92ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZSgpIHsKICAgICAgdGhpcy5wYXJlbnQuX3JlbW92ZUNoaWxkcmVuKHRoaXMuaW5kZXgpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGF0dHJpYnV0ZSBvbiB0aGUgbm9kZS4gSWYgYXR0cmlidXRlIHdpdGggdGhlIHNhbWUga2V5IGFscmVhZHkgaXMgc2V0LCBpdCdzIHZhbHVlIGlzIG92ZXJ3cml0dGVuLgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3NldEF0dHJpYnV0ZQogICAgICogQHByb3RlY3RlZAogICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIHNldC4KICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQXR0cmlidXRlIHZhbHVlLgogICAgICovCgogIH0sIHsKICAgIGtleTogIl9zZXRBdHRyaWJ1dGUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgewogICAgICB0aGlzLl9hdHRycy5zZXQoa2V5LCB2YWx1ZSk7CiAgICB9CiAgICAvKioKICAgICAqIFJlbW92ZXMgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbm9kZSBhbmQgc2V0cyBnaXZlbiBhdHRyaWJ1dGVzLgogICAgICoKICAgICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3NldEF0dHJpYnV0ZXMKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdIEF0dHJpYnV0ZXMgdG8gc2V0LiBTZWUge0BsaW5rIG1vZHVsZTp1dGlscy90b21hcH50b01hcH0gZm9yIGEgbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3NldEF0dHJpYnV0ZXNUbyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEF0dHJpYnV0ZXNUbyhhdHRycykgewogICAgICB0aGlzLl9hdHRycyA9IHRvTWFwKGF0dHJzKTsKICAgIH0KICAgIC8qKgogICAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgZnJvbSB0aGUgbm9kZS4KICAgICAqCiAgICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNyZW1vdmVBdHRyaWJ1dGUKICAgICAqIEBwcm90ZWN0ZWQKICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byByZW1vdmUuCiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgd2FzIHNldCBvbiB0aGUgZWxlbWVudCwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JlbW92ZUF0dHJpYnV0ZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShrZXkpIHsKICAgICAgcmV0dXJuIHRoaXMuX2F0dHJzLmRlbGV0ZShrZXkpOwogICAgfQogICAgLyoqCiAgICAgKiBSZW1vdmVzIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIG5vZGUuCiAgICAgKgogICAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY2xlYXJBdHRyaWJ1dGVzCiAgICAgKiBAcHJvdGVjdGVkCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2NsZWFyQXR0cmlidXRlcyIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFyQXR0cmlidXRlcygpIHsKICAgICAgdGhpcy5fYXR0cnMuY2xlYXIoKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJpbmRleCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIHBvczsKCiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKChwb3MgPSB0aGlzLnBhcmVudC5nZXRDaGlsZEluZGV4KHRoaXMpKSA9PT0gbnVsbCkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1ub2RlLW5vdC1mb3VuZC1pbi1wYXJlbnQ6IFRoZSBub2RlXCdzIHBhcmVudCBkb2VzIG5vdCBjb250YWluIHRoaXMgbm9kZS4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHBvczsKICAgIH0KICAgIC8qKgogICAgICogT2Zmc2V0IGF0IHdoaWNoIHRoaXMgbm9kZSBzdGFydHMgaW4gaXQncyBwYXJlbnQuIEl0IGlzIGVxdWFsIHRvIHRoZSBzdW0gb2Yge0BsaW5rICNvZmZzZXRTaXplIG9mZnNldFNpemV9CiAgICAgKiBvZiBhbGwgaXQncyBwcmV2aW91cyBzaWJsaW5ncy4gRXF1YWxzIHRvIGBudWxsYCBpZiBub2RlIGhhcyBubyBwYXJlbnQuCiAgICAgKgogICAgICogQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgdGhyb3dzIGFuIGVycm9yIGlmIHRoaXMgbm9kZSdzIHBhcmVudCBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXQuCiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgbW9kZWwgdHJlZSBnb3QgYnJva2VuLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcnxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogInN0YXJ0T2Zmc2V0IiwKICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgewogICAgICB2YXIgcG9zOwoKICAgICAgaWYgKCF0aGlzLnBhcmVudCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CgogICAgICBpZiAoKHBvcyA9IHRoaXMucGFyZW50LmdldENoaWxkU3RhcnRPZmZzZXQodGhpcykpID09PSBudWxsKSB7CiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLW5vZGUtbm90LWZvdW5kLWluLXBhcmVudDogVGhlIG5vZGVcJ3MgcGFyZW50IGRvZXMgbm90IGNvbnRhaW4gdGhpcyBub2RlLicsIHRoaXMpOwogICAgICB9CgogICAgICByZXR1cm4gcG9zOwogICAgfQogICAgLyoqCiAgICAgKiBPZmZzZXQgc2l6ZSBvZiB0aGlzIG5vZGUuIFJlcHJlc2VudHMgaG93IG11Y2ggIm9mZnNldCBzcGFjZSIgaXMgb2NjdXBpZWQgYnkgdGhlIG5vZGUgaW4gaXQncyBwYXJlbnQuCiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufS4gV2hlbiBub2RlIGhhcyBgb2Zmc2V0U2l6ZWAgZ3JlYXRlciB0aGFuIGAxYCwgcG9zaXRpb24KICAgICAqIGNhbiBiZSBwbGFjZWQgYmV0d2VlbiB0aGF0IG5vZGUgc3RhcnQgYW5kIGVuZC4gYG9mZnNldFNpemVgIGdyZWF0ZXIgdGhhbiBgMWAgaXMgZm9yIG5vZGVzIHRoYXQgcmVwcmVzZW50cyBtb3JlCiAgICAgKiB0aGFuIG9uZSBlbnRpdHksIGkuZS4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZX0uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICovCgogIH0sIHsKICAgIGtleTogIm9mZnNldFNpemUiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHJldHVybiAxOwogICAgfQogICAgLyoqCiAgICAgKiBPZmZzZXQgYXQgd2hpY2ggdGhpcyBub2RlIGVuZHMgaW4gaXQncyBwYXJlbnQuIEl0IGlzIGVxdWFsIHRvIHRoZSBzdW0gb2YgdGhpcyBub2RlJ3MKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNzdGFydE9mZnNldCBzdGFydCBvZmZzZXR9IGFuZCB7QGxpbmsgI29mZnNldFNpemUgb2Zmc2V0IHNpemV9LgogICAgICogRXF1YWxzIHRvIGBudWxsYCBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge051bWJlcnxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogImVuZE9mZnNldCIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgaWYgKCF0aGlzLnBhcmVudCkgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5zdGFydE9mZnNldCArIHRoaXMub2Zmc2V0U2l6ZTsKICAgIH0KICAgIC8qKgogICAgICogTm9kZSdzIG5leHQgc2libGluZyBvciBgbnVsbGAgaWYgdGhlIG5vZGUgaXMgYSBsYXN0IGNoaWxkIG9mIGl0J3MgcGFyZW50IG9yIGlmIHRoZSBub2RlIGhhcyBubyBwYXJlbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8bnVsbH0KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJuZXh0U2libGluZyIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDsKICAgICAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIHRoaXMucGFyZW50LmdldENoaWxkKGluZGV4ICsgMSkgfHwgbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogTm9kZSdzIHByZXZpb3VzIHNpYmxpbmcgb3IgYG51bGxgIGlmIHRoZSBub2RlIGlzIGEgZmlyc3QgY2hpbGQgb2YgaXQncyBwYXJlbnQgb3IgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogICAgICovCgogIH0sIHsKICAgIGtleTogInByZXZpb3VzU2libGluZyIsCiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsKICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDsKICAgICAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIHRoaXMucGFyZW50LmdldENoaWxkKGluZGV4IC0gMSkgfHwgbnVsbDsKICAgIH0KICAgIC8qKgogICAgICogVGhlIHRvcC1tb3N0IGFuY2VzdG9yIG9mIHRoZSBub2RlLiBJZiBub2RlIGhhcyBubyBwYXJlbnQgaXQgaXMgdGhlIHJvb3QgaXRzZWxmLiBJZiB0aGUgbm9kZSBpcyBhIHBhcnQKICAgICAqIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0sIGl0J3MgYHJvb3RgIGlzIGVxdWFsIHRvIHRoYXQgYERvY3VtZW50RnJhZ21lbnRgLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAgICovCgogIH0sIHsKICAgIGtleTogInJvb3QiLAogICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7CiAgICAgIHZhciByb290ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXMKCiAgICAgIHdoaWxlIChyb290LnBhcmVudCkgewogICAgICAgIHJvb3QgPSByb290LnBhcmVudDsKICAgICAgfQoKICAgICAgcmV0dXJuIHJvb3Q7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gTm9kZTsKfSgpOwovKioKICogVGhlIG5vZGUncyBwYXJlbnQgZG9lcyBub3QgY29udGFpbiB0aGlzIG5vZGUuCiAqCiAqIFRoaXMgZXJyb3IgbWF5IGJlIHRocm93biBmcm9tIGNvcnJ1cHRlZCB0cmVlcy4KICoKICogQGVycm9yIG1vZGVsLW5vZGUtbm90LWZvdW5kLWluLXBhcmVudAogKi8KCgpleHBvcnQgeyBOb2RlIGFzIGRlZmF1bHQgfTs="},{"version":3,"sources":["C:/Users/pc/Desktop/Restoran/Restoran/Restoran.UI/client/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js"],"names":["toMap","CKEditorError","compareArrays","Node","attrs","parent","_attrs","root","is","path","node","unshift","startOffset","options","includeSelf","parentFirst","ancestors","ancestorsA","getAncestors","ancestorsB","i","thisPath","getPath","nodePath","result","isBefore","key","has","get","entries","keys","json","size","attributes","Array","from","reduce","attr","type","_removeChildren","index","value","set","delete","clear","pos","getChildIndex","getChildStartOffset","offsetSize","getChild"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\nexport default class Node {\n\t/**\n\t * Creates a model node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t *\n\t * @abstract\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( attrs ) {\n\t\t/**\n\t\t * Parent of this node. It could be {@link module:engine/model/element~Element}\n\t\t * or {@link module:engine/model/documentfragment~DocumentFragment}.\n\t\t * Equals to `null` if the node has no parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Attributes set on this node.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/node~Node#_attrs\n\t\t */\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Index of this node in it's parent or `null` if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n\t * of all it's previous siblings. Equals to `null` if node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget startOffset() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n\t * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n\t * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n\t * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n\t * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n\t * Equals to `null` if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget endOffset() {\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.startOffset + this.offsetSize;\n\t}\n\n\t/**\n\t * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n\t * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).\n\t *\n\t * @returns {Boolean}\n\t */\n\tisAttached() {\n\t\treturn this.root.is( 'rootElement' );\n\t}\n\n\t/**\n\t * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n\t * create {@link module:engine/model/position~Position Position} instance.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.startOffset );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/model/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Checks if the node has an attribute with given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Converts `Node` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = {};\n\n\t\t// Serializes attributes to the object.\n\t\t// attributes = { a: 'foo', b: 1, c: true }.\n\t\tif ( this._attrs.size ) {\n\t\t\tjson.attributes = Array.from( this._attrs ).reduce( ( result, attr ) => {\n\t\t\t\tresult[ attr[ 0 ] ] = attr[ 1 ];\n\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t * This method is useful when processing model objects that are of unknown type. For example, a function\n\t * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n\t * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n\t *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n\t *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n\t *\n\t * Since this method is also available on a range of view objects, you can prefix the type of the object with\n\t * `model:` or `view:` to check, for example, if this is the model's or view's element:\n\t *\n\t *\t\tmodelElement.is( 'model:element' ); // -> true\n\t *\t\tmodelElement.is( 'view:element' ); // -> false\n\t *\n\t * By using this method it is also possible to check a name of an element:\n\t *\n\t *\t\timageElement.is( 'image' ); // -> true\n\t *\t\timageElement.is( 'element', 'image' ); // -> same as above\n\t *\t\timageElement.is( 'model:element', 'image' ); // -> same as above, but more precise\n\t *\n\t * The list of model objects which implement the `is()` method:\n\t *\n\t * * {@link module:engine/model/node~Node#is `Node#is()`}\n\t * * {@link module:engine/model/text~Text#is `Text#is()`}\n\t * * {@link module:engine/model/element~Element#is `Element#is()`}\n\t * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n\t * * {@link module:engine/model/position~Position#is `Position#is()`}\n\t * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n\t * * {@link module:engine/model/range~Range#is `Range#is()`}\n\t * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n\t * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n\t * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n\t * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n\t * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n\t * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n\t *\n\t * @method #is\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'node' || type == 'model:node';\n\t}\n\n\t/**\n\t * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n\t */\n\t_clone() {\n\t\treturn new Node( this._attrs );\n\t}\n\n\t/**\n\t * Removes this node from it's parent.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._attrs.set( key, value );\n\t}\n\n\t/**\n\t * Removes all attributes from the node and sets given attributes.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttributes\n\t * @protected\n\t * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\t_setAttributesTo( attrs ) {\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to remove.\n\t * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n\t */\n\t_removeAttribute( key ) {\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Removes all attributes from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#clearAttributes\n\t * @protected\n\t */\n\t_clearAttributes() {\n\t\tthis._attrs.clear();\n\t}\n}\n\n/**\n * The node's parent does not contain this node.\n *\n * This error may be thrown from corrupted trees.\n *\n * @error model-node-not-found-in-parent\n */\n"]}]}